/* 
 * Blowfish from Dojo Toolkit 1.8.1
 */
(function(global){

	var crypto = {};

	// from: dojo-release-1.8.1/dojox/encoding/crypto/_base.js.uncompressed.js

	crypto.cipherModes = {
	  // summary:
	  //    Enumeration for various cipher modes.
	  ECB:0, CBC:1, PCBC:2, CFB:3, OFB:4, CTR:5
	};
	crypto.outputTypes = {
	  // summary:
	  //    Enumeration for input and output encodings.
	  Base64:0, Hex:1, String:2, Raw:3
	};


	// from: dojo-release-1.8.1/dojox/encoding/base64.js.uncompressed.js

	var base64 = {};
	var p="=";
	var tab="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

	base64.encode=function(/* byte[] */ba){
	  // summary:
	  //    Encode an array of bytes as a base64-encoded string
	  var s=[], l=ba.length;
	  var rm=l%3;
	  var x=l-rm;
	  for (var i=0; i<x;){
	    var t=ba[i++]<<16|ba[i++]<<8|ba[i++];
	    s.push(tab.charAt((t>>>18)&0x3f));
	    s.push(tab.charAt((t>>>12)&0x3f));
	    s.push(tab.charAt((t>>>6)&0x3f));
	    s.push(tab.charAt(t&0x3f));
	  }
	  //  deal with trailers, based on patch from Peter Wood.
	  switch(rm){
	    case 2:{
	      var t=ba[i++]<<16|ba[i++]<<8;
	      s.push(tab.charAt((t>>>18)&0x3f));
	      s.push(tab.charAt((t>>>12)&0x3f));
	      s.push(tab.charAt((t>>>6)&0x3f));
	      s.push(p);
	      break;
	    }
	    case 1:{
	      var t=ba[i++]<<16;
	      s.push(tab.charAt((t>>>18)&0x3f));
	      s.push(tab.charAt((t>>>12)&0x3f));
	      s.push(p);
	      s.push(p);
	      break;
	    }
	  }
	  return s.join("");  //  string
	};

	base64.decode=function(/* string */str){
	  // summary:
	  //    Convert a base64-encoded string to an array of bytes
	  var s=str.split(""), out=[];
	  var l=s.length;
	  while(s[--l]==p){ } //  strip off trailing padding
	  for (var i=0; i<l;){
	    var t=tab.indexOf(s[i++])<<18;
	    if(i<=l){ t|=tab.indexOf(s[i++])<<12 };
	    if(i<=l){ t|=tab.indexOf(s[i++])<<6 };
	    if(i<=l){ t|=tab.indexOf(s[i++]) };
	    out.push((t>>>16)&0xff);
	    out.push((t>>>8)&0xff);
	    out.push(t&0xff);
	  }
	  //  strip off any null bytes
	  while(out[out.length-1]==0){ out.pop(); }
	  return out; //  byte[]
	};



	// from: dojo-release-1.8.1/dojo/_base/lang.js.uncompressed.js

	var lang = {};
	lang.isString = function(it){
	  // summary:
	  //    Return true if it is a String
	  // it: anything
	  //    Item to test.
	  return (typeof it == "string" || it instanceof String); // Boolean
	};



	// from: dojo-release-1.8.1/dojo/_base/array.js.uncompressed.js

	var arrayUtil = {};
	arrayUtil.map = function(arr, callback, thisObject, Ctr){
	  var i = 0, l = arr && arr.length || 0, out = new (Ctr || Array)(l);
	  if(l && typeof arr == "string") arr = arr.split("");
	  if(typeof callback == "string") callback = cache[callback] || buildFn(callback);
	  if(thisObject){
	    for(; i < l; ++i){
	      out[i] = callback.call(thisObject, arr[i], i, arr);
	    }
	  }else{
	    for(; i < l; ++i){
	      out[i] = callback(arr[i], i, arr);
	    }
	  }
	  return out; // Array
	};



	// from: dojo-release-1.8.1/dojox/encoding/crypto/Blowfish.js.uncompressed.js

	/*  Blowfish
	 *  Created based on the C# implementation by Marcus Hahn (http://www.hotpixel.net/)
	 *  Unsigned math based on Paul Johnstone and Peter Wood patches.
	 *  2005-12-08
	 */
	crypto.Blowfish = new function(){
	  var POW2=Math.pow(2,2);
	  var POW3=Math.pow(2,3);
	  var POW4=Math.pow(2,4);
	  var POW8=Math.pow(2,8);
	  var POW16=Math.pow(2,16);
	  var POW24=Math.pow(2,24);
	  var iv=null;  //  CBC mode initialization vector
	  var boxes={
	    p:[
	      0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344, 0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
	      0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c, 0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
	      0x9216d5d9, 0x8979fb1b
	    ],
	    s0:[
	      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7, 0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
	      0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16, 0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
	      0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee, 0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
	      0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef, 0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
	      0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60, 0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
	      0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce, 0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
	      0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e, 0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
	      0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193, 0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
	      0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88, 0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
	      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e, 0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
	      0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3, 0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
	      0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88, 0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
	      0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6, 0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
	      0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b, 0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
	      0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba, 0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
	      0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f, 0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
	      0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3, 0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
	      0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279, 0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
	      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab, 0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
	      0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db, 0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
	      0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0, 0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
	      0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790, 0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
	      0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4, 0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
	      0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7, 0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
	      0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad, 0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
	      0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299, 0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
	      0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477, 0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
	      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49, 0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
	      0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa, 0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
	      0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41, 0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
	      0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400, 0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
	      0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664, 0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a
	    ],
	    s1:[
	      0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623, 0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
	      0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1, 0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
	      0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6, 0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
	      0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e, 0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
	      0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737, 0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
	      0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff, 0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
	      0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701, 0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
	      0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41, 0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
	      0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf, 0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
	      0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e, 0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
	      0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c, 0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
	      0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16, 0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
	      0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b, 0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
	      0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e, 0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
	      0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f, 0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
	      0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4, 0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
	      0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66, 0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
	      0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802, 0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
	      0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510, 0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
	      0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14, 0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
	      0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50, 0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
	      0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8, 0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
	      0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99, 0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
	      0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128, 0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
	      0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0, 0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
	      0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105, 0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
	      0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3, 0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
	      0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00, 0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
	      0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb, 0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
	      0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735, 0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
	      0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9, 0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
	      0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20, 0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7
	    ],
	    s2:[
	      0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934, 0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
	      0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af, 0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
	      0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45, 0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
	      0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a, 0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
	      0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee, 0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
	      0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42, 0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
	      0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2, 0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
	      0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527, 0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
	      0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33, 0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
	      0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3, 0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
	      0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17, 0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
	      0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b, 0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
	      0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922, 0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
	      0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0, 0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
	      0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37, 0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
	      0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804, 0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
	      0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3, 0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
	      0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d, 0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
	      0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350, 0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
	      0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a, 0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
	      0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d, 0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
	      0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f, 0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
	      0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2, 0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
	      0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2, 0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
	      0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e, 0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
	      0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10, 0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
	      0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52, 0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
	      0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5, 0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
	      0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634, 0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
	      0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24, 0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
	      0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4, 0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
	      0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837, 0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0
	    ],
	    s3:[
	      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b, 0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
	      0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b, 0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
	      0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8, 0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
	      0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304, 0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
	      0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4, 0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
	      0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9, 0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
	      0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593, 0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
	      0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28, 0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
	      0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b, 0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
	      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c, 0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
	      0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a, 0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
	      0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb, 0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
	      0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991, 0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
	      0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680, 0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
	      0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae, 0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
	      0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5, 0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
	      0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370, 0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
	      0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84, 0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
	      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8, 0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
	      0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9, 0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
	      0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38, 0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
	      0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c, 0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
	      0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1, 0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
	      0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964, 0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
	      0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8, 0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
	      0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f, 0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
	      0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02, 0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
	      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614, 0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
	      0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6, 0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
	      0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0, 0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
	      0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e, 0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
	      0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f, 0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6
	    ]
	  }
	////////////////////////////////////////////////////////////////////////////
	//  fixes based on patch submitted by Peter Wood (#5791)
	  function add(x,y){
	    return (((x>>0x10)+(y>>0x10)+(((x&0xffff)+(y&0xffff))>>0x10))<<0x10)|(((x&0xffff)+(y&0xffff))&0xffff);
	  }
	  function xor(x,y){
	    return (((x>>0x10)^(y>>0x10))<<0x10)|(((x&0xffff)^(y&0xffff))&0xffff);
	  }

	  function $(v, box){
	    var d=box.s3[v&0xff]; v>>=8;
	    var c=box.s2[v&0xff]; v>>=8;
	    var b=box.s1[v&0xff]; v>>=8;
	    var a=box.s0[v&0xff];

	    var r = (((a>>0x10)+(b>>0x10)+(((a&0xffff)+(b&0xffff))>>0x10))<<0x10)|(((a&0xffff)+(b&0xffff))&0xffff);
	    r = (((r>>0x10)^(c>>0x10))<<0x10)|(((r&0xffff)^(c&0xffff))&0xffff);
	    return (((r>>0x10)+(d>>0x10)+(((r&0xffff)+(d&0xffff))>>0x10))<<0x10)|(((r&0xffff)+(d&0xffff))&0xffff);
	  }
	////////////////////////////////////////////////////////////////////////////
	  function eb(o, box){
	    //  TODO: see if this can't be made more efficient
	    var l=o.left;
	    var r=o.right;
	    l=xor(l,box.p[0]);
	    r=xor(r,xor($(l,box),box.p[1]));
	    l=xor(l,xor($(r,box),box.p[2]));
	    r=xor(r,xor($(l,box),box.p[3]));
	    l=xor(l,xor($(r,box),box.p[4]));
	    r=xor(r,xor($(l,box),box.p[5]));
	    l=xor(l,xor($(r,box),box.p[6]));
	    r=xor(r,xor($(l,box),box.p[7]));
	    l=xor(l,xor($(r,box),box.p[8]));
	    r=xor(r,xor($(l,box),box.p[9]));
	    l=xor(l,xor($(r,box),box.p[10]));
	    r=xor(r,xor($(l,box),box.p[11]));
	    l=xor(l,xor($(r,box),box.p[12]));
	    r=xor(r,xor($(l,box),box.p[13]));
	    l=xor(l,xor($(r,box),box.p[14]));
	    r=xor(r,xor($(l,box),box.p[15]));
	    l=xor(l,xor($(r,box),box.p[16]));
	    o.right=l;
	    o.left=xor(r,box.p[17]);
	  }

	  function db(o, box){
	    var l=o.left;
	    var r=o.right;
	    l=xor(l,box.p[17]);
	    r=xor(r,xor($(l,box),box.p[16]));
	    l=xor(l,xor($(r,box),box.p[15]));
	    r=xor(r,xor($(l,box),box.p[14]));
	    l=xor(l,xor($(r,box),box.p[13]));
	    r=xor(r,xor($(l,box),box.p[12]));
	    l=xor(l,xor($(r,box),box.p[11]));
	    r=xor(r,xor($(l,box),box.p[10]));
	    l=xor(l,xor($(r,box),box.p[9]));
	    r=xor(r,xor($(l,box),box.p[8]));
	    l=xor(l,xor($(r,box),box.p[7]));
	    r=xor(r,xor($(l,box),box.p[6]));
	    l=xor(l,xor($(r,box),box.p[5]));
	    r=xor(r,xor($(l,box),box.p[4]));
	    l=xor(l,xor($(r,box),box.p[3]));
	    r=xor(r,xor($(l,box),box.p[2]));
	    l=xor(l,xor($(r,box),box.p[1]));
	    o.right=l;
	    o.left=xor(r,box.p[0]);
	  }

	  //  Note that we aren't caching contexts here; it might take a little longer
	  //  but we should be more secure this way.
	  function init(key){
	    var k=key;
	    if(lang.isString(k)){
	      k = arrayUtil.map(k.split(""), function(item){
	        return item.charCodeAt(0) & 0xff;
	      });
	    }

	    //  init the boxes
	    var pos=0, data=0, res={ left:0, right:0 }, i, j, l;
	    var box = {
	      p: arrayUtil.map(boxes.p.slice(0), function(item){
	        var l=k.length, j;
	        for(j=0; j<4; j++){ data=(data*POW8)|k[pos++ % l]; }
	        return (((item>>0x10)^(data>>0x10))<<0x10)|(((item&0xffff)^(data&0xffff))&0xffff);
	      }),
	      s0:boxes.s0.slice(0),
	      s1:boxes.s1.slice(0),
	      s2:boxes.s2.slice(0),
	      s3:boxes.s3.slice(0)
	    };

	    //  encrypt p and the s boxes
	    for(i=0, l=box.p.length; i<l;){
	      eb(res, box);
	      box.p[i++]=res.left, box.p[i++]=res.right;
	    }
	    for(i=0; i<4; i++){
	      for(j=0, l=box["s"+i].length; j<l;){
	        eb(res, box);
	        box["s"+i][j++]=res.left, box["s"+i][j++]=res.right;
	      }
	    }
	    return box;
	  }

	////////////////////////////////////////////////////////////////////////////
	//  PUBLIC FUNCTIONS
	////////////////////////////////////////////////////////////////////////////
	  this.getIV=function(/* dojox.encoding.crypto.outputTypes? */ outputType){
	    // summary:
	    //    returns the initialization vector in the output format specified by outputType
	    var out=outputType||crypto.outputTypes.Base64;
	    switch(out){
	      case crypto.outputTypes.Hex:{
	        return arrayUtil.map(iv, function(item){
	          return (item<=0xf?'0':'')+item.toString(16);
	        }).join("");      //  string
	      }
	      case crypto.outputTypes.String:{
	        return iv.join("");   //  string
	      }
	      case crypto.outputTypes.Raw:{
	        return iv;        //  array
	      }
	      default:{
	        return base64.encode(iv);   //   string
	      }
	    }
	  };

	  this.setIV=function(/* string */data, /* dojox.encoding.crypto.outputTypes? */inputType){
	    // summary:
	    //    sets the initialization vector to data (as interpreted as inputType)
	    var ip=inputType||crypto.outputTypes.Base64;
	    var ba=null;
	    switch(ip){
	      case crypto.outputTypes.String:{
	        ba = arrayUtil.map(data.split(""), function(item){
	          return item.charCodeAt(0);
	        });
	        break;
	      }
	      case crypto.outputTypes.Hex:{
	        ba=[];
	        for(var i=0, l=data.length-1; i<l; i+=2){
	          ba.push(parseInt(data.substr(i,2), 16));
	        }
	        break;
	      }
	      case crypto.outputTypes.Raw:{
	        ba=data;
	        break;
	      }
	      default:{
	        ba=base64.decode(data);
	        break;
	      }
	    }
	    //  make it a pair of words now
	    iv={};
	    iv.left=ba[0]*POW24|ba[1]*POW16|ba[2]*POW8|ba[3];
	    iv.right=ba[4]*POW24|ba[5]*POW16|ba[6]*POW8|ba[7];
	  };

	  this.encrypt = function(/* string */plaintext, /* string */key, /* object? */ao){
	    // summary:
	    //    encrypts plaintext using key; allows user to specify output type and cipher mode via keyword object "ao"
	    var out=crypto.outputTypes.Base64;
	    var mode=crypto.cipherModes.ECB;
	    if (ao){
	      if (ao.outputType) out=ao.outputType;
	      if (ao.cipherMode) mode=ao.cipherMode;
	    }

	    var bx = init(key), padding = 8-(plaintext.length&7);
	    for (var i=0; i<padding; i++){ plaintext+=String.fromCharCode(padding); }

	    var cipher=[], count=plaintext.length >> 3, pos=0, o={}, isCBC=(mode==crypto.cipherModes.CBC);
	    var vector={left:iv.left||null, right:iv.right||null};
	    for(var i=0; i<count; i++){
	      o.left=plaintext.charCodeAt(pos)*POW24
	        |plaintext.charCodeAt(pos+1)*POW16
	        |plaintext.charCodeAt(pos+2)*POW8
	        |plaintext.charCodeAt(pos+3);
	      o.right=plaintext.charCodeAt(pos+4)*POW24
	        |plaintext.charCodeAt(pos+5)*POW16
	        |plaintext.charCodeAt(pos+6)*POW8
	        |plaintext.charCodeAt(pos+7);

	      if(isCBC){
	        o.left=(((o.left>>0x10)^(vector.left>>0x10))<<0x10)|(((o.left&0xffff)^(vector.left&0xffff))&0xffff);
	        o.right=(((o.right>>0x10)^(vector.right>>0x10))<<0x10)|(((o.right&0xffff)^(vector.right&0xffff))&0xffff);
	      }

	      eb(o, bx);  //  encrypt the block

	      if(isCBC){
	        vector.left=o.left;
	        vector.right=o.right;
	      }

	      cipher.push((o.left>>24)&0xff);
	      cipher.push((o.left>>16)&0xff);
	      cipher.push((o.left>>8)&0xff);
	      cipher.push(o.left&0xff);
	      cipher.push((o.right>>24)&0xff);
	      cipher.push((o.right>>16)&0xff);
	      cipher.push((o.right>>8)&0xff);
	      cipher.push(o.right&0xff);
	      pos+=8;
	    }

	    switch(out){
	      case crypto.outputTypes.Hex:{
	        return arrayUtil.map(cipher, function(item){
	          return (item<=0xf?'0':'')+item.toString(16);
	        }).join("");  //  string
	      }
	      case crypto.outputTypes.String:{
	        return cipher.join(""); //  string
	      }
	      case crypto.outputTypes.Raw:{
	        return cipher;  //  array
	      }
	      default:{
	        return base64.encode(cipher); //  string
	      }
	    }
	  };

	  this.decrypt = function(/* string */ciphertext, /* string */key, /* object? */ao){
	    // summary:
	    //    decrypts ciphertext using key; allows specification of how ciphertext is encoded via ao.
	    var ip=crypto.outputTypes.Base64;
	    var mode=crypto.cipherModes.ECB;
	    if (ao){
	      if (ao.outputType) ip=ao.outputType;
	      if (ao.cipherMode) mode=ao.cipherMode;
	    }
	    var bx = init(key);
	    var pt=[];

	    var c=null;
	    switch(ip){
	      case crypto.outputTypes.Hex:{
	        c = [];
	        for(var i=0, l=ciphertext.length-1; i<l; i+=2){
	          c.push(parseInt(ciphertext.substr(i,2), 16));
	        }
	        break;
	      }
	      case crypto.outputTypes.String:{
	        c = arrayUtil.map(ciphertext.split(""), function(item){
	          return item.charCodeAt(0);
	        });
	        break;
	      }
	      case crypto.outputTypes.Raw:{
	        c=ciphertext; //  should be a byte array
	        break;
	      }
	      default:{
	        c=base64.decode(ciphertext);
	        break;
	      }
	    }

	    var count=c.length >> 3, pos=0, o={}, isCBC=(mode==crypto.cipherModes.CBC);
	    var vector={left:iv.left||null, right:iv.right||null};
	    for(var i=0; i<count; i++){
	      o.left=c[pos]*POW24|c[pos+1]*POW16|c[pos+2]*POW8|c[pos+3];
	      o.right=c[pos+4]*POW24|c[pos+5]*POW16|c[pos+6]*POW8|c[pos+7];

	      if(isCBC){
	        var left=o.left;
	        var right=o.right;
	      }

	      db(o, bx);  //  decrypt the block

	      if(isCBC){
	        o.left=(((o.left>>0x10)^(vector.left>>0x10))<<0x10)|(((o.left&0xffff)^(vector.left&0xffff))&0xffff);
	        o.right=(((o.right>>0x10)^(vector.right>>0x10))<<0x10)|(((o.right&0xffff)^(vector.right&0xffff))&0xffff);
	        vector.left=left;
	        vector.right=right;
	      }

	      pt.push((o.left>>24)&0xff);
	      pt.push((o.left>>16)&0xff);
	      pt.push((o.left>>8)&0xff);
	      pt.push(o.left&0xff);
	      pt.push((o.right>>24)&0xff);
	      pt.push((o.right>>16)&0xff);
	      pt.push((o.right>>8)&0xff);
	      pt.push(o.right&0xff);
	      pos+=8;
	    }

	    //  check for padding, and remove.
	    if(pt[pt.length-1]==pt[pt.length-2]||pt[pt.length-1]==0x01){
	      var n=pt[pt.length-1];
	      pt.splice(pt.length-n, n);
	    }

	    //  convert to string
	    return arrayUtil.map(pt, function(item){
	      return String.fromCharCode(item);
	    }).join("");  //  string
	  };

	  this.setIV("0000000000000000", crypto.outputTypes.Hex);
	}();



	if (typeof exports != 'undefined') {
	    exports.blowfish = crypto.Blowfish;
	} else {
	    global.blowfish = crypto.Blowfish;
	}

}(this));
/*jscrambler
 {
 "ignore_transformations_@": {
 "*": {
 "*": false
 },
 "ignorewm": {
 "*": false,
 "string_splitting": true
 }
 }
 }
 */
//"use strict";

var Grids = (function ($) {
	var _win = $ || window;
	var _doc = ($ && $.document) || document;
	var _ver = "/*$version$*/";
	var $$_rootContext = "";
    var $$_assets = "assets/";

	var _setRootContext = function (path) {
		if (path) {
			path = String(path).trim();
		}
		if (path && path.lastIndexOf('/') != path.length - 1) {
			path += '/';
		}
		$$_rootContext = path;
	};
    var _setAssetRoot = function (path) {
        if (path) {
            path = String(path).trim();
        }
        if (path && path.lastIndexOf('/') != path.length - 1) {
            path += '/';
        }
        $$_assets = path;
    };
	var _getAsset = function (url) {
        return "url(" + $$_rootContext + $$_assets + url + ")";
	};
	var _getVersion = function () {
		return _ver;
	};

	var AppInfo = {
		PRODUCT: "RealGridJs",
		TYPE: "/*$prodType$*/",
		VENDER: null
	};

	function $_equalServer(multi, single) {
		if (multi == single) {
			return true;
		} else if (multi.indexOf("*") === 0) {
			multi = multi.substr(1, multi.length-1); // * remove
			return (single.substr(single.indexOf(multi), multi.length) == multi);
		}
		
		return false;
	};

	function $_checkIncludeDomain(licServer, urlServer) {
		var servers = [];
		servers = licServer.split(",");

		for (var i = 0, cnt = servers.length; i < cnt; i++) {
			if ($_equalServer(servers[i], urlServer))
				return true;
		}
		return false;
	};

	function $_getLDKey(keys) {
		var mkey = "";
		for(var i = 0, cnt = keys.length; i < cnt; i++) { 
			mkey += String.fromCharCode(keys[i] >> 1);
		};
		return mkey;
	};

	function $_decryptLic(licEncode) {
		var decoded = blowfish.decrypt(licEncode, _gk+$_getLDKey([202,218,204,100]), {outputType:0, cipherMode: 0});
		var decObj = {};
		var decArr = decoded.split(";");
		for (var i = 0, cnt = decArr.length; i < cnt; i++) {
			var kv = decArr[i].split("=");
			var key = kv[0];
			var value = kv[1];
			if (value && value.length > 0)
				decObj[key] = value;
		}
		return decObj;
	};

	var __lck = function () {
		return true;
	};


if (!Function.prototype.bind) {
	Function.prototype.bind = function (oThis) {
		if (typeof this !== 'function') {
			debugger;
			throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
		}
		var aArgs   = Array.prototype.slice.call(arguments, 1),
			fToBind = this,
			fNOP    = function() {},
			fBound  = function() {
				return fToBind.apply(this instanceof fNOP
						? this
						: oThis,
					aArgs.concat(Array.prototype.slice.call(arguments)));
			};
		fNOP.prototype = this.prototype;
		fBound.prototype = new fNOP();
		return fBound;
	};
}
if (!String.prototype.trim) {
	(function() {
		var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;
		String.prototype.trim = function() {
			return this.replace(rtrim, '');
		};
	})();
}
if (!Array.prototype.indexOf) {
	Array.prototype.indexOf = function(searchElement, fromIndex) {
		var k;
		if (this == null) {
			throw new TypeError('"this" is null or not defined');
		}
		var O = Object(this);
		var len = O.length >>> 0;
		if (len === 0) {
			return -1;
		}
		var n = +fromIndex || 0;
		if (Math.abs(n) === Infinity) {
			n = 0;
		}
		if (n >= len) {
			return -1;
		}
		k = Math.max(n >= 0 ? n : len - Math.abs(n), 0);
		while (k < len) {
			if (k in O && O[k] === searchElement) {
				return k;
			}
			k++;
		}
		return -1;
	};
}
if (!Array.prototype.filter) {
	Array.prototype.filter = function(fun/*, thisArg*/) {
		'use strict';
		if (this === void 0 || this === null) {
			throw new TypeError();
		}
		var t = Object(this);
		var len = t.length >>> 0;
		if (typeof fun !== 'function') {
			throw new TypeError();
		}
		var res = [];
		var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
		for (var i = 0; i < len; i++) {
			if (i in t) {
				var val = t[i];
				if (fun.call(thisArg, val, i, t)) {
					res.push(val);
				}
			}
		}
		return res;
	};
}
(function () {
	var lastTime = 0;
	if (!window.requestAnimationFrame) {
		window.requestAnimationFrame = function (callback, element) {
			var currTime = new Date().getTime();
			var timeToCall = Math.max(0, 16 - (currTime - lastTime));
			var id = window.setTimeout(function () {
					callback(currTime + timeToCall);
				},
				timeToCall);
			lastTime = currTime + timeToCall;
			return id;
		};
	}
}());
var UNDEFINED;
var $_debug = /*$debugging$*/;
var $_logging = /*$debugging$*/;
var __f__ = function realgrid() {};
var $_evl = window.addEventListener;
var console = window.console;
var log = console && typeof console.log == "function" ? Function.prototype.bind.call(console.log, console) : UNDEFINED;
var __epoch = new Date().getTime();
var toString = Object.prototype.toString;
var PI = Math.PI;
var _2PI = Math.PI * 2;
var MAX_INT = Math.pow(2, 53) - 1;
var MIN_INT = -MAX_INT;
var $_temp_size = { width: 0, height: 0 };
var $_csvreg = /,(?=(?:[^\"]*\"[^\"]*\")*(?![^\"]*\"))/;
var $_linereg = /\r|\n|\r\n/;
var $$_autoInc = 0;

var $$_activeGrid;
function $_getActiveGrid() {
	return $$_activeGrid && $$_activeGrid.getHandler && $$_activeGrid.getHandler();
};
function $_setActiveGrid(grid) {
	if ($$_activeGrid != grid) {
		grid && grid._fireGridActivated();
	}
	$$_activeGrid = grid;
};
function _setDebug(debug) {
    $_debug = debug;
};
function _setLogging(logging) {
    $_logging = logging;
};
function _log() {
    log && log.apply(console, arguments);
}
function _trace() {
	$_logging && log && log.apply(console, arguments);
}
var trace = _trace;
function _throwDebug(err) {
	if ($_debug) throw err;
}
var alertOnce = (function () {
	var alerted = false;
	return function (message) {
		if (!alerted) {
			alerted = true;
			alert(message);
		}
	}
}());
function getTimer() {
	return new Date().getTime() - __epoch;
}
var _getTimer = getTimer;
function defined(obj) {
	return obj !== UNDEFINED && obj !== null;
}
function _isEmpty(value) {
	return value === UNDEFINED || value === null || value == "";
}
function _isObj(obj) {
	return typeof obj === "object";
}
function _isObject(obj) {
	if (obj === null) return false;
	return typeof obj === "object";
}
function isObject(obj) {
	return Object(obj) === obj;
}
function _isStr(str) {
	return typeof str == "string";
}
function _isString(obj) {
	return toString.call(obj) === "[object String]"; // for new String("")
}
var isString = _isString;
function _equalsText(s1, s2) {
	if (s1 && s2) {
		return s1.toLowerCase() == s2.toLowerCase();
	} else {
		return !s1 && !s2;
	}
}
function _isWhiteSpace(s) {
	return !s || !s.trim();
}
function _forceFloat(v) {
	v = parseFloat(v);
	return isNaN(v) ? 0 : v;
}
function _forceInt(v) {
	v = parseInt(v);
	return isNaN(v) ? 0 : v;
}
function _isArray(obj) {
	return Array.isArray ? Array.isArray(obj) : toString.call(obj) === '[object Array]';
}
var isArray = _isArray;
function _asArray(obj) {
	 return (Array.isArray ? Array.isArray(obj) : toString.call(obj) === '[object Array]') ? obj : null;
}
var asArray = _asArray;
function _makeArray(obj) {
	return _isArray(obj) ? obj : [obj];
}
function _equalsArray(a1, a2) {
	if (!_isArray(a1) || !_isArray(a2)) {
		return false;
	}
	var len = a1.length;
	if (a2.length != len) {
		return false;
	}
	for (var i = 0; i < len; i++) {
		if (a1[i] != a2[i]) {
			return false;
		}
	}
	return true;
}
function _csvToArray(csv) {
    var v = [];
    if (csv) {
        var arr = csv.split($_csvreg);
        for (var i = 0; i < arr.length; i++) {
            var a = arr[i];
            a && (a = a.trim());
            if (a) {
                if (a.length > 1 && a.charAt(0) == '"' && a.charAt(a.length - 1) == '"') {
                    v.push(a.substr(1, a.length - 2));
                } else if (a == "true") {
                    v.push(true);
                } else if (a == "false") {
                    v.push(false);
                } else if (a == "null") {
                    v.push(null);
                } else if (a == "undefined") {
                    v.push(undefined);
                } else {
                    var n = parseFloat(a);
                    v.push(isNaN(n) ? a : n);
                }
            } else {
                v.push("")
            }
        }
    }
    return v;
}
function _arrayToCsv(vals) {
    var s = "";
    if (vals) {
        for (var i = 0; i < vals.length; i++) {
            if (s) s += ",";
            var v = vals[i];
            if (v === undefined) {
                v = "undefined";
            } else if (v === null) {
                v = "null";
            } else if (typeof v == "number") {
                v = String(v);
            } else if (typeof v == "boolean") {
                v = v ? "true" : "false";
            } else {
                v = '"' + v + '"';
            }
            s += v;
        }
    }
    return "[" + s + "]";
}
function _asDate(d) {
    return d instanceof Date ? d : null;
}
function _tempSize(w, h) {
	$_temp_size.width = w;
	$_temp_size.height = h;
	return $_temp_size;
}
function _pick() {
	var args = arguments;
	var len = args.length;
	var v;
	for (var i = 0; i < len; i++) {
		v = args[i];
		if (v !== UNDEFINED && v !== null) {
			return v;
		}
	}
	return UNDEFINED;
}
function _included(value) {
	var args = arguments;
	var len = args.length;
	for (var i = 1; i < len; i++) {
		if (args[i] == value) {
			return true;
		}
	}
	return false;
}
function _getObj(source, path) {
	if (source && path) {
		var arr = path.split(".");
		var v = source;
		for (var i = 0, cnt = arr.length; v && i < cnt; i++) {
			v = v[arr[i]];
		}
		return v;
	}
	return null;
}
function _toStr(value) {
    if (typeof value === "number") {
        return !isNaN(value) ? String(value) : "";
    } else {
        return value !== null && value !== undefined ? String(value) : "";
    }
}
function _toLowerCase(value) {
    if (value !== undefined && value !== null) {
        return String(value).toLowerCase();
    }
    return value;
}
function _toUpperCase(value) {
    if (value !== undefined && value !== null) {
        return String(value).toUpperCase();
    }
    return value;
}
function _strLen(value) {
    if (value !== undefined && value !== null) {
        return String(value).length;
    }
	return 0;
}
function _pad(value, len, c) {
	len = Math.max(len || 2, 1);
	c = c || 0;
	return new Array(len - String(value).length + 1).join(c) + value;
}
var pad = _pad;
function hex(value, len, c) {
	len = Math.max(len || 2, 1);
	c = c || 0;
	var s = value.toString(16);
	return new Array(len - s.toString(16).length + 1).join(c) + s;
}
function toInt(v, radix) {
	return (v !== UNDEFINED && v !== null) ? parseInt(v, radix || 10) : 0;
}
function toFloat(v) {
	return (v !== UNDEFINED && v !== null) ? parseFloat(v) : 0;
}

function hangulToChosungAll(str){
	var code, cho = ["ㄱ","ㄲ","ㄴ","ㄷ","ㄸ","ㄹ","ㅁ","ㅂ","ㅃ","ㅅ","ㅆ","ㅇ","ㅈ","ㅉ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ"];
	var result = [];
	for(i=0;i<str.length;i++) {
		var ret = {};
		code = str.charCodeAt(i)-44032;
		ret.cho = code>-1 && code<11172 ? cho[Math.floor(code/588)] : str[i];
		ret.org = str[i] === ret.cho ? null : str[i];
		result.push(ret);
	}
	return result;
}

var $$_week_days = window.RG_CONST && window.RG_CONST.WEEKDAYS ? window.RG_CONST.WEEKDAYS : ['일', '월', '화', '수', '목', '금', '토'];
var $$_month_days = [
    [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31],
    [31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
];
function _isLeapYear(year) {
	return ((year % 4 == 0) && (year % 100 != 0)) || (year % 400 == 0);
}
function _incMonth(d, delta) {
    var day = d.getDate();
    d.setDate(1);
    d.setMonth(d.getMonth() + delta);
    d.setDate(Math.min(day, $$_month_days[_isLeapYear(d.getYear()) ? 1 : 0][d.getMonth()]));
    return d;
}
function _minDate(d1, d2) {
	if (d1 !== null) return d1;
	if (d2 !== null) return d2;
	return d1.getTime() < d2.getTime() ? d1 : d2;
}
function _maxDate(d1, d2) {
	if (d1 !== null) return d2;
	if (d2 !== null) return d1;
	return d1.getTime() > d2.getTime() ? d1 : d2;
}
function _toArray(v) {
	return _isArray(v) ? v : defined(v) ? [v] : null;
}
var toArray = _toArray;
function incArray(array, value) {
	array.push(value);
	return value;
}
function _getter(prop) {
	return "get" + prop.chartAt(0).toUpperCase() + prop.substr(1);
}
function _setter(prop) {
	return "set" + prop.charAt(0).toUpperCase() + prop.substr(1);
}
function _isWhitespace(c) {
	return /\s/.test(c);
}
function _trim(s) {
	return s ? s.trim() : null;
}
var trim = _trim;
function _stopEvent(e) {
	if (e.preventDefault) {
		e.cancelable && e.preventDefault();
		e.stopPropagation();
	} else {
		e.returnValue = false;
	}
}
function _capitalize(s) {
	return s.charAt(0).toUpperCase() + s.substr(1);
}
function byteLength(str) {
	var b, i, c;
	for (b = i = 0; c = str.charCodeAt(i++); b += c >> 11 ? 3 : c >> 7 ? 2 : 1);
	return b;
}
function _createProperties(obj, props, def) {
	if (props) {
		var names = props.split(",");
		for (var i = 0, cnt = props.length; i < cnt; i++) {
			obj[names[i]] = def;
		}
	}
}
var _floor = Math.floor;
var _int = Math.floor;
var _round = Math.round;
var _ceil = Math.ceil;
var Errors = {
	NOT_YET_IMPLEMENTED: "Not yet implemented"
};
function _enum(v) {
	return Object.freeze ? Object.freeze(v) : v;
}
function _clone(v) {
	var c = new v.constructor();
	for (var p in v) {
		c[p] = v[p];
	}
	return c;
}
function _extend(obj) {
	obj = obj || {};
	for (var i = 1, len = arguments.length; i < len; i++) {
		var src = arguments[i];
		if (src) {
			for (var prop in src) {
				obj[prop] = src[prop];
			}
		}
	}
	return obj;
}
function _deepExtend(obj) {
	obj = obj || {};
	for (var i = 1, len = arguments.length; i < len; i++) {
		var src = arguments[i];
		if (src) {
			for (var prop in src) {
				var v = src[prop];
				if (_isArray(v)) {
					var arr = [];
					for (var j = 0; j < v.length; j++) {
						arr.push(_deepExtend(v[j]));
					}
					v = arr;
				} else if (_isObject(v)) {
					v = _deepExtend({}, v);
				}
				obj[prop] = v;
			}
		}
	}
	return obj;
}
function AbortError(message) {
	this.message = message;
}
var ajax = function (url, method, data) {
	method = method || "GET";
	data = data !== UNDEFINED ? data : null;
	var req = new XMLHttpRequest();
	req.open(method, url, false);
	req.send(data);
	if (req.status !== 200 && xhr.status !== 0) 
		throw "XMLHttpRequest failed: " + req.status;
    return req.responseText; // req.responsXML;
};
var asyncAjax = function (url, callback, method, data) {
	method = method || "GET";
	data = data !== UNDEFINED ? data : null;
	var req = new XMLHttpRequest;
	req.onreadystatechange = function() {
		if (req.readyState === 4) {
			var error = null;
			if (req.status !== 200 && req.status !== 0) {
				error = "XMLHttpRequest failed: " + req.status;
			}
        	callback(req.responseText, req.status, error);
      	}
    };
    req.open(method, url, true);
    req.send(data);
};
function AssertError(message) {
	this.message = message || "Assert error";
}
AssertError.prototype = new Error();
AssertError.prototype.constructor = AssertError;
var assert = function (test, message) {
	if (!test) {
		if ($_debug) debugger;
		throw new AssertError(message);
	}
};
var _assert = assert;
var _IntegerProperty = function (defaultValue) {
	this.defaultValue = defaultValue;
};
var IntProp_0 = new _IntegerProperty(0);
var IntProp = function (defaultValue) {
	return new _IntegerProperty(defaultValue);
};
var _INHERITTING = {};
var RGBase = function () {};
RGBase.$_hash = 0;
var defineClass = function (name, baseClass, members, statics, callback) {
	if (baseClass !== null && !(typeof baseClass == "function")) {
		if ($_debug) debugger;
		throw "Base class is not a function";
	}
	var f = function () {
		if (arguments[0] !== _INHERITTING) {
			this.$inited = false;
			this.init && this.init.apply(this, arguments);
			this.$inited = true;
		}
	};
	var proto = f.prototype = baseClass ? new baseClass(_INHERITTING) : new RGBase(_INHERITTING);
	var p = null;
	var v, getter, getter2, setter, fn;//, notifier;
	proto.constructor = f;
	proto.$base = baseClass ? baseClass.prototype : RGBase.prototype;
	proto.$name = name;
	if (members) {
		var attrs = {};
		var inits = f.$inits = {};
		for (p in members) {
			v = members[p];
			if (typeof v === "function") {
				v.$name = p;
				v.$owner = proto;
				proto[p] = v;
			} else {
				if (v && v.init) {
					v = v.init;
				}
				attrs[p] = v;
			}
		}
		f.$attrs = {};
		for (p in attrs) {
			v = members[p];
			name = _capitalize(p);
			getter = (typeof v === "boolean") ? "is" + name : p;
			setter = "set" + name;
			fn = null;
			getter2 = p + "_";
			if (proto.hasOwnProperty(getter2)) {//[getter2]) { // "prop_" 함수로 getter를 지정할 수 있다.
				fn = proto[getter2];
				delete proto[getter2];
			} else if (v && v.get) {
				fn = v.get;
			} else if (!proto.hasOwnProperty(getter)) {//[getter]){
				fn = (function (p) {
					return function () {
						return this["_" + p];
					};
				})(p);
			}
			if (fn) {
				fn.$name = getter;
				fn.$owner = proto;
				proto[getter] = fn;
			}
			fn = null;
			if (v && v.set) {
				fn = v.set;
			} else if (!proto.hasOwnProperty(setter)) {//[setter]) {
				if (v instanceof _IntegerProperty) {
					fn = (function (p, getter) {
						return function (value) {
							var oldValue;
							value = parseInt(value);
							if (!isNaN(value) && proto[getter] && (oldValue = proto[getter].call(this)) != value) {
								this["_" + p] = value;
								if (this.$inited) {
									var notifier = p + "PropChanged";
									if (this[notifier]) this[notifier].call(this, p, oldValue, value);
									else this.propertyChanged(p, oldValue, value);
								}
							}
							return this;
						};
					})(p, getter);
				} else {
					fn = (function (p, getter) {
						return function (value) {
							var oldValue;
							if (proto[getter] && (oldValue = proto[getter].call(this)) != value) {
								this["_" + p] = value;
								if (this.$inited) {
									var notifier = p + "PropChanged";
									if (this[notifier]) this[notifier].call(this, p, oldValue, value);
									else this.propertyChanged(p, oldValue, value);
								}
							}
							return this;
						};
					})(p, getter);
				}
			}
			if (fn) {
				fn.$name = setter;
				fn.$owner = proto;
				proto[setter] = fn;
			}
			if (v) {
				if (v instanceof _IntegerProperty) {
					attrs[p] = v.defaultValue;
				} else	if (typeof v.init == "function") {
					inits[p] = v.init;
				} else if (v.hasOwnProperty("value")) {
					attrs[p] = v.value;
				}
			}
			f.$attrs[p] = {
				field: "_" + p,
				value: attrs[p],
				get: proto[getter],
				set: proto[setter]
			};
		}
	}
	if (statics) {
		for (p in statics) {
			f[p] = statics[p];
		}
	}
	if (typeof callback === "function") {
		callback.call(f, f);
	}
	return f;
};
RGBase.prototype.constructor = RGBase;
RGBase.prototype.init = function (nohash) {
	!nohash && (this.$_hash = String(++RGBase.$_hash));
	var f = this.constructor;
	while (f) {
		var inits = f.$inits;
		var attrs = f.$attrs;
		if (attrs) {
			for (var p in attrs) {
				/*
				var v = attrs[p];
				if (v !== UNDEFINED) {
					this["set" + _capitalize(p)].call(this, v);
				} else {
					var fld = "_" + p;
					if (!(fld in this)) {
						this[fld] = UNDEFINED;
					}
				}
				*/
				var v = inits[p];
				var attr = attrs[p];
				if (v) {
					v = v.call(this);
				} else {
					v = attr.value;
				}
				this[attr.field] = v;
			}
		}
		f = f.prototype.$base && f.prototype.$base.constructor;
	}
};
RGBase.prototype.destroy = function (hasDp) {
    var noDestroy = ["VisualStyles","GridStyleSheet"];
    if (!this.$name || noDestroy.indexOf(this.$name) >= 0) {
    	if (this instanceof VisualStyles) {
    		this._listeners = [];
    	}
        return true;
    }

    this._destroying = true;
    var attrkeys = Object.keys(this);
    for (var i = 0, len = attrkeys.length; i < len; i++) {
        var attr = attrkeys[i];
        var obj = this[attr];
        if (attr =="_grid" || attr == "_parent" || attr == "_owner") {
        	this[attr] = null;
        } else if (obj instanceof Array && obj.length > 1  && obj[0] instanceof RGBase) {
            for (var j = 0, arrlen = obj.length; j < arrlen; j++) {
			    if (!hasDp && (obj[j] instanceof DataSource || obj[j] instanceof DataField)) {
			    	// return true;
			    	continue;
			    }
                if (!obj[j]._destroying && obj[j].destroy) {
                	obj[j]._destroying = true;
                	obj[j].destroy(hasDp);
                	obj[j] = null;
                } else {
                    // return false;
                }
            }
            this[attr] = null;
        } else if (obj instanceof RGBase && attr != "_destroying") {
		    if (!hasDp && (obj instanceof DataSource || obj instanceof DataField)) {
			    	continue;
		    	// return true;
		    }
            if (!obj._destroying) {
            	obj._destroying = true;
            	obj.destroy(hasDp) 
            } else {
                // return false;
            }
           	this[attr] = null;
        } else if (_isArray(obj)) {// && obj.length > 0) {
        	// 객체의 property가 배열이면서 내용이 있는 경우 어떻게 해야할것인가? 지금은 객체내부의 destroy에서 일부 해제하고 있다.
        	// this[attr] = null;
        }
    }
    return true;
};

function _throwCallerError() {
	throw new Error("Not supported Function.caller");
}
function _throwInvalidMethod(method) {
	throw new Error("Method is not exists: " + method); 
}
var Base = RGBase.prototype;
RGBase.prototype._super = function () {
	var fn, m = this._super.caller;
	if (m) {
		fn = m.$owner.$base[m.$name];
		if (fn) {
			return fn.apply(this, arguments);
		}
	} else {
		_throwCallerError();
	}
};
RGBase.prototype._inherit = function (fnc) {
	this.constructor.prototype.$base[fnc].apply(this, Array.prototype.slice.call(arguments, 1));
};
RGBase.prototype.className = function () {
	return this.constructor.prototype.$name;
};
RGBase.prototype.baseClass = function () {
	return this.constructor.prototype.$base;
};
RGBase.prototype.baseClassName = function () {
	var base = this.constructor.prototype.$base;
	return base && base.$name;
};
RGBase.prototype.clone = function () {
	var f = this.constructor;
	var obj = new f();
	var attrs = f.$attrs;
	var attr;
	for (var p in attrs) {
		attr = attrs[p];
		obj[attr.field] = this[attr.field];
	}
	return obj;
};
RGBase.prototype.propertyChanged = function (prop, oldValue, newValue) {
};
RGBase.prototype.getAttr = function (prop) {
	var f = this.constructor;
	while (f) {
		var attrs = f.$attrs;
		if (attrs && prop in attrs) {
			return attrs[prop];
		}
		f = f.prototype.$base && f.prototype.$base.constructor;
	}
	return null;
};
RGBase.prototype.getProperty = function (prop) {
	var attr = this.getAttr(prop);
	var v = attr ? (attr.get ? attr.get.call(this) : attr) : UNDEFINED;
	return (v && v.proxy) ? v.proxy() : v;
};
RGBase.prototype.setProperty = function (prop, value) {
	var attr = this.getAttr(prop);
	attr && attr.set && attr.set.call(this, value);
};
RGBase.prototype._initProps = function (config) {
	if (config) {
		for (var prop in config) {
				var name = "_" + prop;
				if (this.hasOwnProperty(name)) {
					this[name] = config[prop];
				}
		}
	}
};
RGBase.prototype.assign = function (source) {
	if (source instanceof RGBase) {
		if (source !== this) {
			var f = source.constructor;
			while (f) {
				var attrs = f.$attrs;
				for (var p in attrs) {
					var thisAttr = this.getAttr(p);
					if (thisAttr && thisAttr.set) {
						attr = attrs[p];
						if (attr.get) {
							var v = attr.get.call(source);
							thisAttr.set.call(this, v);
						}
					}
				}
				f = f.prototype.$base && f.prototype.$base.constructor;
			}
		}
	} else if (_isObject(source)) {
		if (source !== this) {
			for (var p in source) {
				if (source[p] !== UNDEFINED) {
					var attr = this.getAttr(p);
					if (attr && attr.set) {
						attr.set.call(this, source[p]);
					}
				}
			}
		}
	} else {
		this.assignSimple(source);
	}
};
RGBase.prototype.assignSimple = function (source) {
};
RGBase.prototype.assignProps = function (source, props) {
	if (source && source !== this && props) {
		for (var i = 0, cnt = props.length; i < cnt; i++) {
			var p = props[i];
			if (source.hasOwnProperty(p)) {
				var attr = this.getAttr(p);
				if (attr && attr.set) {
					attr.set.call(this, source[p]);
				}
			}
		}
	}
};
function $$_getProxy(v) {
	if (_isArray(v)) {
		var arr = [];
		for (var i = 0, cnt = v.length; i < cnt; i++) {
			arr.push($$_getProxy(v[i]));
		}
		return arr;
	} else if (typeof v.proxy == "function") {
		return v.proxy();
	}
	return v;
}
RGBase.prototype.proxy = function () {
	var attrs;
	var attr;
	var v;
	var obj = {};
	var f = this.constructor;
	while (f) {
		attrs = f.$attrs;
		for (var p in attrs) {
			attr = attrs[p];
			if (attr.get) {
				v = attr.get.call(this);
				if (v && v.noProxy) {
					if (v.toProxy) {
						v = v.toProxy(false);
						if (typeof v === "object" && Object.keys(v).length > 0) {
							obj[p] = v;
						}	
					}
				} else {
					if (v) {
						v = $$_getProxy(v);
					}
					obj[p] = v;
				}
			}
		}
		f = f.prototype.$base && f.prototype.$base.constructor;
	}
	obj.$_hash = this.$_hash;
	return obj;
};
RGBase.prototype.as = function (clazz) {
	return this instanceof clazz ? this : null;
};
var throwDebugError = function (err) {
	if ($_debug) {
		throw err;
	}
};
var _throwAbstractError = function () {
	var caller = arguments.callee.caller; // => function that call throwAbstractError 
	throw Errors.NOT_YET_IMPLEMENTED + ": " + caller.$owner.$name + "::" + caller.$name;
};
var throwAbstractError = _throwAbstractError;
var _cast = function (obj, clazz) {
	return obj instanceof clazz ? obj : null;
};
var EventAware = defineClass(null, null, {
	init: function (nohash) {
		this._super(nohash);
		this._listeners = [];
	},
	destroy: function() {
		this._destroying = true;
		this._listeners = null;
		for (var attr in this) {
			// if (this[attr] instanceof VisualStyles) {
			// 	VisualStyles의 경우 여기서는 처리하지 않는다.
			// }
			if (this[attr] instanceof Rectangle) {
				this[attr] = null;
			}
		}	
		this._super();
	},
	addListener: function (listener, index) {
		if (listener && this._listeners.indexOf(listener) < 0) {
			if (index != undefined && index >= 0)
				this._listeners.splice(index, 0, listener);
			else
				this._listeners.push(listener);
		}
		return this;
	},
	removeListener: function (listener) {
		var i;
		if (listener && (i = this._listeners.indexOf(listener)) >= 0) {
			this._listeners.splice(i, 1);
		}
		return this;
	},
	fireEvent: function (event) {
		var i, listener, callback;
		var cnt = this._listeners.length;
		var args = Array.prototype.slice.call(arguments, 0);
		args[0] = this;
		for (i = 0; i < cnt; i++) {
			listener = this._listeners[i];
			callback = listener[event];
			callback && callback.apply(listener, args);
		}
	},
	fireConfirmEvent: function (event) {
		var i, listener, callback;
		var cnt = this._listeners.length;
		var args = Array.prototype.slice.call(arguments, 0);
		args[0] = this;
		for (i = 0; i < cnt; i++) {
			listener = this._listeners[i];
			callback = listener[event];
			if (callback) {
				var ret = callback.apply(listener, args);
				if (typeof ret === "boolean" && !ret) {
					return false;
				}
			}
		}
		return true;
	},
    fireMessageEvent: function (event) {
        var i, listener, callback;
        var cnt = this._listeners.length;
        var args = Array.prototype.slice.call(arguments, 0);
        args[0] = this;
        for (i = 0; i < cnt; i++) {
            listener = this._listeners[i];
            callback = listener[event];
            if (callback) {
                var ret = callback.apply(listener, args);
                if (typeof ret === "string" && ret) {
                    return ret;
                }
            }
        }
        return null;
    },
    fireObjectEvent: function (event) {
        var i, listener, callback;
        var cnt = this._listeners.length;
        var args = Array.prototype.slice.call(arguments, 0);
        args[0] = this;
        for (i = 0; i < cnt; i++) {
            listener = this._listeners[i];
            callback = listener[event];
            if (callback) {
                var ret = callback.apply(listener, args);
                if (ret != null) {
                    return ret;
                }
            }
        }
        return null;
    }

});
var Base64 = {
    // private property
    _keyStr : "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=",
    // public method for encoding
    encode : function (input) {
        var output = "";
        var chr1, chr2, chr3, enc1, enc2, enc3, enc4;
        var i = 0;
        input = Base64._utf8_encode(input);
        while (i < input.length) {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2)) {
                enc3 = enc4 = 64;
            } else if (isNaN(chr3)) {
                enc4 = 64;
            }
            output = output +
            this._keyStr.charAt(enc1) + this._keyStr.charAt(enc2) +
            this._keyStr.charAt(enc3) + this._keyStr.charAt(enc4);
  
        }
        return output;
    },
    // public method for decoding
    decode : function (input) {
        var output = "";
        var chr1, chr2, chr3;
        var enc1, enc2, enc3, enc4;
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, "");
        while (i < input.length) {
            enc1 = this._keyStr.indexOf(input.charAt(i++));
            enc2 = this._keyStr.indexOf(input.charAt(i++));
            enc3 = this._keyStr.indexOf(input.charAt(i++));
            enc4 = this._keyStr.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64) {
                output = output + String.fromCharCode(chr2);
            }
            if (enc4 != 64) {
                output = output + String.fromCharCode(chr3);
            }
        }
        output = Base64._utf8_decode(output);
        return output;
    },
  
    // private method for UTF-8 encoding
    _utf8_encode : function (string) {
        string = string.replace(/\r\n/g,"\n");
        var utftext = "";
        for (var n = 0; n < string.length; n++) {
            var c = string.charCodeAt(n);
            if (c < 128) {
                utftext += String.fromCharCode(c);
            }
            else if((c > 127) && (c < 2048)) {
                utftext += String.fromCharCode((c >> 6) | 192);
                utftext += String.fromCharCode((c & 63) | 128);
            }
            else {
                utftext += String.fromCharCode((c >> 12) | 224);
                utftext += String.fromCharCode(((c >> 6) & 63) | 128);
                utftext += String.fromCharCode((c & 63) | 128);
            }
  
        }
  
        return utftext;
    },
  
    // private method for UTF-8 decoding
    _utf8_decode : function (utftext) {
        var string = "";
        var i = 0;
        var c = c1 = c2 = 0;
  
        while ( i < utftext.length ) {
  
            c = utftext.charCodeAt(i);
  
            if (c < 128) {
                string += String.fromCharCode(c);
                i++;
            }
            else if((c > 191) && (c < 224)) {
                c2 = utftext.charCodeAt(i+1);
                string += String.fromCharCode(((c & 31) << 6) | (c2 & 63));
                i += 2;
            }
            else {
                c2 = utftext.charCodeAt(i+1);
                c3 = utftext.charCodeAt(i+2);
                string += String.fromCharCode(((c & 15) << 12) | ((c2 & 63) << 6) | (c3 & 63));
                i += 3;
            }
  
        }
  
        return string;
    }
  
}
var EventAware$ = EventAware.prototype;
var $$_compareTextValue = function (v1, v2, caseSensitive, partialMatch) {
	if (v1 === v2) {
		return true;
	}
	var s1 = String(v1);
	var s2 = v2 == null ? undefined : String(v2);
	if (!s1 && !s2) {
		return true;
	}
	if (!s1 || !s2) {
		return false;
	}
	if (!caseSensitive) {
		s1 = s1.toLowerCase();
		s2 = s2.toLowerCase();
	}
	if (partialMatch) {
		return s2.indexOf(s1) >= 0;
	} else {
		return s1 == s2;
	}
};
var $$_get_obj = function (source, props) {
	var obj = source;
	for (var i = 0, cnt = props.length - 1; i < cnt; i++) {
		var p = props[i];
		var obj2 = obj[p];
		if (obj2 === UNDEFINED) {
			obj2 = obj[p] = {};
		}
		obj = obj2;
	}
	return obj;
};
var $$_expand_object = function (obj) {
	var list = [];
	for (var p in obj) {
		var i = p.indexOf(".");
		if (i >= 0) {
			list.push(p);
		}
	}
	if (list.length > 0) {
		var obj2 = {};
		for (var p in obj) {
			obj2[p] = obj[p];
		}
		obj = obj2;
		for (var j = list.length; j--;) {
			p = list[j];
			var arr = p.split(".");
			var s = arr[0];
			if (s) {
				obj2 = $$_get_obj(obj, arr);
				obj2[arr[arr.length - 1]] = obj[p]; 
			}
		}
	} 
	return obj;
};
var Dictionary = function () {
	this._values = {};
	this._keys = {};
};
Dictionary.prototype = {
	constructor: Dictionary,
	containsKey: function (key) {
		return key && this._values.hasOwnProperty(key.$_hash);
	},
	isEmpty: function () {
		for (var v in this._values) {
			return false;
		}
		return true;
	},
	set: function (key, value) {
		if (!key || !key.$_hash) {
			throw "Invalid key";
		}
		this._values[key.$_hash] = value;
		this._keys[key.$_hash] = key;
	},
	unset: function (key) {
		if (key && this._values.hasOwnProperty(key.$_hash)) {
			delete this._values[key.$_hash];
			delete this._keys[key.$_hash];
			return true;
		}
		return false;
	},
	clear: function () {
		this._values = {};
		this._keys = {};
	},
	get: function (key) {
		return key ? this._values[key.$_hash] : undefined;
	},
	keys: function () {
		var a = [];
		for (var k in this._values) {
			a.push(this._keys[k]);
		}
		return a;
	},
	values: function () {
		var a = [];
		for (var k in this._values) {
			a.push(this._values[k]);
		}
		return a;
	},
	each: function (iterator) {
		for (var k in this._values) {
			iterator.call(null, this._keys[k], this._values[k]);
		}
	},
	checkTrue: function (iterator) {
		for (var k in this._values) {
			if (iterator.call(null, this._keys[k], this._values[k])) {
				return true;
			}
		}
		return false;
	},
	checkFalse: function (iterator) {
		for (var k in this._values) {
			if (!iterator.call(null, this._keys[k], this._values[k])) {
				return true;
			}
		}
		return false;
	}
};
function equalArrays(a, b) {
	if (a === b)
		return true;
	if (a == null || b == null)
		return false;
	var len = a.length;
	if (len != b.length)
		return false;
	for (var i = 0; i < len; ++i) {
		if (a[i] !== b[i])
			return false;
	}	
	return true;
}
function decimalAdjust(type, value, exp) {
	if (typeof exp === 'undefined' || +exp === 0) {
		return Math[type](value);
	}
	value = +value;
	exp = +exp;
	if (isNaN(value) || !(typeof exp === 'number' && exp % 1 === 0)) {
		return NaN;
	}
	value = value.toString().split('e');
	value = Math[type](+(value[0] + 'e' + (value[1] ? (+value[1] - exp) : -exp)));
	value = value.toString().split('e');
	return +(value[0] + 'e' + (value[1] ? (+value[1] + exp) : exp));
}
var _round10 = function(value, exp) {
	return decimalAdjust('round', value, exp);
};
var _floor10 = function(value, exp) {
	return decimalAdjust('floor', value, exp);
};
var _ceil10 = function(value, exp) {
	return decimalAdjust('ceil', value, exp);
};
var $$_mobile = undefined;
var $$_setMobile = function (value) {
	$$_mobile = value;
}
var _isMobile = function () {
	if ($$_mobile == undefined) {
		var check = false;
		if (navigator.userAgent.match(/Android/i)
			|| navigator.userAgent.match(/webOS/i)
			|| navigator.userAgent.match(/iPhone/i)
			|| navigator.userAgent.match(/iPad/i)
			|| navigator.userAgent.match(/iPod/i)
			|| navigator.userAgent.match(/BlackBerry/i)
			|| navigator.userAgent.match(/Windows Phone/i)
		)
			check = true;
		if (!check) {
			(function (a) {
				if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(a) ||
					/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(a.substr(0, 4)))
					check = true;
			})(navigator.userAgent || navigator.vendor || window.opera);
		}
		return check;
	} else {
		return Boolean($$_mobile);
	}
};
var ImageList = function (name, rootUrl) {
    var _name = name;
    var _rootUrl = rootUrl;
    var _urls = [];
    var _listeners = [];
    var _images = [];
    this.name = function () {
        return _name;
    };
    this.count = function () {
        return _urls.length;
    };
    this.addListener = function (listener) {
        if (listener && _listeners.indexOf(listener) < 0) {
            _listeners.push(listener);
        }
    };
    this.removeListener = function (listener) {
        var idx = _listeners.indexOf(listener);
        if (idx >= 0) {
            _listener.splice(idx, 1);
        }
    };
    this.addUrl = function (url) {
        if (url && _urls.indexOf(url) < 0) {
            _urls.push(url);
        }
    };
    this.addUrls = function (urls) {
        if (urls) {
            for (var i = 0; i < urls.length; i++) {
                this.addUrl(urls[i]);
            }
        }
    };
    this.getImage = function (index) {
        if (index >= 0 && index < _urls.length) {
            var image = _images[index];
            if (image) {
                return image;
            }
            image = new Image();
            image["index"] = index;
            image["owner"] = this;
            _images[index] = image;
            image.onload = function () {
                this.owner._fireLoaded(this.index);
            }.bind(image);
            image.src = _rootUrl + _urls[index];
        }
        return null;
    };
    this._fireLoaded = function (index) {
        for (var i = 0; i < _listeners.length; i++) {
            _listeners[i].onImageListImageLoaded(this, index);
        }
    };
};
var ImagePool = function () {
    var _listeners = [];
    var _images = {};
    this.addListener = function(listener) {
        if (listener && _listeners.indexOf(listener) < 0) {
            _listeners.push(listener);
        }
    };
    this.removeListener = function(listener) {
        var idx = _listeners.indexOf(listener);
        if (idx >= 0) {
            _listeners.splice(idx, 1);
        }
    };
    this.destroy = function() {
        _images = {};
    }
    this.getImage = function(url) {
        if (url) {
            var image = _images[url];
            if (image) {
                return image;
            }
            image = new Image();
            image["owner"] = this;
            image["url"] = url;
            _images[url] = image;
            image.onload = function() {
                this.owner._fireLoaded(this.url);
            }.bind(image);
            image.src = url;
        }
        return null;
    };
    this._fireLoaded = function(url) {
        for (var i = 0; i < _listeners.length; i++) {
            _listeners[i].onImageLoaded(url);
        }
    };
};
function _parseXml(source) {
	var doc = null;
	try {
		doc = new ActiveXObject("Microsoft.XMLDOM");
		doc.async = false;
		doc.loadXML(source);
	} catch (e) {
		if (doc) throw e;
		doc = new DOMParser().parseFromString(source, "text/xml");
	}
	return doc;
}
function _xmlToStr(doc) {
	if (doc) {
		try {
			return new XMLSerializer().serializeToString(doc);
		} catch (e) {
			return doc.xml;
		}
	}
}
function _getXmlList(xml, tagName) {
	var nodes = [];
	if (xml) {
		var list = xml.childNodes;
		if (list) {
			for (var i = 0, cnt = list.length; i < cnt; i++) {
				var node = list[i];
				if (node.tagName === tagName) {
					nodes.push(node);
				}
			}
		}
	}
	return nodes;
}
function _getNodeValue(xml) {
    return xml.firstChild.nodeValue;
}
function _getXmlAttr(xml, attr) {
	return xml ? xml.getAttribute(attr) : undefined;
}
function _setXmlAttr(xml, attr, value) {
	xml.setAttribute(attr, value);
}
function _addChildWithAttr(doc, parent, child, attr, value) {
	var node = doc.createElement(child);
	attr && node.setAttribute(attr, value);
	parent.appendChild(node);
	return node;
}
var $$$_DEC_SEP = ".";
var $$$_GRP_SEP = ","
function decimalPlaces(num) {
  var match = (''+num).match(/(?:\.(\d+))?(?:[eE]([+-]?\d+))?$/);
  if (!match) { return 0; }
  return Math.max(
       0,
       // Number of digits right of decimal point.
       (match[1] ? match[1].length : 0)
       // Adjust for scientific notation.
       - (match[2] ? +match[2] : 0));
}

var DecimalFormatter = defineClass("DecimalFormatter", null, {
	init : function(format) {
		this._super();
		this._optDecimal = false;
		this._groupPos = 0;
		this._seperator = null;
		this._groupSep = null;
		this._reg = null;
		this._regDecimal = null;
		this._replacement = "$&,";
		this._round = null;
		this._displayMinusZero = true;
		this.parse(format);
	},
	format: function (value) {
		var v = Number(value);
		var p;
		if (isNaN(v)) {
			return "";
		} else {
			var digits = this._minDigits;
			if (this._optDecimal) {
				var dlen = decimalPlaces(v);
				digits = Math.min(Math.max(dlen, this._minDigits),this._maxDigits);
			}
			if (digits > 0 && this._round) {
				p = Math.pow(10,digits);
				switch(this._round) {
					case "c" :
						v = Math.ceil(p * v) / p; 
						break;
					case "f" :
						var arr = v.toString().split(".");
						v = parseFloat(arr.length > 1 ? arr[0] + "."+ arr[1].substr(0,digits) : arr[0]);
						break;
				}
			};
			v = (this._round === "a") ? Math.abs(v) : v;
			v = Number(v.toPrecision(15));
			var fixed = v.toFixed(digits);
			try {
				!this._displayMinusZero && (p = parseFloat(fixed)) === Math.abs(parseFloat(fixed)) && p === 0 && (fixed = Math.abs(v).toFixed(digits));
			} catch (e) {
			}
			if (this._seperator) {
				fixed = fixed.replace($$$_DEC_SEP, this._seperator)
			}
			if (this._reg) {
				if(digits)
					return fixed.replace(this._regDecimal, this._replacement);
				else
					return fixed.replace(this._reg, this._replacement);
			} else {
				return fixed;
			}
		}
	},
	parse: function (format) {
		this._minDigits = 0;
		this._maxDigits = 0;
		this._minInts = 0;
		this._maxInts = 0;
		this._parse(format);
	},
	_parse: function (format) {
		function _isRoundChar(c) {
			return _included(c, "c","f","C","F","a","A");
		};
		if (format) {
			format = format.trim();
		}
		if (!format) {
			return;
		}
		var seperator = $$$_DEC_SEP;
		var groupSep = $$$_GRP_SEP;
		if (format.indexOf(";") > -1) {
			var fmts = format.split(";");
			format = fmts[0];
			if (fmts.length > 1 && fmts[1] && !_isRoundChar(fmts[1])) 
				seperator = fmts[1];
			if (fmts.length > 2 && fmts[2] && !_isRoundChar(fmts[2]))
				groupSep = fmts[2];
			this._round = fmts[3] || fmts[2] || fmts[1];
			this._round = _isRoundChar(this._round) ? this._round.toLowerCase() : this._round;
		}
		this._seperator = seperator == $$$_DEC_SEP ? null : seperator;
		this._groupSep = groupSep == $$$_GRP_SEP ? null : groupSep;
		var i;
		var c;
		var len = format.length;
		var period = format.indexOf($$$_DEC_SEP);
		this._optDecimal = format.indexOf("#",period) > 0;
		if (period >= 0) {
			for (i = period + 1; i < len; i++) {
				if (format.charAt(i) == "0") {
					this._minDigits++;
					this._maxDigits++;
				} else {
					break;
				}
			}
			for (; i < len; i++) {
				if (format.charAt(i) == "#") {
					this._maxDigits++;
				} else {
					break;
				}
			}
		
			format = format.substr(0, period);
		}
		if (format) {
			len = format.length;
			if (format.charAt(len - 1) == $$$_GRP_SEP) {
				this._groupPos = 3; // locale default
				format = format.substr(0, len - 1);
			}
		}
		if (format) {
			len = format.length;
			var zero = true;
			for (i = len - 1; i >= 0; i--) {
				c = format.charAt(i);
				if (c == "0" && zero) {
					this._minInts++;
					this._maxInts++;
				} else if (this._groupPos == 0 && c == $$$_GRP_SEP) {
					this._groupPos = len - i - 1;
				} else if (c == "#") {
					zero = false;
				} else {
					break;
				}
			}
		}
		if (this._groupPos > 0) {
			this._replacement = "$&" + groupSep;
			this._reg        = new RegExp('\\d(?=(\\d{' + this._groupPos + '})+($|\\' + seperator + '))', 'g');
			this._regDecimal = new RegExp('\\d(?=(\\d{' + this._groupPos + '})+\\' + seperator + ')', 'g');
		}
	},
	setDisplayMinusZero: function(value) {
		this._displayMinusZero = value;
	}
}, {
	PerformTest: function (format, count) {
		var f = new DecimalFormatter(format);
		var t = _getTimer();
		for (var i = 0; i < count; i++) {
			f.format(1234567.1234);
		}
		t = _getTimer() - t;
		trace("##### DecimalFormat PerformTest Result : " + t + " msces.");
	},
	Test: function (format, value) {
		var f = new DecimalFormatter(format);
		var r = f.format(value);
		trace("##### DecimalFormat Test Result : " + r );
	}
});
var BooleanFormatter = defineClass("BooleanFormatter", null, {
	init : function(format) {
		this._super();
		this._format = format;
		this._nullText = null;
		this._trueText = null;
		this._falseText = null;
		this._parse();
	},
	format: null,
	setFormat: function (value) {
		if (value != this._format) {
			this._format = value;
			this._parse();
		}
	},
	formatValue: function (v) {
		return (v === UNDEFINED) ? this._nullText : v ? this._trueText : this._falseText;
	},
	_parse: function () {
		this._falseText = this._trueText = null;
		if (this._format) {
			var arr = this._format.split(/[;\:]/);
			this._falseText = arr[0];
			if (arr.length > 0) {
				this._trueText = arr[1];
			}
			if (arr.length > 1) {
				this._nullText = arr[2];
			}
		}
	}
});
var BooleanConverter = function (format) {
	var _format = format;
	var _values = null;
	var _sensitive = true;
	var _trueText = null;
	var _falseText = null;
	this.format = function () {
		return _format;
	};
	this.setFormat = function (value) {
		if (value != _format) {
			_format = value;
			parse(value);
		}
	};
	this.toBool = function (value) {
		if (_values) {
			if (value) {
				var s = _sensitive ? String(value) : String(value).toLowerCase();
				if (s in _values) {
					return _values[s];
				}
			}
		}
		return Boolean(value);
	};
	this.toBoolEx = function (value) {
		var s = _sensitive ? String(value) : String(value).toLowerCase();
		if (_values) {
			if (s in _values) {
				return _values[s];
			}
		}
		return s ? Boolean(s) : undefined; // s ? true : undefined 오 동일.
	};
	this.toBoolStrict = function (value) {
		if (_values) {
			var s = _sensitive ? String(value) : String(value).toLowerCase();
			if (s in _values) {
				return _values[s];
			}
		}
		return undefined;
	};
	this.toText = function (value) {
		return value ? _trueText : _falseText;
	};
	var parse = function (fmt) {
		if (fmt) {
			var s,
				i,
				arr = fmt.split(/[;\:]/),
				falses,
				trues,
				sensitive = true;
			s = arr[0];
			falses = s ? s.split(",") : null;
			if (arr.length > 1) {
				s = arr[1];
				trues = s ? s.split(",") : null;
			}
			if (arr.length > 2) {
				s = trim(arr[2]);
				if (s == "0")
					sensitive = false;
			}
			_values = {};
			_sensitive = sensitive;
			for (i = 0; i < falses.length; i++) {
				s = falses[i];
				_values[sensitive ? s : s.toLowerCase()] = false;
			}
			for (i = 0; i < trues.length; i++) {
				s = trues[i];
				_values[sensitive ? s : s.toLowerCase()] = true;
			}
			_trueText = trues && trues.length > 0 ? trues[0] : "true";
			_falseText = falses && falses.length > 0 ? falses[0] : "false";
		} else {
			_values = {};
			_values["true"] = true;
			_values["false"] = false;
			_trueText = "true";
			_falseText = "false";
		}
	};
	parse(_format);
};
BooleanConverter.Default = new BooleanConverter("false,f,0:true,t,1:0");
var DATE_SEPARATORS = "./-: ";
var DateTimeParser = defineClass("DateTimeParser", null, {
	init : function(format) {
		this._super();
		this._baseYear = 0;
		this._patterns = [];
		this.setFormat(format);
	},
	format: null,
	baseYear: 2000,
	amText: "AM",
	pmText: "PM",
	setFormat: function (value) {
		if (value != this._format) {
			if (!value) {
				throw "Invalid empty date format";
			}
			this.$_parseFormat(value);
			this._format = value;
		}
	},
	setBaseYear: function (value) {
		if (value != this._baseYear) {
			this._baseYear = value;
		}
	},
	setAmText: function (value) {
		if (value != this._amText) {
			this._amText = value;
		}
	},
	setPmText: function (value) {
		if (value != this._pmText) {
			this._pmText = value;
		}
	},
	parse: function (str) {
		try {
			var y = 0;
			var m = 1;
			var d = 1;
			var h = 0;
			var n = 0;
			var s = 0;
			var S = 0;
			var am = 0;
			var pm = 0;
			var len = this._patterns.length;
			var i;
			var p = 0;
			var strlen = str.length;
			for (i = 0; i < len && p < strlen; i++) {
				var pattern = this._patterns[i];
				var c = pattern.c;
				var l = pattern.len;
				switch (c) {
					case "y":
						y = _int(str.substr(p, l));
						break;
					case "M":
						m = _int(str.substr(p, l));
						break;
					case "d":
						d = _int(str.substr(p, l));
						break;
					case "a":
						if (this._amText && str.indexOf(this._amText, p) == p) {
							am = 12;
							l = this._amText.length;
						} else if (this._pmText && str.indexOf(this._pmText, p) == p) {
							pm = 12;
							l = this._pmText.length;
						} else {
							return null;
						}
						break;
					case "H":
						h = _int(str.substr(p, l));
						break;
					case "h":
						h = _int(str.substr(p, l));
						break;
					case "m":
						n = _int(str.substr(p, l));
						break;
					case "s":
						s = _int(str.substr(p, l));
						break;
					case "S":
						S = _int(str.substr(p, l));
						break;
					case ".":
					case "/":
					case "-":
					case ":":
					case " ":
						/*
						if (strict) {
							if (str.charAt(p) != c) {
								return null;
							}
						} else*/ if (DATE_SEPARATORS.indexOf(str.charAt(p)) < 0) {
							return null;
						}
						break;
					default:
						return null;
				}
				p += l;
			}
		} catch (err) {
			return null;
		}
		if (y < 100) {
			y += this._baseYear;
		}
		if (am > 0) {
			if (h == 12) {
				h = 0;
			}
		} else if (pm > 0 && h < 12) {
			h += 12;
		}
		return new Date(y, m - 1, d, h, n, s, S);
	},
	$_parseFormat: function (format) {
		var s = format;
		var len = s.length;
		var i = 0;
		var p;
		var c;
		var l;
		this._patterns = [];
		while (i < len) {
			p = i;
			c = s.charAt(i);
			if (_isWhitespace(c)) {
				i++;
				while (i < len && _isWhitespace(s.charAt(i))) {
					i++;
				}
				this._patterns.push({ c: " ", p: p, len: i - p });
			} else {
				l = 0;
				switch (c) {
					case "y":
						l = this.$_getPattern(s, i, c);
						if (l != 4 && l != 2) this.$_throwInvalidFormat(s);
						break;
					case "M":
					case "d":
					case "H":
					case "h":
					case "m":
					case "s":
						l = this.$_getPattern(s, i, c);
						if (l != 2) this.$_throwInvalidFormat(s);
						break;
					case "S":
						l = this.$_getPattern(s, i, c);
						if (l != 3) this.$_throwInvalidFormat(s);
						break;
					case "a":
					case ".":
					case "/":
					case "-":
					case ":":
						l = this.$_getPattern(s, i, c);
						if (l != 1) this.$_throwInvalidFormat(s);
						break;
					default:
						this.$_throwInvalidFormat(s);
				}
				if (l > 0) {
					this._patterns.push({ c: c, p: i, len: l });
					i += l;
				}
			}
		}
	},
	$_throwInvalidFormat: function (format) {
		if ($_debug) debugger;
		throw "Invalid date format: " + format;
	},
	$_throwInvalidValue: function (value) {
		if ($_debug) debugger;
		throw "Invalid date text: " + value;
	},
	$_getPattern: function (str, i, c) {
		var len = 1;
		while (++i < str.length && str.charAt(i) == c)
			len++;
		return len;
	}
});
var $$_DT_DATE_TOKENS = [
	"yy", "yyyy",
	"M", "MM",
	"d", "dd",
	"a",
	"H", "HH", "h", "hh",
	"m", "mm",
	"s", "ss",
	"S", "SS", "SSS"
];
var $$_DT_DATE_SEPARATORS = [
	".", "/", "-", ":"
];
var U_0 = "0".charCodeAt(0);
var U_9 = "9".charCodeAt(0);
var U_Z = "Z".charCodeAt(0);
var L_Z = "z".charCodeAt(0);
var U_A = "A".charCodeAt(0);
var L_A = "a".charCodeAt(0);
var U_Y = "Y".charCodeAt(0);
var L_Y = "y".charCodeAt(0);
var U_M = "M".charCodeAt(0);
var L_M = "m".charCodeAt(0);
var U_D = "D".charCodeAt(0);
var L_D = "d".charCodeAt(0);
var U_H = "H".charCodeAt(0);
var L_H = "h".charCodeAt(0);
var U_S = "S".charCodeAt(0);
var L_S = "s".charCodeAt(0);
var DateTimeWriter = function (format) {
	var _format = null;
	var _amText = null;
	var _pmText = null;
	var _baseYear = 2000;
	var _preserveTime = false;
	var _tokens = null;
	var _hasAmPm = false;
	var _formatString = null;
	var _parseDateFormatTokens = function (format) {
		var tokens = [];
		if (format) {
			var tok, p, c;
			var str = format.trim();
			var len = str.length;
			var i = 0;
			while (i < len) {
				tok = str.charAt(i);
				if ($$_DT_DATE_SEPARATORS.indexOf(tok) >= 0) {
					tokens.push(tok);
					i++;
				} else {
					p = i++;
					while (i < len && str.charAt(i) == tok) {
						i++;
					}
					tok = str.substring(p, i);
					if ($$_DT_DATE_TOKENS.indexOf(tok) < 0) {
						c = tok.charCodeAt(0);
						if (c >= U_A && c <= U_Z || c >= L_A && c <= L_Z) {
							throw new Error("Invalid datetime write format: " + format);
						}
					}
					tokens.push(tok);
				}
				if (i < len && _isWhitespace(tok = str.charAt(i))) {
					tokens.push(tok);
					while (i < len && _isWhitespace(str.charAt(i))) {
						i++;
					}
				}
			}
		}
		return tokens;
	};
	var _parse = function (fmt) {
		_amText = "AM";
		_pmText = "PM";
		if (fmt) {
			var arr = fmt.split(";");
			_format = arr[0] || DateTimeWriter.$_DefaultFormat;
			_tokens = _parseDateFormatTokens(_format);
			_hasAmPm = _tokens.indexOf("a") >= 0 || _tokens.indexOf("A") >= 0;
			if (arr.length > 1 && arr[1]) {
				var ampms = arr[1].split(",");
				if (ampms.length > 0 && ampms[0]) {
					_amText = ampms[0];
				}
				if (ampms.length > 1 && ampms[1]) {
					_pmText = ampms[1];
				}
			}
		}
	};
	var _pad = function (v) {
		return (v < 10) ? "0" + v : String(v);
	};
	this.format = function () {
		return _format;
	};
	this.formatString = function () {
		return _formatString;
	};
	this.setFormatString = function (value) {
		value = value || DateTimeWriter.$_DefaultFormat;
		if (value != _formatString) {
			_tokens = [];
			_parse(value);
			_formatString = value;
		}
	};
	this.getText = function (d) {
		if (!_tokens) {
			return "";
		}
		var date = d;
		if (!(date instanceof  Date)) {
			date = new Date(d);
		}
		var h;
		var s = "";
		for (var i = 0, cnt = _tokens.length; i < cnt; i++) {
			var t = _tokens[i];
			var len = t.length;
			switch (t.charCodeAt(0)) {
				case L_Y:
					s += len > 2 ? date.getFullYear() : _pad(date.getFullYear() % 100);
					break;
				case U_M:
					s += len > 1 ? _pad(date.getMonth() + 1) : (date.getMonth() + 1);
					break;
				case L_D:
					s += len > 1 ? _pad(date.getDate()) : date.getDate();
					break;
				case U_H:
					s += len > 1 ? _pad(date.getHours()) : date.getHours();
					break;
				case L_H:
					if (_hasAmPm) {
						h = date.getHours();
						if (h == 0) {
							h = 12
						} else if (h > 12) {
							h = h - 12;
						}
						s += len > 1 ? _pad(h) : h;
					} else {
						s += len > 1 ? _pad(date.getHours()) : date.getHours();
					}
					break;
				case L_M:
					s += len > 1 ? _pad(date.getMinutes()) : date.getMinutes();
					break;
				case L_S:
					s += len > 1 ? _pad(date.getSeconds()) : date.getSeconds();
					break;
				case L_A:
				case U_A:
					if (date.getHours() < 12) {
						s += _amText;
					} else {
						s += _pmText;
					}
					break;
				case U_S:
					s += date.getMilliseconds().toString().substr(0, len);
					break;
				/*
				 case U_Y:
				 break;
				 case U_D:
				 s += day of year
				 break;
				 */
				default:
					s += t;
			}
		}
		return s;
	};
	this.setFormatString(format || DateTimeWriter.$_DefaultFormat);
};
DateTimeWriter.$_DefaultFormat = "yyyy/MM/dd";
DateTimeWriter.Default = new DateTimeWriter(DateTimeWriter.$_DefaultFormat);
var $$_DATE_TOKENS = [
	"yy", "yyyy",
	"M", "MM",
	"d", "dd",
	"a", "A",
	"H", "HH", "h", "hh",
	"m", "mm",
	"s", "ss"
];
var $$_DATE_SEPARATORS = [
	".", "/", "-", ":"
];
var $$_ZERO_CHAR = "0".charCodeAt(0);
var $$_NINE_CHAR = "9".charCodeAt(0);
var DatetimeConverter = function (format) {
	var _formatString = null;
	var _format = null;
	var _amText = null;
	var _pmText = null;
	var _baseYear = 2000;
	var _preserveTime = false;
	var _splitWords = function (str) {
		var i, p, c, c2;
		var len = str.length;
		var words = [];
		p = i = 0;
		c = str.charAt(i++);
		while (i < len) {
			c2 = str.charAt(i);
			if (c2 != c) {
				words.push(str.substring(p, i));
				c = c2;
				p = i;
			}
			i++;
		}
		if (p < len) {
			words.push(str.substr(p));
		}
		return words;
	};
	var _parseDateFormatTokens = function (format) {
		var str;
		var tokens = [];
		if (str = _trim(format)) {
			var c, p, s, j;
			var len = str.length;
			var i = 0;
			while (i < len) {
				c = str.charAt(i);
				if ($$_DATE_SEPARATORS.indexOf(c) >= 0) {
					tokens.push(c);
					i++;
				} else {
					p = i++;
					while (i < len && str.charAt(i) == c) {
						i++;
					}
					c = str.substring(p, i);
					if ($$_DATE_TOKENS.indexOf(c) < 0) {
						throw new Error("Invalid datetime read format: " + format);
					}
					tokens.push(c == "A" ? "a" : c);
				}
				if (i < len && _isWhitespace(c = str.charAt(i))) {
					tokens.push(" ");
					while (i < len && _isWhitespace(str.charAt(i))) {
						i++;
					}
				}
			}
			var tokens2 = [];
			len = tokens.length;
			p = 0;
			for (i = 0; i < len; i++) {
				c = tokens[i];
				if (c == "a" || $$_DATE_TOKENS.indexOf(c) < 0) {
					if (p > 1) {
						tokens2.push("E");
					}
					tokens2.push(c);
					p = 0;
				} else {
					if (p == 1) {
						tokens2.splice(tokens2.length - 2, 0, "L");
					}
					tokens2.push(c);
					p++;
				}
			}
			tokens = tokens2;
		}
		return tokens;
	};
	var _parseDateValueTokens = function (date, amStr, pmStr) {
		var str;
		var tokens = [];
		var ampms = ["am", "pm", "AM", "PM", "Am", "Pm", "aM", "pM"];
		amStr && ampms.push(amStr);
		pmStr && ampms.push(pmStr);
		if (str = _trim(date)) {
			var c, p;
			var len = str.length;
			var i = 0;
			while (i < len) {
				c = str.charAt(i);
				if (DATE_SEPARATORS.indexOf(c) >= 0) {
					tokens.push(c);
					i++;
				} else if (c.charCodeAt(0) >= $$_ZERO_CHAR && c.charCodeAt(0) <= $$_NINE_CHAR) {
					p = i++;
					while (i < len && str.charCodeAt(i) >= $$_ZERO_CHAR && str.charCodeAt(i) <= $$_NINE_CHAR) {
						i++;
					}
					c = str.substring(p, i);
					tokens.push(c);
				} else {
					var idx = -1;
					for (var j = 0; j < ampms.length; j++) {
						if (str.indexOf(ampms[j], i) == i) {
							idx = j;
							break;
						}
					}
					if (idx < 0) {
						throw "Invalid date value: " + str;
					}
					tokens.push(ampms[j]);
					i += ampms[j].length;
				}
				if (i < len && _isWhitespace(c = str.charAt(i))) {
					tokens.push(" ");
					while (i < len && _isWhitespace(str.charAt(i))) {
						i++;
					}
				}
			}
		}
		return tokens;
	};
	var _validateDateFormat = function (format) {
		if (format = _trim(format)) {
			var tokens = _parseDateFormatTokens(format);
			var i = 0;
			/*
			 var str:String = StringUtil.trim(format);
			 var arr:Array = str.split(/[\s+|\.|\-|\/|\:]/);
			 for each (var s:String in arr) {
			 if (s && DATE_TOKENS.indexOf(s) < 0) {
			 var words:Array = splitWords(s);
			 var valid:Boolean = true;
			 for each (var w:String in words) {
			 if(DATE_TOKENS.indexOf(w) < 0) {
			 valid = false;
			 break;
			 }
			 }
			 if (!valid) {
			 throw new Error("Invalid datetime read format: " + format);
			 }
			 }
			 }
			 var ampm:Boolean = arr.indexOf("a") >= 0 || arr.indexOf("A") >= 0;
			 */
			var ampm = tokens.indexOf("a") >= 0;
			if (ampm && tokens.indexOf("H") >= 0) {
				throw "Invalid datetime read format - 'H'와 'a'가 같이 존재할 수 없습니다: " + format;
			}
			if (tokens.indexOf("h") >= 0 && !ampm) {
				throw "Invalid datetime read format - 'h'가 있으면 'a'가 반드시 있어야 합니다: " + format;
			}
		}
	};
	var _parse = function (fmt) {
		_amText = "am";
		_pmText = "pm";
		_baseYear = 2000;
		_preserveTime = false;
		if (fmt) {
			var arr = fmt.split(";");
			_format = arr[0] ? arr[0] : _defaultFormat;
			_validateDateFormat(_format);
			if (arr.length > 1 && arr[1]) {
				_baseYear = _int(arr[1]);
			}
			if (arr.length > 2 && arr[2]) {
				var ampms = arr[2].split(",");
				_amText = ampms[0] ? ampms[0] : "am";
				if (ampms.length > 1) {
					_pmText = ampms[1] ? ampms[1] : "pm";
				}
			}
			if (arr.length > 3) {
				_preserveTime = arr[3] ? arr[3] == "1" : false
			}
		}
	};
	this.formatString = function () {
		return _formatString;
	};
	this.setFormatString = function (value) {
		if (value != _formatString) {
			_formatString = value;
			_parse(value);
		}
	};
	this.format = function () {
		return _format;
	};
	/**
	 * 1. trim()한다.
	 * 2. 이어진 space는 하나의 space로 간주한다.
	 * 3. 일 구분자는 ".", "/", "-" 셋 중 하나면 된다.
	 */
	this.getDate = function (str) {
		var date/*Date*/ = null;
		if (str = _trim(str)) {
			var tokens = _parseDateFormatTokens(_format);
			var values = _parseDateValueTokens(str, _amText, _pmText);
			var ampm = tokens.indexOf("a") >= 0 || tokens.indexOf("A") >= 0;
			var len = tokens.length;
			var vlen = values.length;
			var y = 0;
			var m = 1;
			var d = 1;
			var h = 0;
			var n = 0;
			var s = 0;
			var am = 0;
			var pm = 0;
			var ss;
			var i = 0;
			var j = 0;
			while (i < len && j < vlen) {
				var token = tokens[i];
				var v = values[j];
				switch (token.charAt(0)) {
					case "L":
						ss = String(v);
						i++;
						while (i < len && (str = tokens[i]) != "E") {
							v = ss ? _int(ss.substr(0, str.length)) : -1;
							ss = ss.substr(str.length);
							switch (str.charAt(0)) {
								case "Y":
								case "y":
									y = Math.max(0, v);
									break;
								case "M":
									m = v >= 0 ? v : 1;
									break;
								case "D":
								case "d":
									d = v >= 0 ? v : 1;
									break;
								case "H":
								case "h":
									h = Math.max(0, v);
									break;
								case "m":
									n = Math.max(0, v);
									break;
								case "s":
									s = Math.max(0, v);
									break;
							}
							i++;
						}
						break;
					case "Y":
					case "y":
						y = _int(v);
						break;
					case "M":
						m = _int(v);
						break;
					case "D":
					case "d":
						d = _int(v);
						break;
					case "H":
					case "h":
						h = _int(v);
						break;
					case "m":
						n = _int(v);
						break;
					case "s":
						s = _int(v);
						break;
					case "a":
						str = String(v);
						if (str) {
							str = str.toLowerCase();
							if ((_amText && str == _amText.toLowerCase()) || (str == "am")) {
								am = 12;
							} else if ((_pmText && str == _pmText.toLowerCase()) || (str == "pm")) {
								pm = 12;
							}
						}
						break;
				}
				i++;
				j++;
			}
			if (y < 100 && y >= 0) {
				y += _baseYear;
			}
			if (y < 0 || y > 9999) {
				return null;
			}
			if (_included(m,1,3,5,7,8,10,12)) {
				if (d < 1 || d > 31) return null;
			} else if (_included(m,4,6,9,11)) {
				if (d < 1 || d > 30) return null;
			} else if (m == 2) {
				if (d > 29) {
					return null;
				}
				if (d == 29) {
					if (!((y % 4 == 0) && (y % 100 != 0) || (y % 400 == 0)))
						return null;
				}
			} else {
				return null;
			}
			if (h < 0 || h > 24) {
				return null;
			}
			if ((am > 0 || pm > 0) && h > 12) {
				return null;
			}
			if (n < 0 || n > 59) {
				return null;
			}
			if (s < 0 || s > 59) {
				return null;
			}
			if (am > 0) {
				h = h % 12;
			} else if (pm > 0) {
				h = h % 12 + 12;
			}
			date = new Date(y, m - 1, d, h, n, s);
		}
		return date;
	};
    this.getDateNull = function (s) {
        try {
            return this.getDate(s);
        } catch (err) {
        }
        return null;
    };
	this.getText = function (d) {
		var date/*Date*/ = d;
		if (!(date instanceof Date)) {
			date = new Date(d);
		}
		var tokens = _parseDateFormatTokens(_format);
		var ampm = tokens.indexOf("a") >= 0 || tokens.indexOf("A") >= 0;
		var s = "";
		var h;
		for (var i = 0, cnt = tokens.length; i < cnt; i++) {
			var t = tokens[i];
			var len = t.length;
			switch (t.charAt(0)) {
				case "L":
					break;
				case "Y":
				case "y":
					s += len > 2 ? date.getFullYear() : pad(date.getFullYear() % 100);
					break;
				case "M":
					s += len > 1 ? pad(date.getMonth() + 1) : date.getMonth() + 1;
					break;
				case "D":
				case "d":
					s += len > 1 ? pad(date.getDate()) : date.getDate();
					break;
				case "H":
					s += len > 1 ? pad(date.getHours()) : date.getHours();
					break;
				case "h":
					if (ampm) {
						h = date.getHours();
						if (h == 0) {
							h = 12
						} else if (h > 12) {
							h = h - 12;
						}
						s += len > 1 ? pad(h) : h;
					} else {
						s += len > 1 ? pad(date.getHours()) : date.getHours();
					}
					break;
				case "m":
					s += len > 1 ? pad(date.getMinutes()) : date.getMinutes();
					break;
				case "s":
					s += len > 1 ? pad(date.getSeconds()) : date.getSeconds();
					break;
				case "A":
				case "a":
					if (date.getHours() < 12) {
						s += _amText;
					} else {
						s += _pmText;
					}
					break;
				default:
					s += t;
			}
		}
		return s;
	};
	this._daysOfYear = function (d) {
		var MONTH_DAYS = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30];

		var days = 0;
		for (var i = 0; i < d.getMonth(); i++)
			days += MONTH_DAYS[i];
		
		if (d.getMonth() >= 2) {
			var y = d.getFullYear();
			if (y % 400 == 0 || (y % 4 == 0 && y % 100 != 0))
				days++;
		}
		
		days += d.getDate();
		
		return days;
	};
	this._daysOfPriorYears = function (y) {
		if (y <= 1900)
			return 0;
		
		y--;
		var leapDays =   
			parseInt(y / 4)   // plus julian leap days in prior years
			- parseInt(y / 100) // minus prior century years
			+ parseInt(y / 400) // plus years divisible by 400
			- 460;      // leap days in previous 1900 years
		
		return 365 * (y - 1899) + leapDays;
	};
	this.toExcelDate = function (d) {
		var DAY_MILLISECONDS = 86400000;

		var time = (((d.getHours() * 60 + d.getMinutes()) * 60 + d.getSeconds()) * 1000 + d.getMilliseconds()) / DAY_MILLISECONDS;
		var days = this._daysOfPriorYears(d.getFullYear()) + this._daysOfYear(d);
		
		var v = days + time;
		if (v >= 60) v++; // ?
		return v;
	};
	this.setFormatString(format);
};
DatetimeConverter.$_DefaultFormat = "yyyy/MM/dd";
DatetimeConverter.Default = new DatetimeConverter(DatetimeConverter.$_DefaultFormat);
DatetimeConverter.getSimpleDateNull = function(date) {
	if (date instanceof Date) {
		return date;
	};
	if (typeof date === "number") {
		return new Date(date);
	};
	date = date.length === 8 && /^[0-9]*$/.test(date) ? date.replace(/(\d{4})(\d{2})(\d{2})/,"$1/$2/$3") : date;
	var arr = date.split(/[.//-]/);
	if (arr.length != 3) {
		return null;
	};
	var y = parseInt(arr[0]), m = parseInt(arr[1]-1), d = parseInt(arr[2]);
	date = new Date(y,m,d);
	if (y == date.getFullYear() && m == date.getMonth() && d == date.getDate()) {
		return date;// 20190099 처럼 올바르지 않은 날짜는 null처리해버린다.
	} else {
		return null;
	}
}

var ISODateTimeParser = function () {
}
var $$_zoneOffset = new Date().getTimezoneOffset() * 60 * 1000;
ISODateTimeParser.parse = function (str, check) {
	var finalDate = null;
	try	{
		var t = str.indexOf("T");
		var dateStr = str.substring(0, t);
		var timeStr = str.substring(t + 1);
		var arr = dateStr.split("-");
		var len = arr.length;
		var year = _int(arr[0]);
		var month = len > 1 ? _int(arr[1]) : 1;
		var date = len > 2 ? _int(arr[2]) : 1;
		var multiplier;
		var offsetHours;
		var offsetMinutes;
		var offsetStr;
		if (timeStr.indexOf("Z") != -1) {
			multiplier = 1;
			offsetHours = 0;
			offsetMinutes = 0;
			timeStr = timeStr.replace("Z", "");
		} else if (timeStr.indexOf("+") != -1) {
			multiplier = 1;
			offsetStr = timeStr.substring(timeStr.indexOf("+") + 1, timeStr.length);
			offsetHours = Number(offsetStr.substring(0, offsetStr.indexOf(":")));
			offsetMinutes = Number(offsetStr.substring(offsetStr.indexOf(":") + 1, offsetStr.length));
			timeStr = timeStr.substring(0, timeStr.indexOf("+"));
		} else if (timeStr.indexOf("-") != -1) {
			multiplier = -1;
			offsetStr = timeStr.substring(timeStr.indexOf("-")+1, timeStr.length);
			offsetHours = Number(offsetStr.substring(0, offsetStr.indexOf(":")));
			offsetMinutes = Number(offsetStr.substring(offsetStr.indexOf(":") + 1, offsetStr.length));
			timeStr = timeStr.substring(0, timeStr.indexOf("-"));
		} else {
			multiplier = 0;
		}
		var timeArr = timeStr.split(":");
		len = timeArr ? timeArr.length : 0;
		var hour = len > 0 ? _int(timeArr[0]) : 0;
		var minutes = len > 1 ? _int(timeArr[1]) : 0;
		var secondsArr = (len > 2) ? String(timeArr[2]).split(".") : null;
		var seconds = (secondsArr && secondsArr.length > 0) ? _int(secondsArr[0]) : 0;
		var milliseconds = (secondsArr && secondsArr.length > 1) ? 1000 * parseFloat("0." + secondsArr[1]) : 0;
		var utc = Date.UTC(year, month-1, date, hour, minutes, seconds, milliseconds);
		var offset = multiplier ? (((offsetHours * 3600000) + (offsetMinutes * 60000)) * multiplier) : -$$_zoneOffset;
		finalDate = new Date(utc - offset);
		if (check && isNaN(finalDate.getTime())) {
			throw "Invalidate date text: " + str;
		}
	} catch (e) {
		if (check) {
			var eStr = "Invalid date Text: " + str;
			eStr += "\nError: " + e.toString();
			throw eStr;
		}
	}
	return finalDate;
};

var DateTimeReader = function (format) {
	var _format = null;
	var _type = 0;
	var _parser = new DateTimeParser();
	var _parse = function (fmt) {
		if (fmt) {
			var s = fmt.toLowerCase();
			_type = Math.max(0, DateTimeReader.FORMATS.indexOf(s));
			if (_type == 0) {
				_parser.setFormat(fmt);
			}
		}
	};
	this.format = function () {
		return _format;
	};
	this.setFormat = function (value) {
		if (value != _format) {
			_format = value;
			_parse(value);
		}
	};
	this.amText = function () {
		return _parser.amText();
	};
	this.setAmText = function (value) {
		_parser.setAmText(value);
	};
	this.pmText = function () {
		return _parser.pmText();
	};
	this.setPmText = function (value) {
		_parser.setPmText(value);
	};
	this.baseYear = function () {
		return _parser.baseYear();
	};
	this.setBaseYear = function (value) {
		_parser.setBaseYear(value);
	};
	this.toDate = function (value) {
        if (value === undefined || value === null || value === "") {
            return null;
        }
		var d = value;
		if (!(d instanceof Date)) {
			var s = String(value);
			if (s) {
				switch (_type) {
					case 0:
						d = _parser.parse(s/*, strict*/);
						break;
					case 1:
						d = ISODateTimeParser.parse(s);
						break;
					case 2:
						s = parseInt(value);
						d = new Date(s);
						break;
					case 3:
					default:
						d = new Date(s);
						break;
				}
			}
		}
        if (d) {
            return isNaN(d.getTime()) ? null : d;
        }
        return null;
	};
	this.setFormat(format);
};
DateTimeReader.FORMATS = ["custom", "iso", "timestamp", "platform"];
DateTimeReader.Default = new DateTimeReader("yyyy/MM/dd HH:mm:ss");
DateTimeReader.Default.setAmText("AM");
DateTimeReader.Default.setPmText("PM");
DateTimeReader.Default.setBaseYear(2000);

ExcelFormatConverter = defineClass("ExcelFormatConverter", null, {}, {
	convertNumberFormat: function (format) {
		if (format.indexOf(".#") > 0)
			return format.replace(".#", ".0");
		else 
			return format;
	},
	convertDateFormat: function (format) {
		var result = "";
		var l = format.length;
		for (var i = 0; i < l; i++) {
			var c = format.charAt(i);
			switch (c) {
				case "y":
				case "d":
				case "m":
				case "s":
				case ":":
					result = result + c;
					break;
				case "M":
					result = result + "m";
					break;
				case "a":
					result = result + "AM/PM"
					break;
				case "H":
					result = result + "h";
					if (i >= l-1 || format.charAt(i+1) != "H")
						result = result + "h";
					break;
				case "h":
					if (i == 0 || format.charAt(i-1) != "h")
						result = result + "h";
					break;
				case "S":
					break;
				case ".":
				case "/":
				case "-":
				case " ":
					if (i >= l-1 || format.charAt(i+1) != "S")
						result = result + "\\" + c;
					break;
				default:
					result = result + "\"" + c + "\"";
			}
		}

		return result;
	}
});
ExcelFormatConverter.Default = new ExcelFormatConverter();
var $$_drawPlusBox = function (g, r, size, fillBox, fillSign) {
	var x = _round(r.x + (r.width - size) / 2);
	var y = _round(r.y + (r.height - size) / 2);
	var s = _round(size / 9.0);
	var pts = [
		x + s * 0, y + s * 0,
		x + s * 0, y + s * 9,
		x + s * 9, y + s * 9,
		x + s * 9, y + s * 0,
	];
	var pts2 = [
	    x + s * 4, y + s * 2,
		x + s * 4, y + s * 4,
		x + s * 2, y + s * 4,
		x + s * 2, y + s * 5,
		x + s * 4, y + s * 5,
		x + s * 4, y + s * 7,
		x + s * 5, y + s * 7,
		x + s * 5, y + s * 5,
		x + s * 7, y + s * 5,
		x + s * 7, y + s * 4,
		x + s * 5, y + s * 4,
		x + s * 5, y + s * 2,
	];
	g.drawPolygonArray(fillBox, null, pts);
	g.drawPolygonArray(fillSign, null, pts2);
};
var $$_drawMinusBox = function (g, r, size, fillBox, fillSign) {
	var x = _round(r.x + (r.width - size) / 2);
	var y = _round(r.y + (r.height - size) / 2);
	var s = _round(size / 9.0);
	var pts = [
		x + s * 0, y + s * 0,
		x + s * 0, y + s * 9,
		x + s * 9, y + s * 9,
		x + s * 9, y + s * 0,
	];
	var pts2 = [
		x + s * 2, y + s * 4,
		x + s * 2, y + s * 5,
		x + s * 7, y + s * 5,
		x + s * 7, y + s * 4,
	];
	g.drawPolygonArray(fillBox, null, pts);
	g.drawPolygonArray(fillSign, null, pts2);
};
var $$_drawCheckMark = function (g, fill, r, checkSize) {
	var x = r.x + (r.width - checkSize) / 2;
	var y = r.y + (r.height - checkSize) / 2 - checkSize / 6.0;
	var s = checkSize / 10.0;
	var pts = [
		x + s * 0, y + s * 6.573,
		x + s * 4.3915, y + s * 10,
		x + s * 10.1, y + s * 0.91,
		x + s * 8.205, y + s * 0,
		x + s * 3.684, y + s * 6.9425,
		x + s * 1.2, y + s * 5,
	];
	g.drawPolygonArray(fill, null, pts);
};
var $$_drawCloseMark = function(g, fill, r, size) {
	var	x = r.x + (r.width - size) / 2;
	var	y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 2, y + s * 1,
		x + s * 1, y + s * 2,
		x + s * 4, y + s * 5,
		x + s * 1, y + s * 8,
		x + s * 2, y + s * 9,
		x + s * 5, y + s * 6,
		x + s * 8, y + s * 9,
		x + s * 9, y + s * 8,
		x + s * 6, y + s * 5,
		x + s * 9, y + s * 2,
		x + s * 8, y + s * 1,
		x + s * 5, y + s * 4
	];
	g.drawPolygonArray(fill, null, pts);

};
var $$_drawRightArrow = function (g, r, size, fill) {
	var x = r.x + (r.width - size) / 2;
	var y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 1.75, y + s * 1,
		x + s * 5.25, y + s * 4.5,
		x + s * 1.75, y + s * 8,
		x + s * 2.75, y + s * 9,
		x + s * 7.25, y + s * 4.5,
		x + s * 2.75, y + s * 0,
	];
	g.drawPolygonArray(fill, null, pts);
};
var $$_drawDownArrow = function (g, r, size, fill) {
	var x = r.x + (r.width - size) / 2;
	var y = r.y + (r.height - size) / 2;
	var s = size / 9.0;
	var pts = [
		x + s * 0, y + s * 2.75,
		x + s * 4.5, y + s * 7.25,
		x + s * 9, y + s * 2.75,
		x + s * 8, y + s * 1.75,
		x + s * 4.5, y + s * 5.25,
		x + s * 1, y + s * 1.75,
	];
	g.drawPolygonArray(fill, null, pts);
};
function ExpressionSyntaxError(message, pos) {
	this.message = message;
	this.tokenPos = pos;
}
ExpressionSyntaxError.prototype = new Error();
ExpressionSyntaxError.prototype.constructor = ExpressionSyntaxError;
function ExpressionEvaluationError(message) {
	this.message = message;
}
ExpressionEvaluationError.prototype = new Error();
ExpressionEvaluationError.prototype.constructor = ExpressionEvaluationError;
var $$_createTokenArray = function () {
	var arr = [];
	for (var i = 0; i < arguments.length; i++) {
		arr[arguments[i]] = true;
	}
	return arr;
};
var TokenKind = {
	Unknown 		: 0,
	Add 			: 1,
	Slash 			: 2,
	Star 			: 3,
	Minus 			: 4,
	Plus 			: 5,
	Identifier 		: 10,
	And 			: 11,
	In 				: 12,
	Not 			: 13,
	Div 			: 14,
	Mod 			: 15,
	Shl 			: 16,
	Shr 			: 17,
	Or 				: 18,
	Xor 			: 19,
	ToStr 			: 20,
	ToNum 			: 21,
	ToBool 			: 23,
	Length 	     	: 24,
	LengthBin 	   	: 25,
	Is 				: 26,
	IsNot 			: 27,
	BraceClose 		: 30,
	BraceOpen 		: 31,
	Comma 			: 32,
	CRLF 			: 33,
	Null 			: 34,
	Defined 		: 35,
	Empty	 		: 36,
	NaN	 			: 37,
	Equal 			: 40,
	Greater 		: 41,
	GreaterEqual 	: 42,
	Lower 			: 43,
	LowerEqual 		: 44,
	NotEqual 		: 45,
	Like 			: 46,
	NotLike 		: 47,
	ILike 			: 48,
	NotILike 		: 49,
	Match 			: 50,
	NotMatch 		: 51,
	IMatch 			: 52,
	NotIMatch 		: 53,
	String 			: 60,
	StringLiteral 	: 61,
	Ascii 			: 62,
	FloatLiteral 	: 63,
	IntegerLiteral 	: 64,
	Point 			: 65,
	RoundOpen 		: 66,
	RoundClose 		: 67,
	DotDot 			: 68,
	BracketOpen 	: 69,
	BracketClose 	: 70,
	Space 			: 71,
	Symbol 			: 80,
	ToDateStr       : 90,
	ToYear          : 91,
	ToMonth         : 92,
	ToDay           : 93,
	ToHour          : 94,
	ToRoundDown		: 95,
};
TokenKind.IS_CHECK = $$_createTokenArray(TokenKind.Is, TokenKind.IsNot);
TokenKind.IS_RELATIVE = $$_createTokenArray(TokenKind.Equal, TokenKind.NotEqual, TokenKind.Like, TokenKind.NotLike, TokenKind.ILike, TokenKind.NotILike, TokenKind.Match, TokenKind.NotMatch, TokenKind.IMatch, TokenKind.NotIMatch, TokenKind.Greater, TokenKind.GreaterEqual, TokenKind.Lower, TokenKind.LowerEqual);
TokenKind.IS_ADDITIVE = $$_createTokenArray(TokenKind.Minus, TokenKind.Plus, TokenKind.Or, TokenKind.Xor);
TokenKind.IS_MULTIPLICATIVE = $$_createTokenArray(TokenKind.And, TokenKind.Star, TokenKind.Slash, TokenKind.Div, TokenKind.Mod, TokenKind.Shl, TokenKind.Shr);
var ExpressionLexer = function () {
	var IS_IDENT = [];
	var IS_INTEGER = [];
	var IS_NUMBER = [];
	var IS_WHITE = [];
	var IS_END = [];
	var QUOTATION = 0;
	var SQUOTATION = 0;
	var BACKSLASH = 0;
	var Keywords = {};
	for (var i = 0; i < 256; i++) {
		IS_IDENT[i] = (i == "_".charCodeAt()) || 
			(i >= "0".charCodeAt() && i <= "9".charCodeAt()) ||
			(i >= "a".charCodeAt() && i <= "z".charCodeAt()) ||
			(i >= "A".charCodeAt() && i <= "Z".charCodeAt());
		IS_INTEGER[i] = 
			(i >= "0".charCodeAt() && i <= "9".charCodeAt()) ||
			(i >= "a".charCodeAt() && i <= "f".charCodeAt()) ||
			(i >= "A".charCodeAt() && i <= "F".charCodeAt());
		IS_NUMBER[i] = 
			(i >= "0".charCodeAt() && i <= "9".charCodeAt()) ||
			i == ".".charCodeAt() || i == "e".charCodeAt() || i == "E".charCodeAt();
		IS_WHITE[i] = (i >= 1 && i <= 9) || (i == 11) || (i >= 14 && i <= 32);
		IS_END[i] = (i == 0); // || (i == 10) || (i == 13); // 개행문자는 끝이 아니므로 제외
	}
	QUOTATION = "\"".charCodeAt();
	SQUOTATION = "'".charCodeAt();
	BACKSLASH = "\\".charCodeAt();
	Keywords = {};
	Keywords["str"] = TokenKind.ToStr;			
	Keywords["num"] = TokenKind.ToNum;			
	Keywords["bool"] = TokenKind.ToBool;			
	Keywords["not"] = TokenKind.Not;			
	Keywords["len"] = TokenKind.Length;			
	Keywords["lenb"] = TokenKind.LengthBin;			
	Keywords["and"] = TokenKind.And;			
	Keywords["in"] = TokenKind.In;			
	Keywords["mod"] = TokenKind.Mod;			
	Keywords["or"] = TokenKind.Or;			
	Keywords["div"] = TokenKind.Div;			
	Keywords["shl"] = TokenKind.Shl;			
	Keywords["shr"] = TokenKind.Shr;			
	Keywords["xor"] = TokenKind.Xor;		
	Keywords["is"] = TokenKind.Is;			
	Keywords["like"] = TokenKind.Like;
	Keywords["ilike"] = TokenKind.ILike;
	Keywords["match"] = TokenKind.Match;
	Keywords["imatch"] = TokenKind.IMatch;
	Keywords["defined"] = TokenKind.Defined;			
	Keywords["null"] = TokenKind.Null;			
	Keywords["empty"] = TokenKind.Empty;			
	Keywords["nan"] = TokenKind.NaN;	
	Keywords["datestr"] = TokenKind.ToDateStr;
	Keywords["year"] = TokenKind.ToYear;
	Keywords["month"] = TokenKind.ToMonth;
	Keywords["day"] = TokenKind.ToDay;
	Keywords["hour"] = TokenKind.ToHour;
	Keywords["rounddown"] = TokenKind.ToRoundDown;

	var _procs = null;
	var _source = null;
	var _len = 0;
	var _tokenId = 0;
	var _run = 0;
	var _runAhead = 0;
	var _nextRun = 0;
	var _lineNo = 0;
	var _linePos = 0;
	var _tokenPos = 0;
	function _next() {
		var c = _source.charCodeAt(_run);
		_tokenPos = _run;
		if (c < 256) {
			_procs[c]();
		} else {
			_identProc();
		}
	}
	function _unkownProc() {
		_tokenId = TokenKind.Unknown;
		_run++;
	}
	function _symbolProc() {
		_tokenId = TokenKind.Symbol;
		_run++;
	}
	function _commaProc() {
		_tokenId = TokenKind.Comma;
		_run++;
	}
	function _crProc() {
		_tokenId = TokenKind.CRLF;
		if (_source.charCodeAt(_run + 1) == 10) {
			_run += 2;
		} else {
			_run++;
		}
		_lineNo++;
		_linePos = _run;
	}
	function _lfProc() {
		_tokenId = TokenKind.CRLF;
		_run++;
		_lineNo++;
		_linePos = _run;
	}
	function _equalProc() {
		_tokenId = TokenKind.Equal;
		_run++;
	}
	function _greaterProc() {
		if (_source.charAt(_run + 1) == "=") {
			_tokenId = TokenKind.GreaterEqual;
			_run += 2;
		} else {
			_tokenId = TokenKind.Greater;
			_run++;
		}
	}
	function _lowerProc() {
		if (_source.charAt(_run + 1) == "=") {
			_tokenId = TokenKind.LowerEqual;
			_run += 2;
		} else if (_source.charAt(_run + 1) == ">") {
			_tokenId = TokenKind.NotEqual;
			_run += 2;
		} else {
			_tokenId = TokenKind.Lower;
			_run++;
		}
	}
	function _nextIdent() {
		var i = _run;
		while (i < _len && (!IS_IDENT[_source.charCodeAt(i)])) {
			i++;
		}
		var j = i;
		while (i < _len && (IS_IDENT[_source.charCodeAt(i)])) {
			i++;
		}
		if (i > j) {
			_nextRun = i;
			return _source.substr(j, i - j).toLowerCase();
		} else {
			return null;
		}
	}
	function _identProc() {
		var i = _run;
		while (_run < _len && (IS_IDENT[_source.charCodeAt(_run)] || _source.charCodeAt(_run) > 255)) {
			_run++;
		}
		var s = _source.substr(i, _run - i).toLowerCase();
		if (Keywords.hasOwnProperty(s)) {
			_tokenId = Keywords[s];
			switch (_tokenId) {
			case TokenKind.Not:
				s = _nextIdent();
				if (s) {
					switch (s) {
					case "like":
						_tokenId = TokenKind.NotLike;
						_run = _nextRun;
						break;
					case "ilike":
						_tokenId = TokenKind.NotILike;
						_run = _nextRun;
						break;
					case "match":
						_tokenId = TokenKind.NotMatch;
						_run = _nextRun;
						break;
					case "imatch":
						_tokenId = TokenKind.NotIMatch;
						_run = _nextRun;
						break;
					}
				}
				break; 
			case TokenKind.Is:
				s = _nextIdent();
				if (s == "not") {
					_tokenId = TokenKind.IsNot;
					_run = _nextRun;
				}
				break;
			}
		}
		else {
			_tokenId = TokenKind.Identifier;
		}
	}
	function _integerProc() {
		_tokenId = TokenKind.IntegerLiteral;
		_run++;
		while (_run < _len && IS_INTEGER[_source.charCodeAt(_run)]) {
			_run++;
		}
	}
	function _numberProc() {
		_tokenId = TokenKind.IntegerLiteral;
		_run++;
		while (_run < _len && IS_NUMBER[_source.charCodeAt(_run)]) {
			if (_source.charAt(_run) == ".") {
				if (_source.charAt(_run + 1) == ".") {// dotdot에서 처리함.
					break;
				}
				_tokenId = TokenKind.FloatLiteral;
			}
			_run++;
		}
	}
	function _minusProc() {
		_tokenId = TokenKind.Minus;
		_run++;
	}
	function _plusProc() {
		_tokenId = TokenKind.Plus;
		_run++;
	}
	function _pointProc() {
		var s = _source.charAt(_run + 1);
		if (s == ".") {
			_tokenId = TokenKind.DotDot;
			_run += 2;
		} else {
			_tokenId = TokenKind.Point;
			_run++;
		}
	}
	function _roundOpenProc() {
		_tokenId = TokenKind.RoundOpen;
		_run++;
	}
	function _roundCloseProc() {
		_tokenId = TokenKind.RoundClose;
		_run++;
	}
	function _slashProc() {
		_tokenId = TokenKind.Slash;
		_run++;
	}
	function _spaceProc() {
		_tokenId = TokenKind.Space;
		_run++;
		while (_run < _len && IS_WHITE[_source.charCodeAt(_run)]) {
			_run++;
		}
	}
	function _bracketOpenProc() {
		_tokenId = TokenKind.BracketOpen;
		_run++;
	}
	function _bracketCloseProc() {
		_tokenId = TokenKind.BracketClose;
		_run++;
	}
	function _starProc() {
		_tokenId = TokenKind.Star;
		_run++;
	}
	function _modProc() {
		_tokenId = TokenKind.Mod;
		_run++;
	}
	function _stringProc() {
		_tokenId = TokenKind.StringLiteral;
		do {
			var c = _source.charCodeAt(_run);
			if (IS_END[c]) {
				throw new ExpressionSyntaxError("Untermintated string", c);
			}
			if (c == BACKSLASH) {
				_run++
			}
			_run++;
		} while (_run < _len && _source.charCodeAt(_run) != QUOTATION);
		_run++;
	}
	function _smallStringProc() {
		_tokenId = TokenKind.StringLiteral;
		do {
			var c = _source.charCodeAt(_run);
			if (IS_END[c]) {
				throw new ExpressionSyntaxError("Untermintated string", c);
			}
			if (c == BACKSLASH) {
				_run++
			}
			_run++;
		} while (_run < _len && _source.charCodeAt(_run) != SQUOTATION);
		_run++;
	}
	function _initProcs() {
		var i;
		_procs = [];
		for (i = 1; i <= 255; i++) {
			_procs[i] = _symbolProc;
		}
		for (i = 1; i <= 32; i++) {
			_procs[i] = _spaceProc;
		}
		_procs[10] = _lfProc;
		_procs[13] = _crProc;
		_procs["$".charCodeAt()] = _integerProc;
		_procs[QUOTATION] = _stringProc;
		_procs[SQUOTATION] = _smallStringProc;
		for (i = 0; i <= 9; i++) {
			_procs["0".charCodeAt() + i] = _numberProc;
		}
		for (i = "A".charCodeAt(); i <= "Z".charCodeAt(); i++) {
			_procs[i] = _identProc;
		}
		for (i = "a".charCodeAt(); i <= "z".charCodeAt(); i++) {
			_procs[i] = _identProc;
		}
		_procs["_".charCodeAt()] = _identProc;
		_procs["(".charCodeAt()] = _roundOpenProc;
		_procs[")".charCodeAt()] = _roundCloseProc;
		_procs["*".charCodeAt()] = _starProc;
		_procs["+".charCodeAt()] = _plusProc;
		_procs[",".charCodeAt()] = _commaProc;
		_procs["-".charCodeAt()] = _minusProc;
		_procs[".".charCodeAt()] = _pointProc;
		_procs["/".charCodeAt()] = _slashProc;
		_procs["%".charCodeAt()] = _modProc;
		_procs["<".charCodeAt()] = _lowerProc;
		_procs["=".charCodeAt()] = _equalProc;
		_procs[">".charCodeAt()] = _greaterProc;
		_procs["[".charCodeAt()] = _bracketOpenProc;
		_procs["]".charCodeAt()] = _bracketCloseProc;
	};
	this.tokenId = function () {
		return _tokenId;
	};
	this.tokenLoc = function () {
		return { x: _tokenPos - _linePos, y: _lineNo };
	};
	this.tokenLen = function () {
		return _run - _tokenPos;
	};
	this.token = function () {
		return _source.substr(_tokenPos, this.tokenLen());
	};
	this.isSpace = function () {
		return _tokenId == TokenKind.Space;
	};
	this.init = function (source) {
		_source = source;
		_len = source.length;
		_lineNo = 0;
		_linePos = 0;
		_tokenPos = 0;
		_runAhead = _run = 0;
		_tokenId = 0;
	};
	this.charAhread = function () {
		_runAhead = _run;
		while (_runAhead < _len && _source.charCodeAt(_runAhead) > 0 && _source.charCodeAt(_runAhead) <= 32) {
			_runAhead++;
		}
		return _source.charCodeAt(this._runAhead);
	};
	this.nextId = function (tokenId) {
		do {
			_next();
		} while (_run < _len && _tokenId != tokenId);
	};
	this.nextNoSpace = function () {
		if (_run < _len) {
			do {
				_next();
			} while (_run < _len && this.isSpace());
		}
	};
	this.isFirstInLine = function () {
		if (_tokenPos == 0) {
			return true;
		}
		var c;
		var runBack = _tokenPos;
		runBack--;
		while (runBack > 0 && IS_WHITE[_source.charCodeAt(runBack)]) {
			runBack--;
		}
		if (runBack == 0) {
			return true;
		}
		c = _source.charCodeAt(runBack);
		if (c == 10 || c == 13) {
			return true;
		}
		return false;
	};
	_initProcs();
};
var /* abstract */ ExpressionNode = defineClass("ExpressionNode", null, {
	init: function () {
		this._super();
	},
	destroy: function() {
		return false;
	},
	_asLiteral: function () {
		return null;
	},
	evaluate: function (/*runtime*/) {
		throwAbstractError();
	},
	toString: function () {
		return String(this);
	}
});
var EmptyExpressionNode = defineClass("EmptyExpressionNode", ExpressionNode, {
    init: function () {
        this._super();
    },
    destroy: function() {
    	return false; // 
    },
    _asLiteral: function () {
        return null;
    },
    evaluate: function (/*runtime*/) {
        return undefined;
    },
    toString: function () {
        return "";
    }
}, null, function (f) {
    f.Default = new f();
});
var FunctionExpressionNode = defineClass("FunctionExpressionNode", ExpressionNode, {
	init : function(func) {
		this._super();
		this._funcProc = func;
	},
	destroy: function() {
		return false;
	},
	_asLiteral: function() {

	},
/*
	runtime별로 사용되는 속성들이 다 틀리다. 필수적인 것은 grid, index이다. 

	filterRuntime.evaluate 분리.
	DataRowExpressionRuntime 분리.
	FooterExpressionRuntime분리.
	DataCellRenderRuntime
*/
	evaluate: function(runtime) {
		if (this._funcProc && typeof this._funcProc === "function") {
			if (runtime._evaluate) {
				return runtime._evaluate.call(runtime, this._funcProc);
			}
			var grid = runtime._grid;
			var cell = runtime._cell;
			var item = null;
			!cell && (runtime._target instanceof DataCellElement || runtime._target instanceof ValueCell) && (cell = runtime._target);
			!grid && runtime._target.grid && (grid = runtime._target.grid());
			!grid && runtime._target._index && (grid = runtime._target._index.grid());
			var index = _extend({}, cell && cell._index && cell._index.proxy());
			if (cell instanceof FooterCell) {
				index["footerIndex"] = cell._footerIndex;
			}
			var handler = grid && grid.getHandler();
			if (cell && !cell._index.item()) {
				cell._index._item = runtime._item;
			}
			var value = cell && ( cell.value() != null ? cell.value() : cell.displayText ? cell.displayText() : cell.value());
			try {
				return this._funcProc(handler, index, value);
			} catch (e) {
				return null;
			}
		}
	},
	toString: function() {
		return this._funcProc.toString();	
	}
});
var ExpressionNodeImpl = defineClass("ExpressionNodeImpl", ExpressionNode, {
	init: function() {
		this._super();
		this.leftExpr = null;
		this.rightExpr = null;
		this.operator = TokenKind.Unknown;
		this._literal = null; // LiteralNode
	},
	evaluate: function(runtime) {
		if (this._literal) {
			return this._literal.value();
		} else if (this.rightExpr) {
			var v1 = this.leftExpr.evaluate(runtime);
			var v2 = this.rightExpr.evaluate(runtime);
			switch (this.operator) {
			case TokenKind.Equal:
				return v1 == v2;
			case TokenKind.NotEqual:
				return v1 != v2;
			case TokenKind.Greater:
				return v1 > v2;
			case TokenKind.GreaterEqual:
				return v1 >= v2;
			case TokenKind.Lower:
				return v1 < v2;
			case TokenKind.LowerEqual:
				return v1 <= v2;
				/*
				 * case TokenKind.Is: case TokenKind.IsNot:
				 */
			case TokenKind.Like:
				return this._calcLike(v1, v2, false);
			case TokenKind.NotLike:
				return !this._calcLike(v1, v2, false);
			case TokenKind.ILike:
				return this._calcLike(v1, v2, true);
			case TokenKind.NotILike:
				return !this._calcLike(v1, v2, true);
			case TokenKind.Match:
				return this._calcMatch(v1, v2, false);
			case TokenKind.NotMatch:
				return !this._calcMatch(v1, v2, false);
			case TokenKind.IMatch:
				return this._calcMatch(v1, v2, true);
			case TokenKind.NotIMatch:
				return !this._calcMatch(v1, v2, true);
			default:
				throw new ExpressionEvaluationError(
						"Unknown operator: " + operator);
			}
		} else {
			return this.leftExpr.evaluate(runtime);
		}
	},
	toString: function() {
		var s = "";
		if (this._literal) {
			s = this._literal.toString();
		} else if (this.rightExpr) {
			var s1 = this.leftExpr.toString();
			var s2 = this.rightExpr.toString();
			var op;
			switch (this.operator) {
			case TokenKind.Equal:
				op = "=";
				break;
			case TokenKind.NotEqual:
				op = "<>";
				break;
			case TokenKind.Greater:
				op = ">";
				break;
			case TokenKind.GreaterEqual:
				op = ">=";
				break;
			case TokenKind.Lower:
				op = "<";
				break;
			case TokenKind.LowerEqual:
				op = "<=";
				break;
			case TokenKind.Like:
				op = "like";
				break;
			case TokenKind.NotLike:
				op = "not like";
				break;
			case TokenKind.ILike:
				op = "ilike";
				break;
			case TokenKind.NotILike:
				op = "not ilike";
				break;
			case TokenKind.Match:
				op = "match";
				break;
			case TokenKind.NotMatch:
				op = "not match";
				break;
			case TokenKind.IMatch:
				op = "imatch";
				break;
			case TokenKind.NotIMatch:
				op = "not imatch";
				break;
			case TokenKind.Comma:
				op = ",";
				break;
			default:
				op = "<<ERROR>>";
				break;
			}
			s = "(" + s1 + " " + op + " " + s2 + ")";
		} else {
			s = this.leftExpr.toString();
		}
		return s;
	},
	isIdentifier: function(value) {
		return this.leftExpr && !this.rightExpr && this.leftExpr.isIdentifier(value);
	},
	_prepareValue: function() {
		this.leftExpr._prepareValue();
		if (this.rightExpr == null) {
			this._literal = this.leftExpr._getLiteral();
		} else {
			this.rightExpr._prepareValue();
		}
	},
	_getLiteral: function() {
		return this._literal;
	},
	_calcLike: function(v1, v2, ignoreCase) {
		var s1 = String(v1);
		var s2 = String(v2);
		if (s1 && s2) {
			if (ignoreCase) {
				s1 = s1.toLowerCase();
				s2 = s2.toLowerCase();
			}
			var len = s2.length;
			if (len > 1) {
				var first = s2.charAt(0) == "%";
				var last = s2.charAt(len - 1) == "%";
				if (first && last) {
					s2 = s2.substr(1, len - 2);
					return s1.indexOf(s2, 0) >= 0;
				} else if (first) {
					s2 = s2.substr(1, len - 1);
					len = s1.length;
					return s1.lastIndexOf(s2, len - 1) == len - 1;
				} else if (last) {
					s2 = s2.substr(0, len - 1);
					return s1.indexOf(s2, 0) == 0;
				} else {
					return s1 == s2;
				}
			} else if (s2 == "%") {
				return false;
			} else {
				return s1 == s2;
			}
		}
		return false;
	},
	_calcMatch: function(v1, v2, ignoreCase) {
		var exp = new RegExp(v2, "m" + (ignoreCase ? "i" : ""));
		return exp.test(v1);
	}
});
var CheckableNode = defineClass("CheckableNode", ExpressionNode, {
	init: function() {
		this._super();
	}
});
var DefinedNode = defineClass("DefinedNode", CheckableNode, {
	init: function() {
		this._super();
	},
	value: function() {
		return UNDEFINED;
	},
	_asLiteral: function() {
		return this;
	},
	evaluate: function(runtime) {
		return UNDEFINED;
	},
	toString: function() {
		return "defined";
	}
});
var EmptyNode = defineClass("EmptyNode", CheckableNode, {
	init: function() {
		this._super();
	},
	value: function() {
		return UNDEFINED;
	},
	_asLiteral: function() {
		return this;
	},
	evaluate: function(runtime) {
		return UNDEFINED;
	},
	toString: function() {
		return "empty";
	}
});
var NullNode = defineClass("NullNode", CheckableNode, {
	init : function() {
		this._super();
	},
	value : function() {
		return UNDEFINED;
	},
	_asLiteral: function () {
		return this;
	},
	evaluate : function(runtime) {
		return null;
	},
	toString : function() {
		return "null";
	}
});
var NanNode = defineClass("NanNode", CheckableNode, {
	init: function () {
		this._super();
	},
	value: function () {
		return NaN;
	},
	_asLiteral: function () {
		return this;
	},
	evaluate: function (runtime) {
		return NaN;
	},
	toString: function () {
		return "NaN";
	}
});
var CheckNode = defineClass("CheckNode", ExpressionNodeImpl, {
	init: function (leftExpr, op, literal) {
		this._super();
		this.leftExpr = leftExpr;
		this.operator = op;
		this._isNot = op == TokenKind.IsNot;
		this._value = -1;
		if (literal instanceof DefinedNode) {
			this._value = CheckNode.DEFINED;
		} else if (literal instanceof NullNode) {
			this._value = CheckNode.NULL;
		} else if (literal instanceof EmptyNode) {
			this._value = CheckNode.EMPTY;
		} else if (literal instanceof NanNode) {
			this._value = CheckNode.NAN;
		}
	},
	_prepareValue: function () {
		this.leftExpr._prepareValue();
		this._literal = this.leftExpr._getLiteral();
	},
	_getLiteral: function () {
		return null;
	},
	evaluate: function (runtime) {
		var v = this._literal ? this._literal.value() : this.leftExpr.evaluate(runtime);
		var r;
		switch (this._value) {
		case CheckNode.DEFINED:
			r = (v !== UNDEFINED);
			break;
		case CheckNode.NULL:
			r = (v === UNDEFINED || v === null);
			break;
		case CheckNode.EMPTY:
			r = (v === UNDEFINED || v === null || String(v).length == 0);
			break;
		case CheckNode.NAN:
			r = (v === null || isNaN(v));
			break;
		default:
			return UNDEFINED;
		}
		return this._isNot ? !r : r;
	},
	toString: function () {
		var s = "<<ERROR>>";
		switch (this._value) {
			case CheckNode.DEFINED:
				s = "defined";
				break;
			case CheckNode.NULL:
				s = "null";
				break;
			case CheckNode.EMPTY:
				s = "empty";
				break;
			case CheckNode.NAN:
				s = "NaN";
				break;
		}
		return "(" + ((this._isNot ? "is not " : "is ") + s) + ")";
	}
}, {
	DEFINED	: 0,
	NULL	: 1,
	EMPTY	: 2,
	NAN		: 3
});
var FloatLiteralNode = defineClass("FloatLiteralNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._value = Number(literal);
	},
	value : function() {
		return this._value;
	},
	_asLiteral: function () {
		return this;
	},
	evaluate : function(runtime) {
		return this._value;
	},
	toString : function() {
		return String(this._value);
	}
});
var IntegerLiteralNode = defineClass("IntegerLiteralNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._value = parseInt(literal);
	},
	value : function() {
		return this._value;
	},
	_asLiteral : function() {
		return this;
	},
	evaluate : function(runtime) {
		return this._value;
	},
	toString : function() {
		return String(this._value);
	}
});
var StringLiteralNode = defineClass("StringLiteralNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._value = literal.substr(1, literal.length - 2);
		var val = "";
 		var run = 0;
 		var isEscape = false;
 		while (run < this._value.length) {
 			if (this._value[run] == "\\" && !isEscape) {
 				isEscape = true;
 				run++;
 				continue;
 			}
 			isEscape = false;
 			val += this._value[run++]
 		};
 		this._value = val;		
	},
	value : function() {
		return this._value;
	},
	_asLiteral : function() {
		return this;
	},
	evaluate : function(runtime) {
		return this._value;
	},
	toString : function() {
		return this._value;
	}
});
var IdentifierNode = defineClass("IdentifierNode", ExpressionNode, {
	init : function(literal) {
		this._super();
		this._literal = literal;
		this._idKey = -651212;
	},
	identifier: function () {
		return this._literal;
	},
	evaluate : function(runtime) {
		if (this._idKey == -651212) {
			this._idKey = runtime.isIdentifier(this._literal);
		}
		return runtime.evaluateIdentifier(this._idKey);
	},
	toString : function() {
		return this._literal;
	}
});
var IndexerNode = defineClass("IndexerNode", ExpressionNode, {
	init : function(ident, expression, capital) {
		this._super();
		this._ident = ident;
		this._indexer = expression;
		this._capital = capital;
		this._idKey = -1490313;
		this._intIndex = NaN;
		this._strIndex = null;
	},
	_prepareValue: function () {
		var vnode = null;
		var lit = this._indexer._asLiteral();
		if (!lit) {
			vnode = this._indexer._prepareValue && this._indexer;
			if (vnode) {
				vnode._prepareValue();
				lit = vnode._getLiteral();
			}
		}
		if (lit) {
			var v = lit.value();
			if (typeof v === "string") {
				this._strIndex = v;
			} else {
				this._intIndex = parseInt(v);
			}
			if (this._capital && this._strIndex) {
				this._strIndex = this._strIndex.toUpperCase();
			}
		}
	},
	_getLiteral: function () {
		return null;
	},
	evaluate : function(runtime) {
		if (this._idKey == -1490313) {
			this._idKey = runtime.isIdentifier(this._ident);
		}
		if (this._strIndex) {
			return runtime.evaluateIndexerS(this._idKey, this._strIndex, this._capital);
		} else if (!isNaN(this._intIndex)) {
			return runtime.evaluateIndexerI(this._idKey, this._intIndex);
		} else {
			var index = this._indexer.evaluate(runtime);
			if (typeof index === "string") {
				return runtime.evaluateIndexerS(this._idKey, index, this._capital);
			} else {
				return runtime.evaluateIndexerI(this._idKey, index);
			}
		}
	},
	toString : function() {
		var s = this._ident + "[" + this._indexer.toString() + "]";
		return s;
	}
});
var /* abstract */ UnaryNode = defineClass("UnaryNode", ExpressionNode, {
	init : function(factor) {
		this._super();
		this._factor = factor;
		this._literal = null;
	},
	_prepareValue: function () {
		this._literal  = this._factor._asLiteral();
		if (!this._literal && this._factor._prepareValue) {
			this._factor._prepareValue();
			this._literal = this._factor._getLiteral();
		}
	},
	_getLiteral: function () {
		return null;
	}
});
var LenNode = defineClass("LenNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function (runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v ? v.length : 0;
	},
	toString: function () {
		return "(len " + this._factor + ")";
	}
});
var MinusNode = defineClass("MinusNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return -v;
	},
	toString: function() {
		return "-" + this._factor;
	}
});
var PlusNode = defineClass("PlusNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v;
	},
	toString: function() {
		return "+" + this._factor;
	}
});
var NotNode = defineClass("NotNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return !v;
	},
	toString: function() {
		return "(not " + this._factor + ")";
	}
});
var ToBoolNode = defineClass("ToBoolNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return Boolean(v);
	},
	toString: function() {
		return "(bool " + this._factor + ")";
	}
});
var ToNumberNode = defineClass("ToNumberNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return Number(v);
	},
	toString: function() {
		return "(num " + this._factor + ")";
	}
});
var ToStringNode = defineClass("ToStringNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return String(v);
	},
	toString: function() {
		return "(str " + this._factor + ")";
	}
});
var ToDateStringNode = defineClass("ToDateStringNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		if (v instanceof Date) {
			v = _pad(v.getFullYear(),4) + 
				_pad((v.getMonth() + 1), 2) + 
				_pad(v.getDate(), 2) +
				_pad(v.getHours(),2) + 
				_pad(v.getMinutes(), 2) + 
				_pad(v.getSeconds(), 2) + 
				_pad(v.getMilliseconds(),3);
		}
		return String(v);
	},
	toString: function() {
		return "(datestr " + this._factor + ")";
	}
});
var ToYearNode = defineClass("ToYearNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v instanceof Date ? v.getFullYear() : null;
	},
	toString: function() {
		return "(year " + this._factor + ")";
	}
});
var ToMonthNode = defineClass("ToMonthNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v instanceof Date ? v.getMonth() + 1 : null;
	},
	toString: function() {
		return "(month " + this._factor + ")";
	}
});
var ToDayNode = defineClass("ToDayNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v instanceof Date ? v.getDate() : null;
	},
	toString: function() {
		return "(day " + this._factor + ")";
	}
});
var ToHourNode = defineClass("ToHourNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		return v instanceof Date ? v.getHours() : null;
	},
	toString: function() {
		return "(hour " + this._factor + ")";
	}
});
var ToRoundDownNode = defineClass("ToRoundDownNode", UnaryNode, {
	init: function(factor) {
		this._super(factor);
	},
	evaluate: function(runtime) {
		// var v = this._literal ? this._literal.value() : this._factor.evaluate(runtime);
		if (this._factor._literal) {
			return this._factor._literal.value();
		} else if (this._factor.rightExpr) {
			var v1 = this._factor.leftExpr.evaluate(runtime);
			var v2 = this._factor.rightExpr.evaluate(runtime);
			switch (this._factor.operator) {
				case TokenKind.Comma:
					var v3 = Math.pow(10,v2);
					return Math.floor(v1 * v3) / v3;
				break;
				default :
					throw new ExpressionEvaluationError("Unknown operator: " + operator);
			}
		} else {
			return this._factor.leftExpr.evaluate(runtime);
		}
	}, 
	toString: function() {
		return "(rounddown "+ this._factor + ")";
	}
});
var TermNode = defineClass("TermNode", ExpressionNode, {
	init: function() {
		this._super();
		this._factors = []; // ExpressionNode
		this._operators = [];
		this._literal = null;
	},
	addFactor: function (factor) {
		this._factors.push(factor);
	},
	addOperator: function (tokenId) {
		this._operators.push(tokenId);
	},
	isIdentifier: function (value) {
		return this._factors.length == 1 && this._factors[0] instanceof IdentifierNode && 
			this._factors[0].identifier() == value;
	},
	_prepareValue: function () {
		var i, cnt, factor;
		for (i = 0, cnt = this._factors.length; i < cnt; i++) {
			factor = this._factors[i]; 
			if (factor._prepareValue) {
				factor._prepareValue();
			}
		}
		if (this._operators.length == 0) {
			factor = this._factors[0];
			this._literal = factor._asLiteral();
			if (!this._literal && factor._prepareValue) {
				this._literal = factor._getLiteral();
			}
		}
	},
	_getLiteral: function () {
		return this._literal;
	},
	evaluate: function(runtime) {
		if (this._literal) {
			return this._literal.value();
		}
		var i;
		var v2;
		var len = this._factors.length;
		var v1 = this._factors[0].evaluate(runtime);
		for (i = 1; i < len; i++) {
			v2 = this._factors[i].evaluate(runtime);

			switch (this._operators[i - 1]) {
				case TokenKind.And:
					v1 = v1 && v2;
					break;
				case TokenKind.Star:
					v1 = v1 * v2;
					break;
				case TokenKind.Slash:
					v1 = v1 / v2;
					break;
				case TokenKind.Div:
					v1 = _int(_int(v1) / _int(v2));
					break;
				case TokenKind.Mod:
					v1 = v1 % v2;
					break;
				case TokenKind.Shl:
					v1 = v1 << v2;
					break;
				case TokenKind.Shr:
					v1 = v1 >> v2;
					break;
			}
		}
		return v1;
	},
	toString: function() {
		var s = "";
		if (this._literal) {
			s = this._literal.toString();
		} else if (this._factors.length == 1) {
			s = this._factors[0].toString();
		} else {
			var i;
			var len = this._factors.length;
			s = "(" + this._factors[0].toString();
			for (i = 1; i < len; i++) {
				switch (this._operators[i - 1]) {
					case TokenKind.And:
						s += " and ";
						break;
					case TokenKind.Star:
						s += " * ";
						break;
					case TokenKind.Slash:
						s += " / ";
						break;
					case TokenKind.Div:
						s += " / ";
						break;
					case TokenKind.Mod:
						s += " mod ";
						break;
					case TokenKind.Shl:
						s += " shl ";
						break;
					case TokenKind.Shr:
						s += " shr ";
						break;
				}
				s += this._factors[i].toString();
			}
			s += ")";
		}
		return s;
	}
});
var SimpleExpressioNode = defineClass("SimpleExpressioNode", ExpressionNode, {
	init: function() {
		this._super();
		this._terms = []; // TermNode
		this._operators = [];
		this._literal = null;
	},
	addTerm: function (term) {
		this._terms.push(term);
	},
	addOperator: function (tokenId) {
		this._operators.push(tokenId);
	},
	isIdentifier: function (value) {
		return this._terms.length == 1 && this._terms[0].isIdentifier(value);
	},
	_prepareValue: function () {
		var i;
		var cnt;
		for (i = 0, cnt = this._terms.length; i < cnt; i++) {
			this._terms[i]._prepareValue();
		}
		if (this._operators.length == 0) {
			this._literal = this._terms[0]._getLiteral();
		}
	},
	_getLiteral: function () {
		return this._literal;
	},
	evaluate: function(runtime) {
		if (this._literal) {
			return this._literal.value();
		}
		var i;
		var v2;
		var len = this._terms.length;
		var v1 = this._terms[0].evaluate(runtime);
		for (i = 1; i < len; i++) {
			v2 = this._terms[i].evaluate(runtime);
			switch (this._operators[i - 1]) {
			case TokenKind.Minus:
				v1 = v1 - v2;
				break;
			case TokenKind.Plus:
				v1 = v1 + v2;
				break;
			case TokenKind.Or:
				v1 = v1 || v2;
				break;
			case TokenKind.Xor:
				v1 = v1 ^ v2;
				break;
			}
		}
		return v1;
	},
	toString: function() {
		var s = "";
		if (this._literal) {
			s = this._literal.toString();
		} else if (this._terms.length == 1) {
			s = this._terms[0].toString();
		} else {
			var i;
			var len = this._terms.length;
			s = "(" + this._terms[0].toString();
			for (i = 1; i < len; i++) {
				switch (this._operators[i - 1]) {
					case TokenKind.Minus:
						s += " - ";
						break;
					case TokenKind.Plus:
						s += " + ";
						break;
					case TokenKind.Or:
						s += " or ";
						break;
					case TokenKind.Xor:
						s += " xor ";
						break;
					default:
						s += " <<ERROR>> ";
				}
				s += this._terms[i].toString();
			}
			s += ")";
		}
		return s;
	}
});
var ExpressionParser = function () {
	var _node = null;
	var	_capitalIndexers = null;
	var	_lexer = new ExpressionLexer();
	function _syntaxError(message, pos) {
		throw new ExpressionSyntaxError(message, pos);
	}
	function _expected(tokenId) {
		if (tokenId != _lexer.tokenId()) {
			throw new ExpressionSyntaxError("Token is not a expected kind [" + tokenId + "]: " + _lexer.tokenId(), _lexer.tokenLoc());
		}
		_nextToken();
	}
	function _nextToken() {
		_lexer.nextNoSpace();
	}
	function _doExpression() {
		var expr = null;
		var left = _doSimpleExpression();
		var right;
		var check;
		var op;
		if (TokenKind.IS_CHECK[op = _lexer.tokenId()]) {
			_nextToken();
			right = _doSimpleExpression();
			right._prepareValue();
			check = _cast(right._getLiteral(), CheckableNode);
			if (check) {
				expr = new CheckNode(left, op, check);
			} else {
				throw new ExpressionSyntaxError("is operator's operand must be defined, null or empty: " + _lexer.tokenId());
			}
		} else {
			expr = new ExpressionNodeImpl();
			expr.leftExpr = left;
			if (TokenKind.IS_RELATIVE[_lexer.tokenId()]) {
				expr.operator = _lexer.tokenId();
				_nextToken();
				expr.rightExpr = _doSimpleExpression();
			} else if (_lexer.tokenId() == TokenKind.Comma) {
				expr.operator = _lexer.tokenId();
				_nextToken();
				expr.rightExpr = _doSimpleExpression();
			}
		}
		return expr;
	}
	function _doSimpleExpression() {
		var expr = new SimpleExpressioNode();
		expr.addTerm(_doTerm());
		while (TokenKind.IS_ADDITIVE[_lexer.tokenId()]) {
			expr.addOperator(_lexer.tokenId());
			_nextToken();
			expr.addTerm(_doTerm());
		}
		return expr;
	}
	function _doTerm() {
		var term = new TermNode();
		term.addFactor(_doFactor());
		while (TokenKind.IS_MULTIPLICATIVE[_lexer.tokenId()]) {
			term.addOperator(_lexer.tokenId());
			_nextToken();
			term.addFactor(_doFactor());
		}
		return term;
	};
	function _doFactor() {
		var tokenId = _lexer.tokenId();
		switch (tokenId) {
			case TokenKind.StringLiteral:
				return _doCharString();
			case TokenKind.RoundOpen:
				return _doRoundOpen();
			case TokenKind.Identifier:
				return _doIdentifier();
			case TokenKind.IntegerLiteral:
				return _doInteger();
			case TokenKind.FloatLiteral:
				return _doNumber();
			case TokenKind.Minus:
				return _doMinus();
			case TokenKind.Plus:
				return _doPlus();
			case TokenKind.Not:
				return _doNot();
			case TokenKind.Defined:
				return _doDefined();
			case TokenKind.Null:
				return _doNull();
			case TokenKind.Empty:
				return _doEmpty();
			case TokenKind.NaN:
				return _doNaN();
			case TokenKind.ToBool:
				return _doToBool();
			case TokenKind.ToNum:
				return _doToNumber();
			case TokenKind.ToStr:
				return _doToString();
			case TokenKind.Length:
				return _doLength();
			case TokenKind.LengthBin:
				return _doLengthBin();
			case TokenKind.ToDateStr:
				return _doToDateString();
			case TokenKind.ToYear:
				return _doToYear();
			case TokenKind.ToMonth:
				return _doToMonth();
			case TokenKind.ToDay:
				return _doToDay();
			case TokenKind.ToHour:
				return _doToHour();
			case TokenKind.ToRoundDown:
				return _doRoundDown();
		}
		throw new ExpressionSyntaxError("Unkown token: " + tokenId);
	}
	function _doCharString() {
		var literal = _lexer.token();
		_nextToken();
		return new StringLiteralNode(literal);
	}
	function _doRoundOpen() {
		_nextToken();
		var node = _doExpression();
		_expected(TokenKind.RoundClose);
		return node;
	}
	function _doIdentifier() {
		var literal = _lexer.token();
		_nextToken();
		if (_lexer.tokenId() == TokenKind.BracketOpen) {
			_nextToken();
			var node = _doExpression();
			_expected(TokenKind.BracketClose);
			return new IndexerNode(literal, node, _capitalIndexers.indexOf(literal) >= 0);
		} else {
			return new IdentifierNode(literal);
		}		
	}
	function _doNumber() {
		var literal = _lexer.token();
		_nextToken();
		return new FloatLiteralNode(literal);
	}	
	function _doInteger() {
		var literal = _lexer.token();
		_nextToken();
		return new IntegerLiteralNode(literal);
	};	
	function _doMinus() {
		_nextToken();
		return new MinusNode(_doFactor());
	}
	function _doPlus() {
		_nextToken();
		return new PlusNode(_doFactor());
	}
	function _doNot() {
		_nextToken();
		return new NotNode(_doFactor());
	}
	function _doDefined() {
		_nextToken();
		return new DefinedNode();
	}
	function _doNull() {
		_nextToken();
		return new NullNode();
	}
	function _doEmpty() {
		_nextToken();
		return new EmptyNode();
	}
	function _doNaN() {
		_nextToken();
		return new NanNode();
	}
	function _doToBool() {
		_nextToken();
		return new ToBoolNode(_doFactor());
	}
	function _doToNumber() {
		_nextToken();
		return new ToNumberNode(_doFactor());
	}
	function _doToString() {
		_nextToken();
		return new ToStringNode(_doFactor());
	}
	function _doLength() {
		_nextToken();
		return new LenNode(_doFactor());
	}
	function _doLengthBin() {
		_nextToken();
		return new LenBinNode(_doFactor());
	}
	function _doToDateString() {
		_nextToken();
		return new ToDateStringNode(_doFactor());
	}
	function _doToYear() {
		_nextToken();
		return new ToYearNode(_doFactor());
	}
	function _doToMonth() {
		_nextToken();
		return new ToMonthNode(_doFactor());
	}
	function _doToDay() {
		_nextToken();
		return new ToDayNode(_doFactor());
	}
	function _doToHour() {
		_nextToken();
		return new ToHourNode(_doFactor());
	}
	function _doRoundDown() {
		_nextToken();
		return new ToRoundDownNode(_doFactor());
	}

	this.parse = function (source, capitalIndexers) {
		if (!source)
			return null;
		try {
			var exp = typeof source === "function" ? source : new Function('' ,'return '+source)();
			if (typeof exp === "function") {
				return new FunctionExpressionNode(exp);
			}
		} catch (e) {

		}
		_capitalIndexers = capitalIndexers || [];
		_lexer.init(source);
		_nextToken();
		var expr = _doExpression();
		if (expr) {
			expr._prepareValue();
		}
		return expr;
	};
	this.evaluate = function (source, runtime, capitalIndexers) {
		var expr = this.parse(source, capitalIndexers);
		return expr.evaluate(runtime);
	};
};
ExpressionParser.Default = new ExpressionParser();

var /* abstract */ ExpressionRuntime = defineClass("ExpressionRuntime", null, {
	init: function () {
		this._super();
	},
	isIdentifier: function (token) {
		throw new Error("Token is not a valid Identifier: " + token);
	},
	evaluateIdentifier: function (idKey) {
		throw new Error("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		throw new Error("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index) {
		throw new Error("Invalid identifier indexer: " + idKey);
	}
});

var $$_XML_HEAD = '<?xml version="1.0" encoding="UTF-8" standalone="yes"?>\r\n';
var _excelColCaption = function (col) {
	var ret = "";
	while (col >= 0) {
		ret = String.fromCharCode(col % 26 + 65)+ret;
		col = Math.floor(col / 26) -1;
	};
	return ret;
};
var _formatIndentXml = function (xml) {
    var formatted = '';
    var reg = /(>)(<)(\/*)/g;
    xml = xml.replace(reg, '$1\r\n$2$3');
    var pad = 0;

    var nodes = xml.split('\r\n');
    for (var index = 0, len = nodes.length; index < len; index++) {
    	var node = nodes[index];
        var indent = 0;
        if (node.match( /.+<\/\w[^>]*>$/ )) {
            indent = 0;
        } else if (node.match( /^<\/\w/ )) {
            if (pad != 0) {
                pad -= 1;
            }
        } else if (node.match( /^<\w[^>]*[^\/]>.*$/ )) {
            indent = 1;
        } else {
            indent = 0;
        }

        var padding = '';
        for (var i = 0; i < pad; i++) {
            padding += '  ';
        }

        formatted += padding + node + '\r\n';
        pad += indent;
    };

    return formatted;
};

var ExcelStrings = defineClass("ExcelStrings", null, {
	init: function (workbook) {
		this._super();
		this._nextId = 0;
		this._count = 0;
		this._stringMap = {};
		this._strings = [];
	},
	count: function () { return this._count; },
	uniqueCount: function () { return this._nextId; },
	add: function (text) {
		this._count++;
		var id = this._stringMap[text];
		if (id === undefined) {
			id = this._nextId++;
			this._stringMap[text] = id;
			this._strings[id] = text;
		}
		return id;
	},
	getIndex: function (text) {
		return this._stringMap[text];
	},
	createPart: function () {
		var s = '<sst xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"></sst>';
		var doc = _parseXml(s);
		var root = doc.documentElement;
		var spaceTest = /^\s|\s$|\r|\n|\r\n/;
		root.setAttribute("count", this._count);
		root.setAttribute("uniqueCount", this._nextId);
		for (var i = 0, cnt = this._strings.length; i < cnt; i++) {
			var node = doc.createElement("si");
			root.appendChild(node);
			var child = doc.createElement("t");
			node.appendChild(child);
			var text = doc.createTextNode(this._strings[i]);
			child.appendChild(text);
			spaceTest.test(this._strings[i]) ? child.setAttribute("xml:space","preserve") : null;			
		}
		s = _xmlToStr(doc);
		// return _formatIndentXml($$_XML_HEAD + s);
		return $$_XML_HEAD + s; // sheetJS에서 formatting된 SharedString을 못읽는다.
	}
});
var ExcelFont = function () {
	this.id = undefined;
	this.name = "Tahoma";
	this.size = 10;
	this.color = "ff000000";
	this.bold = false;
	this.italic = false;
	this.scheme = undefined;
	this.underline = false;
};
ExcelFont.prototype.toString = function() {
	return this.name+" "+this.size+" "+this.color+" "+this.bold+" "+this.italic;
};
ExcelFont.prototype.serialize = function (doc, node) {
	_addChildWithAttr(doc, node, "sz", "val", this.size || 10);
	_addChildWithAttr(doc, node, "name", "val", this.name || "Calibri");
	_addChildWithAttr(doc, node, "color", "rgb", this.color || "ff000000");
	_addChildWithAttr(doc, node, "b", "val", this.bold ? "true" : "false");
	_addChildWithAttr(doc, node, "i", "val", this.italic ? "true" : "false");
	this.underline && _addChildWithAttr(doc, node, "u");
};
var ExcelFill = function () {
	this.id = undefined;
	this.patternType = "none";
	this.color = undefined;
	this.gradient = undefined;
	this.color2 = undefined;
	this.degree = "90";
	this.tint = 0;
	this.serialize = function (doc, node) {
		var color;
		if (this.gradient == "linear") {
			var gradient = doc.createElement("gradientFill");
			node.appendChild(gradient);
			gradient.setAttribute("degree", this.degree);
			var stop = doc.createElement("stop");
			gradient.appendChild(stop);
			stop.setAttribute("position", "0");
			color = doc.createElement("color");
			stop.appendChild(color);
			color.setAttribute("rgb", this.color);
			color.setAttribute("tint", this.tint);
			stop = doc.createElement("stop");
			gradient.appendChild(stop);
			stop.setAttribute("position", "1");
			color = doc.createElement("color");
			stop.appendChild(color);
			color.setAttribute("rgb", this.color2);
			color.setAttribute("tint", this.tint);
		} else {
			var pattern = doc.createElement("patternFill");
			node.appendChild(pattern);
			pattern.setAttribute("patternType", this.patternType);
			if (this.patternType != "none") {
				color = doc.createElement("fgColor");
				pattern.appendChild(color);
				color.setAttribute("rgb", this.color);
				color.setAttribute("tint", this.tint);
				/*
				 color = doc.createElement("bgColor");
				 pattern.appendChild(color);
				 color.setAttribute("rgb", "ffffffff");
				 color.setAttribute("tint", "0");
				 */
			}
		}
	}
};
ExcelFill.prototype.toString = function() {
	return this.patternType+" "+this.color+" "+this.gradient+" "+this.color2+" "+this.degree+" "+this.tint;
};
var ExcelBorder = function () {
	this.id = undefined;
	this.left = undefined;
	this.right = undefined;
	this.top = undefined;
	this.bottom = undefined;
};
ExcelBorder.prototype.serialize = function (doc, node) {
	this.serializeBorder(doc, node, "left");
	this.serializeBorder(doc, node, "right");
	this.serializeBorder(doc, node, "top");
	this.serializeBorder(doc, node, "bottom");
};
ExcelBorder.prototype.serializeBorder = function (doc, parent, border) {
	var node = doc.createElement(border);
	parent.appendChild(node);
	border = this[border];
	if (border) {
		node.setAttribute("style", "thin");
		var color = doc.createElement("color");
		node.appendChild(color);
		color.setAttribute("rgb", border._color.toColorHex());
	}
};
ExcelBorder.prototype.toString = function() {
	return	(this.left ? this.left.toText() : this.left)+" "+
			(this.right ? this.right.toText() : this.right)+" "+
			(this.top ? this.top.toText() : this.top)+" "+
			(this.bottom ? this.bottom.toText() : this.bottom);
}
var ExcelStyle = function () {
	this.id = undefined;
	this.horzAlign = ExcelStyle.ALIGN_NEAR;
	this.vertAlign = ExcelStyle.VALIGN_CENTER;
	this.wrapText = false;
	this.formatId = 0;
	this.font = null;		// ExcelFont
	this.fill = null;		// ExcelFill
	this.border = null;		// ExcelBorder
	this.xfId = 0; 			// first cellStyleXf
};
ExcelStyle.prototype.toString = function() {
	return 	this.horzAlign+" "+this.vertAlign+" "+this.wrapText+" "+this.formatId+" "+(this.font ? this.font.id : undefined)+" "+(this.fill ? this.fill.id : undefined)+" "+(this.border ? this.border.id : undefined)+" "+this.xfId;
};
ExcelStyle.ALIGN_NEAR = "left";
ExcelStyle.ALIGN_CENTER = "center"; // "centerContinuous"
ExcelStyle.ALIGN_FAR = "right";
ExcelStyle.VALIGN_NEAR = "top";
ExcelStyle.VALIGN_CENTER = "center"; // "center"
ExcelStyle.VALIGN_FAR = "bottom";
ExcelStyle.prototype.clone = function () {
	var es = new ExcelStyle();
	for (var p in this) {
		if (this.hasOwnProperty(p)) {
			es[p] = this[p];
		}
	}
	es.id = undefined;
	return es;
};
ExcelStyle.prototype.serialize = function (doc, node) {
	node.setAttribute("borderId", this.border ? this.border.id :"0");
	node.setAttribute("fillId", this.fill ? this.fill.id : "0");
	node.setAttribute("fontId", this.font ? this.font.id : "0");
	node.setAttribute("numFmtId", this.formatId);
	node.setAttribute("xfId", "0");
	var align = doc.createElement("alignment");
	node.appendChild(align);
	align.setAttribute("horizontal", this.horzAlign);
	align.setAttribute("vertical", this.vertAlign);
	this.wrapText && align.setAttribute("wrapText", "1");
};
$$_EXCEL_NUMFMT_START = 200;
var ExcelStyles = defineClass("ExcelStyles", null, {
	init: function (workbook) {
		this._super();
		this._fonts = [];
		this._fills = [];
		this._borders = [];
		this._numFormats = [];
		this._xfs = [];
		var fill = new ExcelFill();
		this._fills.push(fill, fill);
		var border = new ExcelBorder();
		this._borders.push(border);
		var font = new ExcelFont();
		this._fonts.push(font);
		var style = new ExcelStyle();
		this._xfs.push(style);

		this._fontsMap = {};
		this._fillsMap = {};
		this._bordersMap = {};
		this._xfsMap = {};

	},
	addFont: function (font) {
		var s, idx;
		if (font) {
			s = font.toString();
			if (this._fontsMap.hasOwnProperty(s)) {
				idx = this._fontsMap[s];
				if (idx != null) {
					return font.id = idx;
				}
			}
			this._fonts.push(font);
			return this._fontsMap[s] = font.id = this._fonts.length-1;
		}
		return 0;
	},
	addFill: function (fill) {
		var s, idx;
		if (fill) {
			s = fill.toString();
			if (this._fillsMap.hasOwnProperty(s)) {
				idx = this._fillsMap[s];
				if (idx != null) {
					return fill.id = idx;
				}
			}
			this._fills.push(fill);
			return this._fillsMap[s] = fill.id = this._fills.length - 1;
		}
		return 0;
	},
	addBorder: function (border) {
		var s, idx;
		if (border) {
			s = border.toString();
			if (this._bordersMap.hasOwnProperty(s)) {
				idx = this._bordersMap[s];
				if (idx != null) {
					return border.id = idx;
				}
			}
			this._borders.push(border);
			return this._bordersMap[s] = border.id = this._borders.length-1;
		}
		return 0;
	},
	addNumberFormat: function (format) {
		var idx = this._numFormats.indexOf(format);
		if (idx < 0) {
			this._numFormats.push(format);
			idx = this._numFormats.length - 1;
		}
		return $$_EXCEL_NUMFMT_START + idx;
	},
	add: function (style) {
		var s, idx;
		if (style) {

			s = style.toString();
			if (this._xfsMap.hasOwnProperty(s)) {
				idx = this._xfsMap[s];
				if (idx != null) {
					return style.id = idx;
				}
			}
			this._xfs.push(style);
			return this._xfsMap[s] = style.id = this._xfs.length-1;


			// var xfs;
			// for (var i = 0, cnt = this._xfs.length; i < cnt ; i++) {
			// 	xfs = this._xfs[i];
			// 	if (xfs.id != null && xfs.toString() == style.toString()) {
			// 		return style.id = xfs.id;
			// 	}
			// }
			// var s = style.toString();
			// this._xfs.push(style);
			// return style.id = this._xfs.length - 1;
		}
		return 0;
	},
	createPart: function () {
		var s = '<styleSheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main"></styleSheet>';
		var doc = _parseXml(s);
		var root = doc.documentElement;
		if (this._numFormats.length > 0) {
			var numFmts = doc.createElement("numFmts");
			root.appendChild(numFmts);
			this.$_createNumberFormats(doc, numFmts);
		}
		var fonts = doc.createElement("fonts");
		root.appendChild(fonts);
		this.$_createFonts(doc, fonts);
		var fills = doc.createElement("fills");
		root.appendChild(fills);
		this.$_createFills(doc, fills);
		var borders = doc.createElement("borders");
		root.appendChild(borders);
		this.$_createBorders(doc, borders);
		var defXfs = doc.createElement("cellStyleXfs");
		root.appendChild(defXfs);
		this.$_createDefXfs(doc, defXfs);
		var xfs = doc.createElement("cellXfs");
		root.appendChild(xfs);
		this.$_createXfs(doc, xfs);
		s = _xmlToStr(doc);
		// return _formatIndentXml($$_XML_HEAD + s);
		return $$_XML_HEAD + s;
	},
	$_createNumberFormats: function (doc, parent) {
		for (var i = 0, cnt = this._numFormats.length; i < cnt; i++) {
			var node = doc.createElement("numFmt");
			_setXmlAttr(node, 'formatCode', this._numFormats[i]);
			_setXmlAttr(node, 'numFmtId', $$_EXCEL_NUMFMT_START + i);
			parent.appendChild(node);
		}
	},
	$_createFonts: function (doc, parent) {
		if (this._fonts.length < 1) {
			var f = new ExcelFont();
			this._fonts.push(f);
		}
		for (var i = 0, cnt = this._fonts.length; i < cnt; i++) {
			var node = doc.createElement("font");
			this._fonts[i].serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._fonts.length);
	},
	$_createFills: function (doc, parent) {
		if (this._fills.length < 1) {
			var f = new ExcelFill();
			this._fills.push(f);
		}
		for (var i = 0, cnt = this._fills.length; i < cnt; i++) {
			var node = doc.createElement("fill");
			this._fills[i].serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._fills.length);
	},
	$_createBorders: function (doc, parent) {
		if (this._borders.length < 1) {
			var b = new ExcelBorder();
			this._borders.push(b);
		}
		for (var i = 0, cnt = this._borders.length; i < cnt; i++) {
			var node = doc.createElement("border");
			this._borders[i].serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._borders.length);
	},
	$_createDefXfs: function (doc, parent) {
		var node = doc.createElement("xf");
		parent.appendChild(node);
		node.setAttribute("borderId", 0);
		node.setAttribute("fillId", 0);
		node.setAttribute("fontId", 0);
		node.setAttribute("numFmtId", 0);
		parent.setAttribute("count", 1);
	},
	$_createXfs: function (doc, parent) {
		if (this._xfs.length < 1) {
			var f = new ExcelStyle();
			this._xfs.push(f);
		}
		for (var i = 0, cnt = this._xfs.length; i < cnt; i++) {
			var xf = this._xfs[i];
			var node = doc.createElement("xf");
			xf.serialize(doc, node);
			parent.appendChild(node);
		}
		parent.setAttribute("count", this._xfs.length);
	}
});
var ExcelColumn = function () {
	this.index = undefined;
	this.width = 10;
	this.style = null;	// ExcelStyle
	this.serialize = function (doc, node) {
		node.setAttribute("min", this.index);
		node.setAttribute("max", this.index);
		node.setAttribute("width", this.width);
		this.style && node.setAttribute("style", this.style.id);
	}
};
var ExcelNode = function(nodeName, value) {
	this._nodeName = nodeName;
	this._attributes = {};
	this._childs = [];
	this._cellMap = {};
	this._value = value;
	this.destroy = function() {
		this._attributes = null;
		for (var i = 0, cnt = this._childs.length ; i < cnt ; i++) {
			this._childs[i].destroy && this._childs[i].destroy();
		}
		this._childs = null;
	};
	this.toText = function() {
		var nStrings = [];
		var strs = [];
		var key, i, cnt, item;
		var s;
		nStrings.push("<"+this._nodeName);
		for (key in this._attributes) {
			nStrings.push(" "+key+"="+"\""+this._attributes[key]+"\"");
		}
		nStrings.push(">");
		for (i=0, cnt=this._childs.length; i < cnt ; i++) {
			item = this._childs[i];
			strs.length = 0;
			strs.push("<"+item._nodeName);
			for (key in item._attributes) {
				strs.push(" "+key+"=\""+item._attributes[key]+"\"");
			}
			strs.push(">");
			item.hasOwnProperty("_excelFormula") && strs.push("<f>"+String(item._excelFormula)+"</f>");
			item.hasOwnProperty("_value") && strs.push("<v>"+String(item._value)+"</v>");
			strs.push("</"+item._nodeName+">");
			nStrings.push(strs.join(""));
		}
		this._value != null && nStrings.push(this._value);
		nStrings.push("</"+this._nodeName+">");
		s = nStrings.join("");
		nStrings = null;
		return s;
	};
	this.appendChild = function(node) {
		var cellInfo = node["_attributes"] && node["_attributes"]["r"];
		var idx = this._cellMap[cellInfo];
		if (idx >= 0) {
			this._childs[idx] = node;
		} else {
			idx = this._childs.push(node);	
			this._cellMap[cellInfo] = idx-1;
		}
		
	};
	this.childNodes = function() {
		return this._childs;
	}
	this.setAttribute = function(name, value) {
		!this._attributes && (this._attributes = {});
		this._attributes[name] = value;
	};
	this.getAttribute = function(name) {
		return this._attributes[name];
	};
};

// ExcelNode.prototype.setAttribute = function(name, value) {
// 	!this._attributes && (this._attributes = {});
// 	this._attributes[name] = value;
// };
// ExcelNode.prototype.getAttribute = function(name) {
// 	return this._attributes[name];
// };
// ExcelNode.prototype.appendChild = function(node) {
// 	this._childs.push(node);
// };
// ExcelNode.prototype.childNodes = function() {
// 	return this._childs;
// };
var ExcelSheet = defineClass("ExcelSheet", null, {
	init: function (workbook) {
		this._super();
		this._book = workbook;
		this._columns = null;
		this._doc = null;
		this._viewRoot = null;
		this._dataRoot = null;
		this._mergeRoot = null;
		this._rows = [];
		this._mergeCount = 0;
		this._outlineLevel = 0;
		this.$_preparePart();
		this._dateConverter = DatetimeConverter.Default;
		this._dataRows = [];  // ExcelNode;
		this._sparkGroups = {};
		this._sheetName = workbook._sheets && ("Sheet"+(workbook._sheets.length+1));
	},
	destroy : function() {
		this._book = null;
		this._columns = null;
		this._doc = null;
		this._viewRoot = null;
		this._dataRoot = null;
		this._mergeRoot = null;
		this._rows = null;
		this._dateConverter = null;
		this._dataRows = null;
	},
	colCount: function () {
		return this._columns.length;
	},
	rowCount: function () {
		// return this._rows.length;
		return this._dataRows.length;
	},
	setColumns: function (columns) {
		this._columns = columns;
	},
	addRow: function (r, ht) {
		// var row = this._rows[r];
		// if (!row) {
		// 	var row = this._doc.createElement("row");
		// 	row.setAttribute("r", r + 1);
		// 	this._rows[r] = row;
		// 	this._dataRoot.appendChild(row);
		// }
		// if (row && ht && ht > -1) { 
		// 	row.setAttribute("ht", ht);
		//  	row.setAttribute("customHeight","1");
		//  }
		// return row;

		var row = this._dataRows[r] ? this._dataRows[r] : (this._dataRows[r] = new ExcelNode("row"));
		row.setAttribute("r", r+1);
		ht && ht > -1 && (row.setAttribute("ht", ht), row.setAttribute("customHeight", "1"));
		return row;
	},
	setRowLevel: function (r, level) {
		// if (level >= 0) {
		// 	var row = this._rows[r];
		// 	if (row) {
		// 		row.setAttribute("outlineLevel", level);
		// 		this._outlineLevel = Math.max(level, this._outlineLevel);
		// 	}
		// }
		if (level >= 0) {
			var row = this._dataRows[r];
			if (row) {
				row.setAttribute("outlineLevel", level);
				this._outlineLevel = Math.max(level, this._outlineLevel);
			}
		}

	},
	addBlank: function (r, c, s, ht) {
		// var row = this.addRow(r, ht);
		// var cell = this._doc.createElement("c");
		// cell.setAttribute("r", _excelColCaption(c) + (r + 1));
		// s && cell.setAttribute("s", s.id);
		// row.appendChild(cell);
		var row = this.addRow(r, ht);
		var cell = {};
		cell["_nodeName"] = "c";
		var attrs = cell["_attributes"] = {};
		attrs["r"] = _excelColCaption(c) + (r + 1);
		s && (attrs["s"] = s.id);
		row.appendChild(cell);
	},
	addMerge: function (r, c, rows, cols) {
		var range = _excelColCaption(c) + (r + 1) + ":" + _excelColCaption(c + cols - 1) + (r + rows);
		var cell = this._doc.createElement("mergeCell");
		cell.setAttribute("ref", range);
		this._mergeRoot.appendChild(cell);
		this._mergeCount++;
	},
	$_addCell: function (r, c, t, value, s, ht, excelFormula) {
		// var row = this.addRow(r, ht);
		// var cell = this._doc.createElement("c");
		// cell.setAttribute("r", _excelColCaption(c) + (r + 1));
		// cell.setAttribute("t", t);
		// s && cell.setAttribute("s", s.id);
		// row.appendChild(cell);
		// if (excelFormula) {
		// 	var f = this._doc.createElement("f");
		// 	f.appendChild(this._doc.createTextNode(excelFormula));
		// 	cell.appendChild(f);
		// }
		// var v = this._doc.createElement("v");
		// v.appendChild(this._doc.createTextNode(value));
		// cell.appendChild(v);

		var row = this.addRow(r, ht);
		var cell = {};
		cell["_nodeName"] = "c";
		var attrs = cell["_attributes"] = {};
		attrs["r"] = _excelColCaption(c) + (r + 1);
		attrs["t"] = t;
		s && (attrs["s"] = s.id);
		excelFormula && (cell["_excelFormula"] = excelFormula);
		cell["_value"] = value;
		row.appendChild(cell);
	},
	addText: function (r, c, value, style, ht) {
		var s = (value !== undefined && value !== null) ? value : "";
		s = this._book.addString(s);
		this.$_addCell(r, c, "s", s, style, ht);
	},
	addLink: function (r, c, value, link, style, ht) {
		if (!link || (link == "")) {
			this.addText(r, c, value, style, ht);
		} else {
			var p = document.createElement("div");
			p.innerText = p.textContent = link;
			link = p.innerHTML.replace(/(<br>|<br\/>)/gi, "&#13;&#10;");

			p.innerText = p.textContent = value;
			value = p.innerHTML.replace(/(<br>|<br\/>)/gi, "\r\n");;

			link = 'HYPERLINK("'+link+ ( value ? '","'+value+'")':'")');

			this.$_addCell(r, c, "str", value, style, ht, link);
			p = null;
		}
	},
	addNumber: function (r, c, value, style, ht, excelFormula) {
		var s = isNaN(value) || value == null ? "" : String(value);
		this.$_addCell(r, c, "n", s, style, ht, excelFormula);
	},
	addBool: function (r, c, value, style, rowSpan, colSpan, ht) {
		this.$_addCell(r, c, "b", value ? 1 : 0, style, ht);
	},
	addDate: function (r, c, value, style, rowSpan, colSpan, compatibility, ht) {
		if (value) {
			// if (compatibility) { //for excel 2007
				var n = this._dateConverter.toExcelDate(value);
				this.addNumber(r, c, n, style, ht);
			// } else {
			// 	var d = this.$_dateToStr(value);
			// 	this.$_addCell(r, c, "d", d, style, ht);
			// }
		} else {
			this.$_addCell(r, c, "s", "", style, ht);
		}
	},
	addSparkLine: function(r, c, startCol, item, es) {
		var column = item.column;
		var sparkLineGroup = this._sparkGroups[column.$_hash] || (this._sparkGroups[column.$_hash] = item.sparkLineGroup);
		var sc = sparkLineGroup.refColumnInfo.startColumn;
		var ec = sparkLineGroup.refColumnInfo.endColumn;
		var addRow = sparkLineGroup.refColumnInfo.row;
		addRow = addRow == null ? 0 : addRow;
		var sparkLines = sparkLineGroup.sparkLines;
		var refColumns = this._sheetName+"!"+_excelColCaption(sc+startCol) + (r + 1 + addRow)+":"+_excelColCaption(ec+startCol) + (r + 1 + addRow);
		var cell = _excelColCaption(c) + (r + 1);
		sparkLines[cell] = refColumns;
		this.addBlank(r,c,es);
	},	
	createPart: function () {
		var doc = this._doc;
		var root = doc.documentElement;
		var i, cnt;
		var dataRows;
		var sparkGroup, s, colors, sparkLines, sparkLine, sparkType;
		/*
		var views = doc.createElement("sheetViews");
		root.appendChild(views);
		var view = doc.createElement("sheetView");
		views.appendChild(view);
		view.setAttribute("tabSelected", "1");
		view.setAttribute("workbookViewId", "0");
		var pane = doc.createElement("pane");
		view.appendChild(pane);
		pane.setAttribute("state", "forzen");
		pane.setAttribute("activePane", "bottomLeft");
		pane.setAttribute("topLeftCell", "A2");
		pane.setAttribute("ySplit", "1");
		var sel = doc.createElement("selection");
		view.appendChild(sel);
		sel.setAttribute("pane", "bottomLeft");
		*/
		// var ref = "A1:"+_excelColCaption(this._columns.length-1)+this._rows.length;
		var ref = "A1:"+_excelColCaption(this._columns.length-1)+this._dataRows.length;
		var dim = doc.getElementsByTagName("dimension");
		dim && dim.length > 0 && dim[0].setAttribute("ref",ref);
		if (this._outlineLevel > 0) {
			var fmtPtr = doc.createElement("sheetFormatPtr");
			root.appendChild(fmtPtr);
			fmtPtr.setAttribute("outlineLevelRow", this._outlineLevel);
		}
		if (this._columns) {
			var cols = doc.createElement("cols");
			root.appendChild(cols);
			this.$_createCols(doc, cols);
		}
		if (this._mergeCount > 0) {
			root.appendChild(this._mergeRoot);
			this._mergeRoot.setAttribute("count", this._mergeCount);
		}
		var rows = [];
		// String.replace가 너무 성능이 저하된다. 70~80만셀정도가 한계이다.
		// array로 처리하고 있지만 100만~120만정도셀까지만 처리가능하다.
		// xml을 이용해서 cell을 생성하는 경우 너무 느리고 용량에 한계가 있다. 
		// dimension/sheetView/cols/mergeCells는 xml형태로 처리하고 sheetData는 array로 처리한다.
		var nodes = doc.childNodes.item(0);
		rows.push('<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships">');
		nodes.getElementsByTagName("dimension") && rows.push(_xmlToStr(nodes.getElementsByTagName("dimension").item(0)));
		nodes.getElementsByTagName("sheetViews") && rows.push(_xmlToStr(nodes.getElementsByTagName("sheetViews").item(0)));
		nodes.getElementsByTagName("cols") && rows.push(_xmlToStr(nodes.getElementsByTagName("cols").item(0)));
		// nodes.getElementsByTagName("sheetData") && rows.push(_xmlToStr(nodes.getElementsByTagName("sheetData").item(0)));
		rows.push("<sheetData>");
		// var s = _xmlToStr(doc);
		// var s = "";
		dataRows = this._dataRows;
		for (i = 0, cnt = dataRows.length; i < cnt; i++) {
			dataRows[i] && rows.push(dataRows[i].toText());
		};
		rows.push("</sheetData>");
		nodes.getElementsByTagName("mergeCells") && rows.push(_xmlToStr(nodes.getElementsByTagName("mergeCells").item(0)));
		if (Object.keys(this._sparkGroups).length > 0) {
  			rows.push('<extLst>');
  			rows.push('<ext uri="{05C60535-1F16-4fd2-B633-F4F36F0B64E0}" xmlns:x14="http://schemas.microsoft.com/office/spreadsheetml/2009/9/main">');
  			rows.push('<x14:sparklineGroups xmlns:xm="http://schemas.microsoft.com/office/excel/2006/main">');
  			for (var i in this._sparkGroups) {
  				sparkGroup = this._sparkGroups[i];
  				colors = sparkGroup.colors;
				sparkLines = sparkGroup.sparkLines;
				sparkType = sparkGroup.type || "line";
  				s = '<x14:sparklineGroup displayEmptyCellsAs="gap" type="'+sparkType+'" '+
  					(colors.colorMarkers ? 'markers="1" ' : "") +
  					(colors.colorFirst ? 'first="1" ' : "") +
  					(colors.colorLast ? 'last="1" ' : "") +
  					(colors.colorHigh ?  'high="1" ' : "") +
  					(colors.colorLow ? 'low="1" ' : "") +
  					'>';
  				rows.push(s);
  				colors.colorSeries && (rows.push('<x14:colorSeries rgb="'+colors.colorSeries+'"/>'));
  				colors.colorMarkers && (rows.push('<x14:colorMarkers rgb="'+colors.colorMarkers+'"/>'));
  				colors.colorFirst && (rows.push('<x14:colorFirst rgb="'+colors.colorFirst+'"/>'));
  				colors.colorLast && (rows.push('<x14:colorLast rgb="'+colors.colorLast+'"/>'));
  				colors.colorHigh && (rows.push('<x14:colorHigh rgb="'+colors.colorHigh+'"/>'));
  				colors.colorLow && (rows.push('<x14:colorLow rgb="'+colors.colorLow+'"/>'));
  				// for (var key in colors) {
  				// 	rows.push('<x14:'+key+' rgb="'+colors[key]+'"/>');	
  				// }
  				rows.push('<x14:sparklines>');
  				for (var key in sparkLines) {
  					rows.push('<x14:sparkline>');
  					rows.push('<xm:f>'+sparkLines[key]+'</xm:f>')
  					rows.push('<xm:sqref>'+key+'</xm:sqref>')
  					rows.push('</x14:sparkline>');
  				}
  				rows.push('</x14:sparklines>');
  				rows.push('</x14:sparklineGroup>');
  				// s += sparkGroup.
  			}
  			rows.push('</x14:sparklineGroups>');
  			rows.push('</ext>');
  			rows.push('</extLst>');
		}		
		// !_isChrome && (s = s.replace(/ xmlns=""/g, '').replace(/xmlns=""/g, ''));
		rows.push("</worksheet>");
		
		for (i = 0, cnt = dataRows.length; i < cnt; i++) {
			dataRows[i] && dataRows[i].destroy && dataRows[i].destroy();
			dataRows[i] = null;
		}
		// this._rows = null;
		this._dataRows = null;
		// return _formatIndentXml($$_XML_HEAD + s);
		return $$_XML_HEAD + rows.join("");
	},
	$_preparePart: function () {
		var s = '<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"></worksheet>';
		var doc = this._doc = _parseXml(s);
		var dim = doc.createElement("dimension");
		doc.documentElement.appendChild(dim);
		var views = doc.createElement("sheetViews");
		doc.documentElement.appendChild(views);
		var view = this._viewRoot = doc.createElement("sheetView");
		views.appendChild(view);
		view.setAttribute("workbookViewId", "0"); // required attr.
		(!this._book._sheets || this._book._sheets.length == 0) && view.setAttribute("tabSelected", "1");
		view.setAttribute("showOutlineSymbols", "true"); // 기본값이 true.
		this._dataRoot = doc.createElement("sheetData");
		this._mergeRoot = doc.createElement("mergeCells");
	},
	$_createCols: function (doc, elt) {
		var cols = this._columns;
		//elt.setAttribute("count", cols.length);
		for (var i = 0, cnt = cols.length; i < cnt; i++) {
			var col = cols[i];
			var node = doc.createElement("col");
			col.serialize(doc, node);
			elt.appendChild(node);
		}
	},
	$_dateToStr: function (d) {
		return _pad(d.getFullYear(),4) + _pad((d.getMonth() + 1), 2) + _pad(d.getDate(), 2) +
			"T" + _pad(d.getHours(),2) + _pad(d.getMinutes(), 2) + _pad(d.getSeconds(), 2);
	}
});
/*
var ExcelWorkbook = defineClass("ExcelWorkbook", null, {
	init: function () {
		this._super();
		this._parts = {};
		this._sst = new ExcelStrings(this);
		this._styles = new ExcelStyles(this);
		this._sheet = new ExcelSheet(this);
		this.$_preapreTemplateParts();
	},
	destroy: function() {
		this._parts = {};
		this._sst = null;
		this._styles = null;
		this._sheet && this._sheet.destroy && this._sheet.destroy();
	},
	parts: function () {
		return this._parts;
	},
	sheet: function () {
		return this._sheet;
	},
	addString: function (s) {
		return this._sst.add(s);
	},
	addNumberFormat: function (format) {
		return this._styles.addNumberFormat(format);
	},
	addFill: function (fill) {
		return this._styles.addFill(fill);
	},
	addBorder: function (border) { 
		return this._styles.addBorder(border);
	},
	addFont: function (font) {
		return this._styles.addFont(font);
	},
	addStyle: function (style) {
		return this._styles.add(style);
	},
	createParts: function () {
		var parts = this._parts;
		parts['xl/sharedStrings.xml'] = this._sst.createPart();
		parts['xl/styles.xml'] = this._styles.createPart();
		parts['xl/worksheets/sheet1.xml'] = this._sheet.createPart();
		if (this._sheet._sheetName) {
			var s = parts['xl/workbook.xml'];
			s.indexOf('name="Sheet1"') && (s = s.replace('name="Sheet1"', 'name="'+this._sheet._sheetName+'"'));
			parts['xl/workbook.xml'] = s;
		}
		return parts;
	},
	$_preapreTemplateParts: function () {
		var parts = this._parts;
		parts['[Content_Types].xml'] = $$_XML_HEAD + '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/><Override PartName="/xl/worksheets/sheet1.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml"/></Types>';
		parts['_rels/.rels'] = $$_XML_HEAD + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/></Relationships>';
		parts['docProps/app.xml'] = $$_XML_HEAD + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"><Application>RealGridJS</Application><AppVersion>1.0</AppVersion></Properties>';
		parts['docProps/core.xml'] = $$_XML_HEAD + '<coreProperties xmlns="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dcterms:created xsi:type="dcterms:W3CDTF">2014-12-25T03:06:34Z</dcterms:created><dc:creator>Wooritech</dc:creator></coreProperties>';
		parts['xl/workbook.xml'] = $$_XML_HEAD + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><workbookPr date1904="false"/><bookViews><workbookView activeTab="0"/></bookViews><sheets><sheet name="Sheet1" r:id="rId3" sheetId="1"/></sheets></workbook>';
		parts['xl/_rels/workbook.xml.rels'] = $$_XML_HEAD + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet" Target="worksheets/sheet1.xml"/></Relationships>';
	}
});
*/
var ExcelWorkbook2 = defineClass("ExcelWorkbook2", null, {
	init:function() {
		this._super();
		this._parts = {};
		this._sst = new ExcelStrings(this);
		this._styles = new ExcelStyles(this);
		this._sheets = [];
		this._RelationshipId = 3;
		this.$_preapreTemplateParts();
	},
	destroy: function() {
		this._parts = {};
		this._sst = null;
		this._styles = null;
		if (this._sheets.length) {
			for (var i = 0, cnt = this._sheets.length; i < cnt ; i++) {
				this._sheets[i].destroy();
			}
		}
	},
	parts: function() {
		return this._parts;
	},
	sheets: function() {
		return this._sheets;
	},
	addString: function (s) {
		return this._sst.add(s);
	},
	addNumberFormat: function (format) {
		return this._styles.addNumberFormat(format);
	},
	addFill: function (fill) {
		return this._styles.addFill(fill);
	},
	addBorder: function (border) { 
		return this._styles.addBorder(border);
	},
	addFont: function (font) {
		return this._styles.addFont(font);
	},
	addStyle: function (style) {
		return this._styles.add(style);
	},
	createParts: function () {
		var parts = this._parts;
		parts['xl/sharedStrings.xml'] = this._sst.createPart();
		parts['xl/styles.xml'] = this._styles.createPart();
		var contentType = parts["[Content_Types].xml"];
		contentType = _parseXml(contentType);
		// var types = contentType.selectNodes("Types");
		var types = contentType.getElementsByTagName("Types")
		types = types && types.length > 0 ? types.item(0) : null;
		var workbookXml = parts['xl/workbook.xml'];
		workbookXml = _parseXml(workbookXml);
		// var sheets = workbookXml.selectNodes("workbook").item(0).selectNodes("sheets");
		var sheets = workbookXml.getElementsByTagName("workbook").item(0).getElementsByTagName("sheets");
		sheets = sheets && sheets.length > 0 ? sheets.item(0) : null;
		var rels = parts['xl/_rels/workbook.xml.rels'];
		rels = _parseXml(rels);
		// var relationships = rels.selectNodes("Relationships");
		var relationships = rels.getElementsByTagName("Relationships");
		relationships = relationships && relationships.length > 0 ? relationships.item(0) : null;
		for (var i = 0, cnt = this._sheets.length; i < cnt ; i++) {
			var sheet = this._sheets[i];
			var rName = "worksheets/sheet"+(i+1).toString()+".xml";
			var sn = "xl/"+rName;
			parts[sn] = sheet.createPart();
			if (types) {
				var partName = contentType.createElement("Override");
				partName.setAttribute("PartName","/"+sn);
				partName.setAttribute("ContentType","application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml");
				types.appendChild(partName);				
			}
			if (sheets) {
				var sh = workbookXml.createElement("sheet");
				sh.setAttribute("name", sheet._sheetName || "Sheet"+(i+1).toString());
				sh.setAttribute("sheetId", (i+1).toString());
				sh.setAttribute("r:id", sheet._id);
				sheets.appendChild(sh);
			}
			if (relationships) {
				var rel = rels.createElement("Relationship");
				rel.setAttribute("Id", sheet._id);
				rel.setAttribute("Type", "http://schemas.openxmlformats.org/officeDocument/2006/relationships/worksheet");
				rel.setAttribute("Target", rName);
				relationships.appendChild(rel);
			}
		}
		parts["[Content_Types].xml"] = _xmlToStr(contentType);
		parts['xl/workbook.xml'] = _xmlToStr(workbookXml);
		parts['xl/_rels/workbook.xml.rels'] = _xmlToStr(rels);
		return parts;
	},
	$_preapreTemplateParts: function () {
		var parts = this._parts;
		var createDt = new Date().toISOString();
		parts['[Content_Types].xml'] = $$_XML_HEAD + '<Types xmlns="http://schemas.openxmlformats.org/package/2006/content-types"><Default Extension="rels" ContentType="application/vnd.openxmlformats-package.relationships+xml"/><Default Extension="xml" ContentType="application/xml"/><Override PartName="/docProps/app.xml" ContentType="application/vnd.openxmlformats-officedocument.extended-properties+xml"/><Override PartName="/docProps/core.xml" ContentType="application/vnd.openxmlformats-package.core-properties+xml"/><Override PartName="/xl/sharedStrings.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sharedStrings+xml"/><Override PartName="/xl/styles.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml"/><Override PartName="/xl/workbook.xml" ContentType="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml"/></Types>';
		parts['_rels/.rels'] = $$_XML_HEAD + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/officeDocument" Target="xl/workbook.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/extended-properties" Target="docProps/app.xml"/><Relationship Id="rId3" Type="http://schemas.openxmlformats.org/package/2006/relationships/metadata/core-properties" Target="docProps/core.xml"/></Relationships>';
		parts['docProps/app.xml'] = $$_XML_HEAD + '<Properties xmlns="http://schemas.openxmlformats.org/officeDocument/2006/extended-properties"><Application>RealGridJS</Application><AppVersion>1.0</AppVersion></Properties>';
		parts['docProps/core.xml'] = $$_XML_HEAD + '<coreProperties xmlns="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:cp="http://schemas.openxmlformats.org/package/2006/metadata/core-properties" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:dcterms="http://purl.org/dc/terms/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"><dcterms:created xsi:type="dcterms:W3CDTF">'+createDt+'</dcterms:created><dc:creator>Wooritech</dc:creator></coreProperties>';
		parts['xl/workbook.xml'] = $$_XML_HEAD + '<workbook xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main" xmlns:r="http://schemas.openxmlformats.org/officeDocument/2006/relationships"><workbookPr date1904="false"/><bookViews><workbookView activeTab="0"/></bookViews><sheets></sheets></workbook>';
		parts['xl/_rels/workbook.xml.rels'] = $$_XML_HEAD + '<Relationships xmlns="http://schemas.openxmlformats.org/package/2006/relationships"><Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/sharedStrings" Target="sharedStrings.xml"/><Relationship Id="rId2" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/styles" Target="styles.xml"/></Relationships>';
	},
	getRelationshipId: function() {
		return "rId"+(this._RelationshipId++).toString();
	}
})
var HtmlSheet = defineClass("HtmlSheet", null, {
    init : function () {
        this._headrow = -1;
        this._bodyrow = -1;
        this._footrow = -1;
        this._headrows = [];
        this._bodyrows = [];
        this._footrows = [];
        this._selfClasses = {};
    
        this._numberFormatter = null;
        this._datetimeWriter = null;
        this._boolFormatter = null;
        this._lineExp = new RegExp("\r\n|\r|\n", "gi");
    },
    addHeadRow: function () {
        this._headrows[++this._headrow] = [];
        return this._headrow;
    },
    addBodyRow: function () {
        this._bodyrows[++this._bodyrow] = [];
        return this._bodyrow;
    },
    addFootRow: function () {
        this._footrows[++this._footrow] = [];
        return this._footrow;
    },
    addHeader: function (column, text, styles, rowspan, colspan) {
        var html = "<th";
        if (rowspan > 1) {
            html += " rowspan=" + rowspan;
        }
        if (colspan > 1) {
            html += " colspan=" + colspan;
        }
        
        html += " class='" + this.$_getCssClasses(column, "rg-header");
        //html += " style='";
        //html += this.$_makeCellStyleToHtml(styles);
        html += "'>";

        html += this.$_makeInnerCellToHtml(column, "rg-header", text, styles, true);
        html += "</th>";
        this._headrows[this._headrow].push(html);
    },
    addFooterText: function (column, text, styles, rowspan, colspan) {
        if (text === null || text === UNDEFINED) {
            text = "";
        }
        if (text) {
            var f;
            if ((f = styles.prefix()) != null) {
                text = f + text;
            }
            if ((f = styles.suffix()) != null) {
                text += f;
            }
        }

        var html = "<th";
        if (rowspan > 1) {
            html += " rowspan=" + rowspan;
        }
        if (colspan > 1) {
            html += " colspan=" + colspan;
        }
        html += " class='" + this.$_getCssClasses(column, "rg-footer") + "'>";

        html += this.$_makeInnerCellToHtml(column, "rg-footer", text, styles, false);
        html += "</td>";
        this._footrows[this._footrow].push(html);
    },
    addFooterNumber: function (column, value, styles, rowspan, colspan) {
        var text = value + "";
        var f;
        if (value && typeof value == "number") {
            if (f = styles.numberFormat()) {
                this.$_setNumberFormat(f);
                text = this._numberFormatter.format(value);
            }
        }
        this.addFooterText(column, text, styles, rowspan, colspan);
    },

    addBlank: function (column, styles, rowspan, colspan) {
        if (this._domMode) {
            var cell = this._doc.createElement("td");
            if (rowspan > 1) {
                cell.setAttribute("rowspan", rowspan);
            }
            if (colspan > 1) {
                cell.setAttribute("colspan", colspan);
            }
            this.$_buildCellStyle(cell, styles);
            this._row.appendChild(cell);
        } else {
            var html = "<td ";
            html += " class='" + this.$_getCssClasses(column, "rg-body");
            html += ">&nbsp;</td>"
            this._bodyrows[this._bodyrow].push(html);
        }
    },
    addText: function (column, text, styles, rowspan, colspan, affixed) {
        affixed = arguments.length > 7 ? affixed : true;

        if (text === null || text === UNDEFINED) {
            text = "";
        }
        if (affixed) {
            var f;
            if ((f = styles.prefix()) != null) {
                text = f + text;
            }
            if ((f = styles.suffix()) != null) {
                text += f;
            }
        }

        var html = "<td";
        if (rowspan > 1) {
            html += " rowspan=" + rowspan;
        }
        if (colspan > 1) {
            html += " colspan=" + colspan;
        }
        html += " class='" + this.$_getCssClasses(column, "rg-body") + "'>";

        html += this.$_makeInnerCellToHtml(column, "rg-body", text, styles, false, rowspan);
        html += "</td>";
        this._bodyrows[this._bodyrow].push(html);
    },
    addNumber: function (column, value, styles, rowspan, colspan) {
        var text = value + "";
        var f;
        if (defined(value) && typeof value == "number") {
            if (f = styles.numberFormat()) {
                this.$_setNumberFormat(f);
                text = this._numberFormatter.format(value);
            }
        }
        this.addText(column, text, styles, rowspan, colspan);
    },
    addDate: function (column, value, styles, rowspan, colspan) {
        var text = "";
        var f;
        if (value && value instanceof Date) {
            if (f = styles.datetimeFormat()) {
                this.$_setDatetimeFormat(f);
                text = this._datetimeWriter.getText(value);
            } else {
                var defaultWriter = DateTimeWriter.Default;
                text = defaultWriter.getText(value);
            }
        }
        this.addText(column, text, styles, rowspan, colspan);
    },
    addBool: function (column, value, styles, rowspan, colspan) {
        var text = "";
        var f;
        if (defined(value)) {
            if (f = styles.booleanFormat()) {
                this.$_setBooleanFormat(f);
                text = this._boolFormatter.formatValue(value);
            } else {
                text = value.toString();
            }
        }
        this.addText(column, text, styles, rowspan, colspan);
    },
    serialize: function () {
        var i, j;
        
        var html = "<style type='text/css'>";
        for (var selfcls in this._selfClasses) {
            html += this._selfClasses[selfcls] + " ";
        }
        html += "</style><table class='rg-html-table' style='border-spacing:0px'>";
        if (this._headrows.length > 0) {
            html += "<thead>";
            for (i = 0; i < this._headrows.length; i++) {
                html += "<tr>";
                html += this._headrows[i].join("");
                html += "</tr>"
            }
            html += "</thead>";
        }
        if (this._bodyrows.length > 0) {
            html += "<tbody>";
            for (i = 0; i < this._bodyrows.length; i++) {
                html += "<tr>";
                html += this._bodyrows[i].join("");
                html += "</tr>"
            }
            html += "</tbody>";       
        }
        if (this._footrows.length > 0) {
            html += "<tfoot>";
            for (i = 0; i < this._footrows.length; i++) {
                html += "<tr>";
                html += this._footrows[i].join("");
                html += "</tr>"
            }
            html += "</tfoot>";
        }
        html += "</html>";
        return html;
    },
    $_setNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
            if (value) {
                this._numberFormatter = new DecimalFormatter(value);
            } else {
                this._numberFormatter = null;
            }
        }
    },
    $_setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
            if (value) {
                this._datetimeWriter = new DateTimeWriter(value);
            } else {
                this._datetimeWriter = null;
            }
        }
    },
    $_setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._boolFormatter = new BooleanFormatter(value);
            } else {
                this._boolFormatter = null;
            }
        }
    },
    $_makeInnerCellToHtml: function (column, rootClass, text, styles, autoWrap) {
        if (!styles.textAlignment) debugger;
        var halign = styles.textAlignment();
        var valign = styles.lineAlignment();

        var html = "<div class='" + this.$_getCssClasses(column, rootClass + "-layout");
        var selfclass = this.$_getSelfCssClasses(column, rootClass + "-layout", styles);
        if (selfclass) {
            html += " " + selfclass;
        }            

        if (rootClass == "rg-body") {
            html += " " + (halign == Alignment.FAR ? "rg-right"  : halign == Alignment.NEAR ? "rg-left" : "rg-center");
            html += " " + (valign == Alignment.FAR ? "rg-bottom" : valign == Alignment.NEAR ? "rg-top"  : "rg-middle");
            if (!autoWrap && styles.textWrap() != TextWrapMode.NORMAL) {
                html += " rg-nowrap";
            }
        }
        html += "'>"
        html += "<div class='" + this.$_getCssClasses(column, rootClass + "-text");
        text = this.$_htmlEscape(text);
        if (text && styles.textWrap() != TextWrapMode.NONE && text.match(this._lineExp)) {
            text = text.replace(this._lineExp, "<br/>");
        }
        html += "'>" + text + "</div></div>";
        return html;
    },
    $_getCssClasses: function (column, pclass) {
        var classes = pclass;
        var partcls = pclass; 
        if (!(column instanceof ValueColumn)) {
            partcls += "-" + (column instanceof Indicator ? "indicator" : column instanceof CheckBar ? "checkbar" : "group");
            classes += " " + partcls;
        }
        var name;
        if (column instanceof Column) {
            var namecls;
            if (name = column.name()) {
                namecls = partcls + "-" + name.replace(" ", "_"); 
                classes += " " + namecls;
            }           
        }
        return classes;
    },
    $_getSelfCssClasses: function (column, pclass, styles) {
        if (column instanceof Column) {
            var borderLeft = styles.borderLeft() ? styles.borderLeft()._width : 0;
            var borderRight = styles.borderRight() ? styles.borderRight()._width : 0;
            var borderTop = styles.borderTop() ? styles.borderTop()._width : 0;
            var borderBottom = styles.borderBottom() ? styles.borderBottom()._width : 0;
            var paddingLeft = styles.paddingLeft();
            var paddingRight = styles.paddingRight()
            var paddingTop = styles.paddingTop();
            var paddingBottom = styles.paddingBottom();
            var spaceWidth = borderLeft + borderRight + paddingLeft + paddingRight;
            var spaceHeight = borderTop + borderBottom + paddingTop + paddingBottom;

            var hash = column.$_hash;
            var sclass = pclass + "-self-" + hash;

            if (!this._selfClasses[sclass]) {
                this._selfClasses[sclass] = "div." + sclass + 
                    "{ width: " + (column.displayWidth()-spaceWidth-1) + 
                    "px; height:" + (column.measuredHeight()-spaceHeight) + 
                    "px; padding-left:" + paddingLeft + 
                    "px; padding-top:" + paddingTop +
                    "px; padding-right:" + paddingRight +
                    "px; padding-bottom:" + paddingBottom + "px }";
            }
            return sclass; 
        }
        return null;
    },
    $_headCount: function() {
        return this._head.children.length;
    },
    $_bodyCount: function() {
        return this._body.children.length;
    },  
    $_colCount: function() {
        return this._row.children.length;
    },
    $_htmlEscape: function (text) {
        if (text && typeof text == "string") {
            return text
                .replace(/&/g, '&amp;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;');
        } else {
            return text;
        }
    }
});

var $$_SCROLL_SIZE = 17;
var Dom = defineClass("Dom", null, {
	init: function (element) {
		this._super();
		this._element = element;
	},
	x: function () {
		return this._element.offsetLeft;
	},
	y: function () {
		return this._element.offsetTop;
	},
	size: function () {
		return Dom.getSize(this._element);
	},
	element: function () {
		return this._element;
	},
	detach: function () {
		this._element.parentNode && this._element.parentNode.removeChild(this._element);
	},
	clearChildren: function () {
        Dom.clearChildren(this._element);
	},
	addChild: function (child) {
		Dom.addChild(this._element, child);
	},
	setStyles: function (styles) {
		Dom.setStyles(this._element, styles);
	},
	getBounds: function () {
		return Dom.getBounds(this._element);
	},
	getOffset: function () {
		return Dom.getOffset(this._element);
	},
	move: function (x, y) {
		Dom.move(this._element, x, y);
	},
	disableSelection: function () {
		Dom.disableSelection(this._element);
	},
	isAncestorOf: function (element) {
		var p = element.parentElement;
		while (p) {
			if (p == this._element) {
				return true;
			}
		}
		return false;
	}
}, {
	createElement: function (elementType, styles, attrs) {
		var elt = document.createElement(elementType);
		styles && Dom.setStyles(elt, styles);
        if (attrs) {
            for (var attr in attrs) {
                elt[attr] = attrs[attr];
            }
        }
		return elt;
	},
	setStyles: function (element, styles) {
		if (styles) {
			var eltStyles = element.style;
			for (var p in styles) {
				eltStyles[p] = styles[p];
			}
		}
	},
	getSize: function (element) {
		var r = element.getBoundingClientRect();
		return { width: r.width, height: r.height };
	},
	setSize: function (element, w, h) {
		var style = element.style;
		style.width = w + "px";
		style.height = h + "px";
	},
	getBounds: function (element) {
		var r = element.getBoundingClientRect();
		/*
		*/
		r.cx = element.offsetLeft;
		r.cy = element.offsetTop;
		return r;
	},
	setBounds: function (element, x, y, w, h) {
		var style = element.style;
		style.left = x + "px";
		style.top = y + "px";
		style.width = w + "px";
		style.height = h + "px";
	},
	getScrolled: function () {
		var body = document.body;
		var docElem = document.documentElement;
		return {
			sx: window.pageXOffset || docElem.scrollLeft || body.scrollLeft,
			sy: window.pageYOffset || docElem.scrollTop || body.scrollTop
		};
	},
	getOffset: function (element) {
		var box = element.getBoundingClientRect();
		var body = document.body;
		var docElem = document.documentElement;
		var scrollTop = window.pageYOffset || docElem.scrollTop || body.scrollTop;
		var scrollLeft = window.pageXOffset || docElem.scrollLeft || body.scrollLeft;
		var clientTop = docElem.clientTop || body.clientTop || 0;
		var clientLeft = docElem.clientLeft || body.clientLeft || 0;
		var x = box.left + scrollLeft - clientLeft;
		var y = box.top + scrollTop - clientTop;
		return { x: Math.round(x), y: Math.round(y) }
	},
	move: function (element, x, y) {
		element.style.left = x + "px";
		element.style.top = y + "px";
	},
	disableSelection: function (element) {
		element.style["-moz-user-select"] = "-moz-none";
		element.style["-khtml-user-select"] = "none";
		element.style["-webkit-user-select"] = "none";
		element.style["-o-user-select"] = "none";
		element.style["-ms-user-select"] = "none";
		element.style["user-select"] = "none";
		/*
		if (typeof element.onselectstart !== 'undefined') {
			element.onselectstart = function() { return false; };
		} else if (typeof element.style.MozUserSelect !== 'undefined') {
			element.style.MozUserSelect = 'none';
		} else {
			element.onmousedown = function() { return false; };
		}
		*/
	},
	addChild: function (element, child) {
		if (element && child && child.parentNode !== element) {
			element.appendChild(child);
			return true;
		}
		return false;
	},
	removeChild: function (element, child) {
		if (element && child && child.parentNode === element) {
			element.removeChild(child);
			return true;
		}
		return false;
	},
    clearChildren: function (element) {
        var elt = element;
        while (elt.lastChild) {
            elt.removeChild(elt.lastChild);
        }
    },
    clearElements: function(element) {
    	while (element.lastChild) {
    		Dom.clearElements(element.lastChild);
    		element.removeChild(element.lastChild);
    	}
    },    
	getChildIndex: function (element) {
        if (element) {
            var parent = element.parentNode;
            if (parent) {
                var childs = parent.childNodes;
                for (var i = 0; i < childs.length; i++) {
                    if (childs[i] === element) {
                        return i;
                    }
                }
            }
        }
		return -1;
	},
    getRadioGroupValue: function (groupName) {
        var items = document.getElementsByName(groupName);
        if (items) {
            for (var i = items.length; i--;) {
                if (items[i].checked) {
                    return items[i].value;
                }
            }
        }
        return undefined;
    },
	htmlEncode: function (text) {
		return document.createElement('a').appendChild(document.createTextNode(text)).parentNode.innerHTML;
	},
	getClipRect: function (r) {
		return "rect(" + r.y + "px," + (r.x + r.width) + "px," + (r.y + r.height) + "px," + r.x + "px)";
	},
	renderTextRect: function (span, font, fill, text, r, align) {
		Dom.renderTextBounds(span, font, fill, text, r.x, r.y, r.width, r.height, align);
	},
	renderTextBounds: function (span, font, fill, text, x, y, w, h, align, valign) {
		if (fill && text) {
			var css = span.style;
			span.textContent = text;
			css.font = font ? font.font : DEF_FONT;
			css.color = fill.css();
			css.whiteSpace = "nowrap";
            css.textDecoration = font.underline ? "underline" : "none";
			var cr = span.getBoundingClientRect2();
			switch (align) {
				case TextAlign.CENTER:
					x = x + (w - cr.width) / 2;
					break;
				case TextAlign.RIGHT:
					x = x + w - cr.width;
					break;
			}
			css.left = x + "px";
			switch (valign) {
				case TextLayout.TOP:
					break;
				case TextLayout.BOTTOM:
					y = y + h - cr.height;
					break;
				case TextLayout.MIDDLE:
				default:
					y = y + (h - cr.height) / 2;
					break;
			}
			css.top = y + "px";
		}
	},
	isAncestorOf: function (elt, child) {
		var p = child.parentElement;
		while (p) {
			if (p == elt) {
				return true;
			}
			p = p.parentElement;
		}
		return false;
	}
});
var Progress = defineClass("Progress", EventAware, {
    init: function () {
        this._super();
        this._view = new ProgressView();
        this._runner = null;
        this._next = 0;
        this._completed = false;
        this._timer = undefined;
    },
    min: 0,
    max: 100,
    step: 1,
    execute: function (runner) {
        if (runner) {
            this._runner = runner;
            this._next = this._min;
            if (runner.container instanceof HTMLElement) {
                this._view.setProperties(this._min, this._max, this._min);
                this._view.show(runner.container);
            }
            this.$_runNext();
        }
    },
    $_runNext: function () {
        if (this._next < this._max) {
            var msg = this._runner.run(this._next);
            this._next += this._step;
            this._view.setPosition(this._next, msg);
            _trace("P R O G R E S S : " + this._min + " > " + this._next + " > " + this._max);
            if (this._next < this._max) {
                setTimeout(function () {
                    this.$_runNext();
                }.bind(this), 0)
                return;
            }
        }
        !this.$_completed && this.$_complete();
    },
    $_complete: function () {
        try {
            this._runner.complete && this._runner.complete();
        } finally {
            _trace("P R O G R E S S : " + "completed : " + +this._min + " > " + this._next + " > " + this._max);
            this.$_completed = true;
            this._view.close();
        }
    }
});
var ProgressView = defineClass("ProgressView", null, {
    init: function (useCssStyle) {
        this._super();
        this._container = null;
        this._dom = new Dom(this.$_createElement(useCssStyle));
        this._min = 0;
        this._max = 0;
        this._pos = 0;
        this._useCssStyle = useCssStyle;
    },
    modal: false,
    message: "Load data...",
    position: function () {
        return this._pos;
    },
    setPosition: function (value, message) {
        value = Math.max(this._min, Math.min(this._max, value));
        if (value != this._pos) {
            this._pos = value;
            this._message = message;
            this.$_refreshView();
        }
    },
    setProperties: function (min, max, pos, message, refresh) {
        this._min = min;
        this._max = Math.max(min, max);
        if (this._max == this._min) this._max = this._min + 1;
        this._pos = Math.max(this._min, Math.min(this._max, pos));
        this._message = message;
        refresh && this.$_refreshView();
    },
    show: function (container, message) {
        this._container = container;
        message && this.$_setMessage(message);
        container.appendChild(this._dom.element());
        var r = container.getBoundingClientRect();
        var sz = this._dom.size();
        this._dom.move((r.width - sz.width) / 2, (r.height - sz.height) / 3);
    },
    close: function () {
        this._dom.detach();
    },
    $_createElement: function (useCssStyle) {
        var div = Dom.createElement("div", {
            position: "absolute",
            zIndex: 3001,
            minWidth: "250px",
            padding: "8px 10px"
            // backgroundColor: "rgba(0, 111, 245, 0.05)",
            // border: "1px solid #ddd"
        });
        useCssStyle && (div.className = "rg-progress");
        !useCssStyle && (div.style.backgroundColor = "rgba(0, 111, 245, 0.05)", div.style.border = "1px solid #ddd");
        div.appendChild(div.$_bar = this.$_createBar(useCssStyle));
        div.appendChild(div.$_msg = this.$_createMsg(useCssStyle));
        return div;
    },
    $_createBar: function (useCssStyle) {
        var div = Dom.createElement("div", {
            width: "100%",
            height: "13px",
            marginBottom: "4px"
            // background: "linear-gradient(#aaa, #ccc)",
            // border: "1px solid #333"
        });
        useCssStyle && (div.className = "rg-progress-bar");
        !useCssStyle && (div.style.background = "linear-gradient(#aaa, #ccc)", div.style.border = "1px solid #333");
        var led = Dom.createElement("div", {
            height: "100%",
            width: "0px"
            // background: "linear-gradient(#fff, #ddd)",
            // borderRight: "1px solid #333"
        });
        div.appendChild(led);
        useCssStyle && (led.className = "rg-progress-progress");
        !useCssStyle && (led.style.background = "linear-gradient(#fff, #ddd)", led.style.borderRight = "1px solid #333");
        div.$_led = led;
        return div;
    },
    $_createMsg: function (useCssStyle) {
        var div = Dom.createElement("div", {
            width: "100%",
            textAlign: "center"
        });
        var span = Dom.createElement("span", {
            // fontSize: "11px",
            // fontFamily: "Tahoma",
            // fontWeight: "bold"
        });
        useCssStyle && (span.className = "rg-progress-message");
        !useCssStyle && (span.style.fontSize = "11px", span.style.fontFamily="Tahoma", span.style.fontWeight="bold");
        div.appendChild(div.$_span = span);
        return div;
    },
    $_refreshView: function () {
        var elt = this._dom.element();
        var bar = elt.$_bar;
        var led = bar.$_led;
        var msg = elt.$_msg.$_span;
        msg.innerHTML = Dom.htmlEncode(this._message);
        var r = Dom.getSize(bar);
        led.style.width = Math.min(r.width - 1, _int(r.width * (this._pos - this._min) / (this._max - this._min))) + "px";
    },
    $_setMessage: function (s) {
        var msg = this._dom.element().$_msg.$_span;
        msg.innerHTML = Dom.htmlEncode(this._message);
    }
});
var ProgressManager = defineClass("ProgressManager", null, {
    init: function (container) {
        this._super();
        this._container = container;
        this._title = null;
        this._view = null;
        this._useCssStyleProgress = false;
    },
    useCssStyleProgress: false,
    show: function (container, title, modal) {
        if (!this._view) {
            this._view = new ProgressView(this._useCssStyleProgress);
        }
        this._view.show(container || this._container, title || "Load data...");
    },
    close: function () {
        this._view && this._view.close();
    },
    setProperties: function (min, max, pos, message) {
        if (!message) {
            message = this._title || "Load data... ";
            if (max > min) {
                message += parseInt((pos - min) * 100 / (max - min)) + "% " + "(" + pos + " / " + max + ")";
            }
        }
        this._view && this._view.setProperties(min, max, pos, message, true);
    }
});
var _isMac = navigator.platform.toUpperCase().indexOf('MAC') >= 0;
var _isOpera = !!window.opera || navigator.userAgent.indexOf(' OPR/') >= 0;
var _isFirefox = typeof InstallTrigger !== 'undefined';   // Firefox 1.0+
var _isWhale = !!window.whale; // whale은 체크만하고 처리하지는 않는다. 
var _isChrome = !!window.chrome && !_isOpera;              // Chrome 1+
var _isSafari = Object.prototype.toString.call(window.HTMLElement).indexOf('Constructor') > 0 || (!_isChrome && !_isOpera && navigator.userAgent.indexOf("Safari") >= 0);
var _isWinSafari = _isSafari && (navigator.platform == "Win32" || navigator.userAgent.indexOf("Windows") >= 0);
var _isIE = /*@cc_on!@*/false || !!document.documentMode; // At least IE6
var _isEdge = navigator.userAgent.toLowerCase().indexOf('edge/') >= 0; // MS Edge 
var _isiOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;  // iOS
var _ieVer = (function(){
    var undef,
        v = 3,
        div = document.createElement('div'),
        all = div.getElementsByTagName('i');
    while (
        div.innerHTML = '<!--[if gt IE ' + (++v) + ']><i></i><![endif]-->',
            all[0]
        );
    return v > 4 ? v : undef;
})();
var _ieOld = _ieVer !== undefined && _ieVer <= 9;
var _ieLeg = _ieVer !== undefined && _ieVer <= 8;
var _norgba = false;
var _ieTen = navigator.appVersion.indexOf("MSIE 10") !== -1;
var _ieNine = navigator.appVersion.indexOf("MSIE 9") !== -1;

(function () {
    var frag = document.createDocumentFragment()
    var div = document.createElement('div');
    var err = false;
    var cr;
    frag.appendChild(div);
    try {
        cr = div.getBoundingClientRect();
    } catch (e) {
        err = true;
    }
    if (err || isNaN(cr.width)) {
        Element.prototype.getBoundingClientRect2 = function () {
            var cr = Element.prototype.getBoundingClientRect.call(this);
            return {
                left: cr.left,
                right: cr.right,
                width: cr.right - cr.left,
                top: cr.top,
                bottom: cr.bottom,
                height: cr.bottom - cr.top
            }
        };
    } else {
        Element.prototype.getBoundingClientRect2 = Element.prototype.getBoundingClientRect;
    }
    try {
        div.style.background = "rgba(0, 0, 0, 1)";
    } catch (e) {
        _norgba = true;
    }
    div = null;
    frag = null;
})();
if (Object.defineProperty && Object.getOwnPropertyDescriptor &&
    Object.getOwnPropertyDescriptor(Element.prototype, "textContent") &&
    !Object.getOwnPropertyDescriptor(Element.prototype, "textContent").get) {
    (function () {
        var innerText = Object.getOwnPropertyDescriptor(Element.prototype, "innerText");
        Object.defineProperty(Element.prototype, "textContent", {
            get: function () {
                return innerText.get.call(this)
            },
            set: function (x) {
                return innerText.set.call(this, x)
            }
        });
    })();
}
var _getBrowserSize = function () {
    return {
        width: _win.innerWidth || _doc.documentElement.clientWidth || _doc.body.clientWidth,
        height: _win.innerHeight || _doc.documentElement.clientHeight || _doc.body.clientHeight
    };
};
/*
function GetZoomFactor () {
    var factor = 1;
    if (document.body.getBoundingClientRect) {
        var rect = document.body.getBoundingClientRect ();
        var physicalW = rect.right - rect.left;
        var logicalW = document.body.offsetWidth;
        factor = Math.round ((physicalW / logicalW) * 100) / 100;
    }
    return factor;
}
function GetScrollPositions () {
    if ('pageXOffset' in window) {  // all browsers, except IE before version 9
        var scrollLeft =  window.pageXOffset;
        var scrollTop = window.pageYOffset;
    }
    else {      // Internet Explorer before version 9
        var zoomFactor = GetZoomFactor ();
        var scrollLeft = Math.round (document.documentElement.scrollLeft / zoomFactor);
        var scrollTop = Math.round (document.documentElement.scrollTop / zoomFactor);
    }
    alert ("The current horizontal scroll amount: " + scrollLeft + "px");
    alert ("The current vertical scroll amount: " + scrollTop + "px");
}
*/
var $$_DOM = {};
var $_validated = 0;
var $_toolValidated = 0;
var _egam_ = Image;
var $_mobileEnable = true;
var UIContainer = defineClass("UIContainer", EventAware, {
    init: function (dom, containerId) {
        this._super();
        dom = !!dom;
        this.$_dom = dom ? $$_DOM : null;
        this.$_rich = !dom;
        if (!containerId) {
            throw "container is null!";
        }
        if (containerId instanceof HTMLDivElement) {
            this._containerDiv = containerId;
        } else {
            this._containerDiv = document.getElementById(containerId);
        }
        if (!this._containerDiv) {
            throw "Invalid grid container element: " + containerId;
        }
        this._canvas = this._container = document.createElement("div");
        this._containerDiv.appendChild(this._container);
        this._container.style.position = "relative"; // 이 것 때문에...
        this._container.style.width = "100%";
        this._container.style.height = "100%";
        this._container.style.borderStyle = "none";
        this._container.style.borderWidth = "0px";
        this._container.style.overflow = "hidden";
        this._container.style["-webkit-touch-callout"] = "none";
        this._container.style["-webkit-user-select"] = "none";
        this._container.style["user-select"] = "none";
        this._container.style["-webkit-tap-highlight-color"] = "rgba(0, 0, 0, 0)";
        var clientRect = this._container.getBoundingClientRect();
        // this._width = this._container.clientWidth;
        // this._height = this._container.clientHeight;
        this._width = parseInt(clientRect.width);//this._container.clientWidth;
        this._height = parseInt(clientRect.height);//this._container.clientHeight;
        this._updateRequested = false;
        this._layoutNeeded = false;
        this._invalidated = false;
        this._defaultTool = new VisualTool(this);
        this._activeTool = this._defaultTool;
        this._captured = false;
        this._focusing = false;
        this._focusingTarget = null;
        this._hovered = null;
        this._currentX = 0;
        this._currentY = 0;
        this._rendered = 0;
        this._defaultCursor = Cursor.AUTO;
        this._drawing = false;
        this._offsetX = 0;
        this._offsetY = 0;
        this._clicked = 0;
        this._clicket = 0;
        this._children = [];
        this._rootElement = this._createRootElement(this.$_dom);
        this._containerRender = this._render.bind(this);
        this._eventHandlers = {};
        this._eventNodes = [];
        this.$_prepareContextMenu();
        this._popupMenuManager = new PopupMenuManager(this).addListener(this);
        this._contextMenu = null;
        this.onContextMenuItemClicked = null;
    },
    _registerEventHandlers: function (canvas) {
        canvas.style.cursor = this._defaultCursor;
        if (_win.addEventListener) {
            this.$_addListener(_win, "resize", this._resizeHandler.bind(this), false);
            this.$_addListener(_win, "mousemove", this._mouseMoveHandler.bind(this), false);
            this.$_addListener(_win, "mouseup", this._mouseUpHandler.bind(this), false);
            this.$_addListener(_win, "focus", this._focusHandlerFireFox.bind(this), true);  // 이벤트가 발생한 객체에서만 발생하고 부모로 전달되지는 않는다.
            this.$_addListener(_win, "focusin", this._focusinHandler.bind(this), true);  // 이벤트가 상위 객체로 전달된다.
            this.$_addListener(canvas, "keydown", this._keyDownHandler.bind(this), false);
            this.$_addListener(canvas, "keyup", this._keyUpHandler.bind(this), false);
            this.$_addListener(canvas, "keypress", this._keyPressHandler.bind(this), false);
            this.$_addListener(canvas, "click", this._clickHandler.bind(this), false);
            this.$_addListener(canvas, "dblclick", this._dblclickHandler.bind(this), false);
            this.$_addListener(canvas, "mousedown", this._mouseDownHandler.bind(this), false);
            this.$_addListener(canvas, "mouseenter", this._mouseEnterHandler.bind(this), false);
            this.$_addListener(canvas, "mouseleave", this._mouseLeaveHandler.bind(this), false);
            this.$_addListener(canvas, "mouseover", this._mouseOverHandler.bind(this), false);
            this.$_addListener(canvas, "focus", this._focusHandler.bind(this), false);
            this.$_addListener(canvas, "blur", this._blurHandler.bind(this), false);
            // this.$_addListener(canvas, "drop", this._dropHandler.bind(this), false);
            if (_isFirefox) {
                this.$_addListener(canvas,"DOMMouseScroll", this._mouseScrollHandler.bind(this), false);
            } else if (_isIE) {
                this.$_addListener(canvas,"wheel", this._wheelHandler.bind(this), false);
            } else {
                this.$_addListener(canvas,"mousewheel", this._mouseWheelHandler.bind(this), false);
            }
            if ($_mobileEnable) {  // $_mobileEnable는 기본적으로 true이다.
                canvas.addEventListener("touchstart", this._touchStartHandler.bind(this), false);
                canvas.addEventListener("touchmove", this._touchMoveHandler.bind(this), false);
                canvas.addEventListener("touchend", this._touchEndHandler.bind(this), false);
                canvas.addEventListener("touchcancel", this._touchCancelHandler.bind(this), false);
                canvas.addEventListener("touchleave", this._touchLeaveHandler.bind(this), false);
            }
        }
    },
    $_addListener: function(node, event, handler, capture) {
        if(!(node in this._eventHandlers)) {
            this._eventHandlers[node] = {};
        }
        if(!(event in this._eventHandlers[node])) {
            this._eventHandlers[node][event] = [];
        }
        this._eventHandlers[node][event].push([handler, capture]);
        node.addEventListener(event, handler, capture);
        if (this._eventNodes.indexOf(node) < 0) {
            this._eventNodes.push(node);
        }
    },
    $_removeListener: function(node, event) {
        if(node in this._eventHandlers) {
            var handlers = this._eventHandlers[node];
            if(event in handlers) {
                var eventHandlers = handlers[event];
                for(var i = eventHandlers.length; i--;) {
                    var handler = eventHandlers[i];
                    node.removeEventListener(event, handler[0], handler[1]);
                }
            }
        }        
    },
    $_removeListenerAll: function(node) {
        var nodes = node ? [node] : this._eventNodes;
        for (var i = 0, cnt = nodes.length; i < cnt ; i++) {
            var elt = nodes[i];
            if(elt in this._eventHandlers) {
                var events = this._eventHandlers[elt];
                for (var event in events) {
                    var handlers = events[event];
                    for (var j = handlers.length; j--;) {
                        var handler = handlers[j];
                        elt.removeEventListener(event, handler[0], handler[1])
                    }
                }
            }        
        }
    },
    destroy: function() {
        this._destroying = true;

        this.$_removeListenerAll();
        this._currentX = this._currentY = null;
        Dom.clearElements(this._container);
        if (this._container.addEventListener) {
            this._container.removeEventListener("contextmenu",this.$_contextMenuHandler);
        }
        if (this._container.parentNode) {
            this._container.parentNode.removeChild(this._container);
        }        
        this.$_contextMenuHandler = null;
        this._container = null;
        this._containerRender = null;
        this._clicket = null;
        this._eventHandlers = null;
        this._eventNodes = null;
        this._super();
    },
    containerElement: function () {
        return this._container;
    },
    isVisible: function () {
        return this._container.style.visibility != "hidden";
    },
    setVisible: function (value) {
        this._container.style.visibility = value ? "visible" : "hidden";
    },
    width: function () {
        return this._width;
    },
    height: function () {
        return this._height;
    },
    defaultTool: function () {
        return this._defaultTool;
    },
    setDefaultTool: function (tool, activate) {
        this._defaultTool = tool;
        if (activate && tool) {
            this.setActiveTool(tool);
        }
        return this;
    },
    activeTool: function () {
        return this._activeTool;
    },
    setActiveTool: function (tool) {
        if (tool !== this._activeTool) {
            if (this._activeTool) {
                this._activeTool.deactivate();
            }
            this._activeTool = tool;
            if (this._activeTool) {
                this._activeTool.activate();
            }
        }
        return this;
    },
    mouseX: function () {
        return this._currentX;
    },
    mouseY: function () {
        return this._currentY;
    },
    popupMenuManager: function () {
        return this._popupMenuManager;
    },
    contextMenu: function () {
        return this._contextMenu;
    },
    setContextMenu: function (value) {
        if (value != this._contextMenu) {
            if (value instanceof PopupMenu) {
                this._contextMenu = value;
            } else if (value) {
                this._contextMenu = new PopupMenu("gridContextMenu", this, value);
            } else {
                this._contextMenu = null;
            }
        }
    },
    addChild: function (control) {
        if (control && this._children.indexOf(control) < 0) {
            this._children.push(control);
            control.attached(this);
        }
        return control;
    },
    removeChild: function (control) {
        var i;
        if (control && (i = this._children.indexOf(control)) >= 0) {
            this._children.splice(i, 1);
            control.detached();
        }
    },
    addElement: function (element, context) {
        return this._rootElement.addElement(element, context);
    },
    removeElement: function (element) {
        this._rootElement.removeElement(element);
    },
    findElementAt: function (x, y, hitTesting) {
        return this._rootElement.findChildAt(x - this._rootElement._x, y - this._rootElement._y, hitTesting);
    },
    setFocus: function () {
        this._setFocusAndScroll(this._canvas);
    },
    updateNow: function () {
        this._render(_getTimer());
    },
    invalidateLayout: function () {
        this._layoutNeeded = true;
        this.invalidate(true);
    },
    invalidate: function (force) {
        if ((!this._updateRequested || !this._invalidated) && (force || !this._drawing)) {
            window.requestAnimationFrame(this._containerRender);
            this._updateRequested = true;
            this._invalidated = true;
        }
    },
    setCursor: function (cursor) {
        this._canvas.style.cursor = cursor || this._defaultCursor;
    },
    _createChildren: function (containerElement) {
    },
    _layoutChildren: function (bounds) {
    },
    _createRootElement: function (dom) {
        return null;
    },
    _render: function (timestamp) {
        if (this._destroying) {
            return;
        }
        this._updateRequested = false;
        this._offsetX = this._canvas.offsetLeft;
        this._offsetY = this._canvas.offsetTop;
        var op = this._canvas.offsetParent;
        while (op) {
            this._offsetX += op.offsetLeft;
            this._offsetY += op.offsetTop;
            op = op.offsetParent;
        }
        this._drawing = true;
        try {
            this.$$_render(timestamp, null, 0, 0);
            if (this._resetSizeCallback) {
                this._resetSizeCallback();
                delete this._resetSizeCallback;
            }
        } finally {
            this._drawing = false;
            this._invalidated = false;
        }
    },
    $$_render: function (timestamp, scrollRect, scrollX, scrollY) {
    },
    _setFocusAndScroll: function (target) {
        if (target) {
            if (!this._focusing) {
                this._focusing = true;
                this._focusingTarget = target;
                try {
                    target.setFocus ? target.setFocus() : target instanceof HTMLCanvasElement ? null : target.focus({preventScroll:true});
                } catch (e) {
                } finally {
                    this._focusing = false;
                    this._focusingTarget = null;
                }
            } else if (target != this._focusingTarget) {
                target.setFocus ? target.setFocus() : target instanceof HTMLCanvasElement ? null : target.focus({preventScroll:true});
            }
        }
        /*
        //safari에서는 preventScroll이 아직 적용되어있지 않다.
        // 아래 코드에서도 safari는 제외되어있었기에 위의 코드로 변경한다.
        // safari에서 스크롤을 막을려면 아래의 코드를 safari에서만 적용되도록 수정해서 적용한다.

        var parr = [];
        if (target) {
            if (!this._focusing) {
                this._focusing = true;
                this._focusingTarget = target;
                try {
                    var x = _win.pageXOffset;
                    var y = _win.pageYOffset;
                    if (_isFirefox || _isChrome || _isOpera) {
                        var p = this._containerDiv && this._containerDiv.parentElement;
                        while (p && !(p instanceof HTMLBodyElement)) {
                            parr.push({element:p, st:p.scrollTop, sl:p.scrollLeft});
                            var p = p.parentElement;
                        }
                    }                    
                    var isiFrame = self !== top, topX, topY, topElement;
                    if (isiFrame) {
                        var p = self.frameElement;
                        while (p) {
                            if (p && p.tagName === "HTML") {
                                topElement = p;
                                topX = p.scrollLeft;
                                topY = p.scrollTop;
                                break;
                            }
                            p = p.parentElement;
                        }
                    }
                    // target이 canvas이면 focus를 주지 않는다. 그럼 스크롤되지 않는다.
                    target.setFocus ? target.setFocus() : target instanceof HTMLCanvasElement ? null : target.focus();
                    if (_win.pageXOffset != x || _win.pageYOffset != y) {
                        _win.scrollTo(x, y);
                    }
                    if (_isFirefox || _isChrome || _isOpera) {
                        for (var i = parr.length; i--;) {
                            if (parr[i].element.scrollTop != parr[i].st || parr[i].element.scrollLeft != parr[i].sl) {
                                parr[i].element.scrollTop = parr[i].st;
                                parr[i].element.scrollLeft = parr[i].sl;
                            }
                        }
                    }
                    if (isiFrame && topElement && (topX != topElement.scrollLeft || topY != topElement.scrollTop)) {
                        topElement.scrollTo(topX, topY);
                    }
                } finally {
                    this._focusing = false;
                    this._focusingTarget = null;
                    p = null;
                }
            } else if (target != this._focusingTarget) {
                target.setFocus ? target.setFocus() : target instanceof HTMLCanvasElement ? null : target.focus();
            }
        }
        */
    },
    checkClicked: function (x, y) {
        if ($_debug) {
            var dx = this._width - x, dy = this._height - y, t = getTimer();
            if (dx < 3 && dy < 3) {
                if (t < this._clicket + 300) {
                    this._clicked++;
                    if (this._clicked == 3) {
                        alert(this);
                    }
                } else {
                    this._clicked = 0;
                }
            }
            this._clicket = t;
        }
    },
    toOffset: function (event) {
        /*
         event.mouseX = event.clientX - _offsetX;
         event.mouseY = event.clientY - _offsetY;
         */
        var elt = this._canvas; // event.target; // canvas로 간주하면 window로 이벤트 핸들링을 해도 동일하게 적용된다.
        var r = elt.getBoundingClientRect();
        event.mouseX = event.clientX - r.left;
        event.mouseY = event.clientY - r.top;
        return event;
    },
    toScreen: function (r) {
        r.x += this._offsetX;
        r.y += this._offsetY;
        return r;
    },
    $_prepareContextMenu: function () {
        this.$_contextMenuHandler = function (e) {
            var menu = this._contextMenu;
            if (!menu) {
                var handler = this.onGetContextMenu;
                if (handler) {
                    var menuItems = handler(this, e.offsetX, e.offsetY);
                    if (menuItems && menuItems.length > 0) {
                        menu = new PopupMenu("gridContextMenu", this, menuItems);
                    }
                }
            }
            if (menu) {
                    e.preventDefault();
                    var target = e.target || e.srcElement;
                    var r = target.getBoundingClientRect();
                    var x = e.clientX - r.left;
                    var y = e.clientY - r.top;
                    this._popupMenuManager.showContext(menu, x, y);
            }
        }.bind(this);
        if ($_evl) {
            this._container.addEventListener("contextmenu", this.$_contextMenuHandler);
        } else {
            this._container.attachEvent("contextmenu", this.$_contextMenuHandler);
        }
    },
    _resizeHandler: function (event) {
    },
    _keyDownHandler: function (event) {
        if (this._activeTool) {
            var ctrl = _isMac && event.metaKey || !_isMac && event.ctrlKey;
            this._activeTool.keyDown(event.keyCode, event.ctrlKey, event.shiftKey, event.altKey, event);
            //this._gridView && this._gridView.isReadMode() && 
            //    _included(event.keyCode,Keys.SPACE, Keys.TAB, Keys.HOME, Keys.END, Keys.RIGHT, Keys.LEFT, Keys.DOWN, Keys.UP, Keys.PAGEDOWN, Keys.PAGEUP) && event.preventDefault && event.preventDefault();
        }
    },
    _keyUpHandler: function (event) {
        if (this._activeTool) {
            var ctrl = _isMac && event.metaKey || !_isMac && event.ctrlKey;
            this._activeTool.keyUp(event.keyCode, event.ctrlKey, event.shiftKey, event.altKey, event);
        }
    },
    _keyPressHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.keyPress(event.keyCode, event);
        }
    },
    _clickHandler: function (event) {
        this.checkClicked(event.clientX - this._offsetX, event.clientY - this._offsetY);
        if (this._activeTool) {
            this._activeTool.click(this.toOffset(event));
        }
    },
    _dblclickHandler: function (event) {
        this.checkClicked(event.clientX - this._offsetX, event.clientY - this._offsetY);
        if (this._activeTool) {
            this._activeTool.dblclick(this.toOffset(event));
        }
    },
    _mouseDownHandler: function (event) {
        this._popupMenuManager.close();
        if (event.target === this._canvas) {
            $$_activeGrid != this._gridView && $_setActiveGrid(this._gridView);
            this._canvas.setAttribute('tabindex', '0');
            this._captured = true;
            this.checkClicked(event.clientX - this._offsetX, event.clientY - this._offsetY);
            this.toOffset(event);
            this._currentX = event.mouseX;
            this._currentY = event.mouseY;
            if (this._activeTool) {
                this._activeTool.mouseDown(event);
            }
            /*
            _stopEvent(event);
            */
            if (_isIE && (!this._activeTool || this._activeTool.isEditing())) {
                _stopEvent(event);
            }
        }
    },
    _mouseMoveHandler: function (event) {
        var hovered = this._hovered;
        if (!this._captured && event.target !== this._canvas) {
            if (hovered) {
                hovered.setHovered(false);
                hovered instanceof HeaderCellElement && hovered.invalidate(true,true);
                this._hovered = null;
            }
            if (this._activeTool) {
                this._activeTool.mouseOutside();
            }
            return;
        }
        this.toOffset(event);
        var x = event.mouseX;
        var y = event.mouseY;
        if (x != this._currentX || y != this._currentY) { // 같은 위치여도 발생하고 있다.
            this._currentX = x;
            this._currentY = y;
            var elt = this.findElementAt(x, y, true);

            if (!this._activeTool || !this._activeTool.isDragging()) {
                if (elt && elt.canHover() && elt != this._hovered ) {
                    if (hovered) {
                        hovered.setHovered(false);
                        if (hovered instanceof HeaderCellHandle) {
                            hovered.invalidate();
                             if (!(elt instanceof HeaderCellHandle))
                                hovered._owner.invalidate();
                        }
                    }
                    this._hovered = elt;
                    if (this._hovered && this._hovered._mouseEnabled) {
                        this._hovered.setHovered(true);
                        if (this._hovered instanceof HeaderCellHandle)
                            this._hovered.invalidate();
                    }
                }
            }
        }
        if (this._activeTool) {
            this._activeTool.mouseMove(event);
        }
    },
    _mouseUpHandler: function (event) {
        if (!this._captured && event.target !== this._canvas) {
            return;
        }
        this._captured = false;
        if (this._activeTool) {
            this._activeTool.mouseUp(this.toOffset(event));
        }
    },
    _mouseEnterHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.mouseEnter(this.toOffset(event));
        }
    },
    _mouseLeaveHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.mouseLeave(this.toOffset(event));
        }
    },
    _mouseOverHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.mouseLeave(this.toOffset(event));
        }
    },
    _mouseWheelHandler: function (event) {
        if (this._activeTool) {
            if (this._activeTool.mouseWheel(this.toOffset(event))) {
                _stopEvent(event);
            }
        }
    },
    _mouseScrollHandler: function (event) {
        if (this._activeTool) {
            event.wheelDelta = -event.detail;
            if (this._activeTool.mouseWheel(this.toOffset(event))) {
                _stopEvent(event);
            }
        }
    },
    _wheelHandler: function (event) {
        if (this._activeTool) {
            event.wheelDelta = event.deltaY != 0 ? -event.deltaY : -event.deltaX;
            if (this._activeTool.mouseWheel(this.toOffset(event))) {
                _stopEvent(event);
            }
        }
    },
    _focusHandler: function (event) {
    },
    _blurHandler: function (event) {
    },
    _focusinHandler: function (event) {
        _trace("focusin to " + event.target);
        if (event.target === this._canvas) {
            !this._gridView._exiting && !_isMobile() &&this._activeTool && this._activeTool.setFocus();
        }
    },
    _focusHandlerFireFox: function (event) {
        _trace("focus to " + event.target);
        // event.target instanceof HTMLCanvasElement && event.target == this._canvas && $_setActiveGrid(this._gridView);
        if (event.target === this._canvas) {
            !this._gridView._exiting && !_isMobile() && this._activeTool && this._activeTool.setFocus();
        }
    },
    _focusoutHandler: function (event) {
        _trace("focusout from " + event.target);
    },
    _touchStartHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchStart(event);
        }
    },
    _touchMoveHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchMove(event);
        }
    },
    _touchEndHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchEnd(event);
        }
    },
    _touchCancelHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchCancel(event);
        }
    },
    _touchLeaveHandler: function (event) {
        if (this._activeTool) {
            this._activeTool.touchEnd(event);
        }
    },
    onMenuItemClick: function (menuItem) {
        this.onContextMenuItemClicked && this.onContextMenuItemClicked(this, menuItem);
        this.fireEvent(UIContainer.CONTEXT_MENU_ITEM_CLICKED, menuItem);
    }
});
UIContainer.CONTEXT_MENU_ITEM_CLICKED = "onUIContainerContextMenuItemClicked";

var PopupMenuItem = defineClass("PopupMenuItem", null, {
	init : function (parent, source) {
		this._super();
		this._parent = parent;
		this._children = null;
		if (source) {
			this.assign(source);
		}
	},
	visible: true,
	enabled: true,
	label: null,
	type: null,
	group: null,
	checked: false,
	tag: UNDEFINED,
	children: null,
	callback: null,
	parent: function () {
		return this._parent;
	},
	setChildren: function (value) {
	},
	isSeparator: function () {
		return this._label == "-" || this._type == MenuItemType.SEPARATOR;
	},
	getData: function () {
		return {
			label: this._label,
			checked: this._checked,
			enabled: this._enabled,
			tag: this._tag
		};
	},
	click: function () {
		if(this._type == "check") {
			this._checked = !this._checked;
		}
		this._parent._itemClicked(this);
	}
});
/* 	menu = [{
 label: "menu label", // "-" 면 separator
 type: "radio | check | normal | separator",
 group: "",
 enabled: true | false,
 checked: true | false,
 tag: "",
 children: [
 ],
 callback
 }, {
 }];
 */
var PopupMenu = defineClass("PopupMenu", EventAware, {
	init: function (name, parent, source) {
		this._super();
		this._name = name;
		this._parent = parent;
		this._items = this._load(source);
	},
	destroy: function() {
		this._super();
	},
	visible: true,
	enabled: true,
	name: null,
	label: null,
	manager: function () {
		var p = this._parent;
		while (p) {
			if (p.popupMenuManager && p.popupMenuManager() instanceof PopupMenuManager) {
				return p.popupMenuManager();
			}
			if (p instanceof PopupMenuManager) {
				return p;
			}
			p = p._parent;
		}
		return null;
	},
	items: function () {
		return this._items;
	},
	count: function () {
		return this._items ? this._items.length : 0;
	},
	isDescendant: function (menu) {
		var p = menu;
		while (p) {
			if (p == this) {
				return true;
			}
			p = p._parent;
		}
		return false;
	},
	_load: function (source) {
		var items = [];
		if (source) {
			source = _makeArray(source);
			for (var i = 0; i < source.length; i++) {
				var src = source[i];
				if (_isArray(src.children) && src.children.length > 0) {
					var menu = new PopupMenu(null, this, src.children);
					menu._parent = this;
					menu._label = src.label;
					menu._callback = src.callback;
					items.push(menu);
				} else {
					var item = new PopupMenuItem(this, src);
					items.push(item);
				}
			}
		}
		return items;
	},
	_itemClicked: function (menuItem) {
		if (menuItem.parent() == this && menuItem.type() == "radio") {
			var group = menuItem.group();
			if (group) {
				for (var i = 0; i < this._items.length; i++) {
					var mi = this._items[i];
					if (mi instanceof PopupMenuItem && mi.type() == "radio" && mi.group() == group) {
						mi.setChecked(false);
					}
				}
				menuItem.setChecked(true);
			}
		}
		var index = this.manager()._popupIndex;
		if (typeof menuItem.callback() === "function") {
			menuItem.callback()(menuItem.proxy(), index.proxy());// callback
			// var manager = this.manager();
			// manager && manager.fireEvent(GridBase.RUN_CALLBACK, menuItem.callback(), menuItem, index);			
		} else if (this._parent instanceof PopupMenuManager) {
			this._parent._doMenuItemClick(menuItem, index);  // dataCell button
		} else if (this._parent.onMenuItemClick) {
			this._parent.onMenuItemClick(menuItem, index);   // contextMenu
		} else {
			this._parent._itemClicked(menuItem);      // clildren click
		}
	}
});
PopupMenu.CLICKED = "onPopupMenuClicked";
var PopupMenuView = defineClass("PopupMenuView", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._useCssStyle = container._gridView instanceof GridBase && (container._gridView._editorOptions._useCssStyle || container._gridView._editorOptions._useCssStylePopupMenu);
		this._containerElement = null;
		this._parentView = null;
		this._dom = new Dom(this._element = this._createElement(this._useCssStyle));
		this._element.addEventListener("contextmenu", function (e) {
			e.preventDefault();
		});
		this._currDiv = null;
		this._menu = null;
		this._childView = null;
		this._showing = false;
		this._timer = undefined;
		this._viewGridInside = false;
	},
	minWidth: 0,
	maxWidth: 0,
	itemIndex: -1,
	destroy: function() {
		return; // PopupMenuView는 여러개의 Grid에서 공통으로 사용한다. 
	},
	manager: function () {
		return this._menu.manager();
	},
	show: function (containerElement, parentView, menuModel, x, y, width, targetHeight) {
		if (!this._showing) {
			this._showing = true;
			try {
				this._containerElement = containerElement;
				this._parentView = parentView;
				this._firstItem = null;
				this._menu = menuModel;
				var p = menuModel._parent;
				while(p._parent) {
					if (p instanceof GridBase) break;
					p = p._parent;
				}
				if (p && p instanceof GridBase) {
					this._viewGridInside = p._editorOptions._viewGridInside;
				} else if (p && p instanceof PopupMenuManager) {
					this._viewGridInside = p._container._gridView._editorOptions._viewGridInside;
				}

				if (menuModel._parent instanceof GridBase || menuModel._parent instanceof PopupMenuManager) {
					if (this._targetView) {
						this.manager()._popupIndex = this._targetView.index();
					} else {
						var grid = this.manager()._container._gridView;
						var index = CellIndex.temp(grid, -1, null).clone();
						grid._layoutManager.mouseToIndex(grid._container._currentX,grid._container._currentY,index);
						if (this._targetView && this._targetView.column) {
							index._column = this._targetView.column();
						}
						this.manager()._popupIndex = index;
					}
				}
				this.$_show(containerElement, this._menu, x, y, width, targetHeight);
			} finally {
				this._showing = false;
			}
		}
	},
	$_show: function (containerElement, menu, x, y, width, targetHeight) {
		var elt = this._element;
		var manager = this.manager();
		var dropdownCount = manager.dropdownCount();
		var container = this._viewGridInside ? containerElement : _doc.documentElement;
		if (!elt) {
			return;
		}
		this._menu = menu;
		this._itemIndex = -1;
		this._dom.clearChildren();
		this.$_buildItems(menu);
		this._disableSelection(elt);
		container.appendChild(elt);
		var cnt = menu.items().length;
		if (dropdownCount && cnt > dropdownCount) {
			var style = window.getComputedStyle(this._firstItem);
			var hh = style && parseInt(style.height.replace("px",""));
			if (hh && !isNaN(hh)) {
				var marginTop = parseInt(style.marginTop.replace("px",""));
				var paddingTop = parseInt(style.paddingTop.replace("px",""));
				marginTop = isNaN(marginTop) ? 0 : marginTop;
				paddingTop = isNaN(paddingTop) ? 0 : paddingTop;
				var marginBottom = parseInt(style.marginBottom.replace("px",""));
				var paddingBottom = parseInt(style.paddingBottom.replace("px",""));
				marginBottom = isNaN(marginBottom) ? 0 : marginBottom;
				paddingBottom = isNaN(paddingBottom) ? 0 : paddingBottom;
				elt.style.overflow = "auto";
				elt.style.height = ((hh + marginTop + paddingTop + paddingBottom) * dropdownCount + 8 + marginBottom) + "px";
			}
		} else {
			elt.style.overflow = "hidden";
			this._element.style.removeProperty("height");
		}

		var br = _getBrowserSize();
		var pr = _ieTen || _ieNine ? Dom.getBounds(_doc.body) : Dom.getBounds(_doc.documentElement);
		// var pr = Dom.getBounds(_doc.documentElement);
		var cr = Dom.getBounds(containerElement); // grid.container;
		var w = br.width;
		var h = br.height;
		var r = this._dom.getBounds();
		var sx = window.pageXOffset || _doc.documentElement.scrollLeft;
		var sy = window.pageYOffset || _doc.documentElement.scrollTop;
		if (document.documentElement.scrollWidth > document.documentElement.clientWidth) {
			h -= 18;
		}
		if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
			w -= 18;
		}
		if (this._viewGridInside) {
			if (y + cr.top + r.height > cr.bottom) {
				if (!this._parentView) {
					y = y - r.height - targetHeight;
				} else {
					y = cr.bottom - r.height - cr.top - 3;
				}
			}
			if (x + cr.left + r.width > cr.right) {
				if (!this._parentView) {
					x = x - r.width - width;
				} else {
					x = cr.right - r.width - cr.left - 3;
				}
			}
		} else {
			if (!this._parentView) {
				x += cr.left - pr.left;
				y += cr.top - pr.top;
			}
			if (y + r.height >= h + sy - 3) {
				y = y - r.height - 3;
				if (y < 0) {
					y = Math.max(0, h - r.height - 3);
				}
			}
			if (x + r.width >= w + sx - 3) {
				x = Math.max(0, w - r.width - 3);
			} else if (width !== undefined) {
				if (r.width < width) {
					x += width - r.width;
				}
			}
		}
		this._dom.move(Math.max(0, x), Math.max(0, y));
	},
	hide: function (recursive) {
		if (recursive && this._parentView) {
			this._parentView.hide(true);
		} else {
			this.$_hideChildView();
			var elt = this._element;
			if (elt && elt.parentNode) {
				this._viewGridInside ? this._containerElement.removeChild(elt) : _doc.documentElement.removeChild(elt);
			}
		}
	},
	_createElement: function (useCssStyle) {
		var element = Dom.createElement("div",{
			position : "absolute",
			float : "none",
			minWidth : "60px",
			overflow : "hidden",
			zIndex : 3000
		});
		!useCssStyle && Dom.setStyles(element,{
			background : "rgb(233, 233, 233)",
			border : "1px solid rgb(200, 200, 200)",
			boxShadow : "rgba(0, 0, 0, 0.8) 1px 2px 5px",
			fontFamily : "Tahoma",
			fontStyle : "normal",
			fontVariant : "normal",
			fontWeight : "normal",
			fontSize : "10pt",
			padding : "4px",
			margin : "0px"
		});
		if (useCssStyle) {
			element.className = "rg-popup-menu";
		} else {
			Dom.setStyles(element, {
				boxSizing : "border-box"
			});
		}
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		return element;
	},
	_showChild: function (menuDiv) {
		if (this != this.manager()._showingView) {
			return;
		}
		if (this._childView && this._childView._menu === menuDiv.menuItem || this._currDiv !== menuDiv) {
			return;
		}
		this.$_hideChildView();
		var menuItem = menuDiv.menuItem;
		var r = this._element.getBoundingClientRect();
		var x = this._element.offsetLeft + r.width - 4;
		var y = this._element.offsetTop + menuDiv.offsetTop - this._element.scrollTop;
		this._childView = PopupMenuView._borrowView(this._container);
		this._childView.show(this._containerElement, this, menuItem, x, y);
	},
	$_hideChildView: function () {
		this.manager()._showingView = null;
		if (this._childView) {
			this._childView.$_hideChildView();
			var container = this._viewGridInside ? this._containerElement : _doc.documentElement;
			try {
				this._childView._element && container.removeChild(this._childView._element);
			} catch (e) {

			}
			PopupMenuView._returnView(this._childView);
			this._childView = null;
		}
	},
	hideChild: function() {
		this.$_hideChildView();
	},
	_disableSelection: function (element) {
		element.style.WebkitUserSelect = "none";
		element.style.MozUserSelect = "none";
		element.style.KhtmlUserSelect = "none";
		element.style.MsUserSelect = "none";
		if (typeof element.onselectstart !== 'undefined') {
			element.onselectstart = function() { return false; };
		} else if (typeof element.style.MozUserSelect !== 'undefined') {
			element.style.MozUserSelect = 'none';
		} else {
			element.onmousedown = function() { return false; };
		}
	},
	_menuItemActived:function(divElt) {
		// menuItem은 PopupMenu와 PopupMenuItem으로 구성된다.
		// PopupMenu는 하위 메뉴를 가진다.
		// div.menuView는 div를 가지고 있는 menuView이다. childView를 div별로 가지고 있지 않을려고...
		this._currDiv = divElt;
		var menuItem = divElt.menuItem;
		this.manager()._showingView = this.manager()._activeView = divElt.menuView;
		if (menuItem instanceof PopupMenuItem) {
			menuItem.isEnabled() && !this._useCssStyle && !menuItem.isSeparator() && (divElt.style.background = "rgba(0, 255, 0, 0.2)")
			if (divElt.menuView && divElt.menuView._childView) {
				divElt.menuView.$_hideChildView();
			}
		} else {
			menuItem.isEnabled() && !this._useCssStyle && (divElt.style.background = "rgba(0, 255, 0, 0.2)")
			this._timer && clearTimeout(this._timer)
			this._timer = setTimeout(function () {
				divElt.menuView._showChild(divElt);
			}, 200);
		}
	},
	_menuItemDeactived:function(divElt) {
		!this._useCssStyle && (divElt.style.background = "");
	},
	_menuItemClicked:function(divElt) {
		var menuItem = divElt.menuItem;
		if (menuItem instanceof PopupMenu) {
			if (menuItem.isEnabled()) {
				this._showChild(divElt);
			}
		} else if (menuItem) {
			this.hide(true);
			if (menuItem.isEnabled()) {
				menuItem.click();
			}
			this.manager().close();
		} else {
			this.$_hideChildView();
		}
	},
	changeItemIndex:function(delta) {
		var idx = this._itemIndex;
		var menu = this._menu;
		var items = menu && menu._items;
		var item;
		if (delta == 0) {
			this._itemIndex = -1;
			this.$_refreshItems(this._itemIndex);
			return;
		}
		if (!items || idx >= items.length) {
			return;
		};
		while (true) {
			idx += delta;
			item = items[idx];
			if (!item || (item.isEnabled() && (!item.isSeparator || !item.isSeparator()))) {
				break;
			}
		};
		if (item) {
			this._itemIndex = idx;
			this.$_refreshItems(this._itemIndex);
		}
	},
	menuItemClicked:function() {
		var element = this._element;
		var elt = element.childNodes[this._itemIndex];
		elt && this._menuItemClicked(elt);
	},
	$_refreshItems:function(itemIndex) {
		var element = this._element;
		var items = this._menu.items();
		for (var i = 0, cnt = element.childNodes.length; i < cnt ; i++) {
			var elt = element.childNodes[i];
			elt.style.background = i === itemIndex ? "rgba(0,255,0,0.2)" : "";
			if (i == itemIndex) {
				var dCount = this.manager().dropdownCount();
				if (dCount > 0) {
					var eltTop = elt.offsetTop;
					var eltHeight = parseInt(elt.offsetHeight) + 4;
					var parentHeight = parseInt(element.offsetHeight);
					var scrollTop = element.scrollTop;
					if (scrollTop > eltTop) {
						element.scrollTop = Math.max(0, element.scrollTop+(eltTop-scrollTop));
					} else if (scrollTop+parentHeight < eltTop+eltHeight) {
						element.scrollTop = element.scrollTop + eltTop+eltHeight - (scrollTop+parentHeight);
					}
				}
				this._menuItemActived(elt);
			}
		}
	},
	$_buildItems: function (menu) {
		var items = menu.items();
		var n = 0;
		var clsList = [];
		var firstItem = null;
		for (var i = 0, cnt = items.length; i < cnt; i++) {
			var menuItem = items[i];
			if (!menuItem.isVisible()) continue;
			var div = _doc.createElement("div");
			div.menuView = this;
			div.menuItem = menuItem;
			Dom.setStyles(div, {
				position : "relative",
				float : "none",
				width : "100%"
			});
			!this._useCssStyle && Dom.setStyles(div,{
				paddingTop : "2px",
				paddingBottom : "2px",
				cursor : "default"
			})
			if (menuItem instanceof PopupMenuItem && menuItem.isSeparator()) {
				this._useCssStyle && (div.className = "rg-popup-separator");
				var hr = _doc.createElement("hr");
				!this._useCssStyle && Dom.setStyles(hr,{
					height : "1px",
					border : "0px",
					margin : "2px",
					color : "#777",
					backgroundColor : "#777"
				});
				this._useCssStyle && (hr.className = "rg-popup-separator-hr");
				div.appendChild(hr);
				div.onmouseover = function (e) {
					var div = e.currentTarget;
					this._menuItemActived(div);
				}.bind(this);
			} else {
				!this._firstItem && (this._firstItem = div);
				clsList.length = 0;
				!this._useCssStyle && ( div.style.color = menuItem.isEnabled() ? "#333" : "#aaa" );
				this._useCssStyle && clsList.push("rg-popup-item");
				this._useCssStyle && menuItem.group && menuItem.group() && clsList.push("rg-popup-"+menuItem.group());
				this._useCssStyle && !menuItem.isEnabled() && clsList.push("rg-popup-item-disable");
				this._useCssStyle && (div.className = clsList.join(" "));
				div.style.whiteSpace = "pre";
				div.onclick = function (e) {
					var div = e.currentTarget;
					this._menuItemClicked(div);
				}.bind(this);
				div.onmouseover = function (e) {
					var div = e.currentTarget;
					this._menuItemActived(div);
				}.bind(this);
				div.onmouseout = function (e) {
					var div = e.currentTarget;
					this._menuItemDeactived(div);
				}.bind(this);
				var check = _doc.createElement("span");
				clsList.length = 0;
				check.style.display = "inline-block";
				check.style.minWidth = "20px";
				check.style.minHeight = "7px";
				check.style.verticalAlign = "middle";
				check.style.outline = "none";
				check.innerHTML = "";
				this._useCssStyle && menuItem.type && (menuItem.type() === "radio" || menuItem.type() === "check") && clsList.push(menuItem.group() ? "rg-popup-radio" : "rg-popup-check");

				if (menuItem.isChecked && menuItem.isChecked()) {
					!this._useCssStyle && Dom.setStyles(check, {
						backgroundImage : "url(" + $$_rootContext + $$_assets + (menuItem.group() ? "menu_radio.png" : "menu_check.png") + ")",
						backgroundRepeat : "no-repeat",
						backgroundPosition : "center center"
					})
					this._useCssStyle && clsList.push(menuItem.group() ? "rg-popup-radio-checked" : "rg-popup-check-checked");
				}
				this._useCssStyle && (check.className = clsList.join(" "));
				check.tabIndex = -1;
				this._disableSelection(check);
				div.appendChild(check);
				var span = _doc.createElement("span");
				span.id = "$popupMenu_item_" + PopupMenuView.$_menuId++;
				span.style.paddingRight = "24px";
				span.innerHTML = menuItem.label();
				span.tabIndex = -1;
				span.style.outline = "none";
				this._disableSelection(span);
				div.appendChild(span);
				if (menuItem instanceof PopupMenu) {
					var arrow = _doc.createElement("span");
					this._useCssStyle && (arrow.className = "rg-popup-expander");
					div.appendChild(arrow);
					arrow.style.position = "absolute";
					arrow.style.right = "0px";
					arrow.style.width = "24px";
					arrow.style.height = (13 + 2 + 2) + "px"; // 13 = 10pt
					arrow.style.verticalAlign = "middle";
					arrow.style.outline = "none";
					arrow.innerHTML = " ";
					!this._useCssStyle && Dom.setStyles(arrow, {
						backgroundImage : "url(" + $$_rootContext + $$_assets + "menu_expander.png" + ")",
						backgroundRepeat : "no-repeat",
						backgroundPosition : "center center"
					})
					arrow.tabIndex = -1;
					this._disableSelection(arrow);
					div.appendChild(arrow);
				}
			}
			this._disableSelection(div);
			this._element.appendChild(div);
			n++;
		};
	}
}, {
	$_menuId: 0,
	$_views: [],
	_borrowView: function (container) {
		var view = PopupMenuView.$_views.pop();
		if (!view) {
			view = new PopupMenuView(container);
		}
		return view;
	},
	_returnView: function (view) {
		if (view._children) {
			for (var i = 0; i < view._children.length; i++) {
				PopupMenuView.returnView(view[i]);
			}
		}
		PopupMenuView.$_views.push(view);
	}
});
var PopupMenuManager = defineClass("PopupMenuManager", EventAware, {
	init: function (visualContainer) {
		this._super();
		this._container = visualContainer;
		this._menus = [];
		this._mainView = null;
		this._showingView = null;
		this._popupIndex = null;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._mainView._element || p.menuItem) {
					return;
				}
				p = p.parentNode;
			}
			this.close();
		}.bind(this);
	},
	destroy: function() {
		this.close();
		this._destroying = true;
		this._mainView = null;
		this._showingView = null;
		this._popupIndex = null;
		this._showingView = null;
		this._activeView = null;
		this._super();
	},
	dropdownCount : 0,
	isShow: function() {
		return !!this._mainView;
	},
	indexOf: function (name) {
		for (var i = this._menus.length; i--;) {
			if (_equalsText(this._menus[i].name(),name)) {
				return i;
			}
		}
		return -1;
	},
	getMenu: function (name) {
		for (var i = this._menus.length; i--;) {
			if (_equalsText(this._menus[i].name(),name)) {
				return this._menus[i];
			}
		}
		return null;
	},
	addMenu: function (name, menuItems, overwrite) {
		if (_isWhiteSpace(name)) {
			throw "Menu name is empty.";
		}
		var index = -1;
		if (!overwrite) {
			index = this.indexOf(name);
			if (index >= 0) {
				return this._menus[index];
			}
		}
		var menu = new PopupMenu(name, this, menuItems);
		if (overwrite && index > -1) {
			this._menus[index] = menu;
		} else {
			this._menus.push(menu);
		}
		return menu;
	},
	removeMenu: function (name) {
		var i = this.indexOf(name);
		if (i >= 0) {
			this._menus.splice(i, 1);
		}
	},
	clearMenus: function () {
		this._menus.length = 0;
	},
	show: function (menu, targetView, cx, cy , width, height) {
		if (!this._mainView) {
			if (typeof menu === "string") {
				menu = this.getMenu(menu);
			} else 	if (!(menu instanceof PopupMenu)) {
				menu = new PopupMenu(null, this, menu);
			}
			if (menu) {
				if (cx != null && cy != null) {
					width = isNaN(width = parseInt(width)) ? 0 : width;
					height = isNaN(height = parseInt(height)) ? 0 : height;
				} else {
					var r = targetView.boundsByContainer();
					var y = r.top();
					if (targetView instanceof MergedDataCellElement) {
						var grid = targetView.grid();
						var lm = grid.layoutManager();
						var itemIndex = targetView.index().I() + targetView.innerIndex() - grid.topItem()+grid.fixedOptions().rowCount();
						if (itemIndex >= 0) {
							var r2 = lm.itemBounds(itemIndex);
							y = lm.bodyBounds().top()+r2.bottom();
						} else {
							y = r.bottom();
						}
					} else {
						y = r.bottom();
					}
					cx = r.x, cy = y, width = r.width, height = r.height;
				}
				this._mainView = this._activeView = PopupMenuView._borrowView(this._container);
				this._mainView._targetView = targetView;
				this._mainView.show(this._container._container, null, menu, cx, cy, width, height);
				$_evl ? _win.addEventListener("mousedown", this._globalMouseHandler) : _win.attachEvent("onmousedown", this._globalMouseHandler);
			}
		}
	},
	showContext: function (menu, x, y) {
		if (menu && !this._mainView) {
			this._mainView = this._activeView = PopupMenuView._borrowView(this._container);
			this._mainView.show(this._container._container, null, menu, x, y, 0, 0);
			$_evl ? _win.addEventListener("mousedown", this._globalMouseHandler) : _win.attachEvent("onmousedown", this._globalMouseHandler);
		}
	},
	close: function () {
		if (this._mainView) {
			this._mainView.hide();
			PopupMenuView._returnView(this._mainView);
			delete this._mainView._targetView;
			this._mainView = null;
			$_evl ? _win.removeEventListener("mousedown", this._globalMouseHandler) : _win.detachEvent("onmousedown", this._globalMouseHandler);	
		}
	},
	_doMenuItemClick: function (menuItem, index) {
		this.fireEvent(PopupMenuManager.MENU_ITEM_CLICKED, menuItem, index);
	},
	_doKeyDown:function(key) {
		var menuView = this._activeView;
		switch (key) {
			case Keys.DOWN : 
				menuView.changeItemIndex(1);
				break;
			case Keys.UP :
				menuView.changeItemIndex(-1);
				break;
			case Keys.LEFT :
				if (menuView._parentView) {
					menuView.changeItemIndex(0);
					menuView.hideChild();
					this._showingView = this._activeView = menuView._parentView || this._mainView;
				}
				break;
			case Keys.RIGHT :
				if (menuView && menuView._childView) {
					menuView = this._showingView = this._activeView = menuView._childView;
					menuView.changeItemIndex(1);
				}
				break;
			case Keys.ENTER:
			case Keys.SPACE:
				menuView.menuItemClicked();
				break;
		}
	},
	keyDown:function(key) {
		this._doKeyDown(key)
	}
});
PopupMenuManager.MENU_ITEM_CLICKED = "onPopupMenuManagerMenuItemClicked";
var TextAlign = _enum( {
	LEFT : "left",
	CENTER : "center",
	RIGHT : "right"
});
var TextLayout = _enum( {
	TOP : "top",
	MIDDLE : "middle",
	BOTTOM : "bottom"
});
var TextWrap = _enum( {
	NONE : "none",
	NORMAL : "normal"
});
var ChartItemShapes = _enum({
	CIRCLE: "circle",
	TRIANGLE: "triangle",
	SQUARE: "square",
	DIAMOND: "diamond"
});
var ContentVisibility = _enum({
	VISIBLE: "visible",
	HIDDEN: "hidden",
	COLLAPSED: "collapsed"
});
var LabelPosition = _enum({
	DEFAULT: "default",
	FAR: "far",
	MID: "mid",
	NEAR: "near"
});
var ContentOrientation = _enum({
	HORIZONTAL: "horizontal",
	VERTICAL: "vertical"
});
var HorizontalAlign = _enum({
	DEFAULT: "default",
	LEFT: "left",
	CENTER: "center",
	RIGHT: "right",
	FILL: "fill"
});
var VerticalAlign = _enum({
	DEFAULT: "default",
	TOP: "top",
	MIDDLE: "middle",
	BOTTOM: "bottom",
	FILL: "fill"
});
var OverflowPolicy = _enum({
	NONE: "none",
	JUSTIFY: "justify"
});
var Rectangle = function(x, y, width, height) {
	if (typeof x === "undefined" || x === null) {
		this.x = this.y = this.width = this.height = 0;
	} else {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
	}
};
Rectangle.prototype = {
	constructor: Rectangle,
	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},
	getInner: function () {
		return new Rectangle(0, 0, this.width, this.height);
	},
	equals: function(r) {
		return r === this
			|| r && this.x === r.x && this.y === r.y && this.width === r.width && this.height === r.height;
	},
	toString: function() {
		return "{x: " + this.x + ", y: " + this.y + ", width: " + this.width + ", height: " + this.height + "}";
	},
	left: function () {
		return this.x;
	},
	setLeft: function (value) {
		var dx = value - this.x;
		this.x += dx;
		this.width -= dx;
	},
	leftBy: function(delta) {
		this.x += delta;
		this.width -= delta;
		return this;
	},
	right: function () {
		return this.x + this.width;
	},
	setRight: function (value) {
		var dx = value - (this.x + this.width);
		this.width += dx;
	},
	rightBy: function(delta) {
		this.width += delta;
		return this;
	},
	top: function () {
		return this.y;
	},
	setTop: function (value) {
		var dy = value - this.y;
		this.y += dy;
		this.height -= dy;
		return this;
	},
	topBy: function(delta) {
		this.y += delta;
		this.height -= delta;
		return this;
	},
	bottom: function () {
		return this.y + this.height;
	},
	setBottom: function (value) {
		var dy = value - (this.y + this.height);
		this.height += dy;
		return this;
	},
	bottomBy: function(delta) {
		this.height += delta;
		return this;
	},
	shrink: function (dx, dy) {
		this.width -= dx;
		this.height -= dy;
		return this;
	},
	expand: function (dx, dy) {
		this.width += dx;
		this.height += dy;
		return this;
	},
	contains: function(x, y) {
		return x >= this.x && x <= this.x + this.width
			&& y >= this.y && y <= this.y + this.height;
	},
	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},
	setEmpty: function() {
		this.width = this.height = 0;
		return this;
	},
	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},
	copy: function (r) {
		this.x = r.x;
		this.y = r.y;
		this.width = r.width;
		this.height = r.height;
		return this;
	},
	copyHorz: function (r) {
		this.x = r.x;
		this.width = r.width;
		return this;
	},
	copyVert: function (r) {
		this.y = r.y;
		this.height = r.height;
		return this;
	},
	inflate: function(left, top, right, bottom) {
		top = arguments.length > 1 ? top : 0;
		right = arguments.length > 2 ? right : left;
		bottom = arguments.length > 3 ? bottom : top;
		if (left) this.setLeft(this.x - left);
		if (top) this.setTop(this.y - top);
		if (right) this.setRight(this.right() + right);
		if (bottom) this.setBottom(this.bottom() + bottom);
		return this;
	},
	offset: function (dx, dy) {
		this.x += dx;
		this.y += dy;
		return this;
	},
	round : function() {
		var r = this.clone();
		r.x >>>= 0;
		r.y >>>= 0;
		r.width >>>= 0;
		r.height >>>= 0;
		return r;
	},
	union: function (r) {
		var r2 = this.clone();
		r2.setLeft(Math.min(this.x, r.x));
		r2.setRight(Math.max(this.right(), r.right()));
		r2.setTop(Math.min(this.y, r.y));
		r2.setBottom(Math.max(this.bottom(), r.bottom()));
		return r2;
	},
	normalize: function () {
		if (this.width < 0) {
			this.x -= this.width;
			this.width *= -1;
		}
		if (this.height < 0) {
			this.y -= this.height;
			this.height *= -1;
		}
		return this;
	}
};
var Size = function (width, height) {
	if (arguments.length == 0) {
		this.width = this.height = 0;
	} else {
		this.width = width;
		this.height = height;
	}
};
Size.EMPTY = new Size();
Size.empty = function () {
	return new Size();
};
Size.create = function (w, h) {
	return new Size(w, h);
};
Size.prototype = {
	constructor: Size,
	clone: function() {
		return new Size(this.width, this.height);
	},
	equals: function(sz) {
		return sz === this
			|| sz && this.width === sz.width && this.height === sz.height;
	},
	toString: function() {
		return "{width: " + this.width + ", height: " + this.height + "}";
	},
	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},
	setEmpty: function() {
		this.width = this.height = 0;
		return this;
	},
	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},
	round : function() {
		var sz = this.clone();
		sz.width >>>= 0;
		sz.height >>>= 0;
		return sz;
	}
};
var Point = function (x, y) {
	if (arguments.length == 0) {
		this.x = this.y = 0;
	} else {
		this.x = x;
		this.y = y;
	}
};
Point.EMPTY = new Point();
Point.empty = function () {
	return new Point();
};
Point.create = function (w, h) {
	return new Point(w, h);
};
Point.prototype = {
	constructor: Size,
	clone: function() {
		return new Point(this.x, this.y);
	},
	equals: function(pt) {
		return pt === this
			|| pt && this.width === pt.width && this.height === pt.height;
	},
	toString: function() {
		return "{x: " + this.x + ", y: " + this.y + "}";
	},
	isEmpty: function() {
		return this.x === 0 || this.y === 0;
	},
	setEmpty: function() {
		this.x = this.y = 0;
		return this;
	},
	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},
	round : function() {
		var pt = this.clone();
		pt.x >>>= 0;
		pt.y >>>= 0;
		return pt;
	}
};
var SideRectangles = function () {
	this.left = new Rectangle();
	this.right = new Rectangle();
	this.top = new Rectangle();
	this.bottom = new Rectangle();
};
SideRectangles.prototype = {
	constructor: SideRectangles,
	clear: function () {
		this.left.setEmpty();
		this.right.setEmpty();
		this.top.setEmpty();
		this.bottom.setEmpty();
	},
	setLeft: function (x, y, w, h) {
		this.left.set(x, y, w, h);
	},
	setRight: function (x, y, w, h) {
		this.right.set(x, y, w, h);
	},
	setTop: function (x, y, w, h) {
		this.top.set(x, y, w, h);
	},
	setBottom: function (x, y, w, h) {
		this.bottom.set(x, y, w, h);
	}
};
var RelativeSize = function (size, fixed) {
	this._size = size;
	this._fixed = fixed;
};
RelativeSize.prototype = {
	constructor: RelativeSize,
	clone: function () {
		return new RelativeSize(this._size, this._fixed);
	},
	getSize: function (targetSize) {
		return this._fixed ? this._size : targetSize * this._size;
	}
};
RelativeSize.Empty = new RelativeSize(0, false);
RelativeSize.createFrom = function (value) {
	var v = 0;
	var f = false;
	if (value) {
		var s = String(value).trim();
		var len = s.length;
		if (len > 0) {
			if (len > 2 && s.lastIndexOf("px") == len - 2) {
				f = true;
				s = s.substr(0, len - 3);
			}
			if (s) {
				v = parseFloat(s);	
			}
		}
	}
	return new RelativeSize(v, f);
};
RelativeSize.equals = function (v1, v2) {
	return v1 instanceof RelativeSize && v2 instanceof RelativeSize && v1._size === v2.size && v1._precentage === v2._precentage;
};
var PercentSize = function (size, fixed) {
	this._size = size;
	this._fixed = fixed;
};
PercentSize.prototype = {
	constructor: PercentSize,
	clone: function () {
		return new PercentSize(this._size, this._fixed);
	},
	getSize: function (orgSize, denominator) {
		return this._fixed ? this._size : orgSize * this._size / (denominator || 100.0);
	}
};
PercentSize.Empty = new PercentSize(0, true);
PercentSize.createFrom = function (value) {
	var v = 0;
	var f = true;
	if (value) {
		var s = String(value).trim();
		var len = s.length;
		if (len > 0) {
			if (len > 1 && s.lastIndexOf("%") == len - 1) {
				f = false;
				s = s.substr(0, len - 1).trim();
			}
			if (s) {
				v = parseFloat(s);	
			}
		}
	}
	return new PercentSize(v, f);
};
PercentSize.equals = function (v1, v2) {
	return v1 instanceof PercentSize && v2 instanceof PercentSize && v1._size === v2.size && v1._precentage === v2._precentage;
};
var SizeF = function (width, height) {
	this.width = width;
	this.height = height;
};
SizeF.prototype = {
	constructor: SizeF,
	clone: function () {
		return new SizeF(this.width, this.height);
	},
	set: function (width, height) {
		this.width = parseFloat(width);
		this.height = parseFloat(height);
	}
};
SizeF.createFrom = function (value) {
	var w = 0, h = 0;
	if (value) {
		var arr = String(value).split(",");
		if (arr.length > 0 ) {
			w = h = parseFloat(arr[0]);
		}
		if (arr.length > 1) {
			h = parseFloat(arr[1]);
		}
	}
	return new SizeF(w, h);
};
var Color = function (value, strict) {
	if (typeof value === "string") {
		Color._parse(value, this, strict, false);// true);
	} else if (value instanceof Color) {
		this._r = value._r;
		this._g = value._g;
		this._b = value._b;
		this._a = value._a;
	} else if (!isNaN(value)) {
		this._a = (value >>> 24) / 255;
		this._r = (value & 0x00ff0000) >> 16;
		this._g = (value & 0x0000ff00) >> 8;
		this._b = value & 0x000000ff;
	} else {
		this._r = this._g = this._b = 0;
		this._a = strict ? NaN : 1;
	}
};
Color._ERROR = new Color(UNDEFINED, true);
Color._ERROR.error = true;
Color.createFrom = function (s, strict) {
	var colorObj = Color._parse(s, $_tempColor, strict, false);
	if (colorObj) {
		return (typeof colorObj === "object") ? colorObj : $_tempColor.clone();
	} else {
		return null;
	}
};
Color._parse = function (value, color, strict, throwError) {
	var s = String(value);
	if (s) {
        var len = s.length;
        var v;
		s = s.trim().toLowerCase();
		if (s.charAt(0) == "#") {
			s = s.substr(1);
			len--;
			if (len >= 6 && len <= 8) {
				color._b = toInt(s.substr(len - 2, 2), 16);
				color._g = toInt(s.substr(len - 4, 2), 16);
				color._r = toInt(s.substr(len - 6, 2), 16);
				color._a = (len == 6) ? (strict ? NaN : 1) : (toInt(s.substr(0, len - 6), 16) / 255.0);
			} else if (len == 3) {
				color._r = toInt(s.charAt(0) + s.charAt(0), 16);
				color._g = toInt(s.charAt(1) + s.charAt(1), 16);
				color._b = toInt(s.charAt(2) + s.charAt(2), 16);
				color._a = strict ? NaN : 1;
			} else if (throwError) {
				throw "Invalid color value text: " + value;
			} else {
				return false;
			}
		} else if (s.indexOf("rgba(") == 0 && s.charAt(len - 1) == ")") {
			s = s.substring(5, len - 1);
			v = s.split(",");
			color._r = toInt(v[0]);
			color._g = toInt(v[1]);
			color._b = toInt(v[2]);
			color._a = v[3];
		} else if (s.indexOf("rgb(") == 0 && s.charAt(len - 1) == ")") {
			s = s.substring(4, len - 1);
			v = s.split(",");
			color._r = toInt(v[0]);
			color._g = toInt(v[1]);
			color._b = toInt(v[2]);
			color._a = strict ? NaN : 1;
		} else if (strict && StrictColors.hasOwnProperty(s)) {
			return StrictColors[s];
		} else if (!strict && Colors.hasOwnProperty(s)) {
			return Colors[s];
		} else {
			var palItem = ColorPaletteItem.createFrom(s, false);
			if (palItem) {
				return palItem;
			}
			if (throwError) {
				throw new Error("Invalid color text: " + value);
			}			
			return false;
		}
		return true;
	}
	return false;
};
Color.getColorStringArray = function (value) {
	return value.trim().toLowerCase().split(/\s+|(rgba\(.*\))|(rgb\(.*\))|(pal\(.*\))/).filter(Boolean);
};
Color.getColorCsvArray = function (value) {
	return value.trim().toLowerCase().split(/\s*,\s*|\s+|(rgba\(.*\))|(rgb\(.*\))|(pal\(.*\))/).filter(Boolean);
};
Color.prototype.clone = function () {
	return new Color(this);
};
Color.prototype.copy = function (source, alpha) {
	if (source) {
		this._r = source._r;
		this._g = source._g;
		this._b = source._b;
		this._a = isNaN(source._a) ? Number(alpha) : source._a;
	} else {
		this._a = Number(alpha);
	}
	return this;
};
Color.prototype.value = function () {
	return "rgba(" + this._r + "," + this._g + "," + this._b + "," + this._a + ")";
};
Color.prototype.valueWithBrightness = function (brightness) {
	var r = this._r;
	var g = this._g;
	var b = this._b;
	var bright = Number(brightness);
	if (!isNaN(bright) && bright != 1) {
		r = _floor(Math.max(0, Math.min(0xff, r * bright)));
		g = _floor(Math.max(0, Math.min(0xff, g * bright)));
		b = _floor(Math.max(0, Math.min(0xff, b * bright)));
		if (r == 0xff && this._r < 0xff) {
			r = _floor((0xff + this._r) / 2);
		}
		if (g == 0xff && this._g < 0xff) {
			g = _floor((0xff + this._g) / 2);
		}
		if (b == 0xff && this._b < 0xff) {
			b = _floor((0xff + this._b) / 2);
		}
	}
	return "rgba(" + r + "," + g + "," + b + "," + this._a + ")";
};
Color.prototype.argb = function () {
	return (Math._floor(this._a * 255) << 24) | (this._r << 16) | (this._g << 8) | this._b;
};
Color.prototype.rgb = function () {
	return (this._r << 16) | (this._g << 8) | this._b;
};
/*
Color.prototype.set = function (a, r, g, b) {
	this._a = a;
	this._r = r;
	this._g = g;
	this._b = b;
};
Color.prototype.setRgb = function (a, r, g, b) {
	this._a = 1.0;
	this._r = r;
	this._g = g;
	this._b = b;
};
Color.prototype.setValue = function (color, alpha) {
	this._r = (color & 0x00ff0000) >> 16;
	this._g = (color & 0x0000ff00) >> 8;
	this._b = color & 0x000000ff;
	this._a = alpha;
};
*/
Color.prototype.extractAlpha = function () {
	var alpha = this._a;
	this._a = NaN;
	return alpha;
};
Color.prototype.toHex = function () {
	return "" + hex(_floor(this._a * 255)) + hex(this._r) + hex(this._g) + hex(this._b);
};
Color.prototype.toColorHex = function () {
	return "" + hex(this._r) + hex(this._g) + hex(this._b);
};
Color.prototype.toString = function () {
	return "#" + hex(_floor(this._a * 255)) + hex(this._r) + hex(this._g) + hex(this._b);
};
Color.prototype.toColorString = function () {
	return "#" + hex(this._r) + hex(this._g) + hex(this._b);
};
Color.areEqual = function (c1, c2) {
	return c1 && c2 && c1._r == c2._r && c1._g == c2._g && c1._b == c2._b && c1._a == c2._a;
};
var $_tempColor = new Color();
var $_tempColors = [new Color(), new Color()];
var Colors = {
	transparent: new Color("#00000000"),
	aqua: new Color("#00ffff"),
	black: new Color("#000000"),
	blue: new Color("#0000ff"),
	fuchsia: new Color("#ff00ff"),
	gray: new Color("#808080"),
	green: new Color("#008000"),
	lime: new Color("#00ff00"),
	maroon: new Color("#800000"),
	navy: new Color("#000080"),
	olive: new Color("#808000"),
	orange: new Color("#ffa500"),
	purple: new Color("#800080"),
	red: new Color("#ff0000"),
	silver: new Color("#c0c0c0"),
	teal: new Color("#008080"),
	white: new Color("#ffffff"),
	yellow: new Color("#ffff00"),
	dimGray: new Color("#696969"),
	ltGray: new Color("#d3d3d3")
};
var StrictColors = {
	transparent: new Color("#00000000"),
	aqua: new Color("#00ffff", true),
	black: new Color("#000000", true),
	blue: new Color("#0000ff", true),
	fuchsia: new Color("#ff00ff", true),
	gray: new Color("#808080", true),
	green: new Color("#008000", true),
	lime: new Color("#00ff00", true),
	maroon: new Color("#800000", true),
	navy: new Color("#000080", true),
	olive: new Color("#808000", true),
	orange: new Color("#ffa500", true),
	purple: new Color("#800080", true),
	red: new Color("#ff0000", true),
	silver: new Color("#c0c0c0", true),
	teal: new Color("#008080", true),
	white: new Color("#ffffff", true),
	yellow: new Color("#ffff00", true),
	dimGray: new Color("#696969", true),
	ltGray: new Color("#d3d3d3", true)
};
var ColorPaletteItem = function (palette, index) {
	this._palette = palette;
	this._index = arguments.length > 1 ? index : -1;
};
ColorPaletteItem.createFrom = function (source, convert) {
	var s = convert ? source.trim().toLowerCase() : source;
	if (s.indexOf("pal(") == 0 && s.charAt(s.length - 1) == ")") {
		s = s.substring(4, s.length - 1);
		if (s.indexOf(",") >= 1) {
			var arr = s.split(",");
			if (arr.length > 1) {
				return new ColorPaletteItem(arr[0], parseInt(arr[1]));
			} else {
				return new ColorPaletteItem(arr[0]);
			}
		} else {
			return new ColorPaletteItem(s);
		}
	}
	return null;
};
ColorPaletteItem.prototype.clone = function () {
	var item = new ColorPaletteItem(this._palette, this._index);
	return item;
};
ColorPaletteItem.prototype.getColor = function () {
	var index = this.getIndex();
	return index >= 0 ? this._palette.getColor(index) : Colors.transparent;
};
ColorPaletteItem.prototype.getIndex = function () {
	var pal = this._palette;
	if (!(pal instanceof ColorPalette)) {
		this._palette = pal = ColorPalette.getPalette(this._palette); 
	}
	if (pal) {
		if (this._index < 0 || this._index >= pal.getCount()) {
			this._index = pal.next();
		}
		return this._index;
	} else {
		return -1;
	}
};
var ColorPalette = function (source) {
	this._colors = [];
	this._next = 0;
	this._parse(source);
};
ColorPalette.register = function (name, palette) {
	if (name) {
		ColorPalette._palettes[name] = palette;
	}
};
ColorPalette.loadPalettes = function (source) {
	if (source) {
		var pals = toArray(source);
		if (pals) {
			for (var i = 0; i < pals.length; i++) {
				var name = pals[i].name;
				var colors = pals[i].colors;
				if (name && colors) {
					var palette = new ColorPalette(colors);
					ColorPalette.register(name, palette);
				}
			}
		}
	}
};
ColorPalette.getPalette = function (name) {
	if (ColorPalette._palettes.hasOwnProperty(name)) {
		return ColorPalette._palettes[name];
	}
	return ColorPalette._palettes["default"];
};
ColorPalette.prototype.getCount = function () {
	return this._colors.length;
};
ColorPalette.prototype.getColors = function () {
	return this._colors.slice();
};
ColorPalette.prototype.next = function () {
	var index = this._next;
	this._next = (this._next + 1) % this._colors.length;
	return index;
};
ColorPalette.prototype.getColor = function (index) {
	return this._colors[index];
};
ColorPalette.prototype._parse = function (source, strict) {
	this._colors = [];
	if (source) {
		var colors = source;
		if (!isArray(colors)) {
			colors = String(source).split(",");
		}
		for (var i = 0, cnt = colors.length; i < cnt; i++) {
			var color = Color.createFrom(colors[i], true);
			this._colors.push(color);
		}
	}
	if (this._colors.length < 1) {
		this._colors.push(Color.createFrom("#00000000"));
	}
};
ColorPalette._palettes = {
	"default": new ColorPalette("#eeeeee")
};
var SolidBrush = function (color) {
	this._color = color instanceof Color ? color : new Color(color);
};
SolidBrush.prototype.color = function () {
	return this._color;
};
SolidBrush.prototype.applyTo = function (g, x, y, w, h) {
	g.setFill(this._color.value());
	return true;
};
SolidBrush.prototype.toText = function () {
	return this._color.toString();
};
SolidBrush.prototype.toColorText = function () {
	return this._color.toColorString();
};
SolidBrush.prototype.css = _norgba ? function () {
	return this._color.toColorString();
} : function () {
	return this._color.value();
};
SolidBrush.prototype.applyToCss = function (css) {
	if (this._color._a < 1) {
		var c = this._color.toString();
		c = "progid:DXImageTransform.Microsoft.gradient(startColorstr=" + c + ",endColorstr=" + c + ")";
		css.filter = c;
		css.background = "";
	} else {
		css.filter = "";
		css.background = this._color.toColorString();
	}
};
SolidBrush.WHITE = new SolidBrush(Colors.white);
SolidBrush.BLACK = new SolidBrush(Colors.black);
SolidBrush.GRAY = new SolidBrush(Colors.gray);
SolidBrush.DKGRAY = new SolidBrush(Colors.dimGray);
SolidBrush.LTGRAY = new SolidBrush(Colors.ltGray);
SolidBrush.RED = new SolidBrush(Colors.red);
SolidBrush.YELLOW = new SolidBrush(Colors.yellow);
SolidBrush.GREEN = new SolidBrush(Colors.green);
SolidBrush.BLUE = new SolidBrush(Colors.blue);
SolidBrush.NULL = {
	applyTo: function (g, x, y, w, h) {
		g.setFill("rgba(0, 0, 0, 0)");
		return true;
	}
};
SolidBrush.Null = SolidBrush.NULL;
SolidBrush.areEqual = function (b1, b2)	 {
	return b1 && b2 && Color.areEqual(b1._color, b2._color);
};
var FillGradient = defineClass(null, null, {
	init: function (source) {
		this._super();
		var s = source ? source.trim().toLowerCase() : null;
		this.parse(s);
	},
	parse: function (source) {
	}
});
FillGradient.createFrom = function (value) {
	if (value) {
		var s = value.trim().toLowerCase();
		if (s.indexOf("linear") == 0) {
			return new LinearGradient(s);
		} else if (s.indexOf("radial") == 0) {
			return new RadialGradient(s);
		} else if (s.indexOf("glass") == 0) {
			return new GlassGradient(s);
		}
	}
	return null;
};
var LinearGradient = defineClass(null, FillGradient, {
	init: function (source) {
		this._super(source);
		this._context = null;
	},
	parse: function (source) {
		this._colors = [];
		this._ratios = [];
		this._angle = 0;
		if (source) {
			var arr = Color.getColorCsvArray(source);
			var cnt = arr.length;
			if (cnt < 2 || arr[0] != "linear") {
				if ($_debug) debugger;
				throw "Invalid linear gradient text";
			}
			var i = 1;
			while (i < cnt) {
				var s = String(arr[i]);
				var color = Color.createFrom(s);
				if (color) {
					this._colors[i - 1] = color;
				} else {
					break;
				}
				i++;
			}
			if (i < cnt) {
				this._angle = parseFloat(arr[i]);
			}
			if (this._colors.length == 1) {
				this._colors[1] = this._colors[0].clone();
			}
			cnt = this._colors.length;
			var inc = 0xff / (cnt - 1);
			var r = 0;
			this._ratios = [0];
			for (i = 1; i < cnt - 1; i++) {
				r += inc;
				this._ratios.push(r / 255.0);
			}
			this._ratios.push(1);
		}
	},
	clone: function () {
		var gradient = new LinearGradient(null);
		gradient._colors = this._colors.slice();
		gradient._ratios = this._ratios.slice();
		gradient._angle = this._angle;
		return gradient;	
	},
	prepare: function (styles) {
		this._context = styles;
	},
	applyTo: function (g, x, y, w, h) {
		var gradient;
		switch (this._angle) {
		case 90:
			gradient = g.createLinearGradient(x, y, x, y + h);
			break;
		case 45:
			gradient = g.createLinearGradient(x, y, x + w, y + h);
			break;
		default:
			gradient = g.createLinearGradient(x, y, x + w, y);
		}
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var v = this._colors[i].value();
			gradient.addColorStop(this._ratios[i], v);
		}
		g.setFill(gradient);
		return true;
	},
	applyToEx: function (g, alpha, brightness, x, y, w, h) {
		var gradient;
		switch (this._angle) {
		case 90:
			gradient = g.createLinearGradient(x, y, x, y + h);
			break;
		case 45:
			gradient = g.createLinearGradient(x, y, x + w, y + h);
			break;
		default:
			gradient = g.createLinearGradient(x, y, x + w, y);
		}
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var v = this._context.getColorValue(this._colors[i], alpha, brightness);
			gradient.addColorStop(this._ratios[i], v);
		}
		g.setFill(gradient);
		return true;
	},
	toText: function () {
		var s = "linear";
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			s += "," + this._colors[i].toString();
		}
		return s + "," + this._angle;
	},
	css: _norgba ? function () {
		return this._colors[0].toColorString();
	} : function () {
		var deg;
		switch (this._angle) {
		case 90:
			deg = 180;
			break;
		case 45:
			deg = 135;
			break;
		default:
			deg = 90;
		}

		var s = "linear-gradient(" + deg +"deg" + "," + this._colors[0].value() + "," + this._colors[1].value() + ")";
		return s;
	},
	applyToCss: function (css) {
		var c1 = this._colors[0].toString();
		var c2 = this._colors[1].toString();
		var c = "progid:DXImageTransform.Microsoft.gradient(startColorstr=" + c1 + ",endColorstr=" + c2 + ")";
		css.filter = c;
		css.background = "";
	}
});
LinearGradient.areEqual = function (g1, g2) {
	var v = g1 && g2;
	if (v) {
		v = g1._colors.length == g2._colors.length;
		if (v) {
			for (var i = 0; i < g1._colors.length; i++) {
				v = Color.areEqual(g1._colors[i], g2._colors[i]);
				if (!v) break;
			}
		}
		if (v) {
			v = g1._ratios.length == g2._ratios.length;
			if (v) {
				for (var i = 0; i < g1._ratios.length; i++) {
					if (g1._ratios[i] != g2._ratios[i]) break;
				}
			}
			if (v) {
				v = g1._angle == g2._angle;
			}
		}
	}
	return v;
};
var RadialGradient = defineClass(null, FillGradient, {
	init: function (source) {
		this._super(source);
	},
	parse: function (source) {
		this._colors = [];
		this._ratios = [];
		if (source) {
			var arr = Color.getColorStringArray(source);
			var cnt = arr.length;
			if (cnt < 2 || arr[0] != "radial") {
				throw "Invalid radial gradient text";
			}
			var i = 1;
			while (i < cnt) {
				var s = String(arr[i]);
				var color = Color.createFrom(s);
				if (color) {
					this._colors[i - 1] = color;
				} else {
					break;
				}
				i++;
			}
			if (i < cnt) {
				this._angle = parseFloat(arr[i]);
			}
			if (this._colors.length == 1) {
				this._colors[1] = this._colors[0].clone();
			}
			cnt = this._colors.length;
			var inc = 0xff / (cnt - 1);
			var r = 0;
			this._ratios = [0];
			for (i = 1; i < cnt - 1; i++) {
				r += inc;
				this._ratios.push(r / 255.0);
			}
			this._ratios.push(1);
		}
	},
	clone: function () {
		var gradient = new RadialGradient(null);
		gradient._colors = this._colors.slice();
		gradient._ratios = this._ratios.slice();
		return gradient;	
	},
	prepare: function (styles) {
	},
	applyTo: function (g, x, y, w, h) {
		var gradient = g.createRadialGradient(x, y, x + w, y + h);
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var v = this._colors[i].value();
			gradient.addColorStop(this._ratios[i], v);
		}
		g.setFill(gradient);
		return true;
	},
	applyToEx: function (g, alpha, brightness, x, y, w, h) {
		var gradient = g.createRadialGradient(x, y, x + w, y + h);
		for (var i = 0, cnt = this._colors.length; i < cnt; i++) {
			var tcolor = $_tempColors[i] || incArray($_tempColors, new Color());
			tcolor.copy(this._colors[i], alpha);
			gradient.addColorStop(this._ratios[i], tcolor.valueWithBrightness(brightness));
		}
		g.setFill(gradient);
		return true;
	}
});
var GlassGradient = defineClass(null, FillGradient, {
	init: function (source) {
		this._super();
	},
	parse: function (source) {
	}
});
var PROP_STYLE 		= "Style";
var PROP_COLOR 		= "Color";
var PROP_ALPHA 		= "Alpha";
var PROP_BRIGHTNESS = "Brightness";
var PROP_WIDTH 		= "Width";
var PROP_GRADIENT 	= "Gradient";
var PROP_IMAGE 		= "Image";
var PROP_BLUR		= "Blur";
var PROP_OFFSET_X	= "OffsetX";
var PROP_OFFSET_Y	= "OffsetY";
var SolidPen = function (color, width, dash) {
	this._color = new Color(color);
	this._width = width !== undefined ? Math.max(0, parseInt(width)) : 1;
	if (dash) this._dash = dash;
};
SolidPen.WHITE = new SolidPen(Colors.white);
SolidPen.BLACK = new SolidPen(Colors.black);
SolidPen.GRAY = new SolidPen(Colors.gray);
SolidPen.DKGRAY = new SolidPen(Colors.dimGray);
SolidPen.LTGRAY = new SolidPen(Colors.ltGray);
SolidPen.RED = new SolidPen(Colors.red);
SolidPen.GREEN = new SolidPen(Colors.green);
SolidPen.BLUE = new SolidPen(Colors.blue);
SolidPen.FOCUS = new SolidPen(Colors.gray, 1, [1,1]);
SolidPen.prototype.applyTo = function (g) {
	g.setStroke(this._color.value(), this._width, this._dash);
	return true;
};
SolidPen.prototype.width = function () {
	return this._width;
};
SolidPen.prototype.getWidth = function () {
	return this._width;
};
SolidPen.prototype.toText = function () {
	return this._color.toString() + "," + this._width + "px";
};
SolidPen.prototype.css = _norgba ? function () {
	return this._width + "px " + "solid " + this._color.toColorString();
} : function () {
	return this._width + "px " + "solid " + this._color.value();
};
SolidPen.areEqual = function (p1, p2) {
	var v = p1 && p2 && Color.areEqual(p1._color, p2._color) && p1._width == p2._width;
	if (v) {
		v = !p1._dash == !p2._dash;
		if (v && p1) {
			for (var i = p1._dash.length; i--;) {
				if (p1._dash[i] != p2._dash[i]) break;
			}
		}
	}
	return v;
};
var requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame ||
                            window.webkitRequestAnimationFrame || window.msRequestAnimationFrame;
window.requestAnimationFrame = requestAnimationFrame || function (render) { setTimeout(render, 10); };
var DEF_FONT_FAMILY = "Tahoma";
var DEF_FONT_SIZE = 12;
var DEF_FONT = DEF_FONT_SIZE + "px " + DEF_FONT_FAMILY;
var Graphics = function (context) {
	var ctx = context;
	!("imageSmoothingEnabled" in ctx) && (ctx.webkitImageSmoothingEnabled = true);
	ctx.mozImageSmoothingEnabled = true;
	ctx.oImageSmoothingEnabled = true;
    ctx.imageSmoothingEnabled = true;
	ctx.setLineDash = ctx.setLineDash || function(){};
    this.LINES_REG = new RegExp('\\n|\\r\\n?');
	this.save = function () {
		ctx.save();
	};
	this.restore = function() {
		ctx.restore();
	};
	this.setCompositionOp = function (op) {
		ctx.globalCompositeOperation = op;
	};
	this.translate = function(dx, dy) {
		ctx.translate(dx, dy);
	};
	this.scale = function (sw, sh) {
		ctx.scale(sw, sh);
	};
	this.rotate = function(angle) {
		ctx.rotate(angle);
	};
	this.clear = function (x, y, w, h) {
		ctx.clearRect(x, y, w, h);
	};
	this.clip = function () {
		ctx.clip();
	};
	this.clipRect = function (r) {
		ctx.beginPath();
		ctx.rect(r.x, r.y, r.width, r.height);
		ctx.clip();
	};
	this.clipRectEx = function (r) {
		ctx.beginPath();
		ctx.rect(r.x, r.y, r.width + 1, r.height + 1);
		ctx.clip();
	};
	this.clipBounds = function (x, y, w, h) {
		ctx.beginPath();
		ctx.rect(x, y, w, h);
		ctx.clip();
	};
	this.clipBoundsEx = function (x, y, w, h) {
		ctx.beginPath();
		ctx.rect(x, y, w + 1, h + 1);
		ctx.clip();
	};
	this.containsPoint = function (x, y) {
		return ctx.isPointInPath(x, y);
	};
	/*
	this.copy = function (x, y, width, height) {
		octx.clearRect(x, y, width, height);
		octx.drawImage(ctx.canvas, x, y, width, height, 0, 0, width, height);
	};
	this.paste = function (x, y, width, height) {
		ctx.drawImage(octx.canvas, 0, 0, width, height, x, y, width, height);
	};
	*/
	this.setAlpha = function (alpha) {
		ctx.globalAlpha = alpha;
	};
	this.setFill = function (fill) {
		ctx.fillStyle = fill;
	};
	this.setStroke = function (stroke, width, dash) {
		ctx.strokeStyle = stroke;
		ctx.lineWidth = width;
		ctx.setLineDash(dash || []);
	};
	this.setShadow = function (color, blur, offset) {
		ctx.shadowColor = color;
		ctx.shadowBlur = blur;
		ctx.shadowOffsetX = ctx.shadowOffsetY = offset;
	};
	this.clearShadow = function () {
		ctx.shadowColor = "transparent";
	};
	this.createLinearGradient = function (x, y, w, h) {
		if (isNaN(w) || isNaN(h)) {
			if ($_debug) debugger;
		}
		return ctx.createLinearGradient(x, y, w, h);
	};
	this.createRadialGradient = function (x, y, w, h) { //, cx, cy) {
		var cx = w / 2;
		var cy = h / 2;
		var rd = Math.min(cx, cy);
		return ctx.createRadialGradient(cx, cy, 0, cx, cy, rd);
	};
	this.drawBounds = function(fill, stroke, x, y, w, h) {
		ctx.beginPath();
		ctx.rect(x, y, w, h);
		if (fill) {
			fill.applyTo(this, x, y, w, h);
			ctx.fill();
		}
		if (stroke) {
			stroke.applyTo(this);
			ctx.stroke();
		}
	};
	this.drawBoundsI = function(fill, stroke, x, y, w, h) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var d = stroked ? (stroke.width() % 2) / 2 : 0;
		x += d;
		y += d;
		ctx.beginPath();
		ctx.rect(x, y, w, h);
		fill && fill.applyTo(this, x, y, w, h) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawRect = function(fill, stroke, r) {
		ctx.beginPath();
		ctx.rect(r.x, r.y, r.width, r.height);
		if (fill) {
			fill.applyTo(this, r.x, r.y, r.width, r.height);
			ctx.fill();
		}
		if (stroke) {
			stroke.applyTo(this);
			ctx.stroke();
		}
	};
	this.drawStrokeRect = function(stroke, r) {
		ctx.beginPath();
		ctx.strokeRect(r.x, r.y, r.width, r.height);
		if (stroke) {
			stroke.applyTo(this);
			ctx.stroke();
		}
	};
	this.fillAndClear = function () {
		ctx.fill();
		ctx.shadowColor = "transparent";
	};
	this.drawRectI = function(fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var d = stroked ? (stroke.width() % 2) / 2 : 0;
		var x = r.x + d;
		var y = r.y + d;
		ctx.beginPath();
		ctx.rect(x, y, r.width, r.height);
		fill && fill.applyTo(this, x, y, r.width, r.height) && this.fillAndClear();
		stroked && ctx.stroke();
	};
	this.drawRoundRectI = function (fill, stroke, r, topLeft, topRight, bottomLeft, bottomRight, edge) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var d = stroked ? (stroke.width() % 2) / 2 : 0;
		var x = r.x + d;
		var y = r.y + d;
		var x2 = r.right() + d + (edge || 0);
		var y2 = r.bottom() + d + (edge || 0);
		ctx.beginPath();
		ctx.moveTo(x + Math.min(topLeft, r.width/2), y);
		ctx.lineTo(x2 - Math.min(topRight, r.width/2), y);
		ctx.quadraticCurveTo(x2, y, x2, y + Math.min(topRight, r.height / 2));
		ctx.lineTo(x2, y2 - Math.min(bottomRight, r.height / 2));
		ctx.quadraticCurveTo(x2, y2, x2 - Math.min(bottomRight, r.width/2), y2);
		ctx.lineTo(x + Math.min(bottomRight,r.width/2), y2);
		ctx.quadraticCurveTo(x, y2, x, y2 - Math.min(bottomRight,r.height/2));
		ctx.lineTo(x, y + Math.min(topLeft, r.height/2));
		ctx.quadraticCurveTo(x, y, x + Math.min(topLeft,r.width/2), y);
		ctx.closePath();
		fill && fill.applyTo(this, x, y, r.width, r.height) && this.fillAndClear();
		stroked && ctx.stroke();
	};
	this.drawRoundRectIWith = function (fill, stroke, r, borders, edge) {
		this.drawRoundRectI(fill, stroke, r, borders.topLeft, borders.topRight,
				borders.bottomLeft, borders.bottomRight, edge);
	};
	this.drawCircle = function (fill, stroke, x, y, radius) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2);
		fill && fill.applyTo(this, x - radius, y - radius, radius * 2, radius * 2) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawCircleBounds = function (fill, stroke, x, y, w, h) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = x + w / 2;
		var cy = y + h / 2;
		var rd = Math.min(w, h) / 2;
		ctx.beginPath();
		ctx.arc(cx, cy, rd, 0, Math.PI * 2);
		fill && fill.applyTo(this, x - rd, y - rd, rd * 2, rd * 2) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawCircleRect = function (fill, stroke, r) {
		this.drawCircleBounds(fill, stroke, r.x, r.y, r.width, r.height);
	};
	this.drawEllipse = function (fill, stroke, x, y, w, h) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var kappa = .5522848,
	      ox = (w / 2) * kappa, // control point offset horizontal
	      oy = (h / 2) * kappa, // control point offset vertical
	      xe = x + w,           // x-end
	      ye = y + h,           // y-end
	      xm = x + w / 2,       // x-middle
	      ym = y + h / 2;       // y-middle
		ctx.beginPath();
		ctx.moveTo(x, ym);
		ctx.bezierCurveTo(x, ym - oy, xm - ox, y, xm, y);
		ctx.bezierCurveTo(xm + ox, y, xe, ym - oy, xe, ym);
		ctx.bezierCurveTo(xe, ym + oy, xm + ox, ye, xm, ye);
		ctx.bezierCurveTo(xm - ox, ye, x, ym + oy, x, ym);
		ctx.closePath();
		fill && fill.applyTo(this, x, y, w, h) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawTriangle = function (fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = r.x + r.width / 2;
		ctx.beginPath();
		ctx.moveTo(cx, r.y);
		ctx.lineTo(r.right(), r.bottom());
		ctx.lineTo(r.x, r.bottom());
		ctx.closePath();
		fill && fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawDiamond = function (fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = r.x + r.width / 2;
		var cy = r.y + r.height / 2;
		ctx.beginPath();
		ctx.moveTo(cx, r.y);
		ctx.lineTo(r.right(), cy);
		ctx.lineTo(cx, r.bottom());
		ctx.lineTo(r.x, cy);
		ctx.closePath();
		fill && fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawCross = function (fill, stroke, r) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		var cx = r.x + r.width / 2;
		var cy = r.y + r.height / 2;
		var w = Math.max(1.5, r.width / 5);
		var h = Math.max(1.5, r.height / 5);
		ctx.beginPath();
		ctx.moveTo(cx - w, r.y);
		ctx.lineTo(cx + w, r.y);
		ctx.lineTo(cx + w, cy - h);
		ctx.lineTo(r.right(), cy - h);
		ctx.lineTo(r.right(), cy + h);
		ctx.lineTo(cx + w, cy + h);
		ctx.lineTo(cx + w, r.bottom());
		ctx.lineTo(cx - w, r.bottom());
		ctx.lineTo(cx - w, cy + h);
		ctx.lineTo(r.x, cy + h);
		ctx.lineTo(r.x, cy - h);
		ctx.lineTo(cx - w, cy - h);
		ctx.closePath();
		fill && fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawDounut = function (fill, stroke, x, y, radius, width) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		ctx.beginPath();
		ctx.arc(x, y, radius, 0, Math.PI * 2, true);
		ctx.arc(x, y, radius - width, 0, Math.PI * 2, false);
		ctx.closePath();
		fill && fill.applyTo(this, x - radius, y - radius, radius * 2, radius * 2) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawArcSector = function (fill, stroke, x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		startAngle += Math.PI * 3 / 2;// orgAngle;
		ctx.beginPath();
		ctx.moveTo(x, y);
		ctx.arc(x, y, radiusX, startAngle, startAngle + angle);
		ctx.lineTo(x, y);
		ctx.closePath();
		fill && fill.applyTo(this, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawArcSector2 = function (fill, stroke, x, y, innerRadiusX, innerRadiusY, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
		var stroked = stroke && stroke.applyTo(this);
		if (!fill && !stroked) return;
		startAngle += Math.PI * 3 / 2;// orgAngle;
		ctx.beginPath();
		ctx.arc(x, y, innerRadiusX, startAngle, startAngle + angle);
		ctx.arc(x, y, radiusX, startAngle + angle, startAngle, true);
		ctx.closePath();
		fill && fill.applyTo(this, x - radiusX, y - radiusY, radiusX * 2, radiusY * 2) && ctx.fill();
		stroked && ctx.stroke();
	};
	this.drawLine = function (stroke, x1, y1, x2, y2) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x1, y1);
			ctx.lineTo(x2, y2);
			ctx.stroke();
		}
	};
	this.drawLineI = function (stroke, x1, y1, x2, y2) {
		if (stroke && stroke.applyTo(this)) {
			var d = (stroke.width() % 2) / 2;
			ctx.beginPath();
			if (x1 == x2) {
				ctx.moveTo(x1 + d, y1);
				ctx.lineTo(x2 + d, y2);
			} else if (y1 == y2) {
				ctx.moveTo(x1, y1 + d);
				ctx.lineTo(x2, y2 + d);
			}
			ctx.stroke();
		}
	};
	this.drawHorzLine = function (stroke, x1, x2, y) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
	};
	this.drawHorzLineI = function (stroke, x1, x2, y) {
		if (stroke && stroke.applyTo(this)) {
			y += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
	};
	this.drawHLine = function (stroke, y, x1, x2) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
	};
	this.drawHLineI = function (stroke, y, x1, x2) {
		if (stroke && stroke.applyTo(this)) {
			y += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x1, y);
			ctx.lineTo(x2, y);
			ctx.stroke();
		}
	};
	this.drawVertLine = function (stroke, y1, y2, x) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
	};
	this.drawVertLineI = function (stroke, y1, y2, x) {
		if (stroke && stroke.applyTo(this)) {
			x += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
	};
	this.drawVLine = function (stroke, x, y1, y2) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
	};
	this.drawVLineI = function (stroke, x, y1, y2) {
		if (stroke && stroke.applyTo(this)) {
			x += (stroke.width() % 2) / 2;
			ctx.beginPath();
			ctx.moveTo(x, y1);
			ctx.lineTo(x, y2);
			ctx.stroke();
		}
	};
	this.drawLines = function (stroke, pts) {
		if (stroke && stroke.applyTo(this)) {
			var rendered = false;
			if (isArray(pts) && pts.length >= 2) {
				ctx.beginPath();
				ctx.moveTo(pts[0].x, pts[0].y);
				for (var i = 1; i < pts.length; i++) {
					ctx.lineTo(pts[i].x, pts[i].y);
				}
				rendered = true;
			} else if (arguments.length >= 5) {
				ctx.beginPath();
				ctx.moveTo(arguments[1], arguments[2]);
				for (var i = 3; i < arguments.length - 1; i += 2) {
					ctx.lineTo(arguments[i], arguments[i + 1]);
				}
				rendered = true;
			}
			if (rendered) {
				ctx.stroke();
			}
		}
	};
	this.drawLinesI = function (stroke, pts) {
		if (stroke && stroke.applyTo(this)) {
			var d = (stroke.width() % 2) / 2;
			var i, len;
			var rendered = false;
			if (isArray(pts) && pts.length >= 2) {
				ctx.beginPath();
                ctx.moveTo(pts[0].x, pts[0].y);
				for (i = 1; i < pts.length; i++) {
					ctx.lineTo(pts[i].x, pts[i].y);
				}
				rendered = true;
			} else if (arguments.length >= 5) {
				var pts2 = [];
				for (i = 1, len = arguments.length; i < len; i++) {
					pts2[i] = arguments[i] + d;
				}
				ctx.beginPath();
				ctx.moveTo(pts2[1], pts2[2]);
				for (i = 3; i < len - 1; i += 2) {
					ctx.lineTo(pts2[i], pts2[i + 1]);
				}
				rendered = true;
			}
			if (rendered) {
				ctx.stroke();
			}
		}
	};
    this.drawLinesArray = function (stroke, pts) {
        if (stroke && pts && pts.length >= 4 && stroke.applyTo(this)) {
            ctx.beginPath();
            ctx.moveTo(pts[0], pts[1]);
            for (var i = 1; i < pts.length / 2; i++) {
                ctx.lineTo(pts[i * 2], pts[i * 2 + 1]);
            }
            ctx.stroke();
        }
    };
    this.drawLinesArrayI = function (stroke, pts) {
        if (stroke && pts && pts.length >= 4 && stroke.applyTo(this)) {
            var d = (stroke.width() % 2) / 2;
            ctx.beginPath();
            ctx.moveTo(pts[0], pts[1]);
            for (var i = 1; i < pts.length / 2; i++) {
                ctx.lineTo(pts[i * 2] + d, pts[i * 2 + 1] + d);
            }
            ctx.stroke();
        }
    };
	this.drawCurve = function (stroke, pts) {
		if (stroke && stroke.applyTo(this)) {
			ctx.beginPath();
			drawCurvedLines(ctx, pts, 0, pts.length - 1);
			ctx.stroke();
		}
	};
	this.drawPolygon = function (fill, stroke, points) {
		var i, cnt, r;
		if (points && (cnt = points.length) > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			ctx.moveTo(points[0].x, points[0].y);
			for (i = 1; i < cnt; i++) {
				ctx.lineTo(points[i].x, points[i].y);
			}
			ctx.closePath();
			if (fill) {
				r = getPointsRect(points);
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
	};
	this.drawPolygonArray = function (fill, stroke, points) {
		var i, cnt, r;
		if (points && (cnt = points.length) > 2) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			ctx.moveTo(points[0], points[1]);
			cnt /= 2;
			for (i = 1; i < cnt; i++) {
				ctx.lineTo(points[i * 2], points[i * 2 + 1]);
			}
			ctx.closePath();
			if (fill) {
				r = getPointArrayRect(points);
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
	};
	this.drawRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			ctx.moveTo(points1[0].x, points1[0].y);
			for (var i = 1, cnt = points1.length; i < cnt; i++) {
				ctx.lineTo(points1[i].x, points1[i].y);
			}
			for (var i = points2.length - 1; i >= 0; i--) {
				ctx.lineTo(points2[i].x, points2[i].y);
			}
			ctx.closePath();
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
	};
	this.drawCurvedRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			drawCurvedLines(ctx, points1, 0, points1.length - 1, true);
			var p = points2[points2.length - 1];
			ctx.lineTo(p.x, p.y);
			drawCurvedLines(ctx, points2, points2.length - 1, 0, false);
			p = points1[0];
			ctx.lineTo(p.x, p.y);
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
	};
	this.drawCurvedStraightRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			drawCurvedLines(ctx, points1, 0, points1.length - 1, true);
			var p = points2[points2.length - 1];
			ctx.lineTo(p.x, p.y);
			for (var i = points2.length - 2; i >= 0; i--) {
				ctx.lineTo(points2[i].x, points2[i].y);
			}
			p = points1[0];
			ctx.lineTo(p.x, p.y);
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
	};
	this.drawStraightCurvedRange = function (fill, stroke, points1, points2) {
		if (points1 && points1.length > 1 && points2 && points2.length > 1) {
			var stroked = stroke && stroke.applyTo(this);
			if (!fill && !stroked) return;
			ctx.beginPath();
			for (var i = 0; i < points1.length; i++) {
				ctx.lineTo(points1[i].x, points1[i].y);
			}
			var p = points2[points2.length - 1];
			ctx.lineTo(p.x, p.y);
			drawCurvedLines(ctx, points2, points2.length - 1, 0, false);
			p = points1[0];
			ctx.lineTo(p.x, p.y);
			if (fill) {
				var r = getPointsRect(points1.concat(points2));
				fill.applyTo(this, r.x, r.y, r.width, r.height) && ctx.fill();
			}
			stroked && ctx.stroke();
		}
	};
	this.drawText = function(font, fill, text, x, y, align, layout) {
		if (fill && fill.applyTo(this)) {
			ctx.beginPath();
			ctx.font = font ? font.font : DEF_FONT;
			ctx.textAlign = (align == TextAlign.CENTER) ? "center" : (align == TextAlign.RIGHT) ? "end" : "start";
			ctx.textBaseline = layout ? layout : "top";
			ctx.fillText(text, x, y);
		}
	};
	this.drawTextRect = function(font, fill, text, r, align, layout) {
		this.drawTextBounds(font, fill, text, r.x, r.y, r.width, r.height, align, layout);
	};
	this.drawTextBounds = function (font, fill, text, x, y, w, h, align, layout) {
		if (text && fill && fill.applyTo(this)) {
			var xSave = x;
			var ySave = y;
			var sz = DEF_FONT_SIZE;
			ctx.beginPath();
			if (font) {
				ctx.font = font.font;
				sz = font.size;
			} else {
				ctx.font = DEF_FONT;
			}
			var ta = "start";
			if (align === TextAlign.CENTER) {
				x += w / 2;
				ta = "center";
			} else if (align === TextAlign.RIGHT) {
				x = x + w;
				ta = "end";
			}
			/*
			switch (layout) {
			case "top":
				break;
			case "bottom":
				y = r.bottom(); 
				break;
			default:
				y += r.height  / 2;
				break;
			}
			y = _floor(y);
			x = _floor(x);
			ctx.textAlign = ta;
			ctx.textBaseline = layout ? layout : "middle";
			ctx.fillText(text, x, y);
			*/
			if (h != sz) {
				switch (layout) {
				case "top":
					break;
				case "bottom":
					y = y + h - sz;
					break;
				case "middle":
				default:
					y += (h - sz) / 2;
					break;
				}
			} 
			y = y + sz / 2;
			ctx.textAlign = ta;
			ctx.textBaseline = "middle";
			ctx.fillText(text, x, y);

			if (font && (font.underline || font.linethrough)) {
				var tx = x, ty = y;
				ctx.beginPath();
				this.setStroke(fill._color.value(), 1)
				w = _int(ctx.measureText(text).width);
				if (align === TextAlign.CENTER) {
					tx -= _int(w / 2);
				} else if (align === TextAlign.RIGHT) {
					tx -= w;
				}
				if (font.underline) {
					ty = _int(y + sz / 2 + 1) + 0.5;
					ctx.moveTo(tx, ty);
					ctx.lineTo(tx + w, ty);
				}
				if (font.linethrough) {
					ctx.moveTo(tx, y);
					ctx.lineTo(tx + w, y);
				}
				ctx.stroke();
			}
			/*
			var t = _getTimer();
			var len = 0;
			for (var i = 0; i < 1000; i++) {
				len += ctx.measureText("text" + i + text).width;
			}
			t = _getTimer() - t;
			_trace(t);
			*/
			/*
			 var t = _getTimer();
			 var len = 0;
			 for (var i = 0; i < 1000; i++) {
			 	len += ("text" + i + text).indexOf("\n");
			 }
			 t = _getTimer() - t;
			 _trace(t);
			debugger;
			 */
		}
	};
    this.getTextRect = function(font, text, x, y, w, h, align, layout, r) {
        if (r) {
            r.width = r.height = 0;
        } else {
            r = new Rectangle();
        }
        if (text) {
            var sz = DEF_FONT_SIZE;
            if (font) {
                ctx.font = font.font;
                sz = font.size;
            } else {
                ctx.font = DEF_FONT;
            }
            r.width = ctx.measureText(text).width;
            r.height = sz;
            r.x = x;
            r.y = y;
            if (align === TextAlign.CENTER) {
                r.x += (w - r.width) / 2;
            } else if (align === TextAlign.RIGHT) {
                r.x += w - r.width;
            }
            switch (layout) {
                case "top":
                    break;
                case "bottom":
                    r.y = r.bottom() - sz;
                    break;
                case "middle":
                default:
                    r.y += (h - sz) / 2;
                    break;
            }
        }
        return r;
    };
	this.drawTextRectExplicit = function(font, fill, text, r, align, layout) {
		this.drawTextBoundsExplicit(font, fill, text, r.x, r.y, r.width, r.height, align, layout);
	};
	this.drawTextBoundsExplicit = function (font, fill, text, x, y, w, h, align, layout) {
		if (!text || !fill) {
			return;
		}
		var wh = w * h, cw, cx, cy;
		if (isNaN(wh) || wh <= 0) {
			return;
		}
		var lines = typeof text == "string" ? text.split(/\n|\r\n?/) : text;
		if (lines.length <= 1) {
			this.drawTextBounds(font, fill, lines[0], x, y, w, h, align, layout);
			return;
		}
        if (fill.applyTo(this)) {
			var hline = DEF_FONT_SIZE;
			ctx.beginPath();
			if (font) {
				ctx.font = font.font;
				hline = font.size;
				if (font.underline) 
					ctx.font = "underline " + ctx.font;
			} else {
				ctx.font = DEF_FONT;
			}
			var hline2 = hline + 1;
			ctx.textBaseline = "middle";
			var i, ta, x2, y2;
			var htotal = hline2 * lines.length;
			var cnt = Math.min(lines.length, Math.ceil(h / hline2));
			if (layout == "top" || htotal >= h) {
			} else {
				switch (layout) {
					case "bottom":
						y = y + h - htotal;
						break;
					case "middle":
					default:
						y += (h - htotal) / 2;
						break;
				}
			}

			for (i = 0; i < cnt; i++) {
				ta = "start";
				if (align === TextAlign.CENTER) {
					x2 = x + w / 2;
					ta = "center";
				} else if (align === TextAlign.RIGHT) {
					x2 = x + w;
					ta = "end";
				} else {
					x2 = x;
				}
				y2 = y + hline2 * i;
				y2 = y2 + hline / 2;
				ctx.textAlign = ta;
	
				// linkable cell hovering
				if (font && (font.underline || font.linethrough)) {
					cw = ctx.measureText(lines[i]).width;
					cx = x2;
					cy = y;
					
					cy = _int(y2 + hline / 2 + 1) + 0.5;
					if (align === TextAlign.CENTER) {
						cx -= _int(cw / 2);
					} else if (align === TextAlign.RIGHT) {
						cx -= cw;
					}
					if (font.underline) {
						ctx.moveTo(cx, cy);
						ctx.lineTo(cx + cw, cy);
					}
					if (font.linethrough) {
						ctx.moveTo(cx, y2);
						ctx.lineTo(cx + cw, y2);
					}
				}

				ctx.fillText(lines[i], x2, y2);
			}
			ctx.stroke();
			
		}
	};
    this.getExplicitTextRect = function (font, text, x, y, w, h, align, layout, r) {
        if (r) {
            r.width = r.height = 0;
        } else {
            r = new Rectangle(x, y, 0, 0);
        }
        if (!text) {
            return r;
        }
        var lines = typeof text == "string" ? text.split(this.LINES_REG) : text;
        if (lines.length == 1) {
            return this.getTextRect(font, lines[0], x, y, w, h, align, layout, r);
        }
        var hline = DEF_FONT_SIZE;
        if (font) {
            ctx.font = font.font;
            hline = font.size;
        } else {
            ctx.font = DEF_FONT;
        }
        var hline2 = hline + 1;
        ctx.textBaseline = "middle";
        var htotal = hline2 * lines.length;
        var cnt = Math.min(lines.length, Math.ceil(h / hline2));
        var i, s, x2, y2, cw;
        if (layout == "top" || htotal >= h) {
        } else {
            switch (layout) {
                case "bottom":
                    y = y + h - htotal;
                    break;
                case "middle":
                default:
                    y += (h - htotal) / 2;
                    break;
            }
        }
        r.y = y;
        r.height = hline2 * cnt;
        for (i = 0; i < cnt; i++) {
            s = lines[i];
            cw = ctx.measureText(s).width;
            if (align === TextAlign.CENTER) {
                x2 = x + (w - cw) / 2;
            } else if (align === TextAlign.RIGHT) {
                x2 = x + w - cw;
            } else {
                x2 = x;
            }
            if (r.width == 0) {
                r.x = x2;
                r.width = cw;
            } else {
                r.setLeft(Math.min(r.x, x2));
                r.setRight(Math.max(r.right(), x2 + cw));
            }
        }
        return r;
    };
	this.drawTextRectWrap = function(font, fill, text, r, align, layout) {
		this.drawTextBoundsWrap(font, fill, text, r.x, r.y, r.width, r.height, align, layout);
	};
	this.drawTextBoundsWrap = function (font, fill, text, x, y, w, h, align, layout) {
		if (!text || !fill) {
			return;
		}
		var wh = w * h;
		if (isNaN(wh) || wh <= 0) {
			return;
		}
		var hline = DEF_FONT_SIZE;
		if (font) {
			ctx.font = font.font;
			hline = font.size;
		} else {
			ctx.font = DEF_FONT;
		}
        var texts = typeof text == "string" ? text.split(this.LINES_REG) : text;
		if (texts.length <= 1 && _int(ctx.measureText(texts[0]).width) <= w) {
			this.drawTextBounds(font, fill, texts[0], x, y, w, h, align, layout);
			return;
		}
		if (fill.applyTo(this)) {
			var i, j, k, words, x2, s, s2, line, w2, ta, y2, cnt;
			var cw, cx, cy;
			var hline2 = hline + 1;
			var nLine = Math.min(texts.length, Math.ceil(h / hline2));
			var lines = [];
			var htotal = 0;
			var first = true;
			for (i = 0; i < nLine && htotal <= h; i++) {
				x2 = 0;
				line = "";
				words = texts[i].split(/(\s+)/);
				for (j = 0; j < words.length && htotal <= h;) {
					s = words[j];
					if (first) {
						first = false;
						s = s.trim();
						if (!s) {
							if ((w2 = ctx.measureText(s).width) > w) {
								htotal += hline2;
								lines.push(s);
							} else {
								line = s;
								x2 = w2;
							}
							s = words[++j];
						}
					}
					if (x2 + (w2 = ctx.measureText(s).width) <= w) {
						line += s === undefined || s === null ? "" : s;
						x2 += w2;
					} else {
						s = s.trim();
						if (s)  {
							if (line) {
								lines.push(line);
								htotal += hline2;
								line = "";
							}
							if (w2 > w) {
								while (s && htotal <= h) {
									for (k = 2; k <= s.length; k++) {
										s2 = s.substr(0, k);
										if (ctx.measureText(s2).width > w) {
											lines.push(s.substr(0, k - 1));
											htotal += hline2;
											s = s.substr(k - 1);
											break;
										}
									}
									if (!s || s.length == 1 || ctx.measureText(s).width <= w) {
										lines.push(s);
										htotal += hline2;
										break;
									}
								}
							} else {
								line = s;
								x2 = w2;
							}
						}
					}
					j++;
				}
				if (line) {
					lines.push(line);
					htotal += hline2;
				}
			}
			cnt = Math.min(lines.length, Math.ceil(h / hline2));
			htotal = lines.length * hline2;
			ctx.beginPath();
			ctx.textBaseline = "middle";
			if (layout == "top" || htotal >= h) {
			} else {
				switch (layout) {
					case "bottom":
						y = y + h - htotal;
						break;
					case "middle":
					default:
						y += (h - htotal) / 2;
						break;
				}
			}
			for (i = 0; i < cnt; i++) {
				ta = "start";
				x2 = x;
				if (align === TextAlign.CENTER) {
					x2 += w / 2;
					ta = "center";
				} else if (align === TextAlign.RIGHT) {
					x2 = x + w;
					ta = "end";
				}
				y2 = y + hline2 * i;
				y2 = y2 + hline / 2;
				ctx.textAlign = ta;

				// linkable cell hovering
				if (font && (font.underline || font.linethrough)) {
					cw = ctx.measureText(lines[i]).width;
					cx = x2;
					cy = y;
					
					cy = _int(y2 + hline / 2 + 1) + 0.5;
					if (align === TextAlign.CENTER) {
						cx -= _int(cw / 2);
					} else if (align === TextAlign.RIGHT) {
						cx -= cw;
					}
					if (font.underline) {
						ctx.moveTo(cx, cy);
						ctx.lineTo(cx + cw, cy);
					}
					if (font.linethrough) {
						ctx.moveTo(cx, y2);
						ctx.lineTo(cx + cw, y2);
					}
				}

				ctx.fillText(lines[i], x2, y2);
			}

			ctx.stroke();
		}
	};
	this.drawTextBoundsEllipse = function (font, fill, text, x, y, w, h, align, layout) {
		var ellipseStr = "..."
		ctx.font = font ? font.font : DEF_FONT;
		var width = ctx.measureText(text).width;
		if (width > w) {
			var ellipseWidth = ctx.measureText(ellipseStr).width;
			if (ellipseWidth > w) {
				this.drawTextBounds(font, fill, ellipseStr, x, y, w, h, align, layout);
			} else {
				var len = text.length;
				while( width >= w - ellipseWidth && len-- > 0) {
					width = ctx.measureText(text = text.substring(0, len)).width;
				}
				text += ellipseStr;
				this.drawTextBounds(font, fill, text, x, y, w, h, align, layout);
			}
		} else {
			this.drawTextBounds(font, fill, text, x, y, w, h, align, layout);
		}
	},
    this.getWrapTextRect = function (font, text, x, y, w, h, align, layout, r) {
        if (r) {
            r.width = r.height = 0;
        } else {
            r = new Rectangle(x, y, 0, 0);
        }
        if (!text) {
            return r;
        }
        var hline = DEF_FONT_SIZE;
        if (font) {
            ctx.font = font.font;
            hline = font.size;
        } else {
            ctx.font = DEF_FONT;
        }
        var texts = typeof text == "string" ? text.split(/\n|\r\n?/) : text;
        if (texts.length == 1 && ctx.measureText(texts[0]).width <= w) {
            return this.getTextRect(font, texts[0], x, y, w, h, align, layout, r);
        }
        var hline2 = hline + 1;
        var nLine = Math.min(texts.length, Math.ceil(h / hline2));
        var lines = [];
        var htotal = 0;
        var first = true;
        var i, j, k, words, x2, s, s2, line, w2, y2, cnt;
        for (i = 0; i < nLine && htotal <= h; i++) {
            x2 = 0;
            line = "";
            words = texts[i].split(/(\s+)/);
            for (j = 0; j < words.length && htotal <= h;) {
                s = words[j];
                if (first) {
                    first = false;
                    s = s.trim();
                    if (!s) {
                        if ((w2 = ctx.measureText(s).width) > w) {
                            htotal += hline2;
                            lines.push(s);
                        } else {
                            line = s;
                            x2 = w2;
                        }
                        s = words[++j];
                    }
                }
                if (x2 + (w2 = ctx.measureText(s).width) <= w) {
                    line += s;
                    x2 += w2;
                } else {
                    s = s.trim();
                    if (s)  {
                        if (line) {
                            lines.push(line);
                            htotal += hline2;
                            line = "";
                        }
                        if (w2 > w) {
                            while (s && htotal <= h) {
                                for (k = 2; k <= s.length; k++) {
                                    s2 = s.substr(0, k);
                                    if ((w2 = ctx.measureText(s2).width) > w) {
                                        lines.push(s.substr(0, k - 1));
                                        htotal += hline2;
                                        s = s.substr(k - 1);
                                        break;
                                    }
                                }
                                if (!s || s.length == 1 || (w2 = ctx.measureText(s).width) <= w) {
                                    lines.push(s);
                                    htotal += hline2;
                                    break;
                                }
                            }
                        } else {
                            line = s;
                            x2 = w2;
                        }
                    }
                }
                j++;
            }
            if (line) {
                lines.push(line);
                htotal += hline2;
            }
        }
        cnt = Math.min(lines.length, Math.ceil(h / hline2));
        htotal = lines.length * hline2;
        if (layout == "top" || htotal >= h) {
        } else {
            switch (layout) {
                case "bottom":
                    y = y + h - htotal;
                    break;
                case "middle":
                default:
                    y += (h - htotal) / 2;
                    break;
            }
        }
        r.y = y;
        r.height = htotal;
        for (i = 0; i < cnt; i++) {
            var cw = ctx.measureText(lines[i]).width;
            if (align === TextAlign.CENTER) {
                x2 = x + (w - cw) / 2;
            } else if (align === TextAlign.RIGHT) {
                x2 = x + w - cw;
            } else {
                x2 = x;
            }
            if (r.width == 0) {
                r.x = x2;
                r.width = cw;
            } else {
                r.setLeft(Math.min(r.x, x2));
                r.setRight(Math.max(r.right(), x2 + cw));
            }
        }
        return r;
    };
	this.drawTextRectA = function(font, fill, text, r, angle) {
		this.drawTextBoundsA(font, fill, text, r.x, r.y, r.width, r.height, angle);
	};
	this.drawTextBoundsA = function(font, fill, text, x, y, w, h, angle) {
		if (fill && fill.applyTo(this)) {
			ctx.beginPath();
			if (font) {
				ctx.font = font.font;
			} else {
				ctx.font = DEF_FONT;
			}
			ctx.save();
			ctx.translate(x + w / 2, y + h / 2);
			ctx.rotate(angle);
			ctx.textAlign = "center";
			ctx.textBaseline = "middle";
			ctx.fillText(text, 0, 0); // (0, 0)에서 그리도록 해야한다!
			ctx.restore();
		}
	};
	this.getTextWidth = function (font, text) {
		if (text) {
			ctx.font = font ? font.font : DEF_FONT;
			return ctx.measureText(text).width;
		}
		return 0;
	};
    this.getLinesWidth = function (font, text) {
        ctx.font = font ? font.font : DEF_FONT;
        var texts = text.split(/\n|\r\n?/);
        var len = texts.length;
        if (len <= 1) {
            return ctx.measureText(text).width;
        } else {
            var w = ctx.measureText(texts[0]).width;
            for (var i = 1; i < len; i++) {
                w = Math.max(ctx.measureText(texts[0]).width);
            }
            return w;
        }
    };
	this.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
		try {
			ctx.drawImage.apply(ctx, arguments);
		} catch (err) {
		}
	};
    this.drawImageI = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
        arguments[1] = Math.floor(arguments[1]);
        arguments[2] = Math.floor(arguments[2]);
        try {
            ctx.drawImage.apply(ctx, arguments);
        } catch (err) {
        }
    };
	this.aL = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
		try {
			ctx.drawImage.apply(ctx, arguments);
		} catch (err) {
		}
	};
};
function getPointsRect(pts) {
	var x1 = pts[0].x;
	var y1 = pts[0].y;
	var x2 = x1;
	var y2 = y1;
	for (var i = 1, cnt = pts.length; i < cnt; i++) {
		var p = pts[i];
		x1 = Math.min(x1, p.x);
		y1 = Math.min(y1, p.y);
		x2 = Math.max(x2, p.y);
		y2 = Math.max(y2, p.y);
	}
	return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
}
function getPointArrayRect(pts) {
	var i, x, y;
	var cnt = pts.length / 2;
	var x1 = pts[0];
	var y1 = pts[1];
	var x2 = x1;
	var y2 = y1;
	for (i = 1; i < cnt; i++) {
		x = pts[i * 2];
		y = pts[i * 2 + 1];
		x1 = Math.min(x1, x);
		y1 = Math.min(y1, y);
		x2 = Math.max(x2, x);
		y2 = Math.max(y2, y);
	}
	return { x: x1, y: y1, width: x2 - x1, height: y2 - y1 };
}
function drawCurvedLines(ctx, pts, start, end, moving) {
	if (start == end) return;
	var reverse = start > end;
	var delta = reverse ? -1 : 1;
	var p = start;
	if (moving || moving === undefined) {
		ctx.moveTo(pts[p].x, pts[p].y);
	}
	if (Math.abs(end - start) == 2) {
		ctx.lineTo(pts[p + delta].x, pts[p + delta].y);
		return;
	}
	var tension = 0.25;
	var tanLeft = { x: 0, y: 0 };
	var tanRight = { x: 0, y: 0 };
	var v1 = { x: 0, y: 0 };
	var v2 = { x: pts[p + delta].x - pts[p].x, y: pts[p + delta].y - pts[p].y };
	var tan = { x: 0, y: 0 };
	var p1 = { x: 0, y: 0 };
	var p2 = { x: 0, y: 0 };
	var mp = { x: 0, y: 0 };
	var len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
	v2.x /= len;
	v2.y /= len;
	var tanLenFactor = pts[p + delta].x - pts[p].x;
	var prevX = pts[p].x;
	var prevY = pts[p].y;
	for (p += delta; p != end; p += delta) {
		v1.x = -v2.x;
		v1.y = -v2.y;
		v2.x = pts[p + delta].x - pts[p].x;
		v2.y = pts[p + delta].y - pts[p].y;
		len = Math.sqrt(v2.x * v2.x + v2.y * v2.y);
		v2.x /= len;
		v2.y /= len;
		if (v2.x < v1.x) {
			tan.x = v1.x - v2.x;
			tan.y = v1.y - v2.y;
		} else {
			tan.x = v2.x - v1.x;
			tan.y = v2.y - v1.y;
		}
		var tanlen = Math.sqrt(tan.x * tan.x + tan.y * tan.y);
		tan.x /= tanlen;
		tan.y /= tanlen;
		if (v1.y * v2.y >= 0)
			tan = { x: 1, y: 0 };
		tanLeft.x = -tan.x * tanLenFactor * tension;
		tanLeft.y = -tan.y * tanLenFactor * tension;
		if (p == (delta + start)) {
			ctx.quadraticCurveTo(pts[p].x + tanLeft.x, pts[p].y + tanLeft.y, pts[p].x, pts[p].y);
		} else {
			p1.x = prevX + tanRight.x;
			p1.y = prevY + tanRight.y;
			p2.x = pts[p].x + tanLeft.x;
			p2.y = pts[p].y + tanLeft.y;
			mp.x = (p1.x + p2.x) / 2;
			mp.y = (p1.y + p2.y) / 2;
			ctx.quadraticCurveTo(p1.x, p1.y, mp.x, mp.y);
			ctx.quadraticCurveTo(p2.x, p2.y, pts[p].x, pts[p].y);
		}
		tanLenFactor = pts[p + delta].x - pts[p].x;
		tanRight.x = tan.x * tanLenFactor * tension;
		tanRight.y = tan.y * tanLenFactor * tension;
		prevX = pts[p].x;
		prevY = pts[p].y;
	}		
	ctx.quadraticCurveTo(prevX + tanRight.x, prevY + tanRight.y, pts[p].x, pts[p].y);
};
Graphics.getEllipsePoint = function (x, y, radiusX, radiusY, angle, orgAngle, clockwise) {
	angle = angle + orgAngle;
	var dir = clockwise ? -1 : 1;
	var p = {};
	p.x = x + Math.cos(angle * dir) * radiusX;
	p.y = y + Math.sin(-angle * dir) * radiusY;
	return p;
};
Graphics.getArcPoint = function (x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise, rate) {
	if (Math.abs(angle) > 2 * Math.PI) {
		angle = 2 * Math.PI;
	}
	if (rate === UNDEFINED) {
		rate = 0.5;
	}
	startAngle += Math.PI * 3 / 2;// orgAngle;
	var dir = clockwise ? -1 : 1;
	angle = startAngle - angle * dir * rate;
	var p = {};
	p.x = x + Math.cos(angle * dir) * radiusX;
	p.y = y + Math.sin(-angle * dir) * radiusY;
	return p;
};
var Drawings = function () {
	var _g = null;
	var _funcs = [];
	var _args = [];
	this._render = function () {
		for (var i = 0, cnt = _funcs.length; i < cnt; i++) {
			_funcs[i].apply(_g, _args[i]);
		}
	};
	this.clear = function (graphics) {
		_g = graphics;
		_funcs = [];
		_args = [];
	};
	this.clipRect = function (r) {
		_funcs.push(_g.clipBounds);
		_args.push([r.x, r.y, r.width, r.height]);
	};
	this.clipRectEx = function (r) {
		_funcs.push(_g.clipBoundsEx);
		_args.push([r.x, r.y, r.width, r.height]);
	};
	this.setAlpha = function (alpha) {
		_funcs.push(_g.setAlpha);
		_args.push([alpha]);
	};
	this.drawBounds = function (fill, stroke, x, y, w, h) {
		_funcs.push(_g.drawBounds);
		_args.push([fill, stroke, x, y, w, h]);
	};
	this.drawBoundsI = function (fill, stroke, x, y, w, h) {
		_funcs.push(_g.drawBoundsI);
		_args.push([fill, stroke, x, y, w, h]);
	};
	this.drawRect = function (fill, stroke, r) {
		_funcs.push(_g.drawBounds);
		_args.push([fill, stroke, r.x, r.y, r.width, r.height]);
	};
	this.drawStrokeRect = function (stroke, r) {
		_funcs.push(_g.drawStrokeRect);
		_args.push([stroke, r.x, r.y, r.width, r.height]);
	};
	this.drawRectI = function (fill, stroke, r) {
		_funcs.push(_g.drawBoundsI);
		_args.push([fill, stroke, r.x, r.y, r.width, r.height]);
	};
	this.drawRoundRectI = function (fill, stroke, r, topLeft, topRight, bottomLeft, bottomRight, edge) {
		_funcs.push(_g.drawRoundRectI);
		_args.push([fill, stroke, r.clone(), topLeft, topRight, bottomLeft, bottomRight, edge]);
	};
	this.drawRoundRectIWith = function (fill, stroke, r, borders, edge) {
		_funcs.push(_g.drawRoundRectIWith);
		_args.push([fill, stroke, r.clone(), borders, edge]);
	};
	this.drawCircle = function (fill, stroke, x, y, radius) {
		_funcs.push(_g.drawCircle);
		_args.push([fill, stroke, x, y, radius]);
	};
	this.drawEllipse = function (fill, stroke, x, y, w, h) {
		_funcs.push(_g.drawEllipse);
		_args.push([fill, stroke, x, y, w, h]);
	};
	this.drawCircleRect = function (fill, stroke, r) {
		_funcs.push(_g.drawCircleRect);
		_args.push([fill, stroke, r.clone()]);
	};
	this.drawTriangle = function (fill, stroke, r) {
		_funcs.push(_g.drawTriangle);
		_args.push([fill, stroke, r.clone()]);
	};
	this.drawDiamond = function (fill, stroke, r) {
		_funcs.push(_g.drawDiamond);
		_args.push([fill, stroke, r.clone()]);
	};
	this.drawArcSector = function (fill, stroke, x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
		_funcs.push(_g.drawArcSector);
		_args.push([fill, stroke, x, y, radiusX, radiusY, startAngle, angle, orgAngle, clockwise]);
	};
	this.drawArcSector2 = function (fill, stroke, x, y, innerRadiusX, innerRadiusY, radiusX, radiusY, startAngle, angle, orgAngle, clockwise) {
		_funcs.push(_g.drawArcSector2);
		_args.push([fill, stroke, x, y, innerRadiusX, innerRadiusY, radiusX, radiusY, startAngle, angle, orgAngle, clockwise]);
	};
	this.drawLine = function (stroke, x1, y1, x2, y2) {
		_funcs.push(_g.drawLine);
		_args.push([stroke, x1, y1, x2, y2]);
	};
	this.drawLineI = function (stroke, x1, y1, x2, y2) {
		_funcs.push(_g.drawLineI);
		_args.push([stroke, x1, y1, x2, y2]);
	};
	this.drawHorzLine = function (stroke, x1, x2, y) {
		_funcs.push(_g.drawHorzLine);
		_args.push([stroke, x1, x2, y]);
	};
	this.drawHorzLineI = function (stroke, x1, x2, y) {
		_funcs.push(_g.drawHorzLineI);
		_args.push([stroke, x1, x2, y]);
	};
	this.drawVertLine = function (stroke, y1, y2, x) {
		_funcs.push(_g.drawVertLine);
		_args.push([stroke, y1, y2, x]);
	};
	this.drawVertLineI = function (stroke, y1, y2, x) {
		_funcs.push(_g.drawVertLineI);
		_args.push([stroke, y1, y2, x]);
	};
	this.drawLines = function (stroke, pts) {
		_funcs.push(_g.drawLines);
		_args.push([stroke, pts]);
	};
	this.drawLinesI = function (stroke, pts) {
		_funcs.push(_g.drawLinesI);
		_args.push([stroke, pts]);
	};
	this.drawCurve = function (stroke, pts) {
		_funcs.push(_g.drawCurve);
		_args.push([stroke, pts]);
	};
	this.drawPolygon = function (fill, stroke, points) {
		_funcs.push(_g.drawPolygon);
		_args.push([fill, stroke, points]);
	};
	this.drawPolygonArray = function (fill, stroke, points) {
		_funcs.push(_g.drawPolygonArray);
		_args.push([fill, stroke, points]);
	};
	this.drawText = function(font, fill, text, x, y, align, layout) {
		_funcs.push(_g.drawText);
		_args.push([font, fill, text, x, y, align, layout]);
	};
	this.drawTextBounds = function (font, fill, text, x, y, w, h, align, layout) {
		_funcs.push(_g.drawTextBounds);
		_args.push([font, fill, text, x, y, w, h, align, layout]);
	};
	this.drawTextRect = function(font, fill, text, r, align, layout) {
		_funcs.push(_g.drawTextBounds);
		_args.push([font, fill, text, r.x, r.y, r.width, r.height, align, layout]);
	};
	this.drawTextRectA = function(font, fill, text, r, angle) {
		_funcs.push(_g.drawTextBoundsA);
		_args.push([font, fill, text, r.x, r.y, r.width, r.height, angle]);
	};
	this.drawImage = function (image, sx, sy, sw, sh, dx, dy, dw, dh) {
		_funcs.push(_g.drawImage);
		_args.push([image, sx, sy, sw, sh, dx, dy, dw, dh]);
	};
	this.getTextWidth = function (font, text) {
		return _graphics.gtTextWidth(font, text);
	};
};
var ShapeDrawing = defineClass("ShapeCellRenderer", null, {
	init: function() {
		this._super();
	},
	draw: function (g, r, fill, stroke) {
		if (fill || stroke) {
			this._doDraw(g, r, fill, stroke);
		}
	},
	_doDraw: function (g, r, fill, stroke) {
	}
});
var PolygonShape = defineClass("PolygonShape", ShapeDrawing, {
	init: function(shape) {
		this._super();
		this.setShape(shape);
	},
	shape: null,
	setShape: function (value) {
		this._shape = value ? (value === "inverted_triangle" ? PolygonShape.INVERTED_TRIANLGE : value.toLowerCase()) : null;
	},
	_doDraw: function (g, r, fill, stroke) {
		var pts, points, i, cnt,
			shape = this._shape;
		if ($$_polygonShapes.hasOwnProperty(shape)) {
		 	pts = $$_polygonShapes[shape];
			if (pts) {
				pts = pts.slice();
				for (i = 0, cnt = pts.length / 2; i < cnt; i++) {
					pts[i * 2] = r.x + pts[i * 2] * r.width;
					pts[i * 2 + 1] = r.y + pts[i * 2 + 1] * r.height;
				}
				pts.push(pts[0], pts[1]);
				g.drawPolygonArray(fill, stroke, pts);
			}
		} else if ($$_pairShapes.hasOwnProperty(shape)) {
			points = $$_pairShapes[shape];
			if (points) {
				pts = points[0];
				pts = pts.slice();
				for (i = 0, cnt = pts.length / 2; i < cnt; i++) {
					pts[i * 2] = r.x + pts[i * 2] * r.width;
					pts[i * 2 + 1] = r.y + pts[i * 2 + 1] * r.height;
				}
				pts.push(pts[0], pts[1]);
				g.drawPolygonArray(fill, stroke, pts);
				pts = points[1];
				pts = pts.slice();
				for (i = 0, cnt = pts.length / 2; i < cnt; i++) {
					pts[i * 2] = r.x + pts[i * 2] * r.width;
					pts[i * 2 + 1] = r.y + pts[i * 2 + 1] * r.height;
				}
				pts.push(pts[0], pts[1]);
				g.drawPolygonArray(fill, stroke, pts);
			}
		}
	}
});
PolygonShape.RECTANGLE = "rectangle";
PolygonShape.TRIANLGE = "triangle";
PolygonShape.INVERTED_TRIANLGE = "itriangle";
PolygonShape.DIAMOND = "diamond";
PolygonShape.UP_ARROW = "uparrow";
PolygonShape.DOWN_ARROW = "downarrow";
PolygonShape.LEFT_ARROW = "leftarrow";
PolygonShape.RIGHT_ARROW = "rightarrow";
PolygonShape.PLUS = "plus";
PolygonShape.MINUS = "minus";
PolygonShape.EQUAL = "equal";
PolygonShape.STAR = "star";
var $$_polygonShapes = {
	rectangle: [0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0],
	triangle: [0.5, 0.0, 0.0, 1.0, 1.0, 1.0],
	itriangle: [0.0, 0.0, 0.5, 1.0, 1.0, 0.0],
	diamond: [0.5, 0.0, 0.0, 0.5, 0.5, 1.0, 1.0, 0.5],
	uparrow: [0.5, 0.0, 0.0, 0.5, 0.3, 0.5, 0.3, 1.0, 0.7, 1.0, 0.7, 0.5, 1.0, 0.5],
	downarrow: [0.3, 0.0, 0.3, 0.5, 0.0, 0.5, 0.5, 1.0, 1.0, 0.5, 0.7, 0.5, 0.7, 0.0],
	leftarrow: [0.0, 0.5, 0.5, 1.0, 0.5, 0.7, 1.0, 0.7, 1.0, 0.3, 0.5, 0.3, 0.5, 0.0],
	rightarrow: [0.0, 0.3, 0.0, 0.7, 0.5, 0.7, 0.5, 1.0, 1.0, 0.5, 0.5, 0.0, 0.5, 0.3],
	plus: [0.3, 0.0, 0.3, 0.3, 0.0, 0.3, 0.0, 0.7, 0.3, 0.7, 0.3, 1.0, 0.7, 1.0, 0.7, 0.7, 1.0, 0.7, 1.0, 0.3, 0.7, 0.3, 0.7, 0.0],
	minus: [0.0, 0.3, 0.0, 0.7, 1.0, 0.7, 1.0, 0.3],
	/*for (var i = 0; i <= 2 * 5; ++i) {
        var a = i * Math.PI / 5 - Math.PI / 2;
        var r = i % 2 == 0 ? 0.5 : 0.191;
        context.lineTo(0.5 + r * Math.cos(a), 0.5 + r * Math.sin(a));
    }*/
	star: [0.5, 0, 0.6122, 0.3454, 0.9755, 0.3454, 0.6816, 0.5590, 0.7938, 0.9045, 0.5, 0.6910, 0.2061, 0.9045, 0.3183, 0.5590, 0.02447, 0.3454, 0.3877, 0.3454]
};
var $$_pairShapes = {
	equal: [[0.0, 0.2, 0.0, 0.4, 1.0, 0.4, 1.0, 0.2], [0.0, 0.6, 0.0, 0.8, 1.0, 0.8, 1.0, 0.6]]
};
var EllipseShape = defineClass("EllipseShape", ShapeDrawing, {
	init: function(shape) {
		this._super();
	},
	_doDraw: function (g, r, fill, stroke) {
		g.drawEllipse(fill, stroke, r.x , r.y, r.width, r.height);
	}
});
var NullShape = defineClass("NullShape", ShapeDrawing, {
	init: function() {
		this._super();
	},
	destroy: function() {
		return false; //
	},
	_doDraw: function (g, r, fill, stroke) {
	}
}, null, function (f) {
	f.Default = new f();
});
var ShadowDom = defineClass("ShadowDom", null, {
	init: function (container, options) {
		this._container = container;
		this._canvas = container._canvas;

		/* internal variables init */
		this._dataProvider = null;
		this._itemProvider = null;
		this._columns = [];
		this._colCount = 0;
		this._buttons = [];
		this._checkboxes = [];
		this._colTitles = [];
		this._editing = false;
		this._editElement = null;
		this._rows = 0;
		this._internalSet = false;

		this._numberFormatter = new DecimalFormatter();
		this._datetimeWriter = new DateTimeWriter();
		this._booleanFormatter = new BooleanFormatter();
		this._numberFormat = null;
		this._datetimeFormat = null;
		this._booleanFormat = null;

		/* table create */
        this._table = document.createElement("table");
        this._caption = document.createElement("caption");
        this._table.appendChild(this._caption);
        this._head = document.createElement("thead");
        this._table.appendChild(this._head);
		this._body = document.createElement("tbody");
        this._table.appendChild(this._body);

		var foot = document.createElement("tfoot");
		var frow =  document.createElement("tr");
		var fcell = document.createElement("td");
		this._prevButton = this.$_addButton(fcell, "prev page", this.$_prevButtonHandler);
		this._nextButton = this.$_addButton(fcell, "next page", this.$_nextButtonHandler);
		frow.appendChild(fcell);
		foot.appendChild(frow);
        this._table.appendChild(foot);

        this._containerDiv = this._canvas;
        
        if ($_debug) {
			this._containerDiv = container._containerDiv;
        }
		this._containerDiv.appendChild(this._table);
		
		this._start = 0;

		/* options init & assign */
		this._initOptions();
		this.assignOptions(options);

		/* popup editor */
		this._editor = new ShadowEditor(container, container._containerDiv, this._editorOptions);

		var self = this;
		this._editor.setBeforeCallback(function (index) {
			if (self._editing) {
				alert(self._aleadyEditMessage);
				self._editor.focusEditor();
				return false;
			} else {
				self._editing = true;
				self._options && self._options.beforeEditPopupCallback && self._options.beforeEditPopupCallback(index);
				return true;
			}
		});
		this._editor.setAfterCallback(function (index) {
			self._options && self._options.afterEditPopupCallback && self._options.afterEditPopupCallback(index);
			self._editing = false;
		});
		this._editor.setEditorCommited(function (index, value) {
			self.$_editorCommitedHandler(index, value);
		});
	},
	destroy: function () {
		this.$_clearBody();
		this._container.$_removeListener(this._prevButton, "click");
		this._container.$_removeListener(this._nextButton, "click");
		this._editor.destroy();
		this._table.parentNode && this._table.parentNode.removeChild(this._table);

		this._numberFormatter.destroy();
		delete this._numberFormatter;
		delete this._datetimeWriter;
		this._booleanFormatter.destroy();
		delete this._booleanFormatter;	
		this._columns = [];

		this._dataProvider = null;
		this._itemProvider = null;

		this._canvas = null;
		this._containerDiv = null;
		this._container = null;
	},
	indicatorVisible: true,
	checkBarVisible: true,
	stateBarVisible: true,
	start: 0,
	count: 20,
	title: null,
	description: null,
	indicatorTitle: null,
	checkBarTitle: null,
	stateBarTitle: null,
	emptyMessage: null,
	editButtonText: null,
	cellButtonTexts: null,
	stateTexts: null,
	rowText: null,
	linkText: null,
	_initOptions: function () {
		this._count = 10;

		this._autoDrawing = true;
		this._indicatorVisible = true;
		this._checkBarVisible = true;
		this._stateBarVisible = true;

		var hasConst = window.RG_CONST && window.RG_CONST.SHADOW;
		this._title             = hasConst && window.RG_CONST.SHADOW.TITLE               || "리얼그리드 테이블 (테이블에서 엔터키로 버튼 링크등의 기능이 실행됩니다)";
		this._description       = hasConst && window.RG_CONST.SHADOW.DESCRIPTION         || "${columns} 열로 이루어진 데이터 테이블입니다.";
		this._indicatorTitle    = hasConst && window.RG_CONST.SHADOW.INDICATOR_TITLE     || "순번";
		this._checkBarTitle     = hasConst && window.RG_CONST.SHADOW.CHECK_BAR_TITLE     || "선택";
		this._stateBarTitle     = hasConst && window.RG_CONST.SHADOW.STATE_BAR_TITLE     || "행 상태";
		this._emptyMessage      = hasConst && window.RG_CONST.SHADOW.EMPTY_MESSAGE       || "데이터가 존재하지 않습니다.";
		this._editButtonText    = hasConst && window.RG_CONST.SHADOW.EDIT_BUTTON_TEXT    || "편집";
		this._cellButtonTexts   = hasConst && window.RG_CONST.SHADOW.CELL_BUTTON_TEXTS   || {action:"실행", popup:"팝업"};
		this._stateTexts        = hasConst && window.RG_CONST.SHADOW.STATE_TEXTS         || {created:"추가", updated:"수정", deleted:"삭제", createAndDeleted: "추가 후 삭제"};
		this._rowText           = hasConst && window.RG_CONST.SHADOW.ROW_TEXT            || "${index} 행";
		this._linkText          = hasConst && window.RG_CONST.SHADOW.LINK_TEXT           || "링크";
		this._summaryText       = hasConst && window.RG_CONST.SHADOW.SUMMARY_TEXT        || "합계 행";
		this._groupSummaryText  = hasConst && window.RG_CONST.SHADOW.GROUP_SUMMARY_TEXT  || "${groupText} 부분 합계 행";
		this._aleadyEditMessage = hasConst && window.RG_CONST.SHADOW.ALEADY_EDIT_MESSAGE || "이미 편집중입니다.";
		this._insertButtonText  = hasConst && window.RG_CONST.SHADOW.INSERT_BUTTON_TEXT  || "행 삽입";
		this._appendButtonText  = hasConst && window.RG_CONST.SHADOW.APPEND_BUTTON_TEXT  || "행 추가";
		this._deleteButtonText  = hasConst && window.RG_CONST.SHADOW.DELETE_BUTTON_TEXT  || "행 삭제";

		hasConst = hasConst && window.RG_CONST.SHADOW.EDITOR;
		this._editorOptions = {
			yearText         : hasConst && window.RG_CONST.SHADOW.EDITOR.YEAR_TEXT          || "년도",
			monthText        : hasConst && window.RG_CONST.SHADOW.EDITOR.MONTH_TEXT         || "월",
			dayText          : hasConst && window.RG_CONST.SHADOW.EDITOR.DAY_TEXT           || "일자",
			ampmText         : hasConst && window.RG_CONST.SHADOW.EDITOR.AMPM_TEXT          || "오전/오후",
			amText           : hasConst && window.RG_CONST.SHADOW.EDITOR.AM_TEXT            || "오전",
			pmText           : hasConst && window.RG_CONST.SHADOW.EDITOR.PM_TEXT            || "오후",
			hourText         : hasConst && window.RG_CONST.SHADOW.EDITOR.HOUR_TEXT          || "시",
			minuteText       : hasConst && window.RG_CONST.SHADOW.EDITOR.MINUTE_TEXT        || "분",
			secondText       : hasConst && window.RG_CONST.SHADOW.EDITOR.SECOND_TEXT        || "초",
			validationMessage: hasConst && window.RG_CONST.SHADOW.EDITOR.VALIDATION_MESSAGE || "잘못된 입력입니다."
		};
	},
	assignOptions: function (options) {
		if (options) {
			options.count && (this._count = 10);
			options.indicatorVisible != undefined && (this._indicatorVisible = options.indicatorVisible);
			options.checkBarVisible != undefined && (this._checkBarVisible = options.checkBarVisible);
			options.stateBarVisible != undefined && (this._stateBarVisible = options.stateBarVisible);
			options.autoDrawing != undefined && (this._autoDrawing = options.autoDrawing);
			options.title && (this._title = options.title);
			options.description && (this._description = options.description);
			options.count && (this._count = options.count);
			options.indicatorTitle && (this._indicatorTitle = options.indicatorTitle);
			options.checkBarTitle && (this._checkBarTitle = options.checkBarTitle);
			options.stateBarTitle && (this._stateBarTitle = options.stateBarTitle);
			options.emptyMessage && (this._emptyMessage = options.emptyMessage);
			options.editButtonText && (this._editButtonText = options.editButtonText);
			options.cellButtonTexts && (this._cellButtonTexts = _clone(options.cellButtonTexts));
			options.stateTexts && (this._stateTexts = _clone(options.stateTexts));
			options.rowText && (this._rowText = options.rowText);
			options.linkText && (this._linkText = options.linkText);
			options.aleadyEditMessage && (this._aleadyEditMessage = options.aleadyEditMessage);
			options.summaryText && (this._summaryText = options.summaryText);
			options.groupSummaryText && (this._groupSummaryText = options.groupSummaryText);
			options.insertButtonText && (this._insertButtonText = options.insertButtonText);
			options.appendButtonText && (this._appendButtonText = options.appendButtonText);
			options.deleteButtonText && (this._deleteButtonText = options.deleteButtonText);
			
			if (options.editor) {
				for (var p in options.editor) {
					this._editorOptions[p] = options.editor[p];
				}
			}
		}
	},
	setColumns: function (grid, columns) {
		this._grid = grid;

		this._columns = [];
		this._fields = [];
		this._editables = [];
		for (var i = 0, cols = columns.length; i < cols; i++) {
			var column = columns[i];
			if (column instanceof DataColumn) {
				this._columns.push(column);
			}
		}
		if (this._autoDrawing && this._itemProvider) {
			this.reset();
		}
	},
	setItemProvider: function (source) {
		if (source instanceof TreeGridItemProvider) {
			throw new Error("TreeView not support Web Accessibility.");
		}
		var sourceChanged = source != this._itemProvider;
		if (sourceChanged) {
			var provider;
			if (this._itemProvider) {
				provider = this._itemProvider.dataSource();
				provider.unregisterClient(this);

			}
			this._itemProvider = source;
			provider = this._dataProvider = this._itemProvider.dataSource();
			provider.registerClient(this);
			provider.addListener(this);
			this._itemProvider.addListener(this);
		}
		
		if (this._autoDrawing && this._columns.length > 0 && (sourceChanged || this._rows == 0)) {
			this.reset();
		}
	},
	reset: function () {
		this.$_setOptions();
		this.$_fillHead();
		this.$_setItems(0);
	},
	onGroupedItemProviderGrouped: function (fields) {
		if (this._columns.length > 0) {
			this.$_setItems(0);
		}
	},
	$_setOptions: function () {
		var grid = this._container.gridView();
		this._indicatorVisible = grid.indicator().isVisible();
		this._footerVisible = grid.footer().isVisible();
		var checkBar = grid.checkBar();
		this._checkBarVisible = checkBar.isVisible();
		this._checkBarExclusive = checkBar.isExclusive();
		this._stateBarVisible = grid.stateBar().isVisible();
		var editOptions = grid.editOptions();
		this._insertable = editOptions.isInsertable();
		this._appendable = editOptions.isAppendable();
		this._deletable = editOptions.isDeletable();
	},
	$_setItems: function (start) {
		this._start = start;
		this.$_clearBody();

		this.$_fillBody();
	},
	$_fillHead: function () {
		var row = this._head.querySelector("tr");
		row && this._head.removeChild(row);
		this._colCount = 0;
		var colTitles = "";
		row = document.createElement("tr");
		var cell;
		if (this._indicatorVisible) {
			cell = document.createElement("th");
			cell.scope = "col";
			cell.innerText = this._indicatorTitle;
			row.appendChild(cell);
			colTitles += this._indicatorTitle + ", ";
			this._colCount++;
		}
		if (this._stateBarVisible) {
			cell = document.createElement("th");
			cell.scope = "col";
			cell.innerText = this._stateBarTitle;
			row.appendChild(cell);
			colTitles += this._stateBarTitle + ", ";
			this._colCount++;
		}
		if (this._checkBarVisible) {
			cell = document.createElement("th");
			cell.scope = "col";
			cell.innerText = this._checkBarTitle;
			row.appendChild(cell);
			colTitles += this._checkBarTitle + ", ";
			this._colCount++;
		}

		this._colTitles = [];
		for (var i = 0, cols = this._columns.length; i < cols; i++) {
			var column = this._columns[i];
			if (column.isVisible() && column.width() > 0) {
				var colHeader = column.header();
				var title = colHeader.text() ? colHeader.text() : column.name();

				cell = document.createElement("th");
				cell.scope = "col";
				cell.innerText = title;
				row.appendChild(cell);
				colTitles += title + ", ";
				this._colTitles.push(title);
				this._colCount++;
			} else {
				this._colTitles.push(null);				
			}
		}
		this._head.appendChild(row);

		cell = document.createElement("th");
		// document.createElement("button");
		this._head.appendChild(row);

		var caption = "";
		if (this._title) {
			caption += "<strong>" + this._title + "</strong>";
		}
		if (this._description) {
			caption += "<span>" + this._description.replace("${columns}", colTitles.substr(0, colTitles.length-2)) + "</span>";
		}
		this._caption.innerHTML = caption;
	},
	$_clearBody: function () {
		for (var i = this._checkboxes.length; i--;) {
			this._container.$_removeListener(this._checkboxes[i], "click");
		}
		this._checkboxes = [];

		for (i = this._buttons.length; i--;) {
			var button = this._buttons[i];
			if (button != this._prevButton && button != this._nextButton) {
				this._container.$_removeListener(this._buttons[i], "click");
			}
		}
		this._buttons = [];

		while (this._body.childNodes.length > 0) {
			this._body.removeChild(this._body.lastChild);
		}
	},
	$_fillBody: function () {
		this._rows = this._itemProvider.itemCount();
		var rows = Math.min(this._rows-this._start, this._count);

		this._prevButton.disabled = this._start == 0;
		this._nextButton.disabled = rows < this._count;

		if (rows > 0) {
			for (var i = 0; i < rows; i++) {
				this.$_buildItem(this._start+i);
			}
			if (this._footerVisible) {
				this.$_buildFooter();
			}
		} else {
			var row = document.createElement("tr");
			var cell = document.createElement("td");
			cell.colSpan = this._colCount;
			cell.innerText = this._emptyMessage;
			row.appendChild(cell);
			this._body.appendChild(row);
		}
	},
	$_buildItem: function (itemIndex) {
		var grid = this._container.gridView();
		var rowGroup = grid.rowGroup();
		var editOptions = grid.editOptions();
		var gridWritiable = editOptions.isWritable() && editOptions.canUpdate();

		var item = this._itemProvider.getItem(itemIndex);

		var rowElement = document.createElement("tr");
		rowElement.id = itemIndex;
		var cellElement;

		if (this._indicatorVisible) {
			cellElement = document.createElement("td");
			cellElement.id = "indicator";
			cellElement.innerText = this.$_getRowText(itemIndex + 1);
			rowElement.appendChild(cellElement);
		}
		if (this._stateBarVisible) {
			cellElement = document.createElement("td");
			cellElement.id = "state";
			var rowState = item.rowState();
			cellElement.innerText = this._stateTexts && rowState != RowState.NONE ? this._stateTexts[rowState] : "";
			rowElement.appendChild(cellElement);
		}
		if (this._checkBarVisible) {
			cellElement = document.createElement("td");
			cellElement.id = "checkbox";
			this.$_addCheckBox(cellElement, itemIndex, item.isChecked(), this._checkBarExclusive, this.$_checkboxHandler);
			rowElement.appendChild(cellElement);
		}

		if (item instanceof GroupItemImpl) { // header
			var text = rowGroup.getHeaderText(item);
			cellElement = document.createElement("td");
			cellElement.colSpan = this._columns.length;
			cellElement.innerText = this._groupSummaryText.replace("${groupText}", text);
			rowElement.appendChild(cellElement);
		} else if (item instanceof GroupFooter) {
			for (var i = 0, cols = this._columns.length; i < cols; i++) {
				var col = this._columns[i];
					if (this._colTitles[i] != null) {
					var text = this.$_getGroupFooterText(item, col);
					cellElement = document.createElement("td");
					if (text) {
						cellElement.innerText = text;
					}
					rowElement.appendChild(cellElement);
				}
			}
		} else {
			for (var i = 0, cols = this._columns.length; i < cols; i++) {
				var col = this._columns[i];
				if (this._colTitles[i] != null) {
					cellElement = document.createElement("td");
					cellElement.id = "col_" + i;
					
					var value = item.getData(col.dataIndex());
					var text = this.$_getText(col, value);
					var cellText = this.$_getRowText(itemIndex + 1) + " " + this._colTitles[i] + " ";

					var renderer;
					if ((renderer = col.rendererObj()) && renderer instanceof LinkCellRenderer) {
						var index = CellIndex.temp(grid, itemIndex, col);
						var url = renderer._getUrl(index);
						cellElement.innerHTML = "<a href='" + url + "' title='" + this._linkText + "' tabindex='-1' target='_blank'>" + text + "</a>";
					} else {
						cellElement.innerHTML = "<span>" + text + "</span>";
					}
					if (gridWritiable && col.isWritable()) {
						this.$_addButton(cellElement, cellText + this._editButtonText, this.$_editButtonHandler);
					}

					var buttonType = col.button();
					renderer = col.renderer();
					if (buttonType == CellButton.IMAGE) {
						var images = col.imageButtons().images;
						for (var b = 0; b < images.length; b++) {
							this.$_addButton(cellElement, cellText + images[b].name, this.$_imageButtonHandler, b);
						}
					} else if (buttonType != CellButton.NONE) {
						this.$_addButton(cellElement, cellText + this._cellButtonTexts[buttonType], buttonType == "action" ? this.$_actionButtonHandler : this.$_popupButtonHandler);
					} else if (renderer) {
						if (renderer.type == "image" || renderer.type == "icon") {
							var text = renderer.altText;
							if (text) {
								this.$_addButton(cellElement, cellText + text, this.$_imageClickHandler, b);
							}
						} else if (renderer.type == "imageButtons") {
							var images = renderer.images;
							for (var b = 0; b < images.length; b++) {
								this.$_addButton(cellElement, cellText + images[b].name, this.$_imageButtonHandler, b);
							}
						} else if (renderer.type == "imageButton") {
							this.$_addButton(cellElement, cellText + renderer.name, this.$_imageButtonHandler, b);
						} 
					}
					rowElement.appendChild(cellElement);
				}
			}
			if (this._insertable || this._appendable || this._deletable) {
				cellElement = document.createElement("td");
				if (this._insertable) {
					this.$_addButton(cellElement, this._insertButtonText, this.$_insertRowButtonHandler);
					if (itemIndex < this._start + this._count - 1) {
						this.$_addButton(cellElement, this._appendButtonText, this.$_appendRowButtonHandler);
					}
				}
				if (this._deletable) {
					this.$_addButton(cellElement, this._deleteButtonText, this.$_deleteRowButtonHandler);
				}
				rowElement.appendChild(cellElement);
			}
		}
		this._body.appendChild(rowElement);
	},
	$_buildFooter: function () {
		var grid = this._container.gridView();
		var footer = grid.footer();
		var headCount = this._indicatorVisible + this._checkBarVisible + this._stateBarVisible;
		var cellElement;
		var i, j;
		var cols = this._columns.length;

		for (i = 0, footers = grid.footer().count(); i < footers; i++) {
			var rowElement = document.createElement("tr");
			if (headCount > 0) {
				cellElement = document.createElement("td");
				cellElement.colSpan = headCount;
				cellElement.innerText = this._summaryText;
				rowElement.appendChild(cellElement);
			}

			for (var j = 0; j < cols; j++) {
				var col = this._columns[j];
				var cellText = this._summaryText + " " + this._colTitles[j] + " ";
				var cell = footer.getCell(grid.getIndex(-1, col), i);
				var text = this.$_getFooterText(col.footer(), cell);
				cellElement = document.createElement("td");
				if (text) {
					cellElement.innerText = text;
				}
				rowElement.appendChild(cellElement);
			}
			this._body.appendChild(rowElement);
		}
	},
	/* utilities */
	$_getText: function (column, value) {
		var fld = column.getField();
		var styles = column.styles();
		var format;
		var text;

		switch (fld.dataType()) {
			case ValueType.NUMBER:
				format = styles.numberFormat();
				if (defined(value) && format) {
					if (format != this._numberFormat) {
						this._numberFormatter.parse(format);
						this._numberFormat = format;
					}
					text = this._numberFormatter.format(value);
				} else if (defined(value)) {
					text = value + "";
				} else {
					text = "";
				}
				break;
			case ValueType.DATETIME:
				format = styles.datetimeFormat();
		        if (value) {
		            if (format) {
		            	if (format != this._datetimeFormat) {
			            	this._datetimeWriter.setFormatString(format);
			            	this._datetimeFormat = format;
			            }
		                text = this._datetimeWriter.getText(value);
		            } else {
		            	text = DateTimeWriter.Default.getText(value);
		            }
		        } else {
		        	text = "";
		        }
		        break;
			case ValueType.BOOLEAN:
				format = styles._booleanFormat;
				if (defined(value) && format) {
		            if (format != this._booleanFormat) {
		            	this._booleanFormatter.setFormat(format);
		            	this._booleanFormat = format;
		            }
		            text = this._booleanFormatter.formatValue(value);
	            } else {
	                text = defined(value) ? value.toString() : "";
				}
				break;
			default:
				if (defined(value)) {
					text = value.toString();
				} else {
					text = "";
				}
				break;
		}
        var f;
        if ((f = styles.prefix()) != null) {
            text = f + text;
        }
        if ((f = styles.suffix()) != null) {
            text += f;
        }
        return text;
	},
	$_getFooterText: function (footer, cell) {
		var styles = footer.styles();
        var v = cell.value();
        var v1 = Number(v);
        var text;
        var format;
        if (!isNaN(v1) && (format = styles.numberFormat())) {
			if (format != this._numberFormat) {
				this._numberFormatter._parse(format);
				this._numberFormat = format;
			}
			text = this._numberFormatter.format(v1);
        } else if (v) {
            text = v;
        } else {
            text = cell.displayText();
            if (!defined(text)) {
            	text = "";
            }
        }

        var f;
        if ((f = styles.prefix()) != null) {
            text = f + text;
        }
        if ((f = styles.suffix()) != null) {
            text += f;
        }
        return text;
	},
	$_getGroupFooterText: function (item, column) {
		var grid = this._container.gridView();
		var rowGroup = grid.rowGroup();
		var v = RowGroupFooterCell.getValue(item, column);
		var styles = column.footer().styles();
        var v1 = Number(v);
        var text;
        var format;

        if (v instanceof Date) {
        	if (format != this._datetimeFormat) {
            	this._datetimeWriter.setFormatString(format);
            	this._datetimeFormat = format;
            }
			text = this._numberFormatter.format(v);
        } else if (typeof v == "string") {
            text = v;
        } else if (isNaN(v)) {
            var itemId = item.index();
            var groupText;
            if (itemId > -1) {
                var index = CellIndex.temp(grid, itemId, column);
                var cell = rowGroup.getFooterCell(index);
                if (v === undefined || typeof v == "number") {
                    text = cell.displayText() || "";
                } else {
                    text = v;
                }
            } else if (groupText = column.footer().groupText()) {
                text = groupText;
            }
        } else {
            text = v;
        }

        var f;
        if ((f = styles.prefix()) != null) {
            text = f + text;
        }
        if ((f = styles.suffix()) != null) {
            text += f;
        }
        return text;
	},
	$_getRowText: function (row) {
		return this._rowText ? this._rowText.replace("${index}", row) : row;
	},
	$_getItemIndex: function (element/*child of td*/) {
		var td = element.parentElement;
		var tr = td ? td.parentElement : null;
		if (tr && tr.id) {
			return parseInt(tr.id);
		}
		return -1;
	},
	$_getCellIndex: function (element/*child of td*/) {
		var td = element.parentElement;
		var tr = td ? td.parentElement : null;
		if (tr) {
			var row = parseInt(tr.id);
			if (!isNaN(row)) {
				var c = td.id;
				c = c.substring(4,c.length);
				var col = this._columns[parseInt(c)];
				if (col) {
					return CellIndex.temp(this._grid, row, col);
				}
			}
		}
		return null;
	},
	$_addCheckBox: function (parent, itemIndex, value, exclusive, handler) {
		var element = document.createElement("input");
		element.type = exclusive ? "radio" : "checkbox";
		element.name = "rg_shadow_item";
		element.tabIndex = -1;
		element.title = this.$_getRowText(itemIndex + 1);
		element.$$value = itemIndex;
		element.checked = value;
		this._container.$_addListener(element, "click", handler.bind(this), false);
  		parent.appendChild(element);
		this._checkboxes.push(element);
		return element;
	},
	$_addButton: function (parent, title, handler, buttonIndex) {
		var element = document.createElement("input");
		element.type = "button";
		element.title = title;
		// element.value = title;
		element.tabIndex = -1;
		if (buttonIndex != undefined) {
			element.$$value = buttonIndex;
		}
		this._container.$_addListener(element, "click", handler.bind(this), false);
		parent.appendChild(element);
		this._buttons.push(element);
		return element;
	},
	/* DataProvider Event */
	onDataProviderDataChanged: function (provider) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderReset: function (provider) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderRefresh: function (provider) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderRefreshClient: function (provider) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderRowCountChanged: function (provider) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderRowMoved: function (provider, row, newRow) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderRowsMoved: function (provider, row, count, newRow) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderStateChanged: function (provider, row) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderStatesChanged: function (provider, rows) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderStatesCleared: function (provider) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	onDataProviderRestoreRows: function (provider) {
		if (this._autoDrawing && this._itemProvider && !this._internalSet) {
			this.$_setItems(this._start);
		}
	},
	/* DataProvider Listner function */
	isDataEditing: function () {
		return this._editing && !this._internalSet;
	},
	commit: function () {
		return false;
	},
	/* handlers */
	$_prevButtonHandler: function (event) {
		// console.log("prev button");
		this.$_setItems(this._start-this._count);
	},
	$_nextButtonHandler: function (event) {
		// console.log("next button");
		this.$_setItems(this._start+this._count);
	},
	$_checkboxHandler: function (event) {
		var checkbox = event.target || event.srcElement || event.originalTarget;
		var index = checkbox.$$value;
		if (checkbox.type == "radio") {
			this._grid.checkItem(index, checkbox.checked, true, true);
		} else {
			this._grid.checkItem(index, checkbox.checked, false, false);
		}
	},
	$_actionButtonHandler: function (event) {
		var button = event.target || event.srcElement || event.originalTarget;
		var index = this.$_getCellIndex(button);

		index && this._grid._fireCellButtonClicked(index);
	},
	$_popupButtonHandler: function (event) {
		// TO DO : Popup Window
	},
	$_imageClickHandler: function (event) {
		var button = event.target || event.srcElement || event.originalTarget;
		var index = this.$_getCellIndex(button);

		index && this._grid._fireDataCellClicked(index);
	},
	$_imageButtonHandler: function (event) {
		var button = event.target || event.srcElement || event.originalTarget;
		var index = this.$_getCellIndex(button);
		var buttonIndex = button.$$value;
		var col = index.column();
		var renderer = col.renderer();
		var buttonName;
		if (renderer) {
			if (renderer.type == "imageButtons") {
				images = renderer.images;
				buttonName = images[buttonIndex].name;
			} else if (renderer.type == "imageButton") {
				buttonName = renderer.name;
			}
		}

		index && this._grid._fireImageButtonClicked(index, buttonIndex, buttonName);
	},
	$_editButtonHandler: function (event) {
		var button = event.target || event.srcElement || event.originalTarget;
		var index = _clone(this.$_getCellIndex(button));
		var rowText = this.$_getRowText(index.itemIndex() + 1);
		var grid = this._container.gridView();
		var current = {itemIndex:index.itemIndex(), column: index.column().name()};
		if (!current.column) {
			current.fieldName = index.column().fieldName();
		}
		grid.setCurrent(current);
		this._editElement = button.parentElement;
		this._editor.popup(index, rowText, this._colTitles[index.col()], button);
	},
	$_appendRowButtonHandler: function (event) {
		var button = event.target || event.srcElement || event.originalTarget;
		var itemIndex = this.$_getItemIndex(button);
		if (itemIndex == -1) {
			this._dataProvider.addRow([]);
		} else {
			var item = this._itemProvider.getItem(itemIndex);
			this._dataProvider.insertRow(item.dataRow()+1, []);
		}
	},
	$_insertRowButtonHandler: function (event) {
		var button = event.target || event.srcElement || event.originalTarget;
		var itemIndex = this.$_getItemIndex(button);
		if (itemIndex != -1) {
			var item = this._itemProvider.getItem(itemIndex);
			this._dataProvider.insertRow(item.dataRow(), []);
		}
	},
	$_deleteRowButtonHandler: function (event) {
		var button = event.target || event.srcElement || event.originalTarget;
		var itemIndex = this.$_getItemIndex(button);
		if (itemIndex != -1) {
			var item = this._itemProvider.getItem(itemIndex);
			this._dataProvider.removeRow(item.dataRow(), []);
		}
	},
	$_editorCommitedHandler: function (index, value) {
		var col = index.dataColumn();
		var item = index.item();
		var fieldName = col.fieldName();
		this._internalSet = true;
		try {
			item.setData(col.dataIndex(),value);
		} finally {
			this._internalSet = false;
		}
		this.$_setElementText(this._editElement, index, item, col, value);

		var siblings = this._editElement.parentNode.childNodes;

		for (var i = siblings.length; i--; ) {
			var sibling = siblings[i];
			if (sibling != this._editElement) {
				var sindex = this.$_getCellIndex(sibling.firstChild);
				if (sindex) {
					var scol = sindex.dataColumn(); 
					if (scol && scol.fieldName() == fieldName) {
						this.$_setElementText(sibling, sindex, item, scol, value);		
					}
				}
			}

		}
	},
	$_setElementText: function (element, index, item, col, value) {
		var text = this.$_getText(col, value);
		var renderer;
		if ((renderer = col.rendererObj()) && renderer instanceof LinkCellRenderer) {
			var url = renderer._getUrl(index);
			var anchor = element.getElementsByTagName("a")[0];
			anchor.text = text;
			anchor.href = url;
		} else {
			var span = element.getElementsByTagName("span")[0];
			span.innerText = text;
		}

		var rowElement = element.parentElement;
		var stateElement = rowElement.querySelector("#state");
		if (stateElement) {
			var rowState = item.rowState();
			stateElement.innerText = this._stateTexts && rowState != RowState.NONE ? this._stateTexts[rowState] : "";
		}		
	}
});
var $$_SHADOW_AM_VALUE = "am";
var $$_SHADOW_PM_VALUE = "pm";

var ShadowEditor = defineClass("ShadowEditor", null, {
	init: function (container, parent, options) {
		this._container = container;
		this._options = options;
		this._valueChanged = false;
		this._type = null;
		this._value = null;
		this._column = null;
		this._itemIndex = null;

		/* generate basic dom */
		var dialog = this._dialog = document.createElement("div");
		dialog.class = "popup";
		dialog.role = "dialog";
		dialog.ariaLabelledby = "popuptitle";
		dialog.style.display = "none";
		dialog.style.position = "absolute";
		dialog.style.left = "0px";
		dialog.style.top = "0px";

		var title = document.createElement("div");
		title.id = dialog.ariaLabelledby;
		title.style.display = "none";
		dialog.appendChild(title);

		this._body = document.createElement("div");
		dialog.appendChild(this._body);

		var foot = document.createElement("div");
		var applyButton = document.createElement("input");
		applyButton.type = "button";
		applyButton.value = "Apply";
		applyButton.title = "Apply";
		this._container.$_addListener(applyButton, "click", this.$_applyButtonHandler.bind(this), false);
		foot.appendChild(applyButton);
		var cancelButton = document.createElement("input");
		cancelButton.type = "button";
		cancelButton.value = "Cancel";
		cancelButton.title = "Cancel";
		this._container.$_addListener(cancelButton, "click", this.$_cancelButtonHandler.bind(this), false);
		foot.appendChild(cancelButton);
		dialog.appendChild(foot);

		if (parent.firstElementChild) {
			parent.insertBefore(dialog, parent.firstElementChild);
		} else {
			parent.appendChild(dialog);
		}

		/* edit controls */
		this._activeControls = [];
		// line
		this._lineInput = null;
		// multiLine
		this._multiInput = null;
		// number
		this._numberInput = null;
		// dropdown
		this._selector = null;
		// date
		this._yearInput = null;
		this._monthInput = null;
		this._dayInput = null;
		this._ampmSelector = null;
		this._hourInput = null;
		this._minuteInput = null;
		this._secondInput = null;
		// search 
		// multiCheck

		//this.$_buildEditor("line"); // set type to "line"
		this._defaultInput = null;

		this._focusControl = null;

	},
	beforeCallback: null,
	afterCallback: null,
	editorCommited: null,
	popup: function (index, rowText, colText, focusControl) {
		var accept = false;
		this._beforeCallback && (accept = this._beforeCallback(index));
		if (accept) {
			this._focusControl = focusControl;
			this._index = index;
			var column = index.dataColumn();
			var type = column.editor();
			if (!type) {
				type = "line";
			}
			this._value = index.item().getData(column.dataIndex());
			this.$_buildEditor(type, rowText, colText);
			this.$_setEditValue(type, this._value);

			this._dialog.style.display = "block";
			this._defaultInput && this._defaultInput.focus();
		}
	},
	focusEditor: function () {
		if (this._defaultInput) {
			this._defaultInput.focus();
		}
	},
	$_closeUp: function (apply) {
		if (apply) {
			var value = this.$_getEditValue(this._type);
			if (value != this._value) {
				this._editorCommited(this._index, value);
			}
		}
		this._dialog.style.display = "none";
		this._afterCallback && this._afterCallback(this._index);
		this._focusControl && this._focusControl.focus();
	},
	$_clearControls: function () {
		for (var i = this._activeControls.length; i--; ) {
			this._container.$_removeListener(this._activeControls[i]);
			this._body.removeChild(this._activeControls[i]);
			delete this._activeControls[i];
		}
		this._activeControls = [];
	},
	$_buildEditor: function (type, rowText, colText) {
		this.$_clearControls();
		var input;
		var cellText = rowText + " " + colText;
		switch (type) {
			case "multiline":
				input = this._multiInput = document.createElement("textarea");
				input.title = cellText;
				this._body.appendChild(input);
				this._activeControls.push(input);
				break;
			case "number":
				input = this._numberInput = this.$_addNumberInput(cellText);
				break;
			case "dropDown":
				input = this._selector = document.createElement("select");
				input.title = cellText;
				this.$_buildSelectOptions(input, this._index);
				this._body.appendChild(input);
				this._activeControls.push(input);
				break;
			case "date":
				var options = this._options;
				input = this._yearInput = this.$_addNumberInput(options.yearText, 2000, 4, 0, 9999); //년도
				this._monthInput = this.$_addNumberInput(options.monthText, 1, 2, 1, 12); // 월
				this._dayInput = this.$_addNumberInput(options.dayText, 1, 2, 1, 31); // 일자

				this._ampmSelector = document.createElement("select");
				this._ampmSelector.title = options.ampmText; //오전/오후
				this._ampmSelector.options[0] = new Option(options.amText, $$_SHADOW_AM_VALUE); // AM
				this._ampmSelector.options[1] = new Option(options.pmText, $$_SHADOW_PM_VALUE); // PM			
				this._body.appendChild(this._ampmSelector);
				this._activeControls.push(this._ampmSelector);

				this._hourInput = this.$_addNumberInput(options.hourText, 0, 2, 0, 11);  // 시
				this._minuteInput = this.$_addNumberInput(options.minuteText, 0, 2, 0, 59); //분
				this._secondInput = this.$_addNumberInput(options.secondText, 0, 2, 0, 59); //초
				break;
			default:
				input = this._lineInput = document.createElement("input");
				input.type = "text";
				input.title = cellText;
				this._body.appendChild(input);		
				this._activeControls.push(input);	
		}
		this._defaultInput = input;
		this._type = type;
	},
	$_buildSelectOptions: function (selector, index) {
		var item = index.item();
		var column = index.dataColumn();
		var values;
		var items;
		var labeling = false;
		var lookupValues, lookupLabels;
		if (column.lookupSource()) {
			var flds = column.lookupKeyFieldIds();
			var keys = [];
			for (var i = 0; i < flds.length - 1; i++) {
				keys.push(item.getData(flds[i]));
			}
			var domain = column.lookupSource().getTextDomain(keys);
			if (domain && domain.values && domain.values.length > 0) {
				items = domain.values;
				values = domain.keys;
				labeling = true;
			}
		} else if ((lookupValues = column.lookupValues() || column.editorOptions().values) && lookupValues.length > 0) {
			if ((lookupLabels = column.lookupLabels() || column.editorOptions().labels) && lookupLabels.length >= lookupValues.length) {
				items = lookupLabels;
				values = lookupValues;
				labeling = true;
			} else {
				items = lookupValues;
			}
		}

		if (items) {
			for (var i = 0; i < items.length; i++) {
				var option = document.createElement("option");
				option.innerText = items[i];
				option.value = labeling && i < values.length ? values[i] : items[i];
				selector.appendChild(option);
			}
		}
	},
	$_addNumberInput: function (title, value, maxlen, min, max) {
		var input = document.createElement("input");
		input.type = "number";
		if (input.type == "number") {
			min != undefined && (input.min = min);
			min != undefined && (input.max = max);
		} else {
			maxlen != undefined && (input.maxLength = maxlen);
			min != undefined && (input.dataset.min = min);
			max != undefined && (input.dataset.max = max);
			this._container.$_addListener(input, "keypress", this.$_numberEditHandler.bind(this), false);
		}
		input.title = title;
		value != undefined && (input.value = value);
		this._body.appendChild(input);
		this._activeControls.push(input);
		return input;
	},
	/* utilities */
	$_setEditValue: function (type, value) {
		switch (type) {
			case "multiline":
				this._multiInput.value = value ? value : "";
				break;
			case "number":
				if (!isNaN(value)) {
					this._numberInput.value = value ? value : "";
				}
				break;
			case "dropDown":
				this._selector.value = value ? value : "";
				break;
			case "date":
				var d = value;
				if (value && typeof value == "string") {
					d = new Date(value);
				}
				if (d instanceof Date && !isNaN(d.getTime())) {
					this._yearInput.value    = d.getFullYear();
					this._monthInput.value   = d.getMonth() + 1;
					this._dayInput.value     = d.getDate();
					var h = d.getHours();
					this._ampmSelector.value = h < 12 ? $$_SHADOW_AM_VALUE : $$_SHADOW_PM_VALUE; 
					this._hourInput.value    = h % 12;
					this._minuteInput.value  = d.getMinutes();
					this._secondInput.value  = d.getSeconds();
				} else {
					this._yearInput.value = "";
					this._monthInput.value = "";
					this._dayInput.value = "";
					this._ampmSelector.value = $$_SHADOW_AM_VALUE;
					this._hourInput.value = "";
					this._minuteInput.value = "";
					this._secondInput.value = "";
				}
				break;
			default:
				this._lineInput.value = value ? value : "";

		}
	},
	$_getEditValue: function (type) {
		switch (type) {
			case "multiline":
				return this._multiInput.value;
			case "number":
				var n = Number(this._numberInput.value);
				return isNaN(n) ? null : n;
			case "dropDown":
				return this._selector.value;
			case "date":
				var year  = parseInt(this._yearInput.value);
				var month = parseInt(this._monthInput.value) - 1;
				var day   = parseInt(this._dayInput.value);
				var hour  = parseInt(this._hourInput.value) + (this._ampmSelector.value == $$_SHADOW_PM_VALUE ? 12 : 0);
				var min   = parseInt(this._minuteInput.value);
				var sec   = parseInt(this._secondInput.value);
				var d = new Date(year, month, day, hour, min, sec);
				return d;
			default:
				return this._lineInput.value;
		}
	},
	$_checkValue: function (type) {
		if (type == "date") {
			var year  = parseInt(this._yearInput.value);
			if (isNaN(year) || year < 0) {
				alert(this._yearInput.title + " " + this._options.validationMessage);
				this._yearInput.focus();
				return false;
			}
			var month = parseInt(this._monthInput.value);
			if (isNaN(month) || month < 1 || month > 12) {
				alert(this._monthInput.title + " " + this._options.validationMessage);
				this._monthInput.focus();
				return false;
			}
			var day = parseInt(this._dayInput.value);
			if (isNaN(day) || day < 1 || day > 31) {
				alert(this._dayInput.title + " " + this._options.validationMessage);
				this._dayInput.focus();
				return false;
			}			
			var hour = parseInt(this._hourInput.value);
			if (isNaN(hour) || hour < 0 || hour > 11) {
				alert(this._hourInput.title + " " + this._options.validationMessage);
				this._hourInput.focus();
				return false;
			}
			var min = parseInt(this._minuteInput.value);
			if (isNaN(min) || min < 0 || min > 59) {
				alert(this._minuteInput.title + " " + this._options.validationMessage);
				this._minuteInput.value.focus();
				return false;
			}
			var sec = parseInt(this._secondInput.value);
			if (isNaN(sec) || sec < 0 || sec > 59) {
				alert(this._secondInput.title + " " + this._options.validationMessage);
				this._secondInput.value.focus();
				return false;
			}
			var d = new Date(year, month, day, hour, min, sec);
			if (d && !isNaN(d.getTime())) {
				return true;
			} else { //윤달 등
				alert(this._options.validationMessage); 
				this._monthInput.focus();
				return false;
			}
		}
		return true;
	},
	/* event handlers */
	$_numberEditHandler: function (event) {
		return (event.charCode >= 48 && event.charCode <= 57);
	},
	$_applyButtonHandler: function (event) {
		if (this.$_checkValue(this._type)) {
			this.$_closeUp(true);
		}
	},
	$_cancelButtonHandler: function (event) {
		this.$_closeUp();
	}
});


var /* abstract */ VisualContext = defineClass("VisualContext", EventAware, {
	init : function() {
		this._super();
	}
});
var CanvasContext = defineClass("CanvasContext", VisualContext, {
	init : function(name, container) {
		this._super();
		this._name = name;
		this._container = container;
		this._canvas = document.createElement("canvas");
		this._ctx = this._canvas.getContext('2d');
		this._graphics = new Graphics(this._ctx);
		this._dirty = false;
		this._buffer = null;
		this._bufferCtx = null;
		this._deviceScale = Math.max(Math.floor(window.devicePixelRatio)||1 , 1);
	},
	destroy: function() {
		this._destroying = true;
		this._container = null;
		this._canvas = null;
		this._ctx = null;
		this._graphics = null;
		this._buffer = null;
		this._bufferCtx = null;
		this._super();
	},
    name: function () {
        return this._name;
    },
	isDirty: function () {
		return this._dirty;
	},
	resize: function (w, h) {
		if (w * this._deviceScale > this._canvas.width) {
			this._canvas.width = w * this._deviceScale;
		}
		if (h * this._deviceScale > this._canvas.height) {
			this._canvas.height = h * this._deviceScale;
		}
	},
	prepare: function (bounds, scrollX, scrollY, clear) {
		if (bounds && (scrollX || scrollY)) {
			var r = bounds;
			var buff = this._buffer;
			if (!buff) {
				this._buffer = buff = _doc.createElement("canvas");
				this._bufferCtx = buff.getContext("2d");
			}
			if (r.width > buff.width) {
				buff.width = r.width;
			}
			if (r.height > buff.height) {
				buff.height = r.height;
			}
			var x = r.x;
			var y = r.y;
			var w = r.width;
			var h = r.height;
			this._bufferCtx.drawImage(this._canvas, x, y, w, h, 0, 0, w, h);
			clear && this._graphics.clear(0, 0, this._canvas.width, this._canvas.height);
			if (scrollX > 0) {
				r.x += scrollX;
				w -= scrollX;
			} else if (scrollX < 0) {
				x -= scrollX;
				w += scrollX;
			}
			if (scrollY > 0) {
				r.y += scrollY;
				h -= scrollY;
			} else if (scrollY < 0) {
				y -= scrollY;
				h += scrollY;
			}
			this._ctx.drawImage(this._buffer, x, y, w, h, r.x, r.y, w, h);
			this._dirty = true;
		} else if (clear) {
			this._graphics.clear(0, 0, this._canvas.width, this._canvas.height);
		}
		this._graphics.save();
		(this._deviceScale > 1) && this._graphics.scale(this._deviceScale, this._deviceScale);
	},
	restore: function () {
		if (this._dirty) {
			this._dirty = false;
		}
		this._graphics.restore();
	},
	invalidate: function (element) {
		if (!this._dirty) {
			this._dirty = true;
		}
	}
});
var /* abstract */ VisualCache = defineClass("VisualCache", EventAware, {
	init : function() {
		this._super();
	}
});
var CanvasCache = defineClass("CanvasCache", VisualCache, {
	init : function(doc, element) {
		this._super();
		this._element = element;
		this._canvas = doc.createElement("canvas");
		this._ctx = this._canvas.getContext('2d');
		this._graphics = new Graphics(this._ctx);
	},
	destroy: function () {
		this._destroying = true;
		this._element = null;
		this._canvas = null;
		this._ctx = null;
		this._graphics = null;
		this._super();
	},
	dispose: function () {
	},
	resize: function (w, h) {
		if (w > this._canvas.width) {
			this._canvas.width = w;
		}
		if (h > this._canvas.height) {
			this._canvas.height = h;
		}
	},
	prepare: function () {
		this._graphics.clear(0, 0, this._canvas.width, this._canvas.height);
		this._graphics.save();
	},
	restore: function () {
		this._graphics.restore();
	},
	invalidate: function (element) {
		if (!this._dirty) {
			this._dirty = true;
			this._container.invalidate();
		}
	}
});
var VisualContainer = defineClass("VisualContainer", UIContainer, {
	init: function (dom, containerId, accessbility, shadowOptions) {
		this._super(dom, containerId);
        var container = this._container;
        this._deviceScale = Math.max(Math.floor(window.devicePixelRatio)||1 , 1);
        if (dom) {
            this._createChildren(container);
            this.invalidateLayout();
            this._registerEventHandlers(container);
        } else {
            var canvas = this._canvas = document.createElement("canvas");
            this._ctx = canvas.getContext('2d');
            container.appendChild(canvas);
            var clientRect = container.getBoundingClientRect();
            canvas.width = parseInt(clientRect.width) * this._deviceScale;//container.clientWidth;
            canvas.height = parseInt(clientRect.height) * this._deviceScale;//container.clientHeight;
            canvas.style.position = "absolute";
            canvas.style.left = "0px";
            canvas.style.top = "0px";
            canvas.style.background = "#fff"; // 이렇게 하지 않으면 상위 div의 값을 따라간다.
            canvas.style.borderStyle = "none";
            canvas.style.borderWidth = "0px";
            if (this._deviceScale > 1) {
	            canvas.style.width = "100%";
	            canvas.style.height = "100%";
	            canvas.style["-webkit-transform"] = "translateZ(0)";
	        };
            canvas.setAttribute('tabindex', '0');
            canvas.setAttribute('role', 'application');

            if (accessbility) {
	            this._shadowDom = new ShadowDom(this, shadowOptions);
            } else {
            	canvas.innerText = "Your browser does not support HTML5 Canvas.";            	
            }

            this._defContext = new CanvasContext("defaultContext", this);
            this._defContext.resize(this._width, this._height);
            this._contexts = null;
            this._createChildren(container);
            this.invalidateLayout();
            this._registerEventHandlers(canvas);
        }
        this._imagePool = new ImagePool();
        this._imagePool.addListener(this);
		/*
		setInterval(function () {
			this.resetSize();
		}.bind(this), 100);
		*/
	},
	destroy: function() {
		this._destroying = true;
		this._imagePool.removeListener(this);
        this._imagePool.destroy();
		Dom.clearElements(this._canvas);
		if (this._canvas.parentNode) {
			this._canvas.parentNode.removeChild(this._canvas);
		};
		this._ctx = null;
		this._canvas = null;
		this._imagePool = null;
        this._shadowDom && this._shadowDom.destroy();
        this._shadowDom = null;
		this._super();
	},
    onImageLoaded: function (url) {
        var img = this._imagePool.getImage(url);
        trace("Image loaded at " + url + " [" + img.width + "," + img.height + "]");
        this.invalidateLayout();
    },
    getCanvasImage: function () {
        return this._canvas && this._canvas.toDataURL();
    },
    getContext: function (contextName) {
        if (this._contexts) {
            for (var i = this._contexts.length; i--;) {
                if (this._contexts[i].name() == contextName) {
                    return this._contexts[i];
                }
            }
        }
        return null;
    },
	addContext: function (context) {
		if (context) {
			if (!this._contexts) {
				this._contexts = [];
			}
			if (this._contexts.indexOf(context) < 0) {
				this._contexts.push(context);
				context.resize(this._width, this._height);
			}
		}
	},
    getImage: function (url) {
        return this._imagePool.getImage(url);
    },
	measureText: function (font, text) {
        if (this.$_dom) {
            return text ? text.length * 8 : 0;
        } else {
            this._ctx.font = font.font;
            return this._ctx.measureText(text).width;
        }
	},
	measureTextRect:function (font, text, x, y, w, h, align, layout, textWrap, rect) {
        var sz;
        switch (textWrap) {
            case TextWrapMode.EXPLICIT:
                sz = this._defContext._graphics.getExplicitTextRect(font, text, x, y, w, h, align, layout, rect);
                break;
            case TextWrapMode.NORMAL:
                sz = this._defContext._graphics.getWrapTextRect(font, text, x, y, w, h, align, layout, rect);
                break;
            default:
                sz = this._defContext._graphics.getTextRect(font, text, x, y, w, h, align, layout, rect);
                break;
        }
        return sz.height;
	},

	invalidateElement: function (element) {
        if (!element._dom) {
            var ctx = element._context || this._defContext;
            ctx.invalidate(element);
        }
		if (!this._drawing && !this._updateRequested) {
			window.requestAnimationFrame(this._containerRender);
			this._updateRequested = true;
		}
	},
	validateElement: function (element) {
	},
	scroll: function (bounds, deltaX, deltaY) {
		this.$$_render(_getTimer(), bounds, deltaX, deltaY);
	},
	setResizeDelay: function(value) {
		if (value != this._resizeDelay) {
			value = !isNaN(value) && !!value ? parseInt(value) : null;
			this._resizeDelay = value;
		}
	},
	resetSize: function (callback) {
		if (!parseInt) {
			return;
		}
		this._resetSizeCallback = callback;
        var clientRect;
        try {
            clientRect = this._container.getBoundingClientRect();
        } catch (e){
            clientRect = {width:this._container.clientWidth, height:this._container.clientHeight};
        };
        if (this._width != parseInt(clientRect.width) /*this._container.clientWidth*/ || this._height != parseInt(clientRect.height) /*this._container.clientHeight*/) {
            if (this._defContext) {
                this._width = parseInt(clientRect.width);
                this._height = parseInt(clientRect.height);
                this._canvas.width = parseInt(clientRect.width) * this._deviceScale;//this._container.clientWidth;
                this._canvas.height = parseInt(clientRect.height) * this._deviceScale;//this._container.clientHeight;
                this._defContext.resize(this._width, this._height);
                if (this._contexts) {
                    for (var i = 0; i < this._contexts.length; i++) {
                        this._contexts[i].resize(this._width, this._height);
                    }
                }
            }
            this.invalidateLayout();
            trace("resized: " + this._width + ", " + this._height);
        } else {
            this.invalidateLayout();
        }
	},
	_createRootElement: function (dom) {
        if (dom) {
            var elt = new RootElement(dom, "root", this);
            this._container.appendChild(elt._dom);
            return elt;
        } else {
            return new RootElement(false, "root", this, this._defContext);
        }
	},
	$_validateChildren: function (element) {
		var elts = element._elements;
		if (elts) {
			for (var i = elts.length; i--;) {
				var elt = elts[i];
				elt._dirty = elt._nodraw = false;
				this.$_validateChildren(elt);
			}
		}
	},
	_doLayout: function (r) {
	},
    _doPrepareRender: function (r) {
    },
	_beforeRender: function (bounds) {
	},
	_doRender: function (bounds) {
		this._doDrawContainer(this._defContext._graphics, bounds);
        if (this._defContext._dirty) {
            this._drawElement(this._rootElement, null, this._invalidated);
        }
        if (this._contexts) {
            for (var i = 0, cnt = this._contexts.length; i < cnt; i++) {
                if (this._contexts[i]._dirty) {
                    this._drawElement(this._rootElement, this._contexts[i], true);
                }
            }
        }
		this.$_validateChildren(this._rootElement);
	},
	_doDrawContainer: function (g, bounds) {
	},
	_drawElement: function (element, context, force) {
        if (element._nodraw) return;
        var i, cnt, elt;
        if (element._dom) {
            element.draw();
            for (i = 0, cnt = element.childCount(); i < cnt; i++) {
                elt = element.getChild(i);
                if (elt.isVisible()) {
                    this._drawElement(elt);
                }
            }
        } else {
            var g = context ? context._graphics : this._defContext._graphics;
            g.save();
            g.translate(element.x(), element.y());
            if (element._mask) {
                if (element._mask instanceof VisualElement) {
                    element._mask._doDraw(g);
                    g.clip();
                } else if (element._mask instanceof Rectangle) {
                    g.clipRect(element._mask);
                }
            } else {
                element.clip(g);
            }
            g.setAlpha(element._alpha);
            if (element._context == context && (force || element._dirty)) {
                var cache = element._cache;
                if (cache) {
                    element.drawCache(g, cache);
                } else {
                    element._graphics = g;
                    element.draw(g, !this._invalidated);
                }
            }
            var elts = element._elements;
            if (elts) {
                for (i = 0, cnt = elts.length; i < cnt; i++) {
                    elt = elts[i];
                    if (elt._visible) {
                        this._drawElement(elt, context, force);
                    }
                }
            }
            g.restore();
        }
	},
	$$_render: function (timestamp, scrollRect, scrollX, scrollY) {
		var t = _getTimer();
		var w = this._width;
		var h = this._height;
        var i;
		this._layoutChildren(new Rectangle(0, 0, w, h));
		if ($_debug) {
			trace("rendering[" + ++this._rendered + "] at " + timestamp);
			t = getTimer();
		}
		if (this._layoutNeeded) {
			this._layoutNeeded = false;
			this._doLayout(new Rectangle(0, 0, w, h));
			if ($_debug) {
				t = _getTimer() - t;
				_trace("layouted in [" + t + "]");
			}
		} else {
            this._doPrepareRender(new Rectangle(0, 0, w, h));
        }
		if ($_debug) {
			t = _getTimer();
		}
		if (this._invalidated) {
			this._defContext._dirty = true;
			if (this._contexts) {
				for (var i = 0, cnt = this._contexts.length; i < cnt; i++) {
					this._contexts[i]._dirty = true;
				}
			}
		}
		this._defContext.prepare(scrollRect, scrollX, scrollY, this._invalidated);
		if (this._contexts) {
			for (i = 0; i < this._contexts.length; i++) {
				this._contexts[i].prepare(null, 0, 0, this._contexts[i]._dirty);
			}
		}
		try {
			$_validated = 0;
			var r = new Rectangle(0, 0, w, h);
			this._beforeRender(r);
			this._doRender(r);
			this._ctx.clearRect(0, 0, w, h);
			if (w > 0 && h > 0) {
				w *= this._deviceScale;
				h *= this._deviceScale;
				this._ctx.clearRect(0, 0, w, h);
				this._ctx.drawImage(this._defContext._canvas, 0, 0, w, h, 0, 0, w, h);
				if (this._contexts) {
					for (i = 0; i < this._contexts.length; i++) {
						this._ctx.drawImage(this._contexts[i]._canvas, 0, 0, w, h, 0, 0, w, h);
					}
				}
			}
		} finally {
			if (this._contexts) {
				for (i = 0; i < this._contexts.length; i++) {
					this._contexts[i].restore();
				}
			}
			this._defContext.restore();
		}
		if ($_debug) {
			t = _getTimer() - t;
			_trace("rendered elements2[" + $_validated + "] in [" + t + "]");
		}
		for (var i = 0, cnt = this._children.length; i < cnt; i++) {
			var c = this._children[i];
			if (c._visible && c._width > 0 && c._height > 0) {
				c.resize();
				c.layoutContent();
				if (c._dirty) {
					c.draw();
				}
				this._ctx.drawImage(c._canvas, 0, 0, c._width, c._height, c._x, c._y, c._width, c._height);
			}
		}
	},
	_resizeHandler: function (event) {
		if (this._resizeDelay) {
			this._resizeTimer && clearTimeout(this._resizeTimer);
			this._resizeTimer = setTimeout(function() {this.resetSize()}.bind(this), this._resizeDelay);
		} else {
			this.resetSize();
		}
	}
});
var VisualContainer$ = VisualContainer.prototype;
var VisualElement = defineClass("VisualElement", EventAware, {
	init: function (dom, name) {
		this._super();
        this._name = name;
        this._parent = null;
        this._elements = null;
        this._dirty = false;
        this._mouseEnabled = true;
        this._hovered = false;
        this._mask = null;
        this._nodraw = false;
        this._context = null;
        this._graphics = null;
        this._drawings = new Drawings();
        this._cache = null;
	},
	destroy: function() {
		var elt;
		this._destroying = true;
        this._context = null;
        this._graphics = null;
		this._drawings = null;
		if (this._elements && _isArray(this._elements)) {
			for (var cnt = this._elements.length; cnt--;) {
				elt =this.removeElementAt(cnt);
				elt && !elt._destroying && elt.destroy && elt.destroy();
			}
			elt = null;
		}
		this._name = null;
        this._elements = null;
        this._cache = null;
        this._mask = null;
		this._x = null;
		this._y = null;
		this._width = null;
		this._height = null;
		this._rotation = null;
		this._super();
	},
	x: 0,
	y: 0,
	width: 0,
	height: 0,
	rotation: 0,
	visible: true,
	alpha: 1,
	renderCallback: null,
	right: function () {
		return this._x + this._width;
	},
	bottom: function () {
		return this._y + this._height;
	},
	setWidth: function (value) {
		value = Math.max(0, value);
		if (value != this._width) {
			this._width = value;
			this.invalidate();
		}
        return this;
	},
	setHeight: function (value) {
		value = Math.max(0, value);
		if (value != this._height) {
			this._height = value;
			this.invalidate();
		}
        return this;
	},
	setVisible: function (value) {
		if (value != this._visible) {
			this._visible = value;
			this.invalidate(true);
		}
        return this;
	},
	isCached: function () {
		return this._cache != null;
	},
	setCached: function (value) {
		if (value && !this._cache) {
			this._cache = new CanvasCache(_doc, this);
			this._cache.resize(this._width, this._height);
		} else if (!value && this._cache) {
			this._cache.dispose();
			this._cahce = null;
		}
	},
	isClickable: function () {
		return false;
	},
	name: function () {
		return this._name;
	},
	setName: function (value) {
		this._name = value;
	},
	container: function() {
		return this._parent && this._parent.container();
	},
	parent: function () {
		return this._parent;
	},
    parentAs: function(cls) {
        var p = this;
        while (p) {
            if (p instanceof cls) {
                return p;
            };
            p = p._parent;
        }
    },
	childCount: function () {
		return this._elements ? this._elements.length : 0;
	},
	isSingleton: function () {
		return this._parent.childCount() == 1;
	},
	position: function () {
		return { x: this._x, y: this._y };
	},
	bounds: function() {
		return new Rectangle(this._x, this._y, this._width, this._height);
	},
	clientRect: function() {
		return new Rectangle(0, 0, this._width, this._height);
	},
	mouseX: function () {
		var container = this.container();
		if (container) {
			var x = container._currentX;
			var p = this;
			while (p && p !== UNDEFINED) {
				x -= p._x;
				p = p._parent;
			}
			return x;
		} else {
			return NaN;
		}
	},
	mouseY: function () {
		var container = this.container();
		if (container) {
			var y = container._currentY;
			var p = this;
			while (p && p !== UNDEFINED) {
				y -= p._y;
				p = p._parent;
			}
			return y;
		} else {
			return NaN;
		}
	},
	mask: function () {
		return this._mask;
	},
	setMask: function (value) {
		this._mask = value ? value.clone() : null;
	},
	isLayer: function () {
		return false;
	},
	setMouseEnabled: function (value) {
		this._mouseEnabled = value;
	},
    canHover: function () {
        return true;
    },
	isHovered: function () {
		return this._hovered;
	},
	setHovered: function (value) {
		if (value != this._hovered) {
			this._hovered = value;
			if (this._hoveredChanged) {
				this._hoveredChanged();
			}
		}
	},
	propertyChanged: function (prop, newValue) {
		this.invalidate();
	},
	getChildren: function () {
		return this._elements && this._elements.concat();
	},
	getChild: function (index) {
		return this._elements ? this._elements[index] : null;
	},
	getChildIndex: function (child) {
		return this._elements ? this._elements.indexOf(child) : -1;
	},
	contains: function (child) {
		return this._elements ? this._elements.indexOf(child) >= 0 : false;
	},
	addChild: function (child, context) {
		return this.insertChild(-1, child, context);
	},
	addElement: function (child, context) {
		return this.addChild(child, context);
	},
	addContextElement: function (child) {
		return this.addChild(child, this._context);
	},
	insertChild: function (index, child, context) {
		if (child instanceof VisualElement && !this.contains(child)) {
			if (!this._elements) {
				this._elements = [];
			}
			if (index < 0) {
                if (this._dom) {
                    this._dom.appendChild(child._dom);
                } else {
                    child._context = context;
                }
                this._elements.push(child);
            } else {
                if (this._dom) {
                    this._elements.length > index ? this._dom.insertBefore(child._dom, this._elements[index]._dom) : this._dom.appendChild(child._dom);
                } else {
                    child._context = context;
                }
                this._elements.splice(index, 0, child);
            }
			child._parent = this;
			child.$_attached(this);
		}
		return child;
	},
	insertElement: function (index, child, context) {
		return this.insertChild(index, child, context);
	},
	removeChild: function (child) {
		if (child && this._elements) {
			var i = this._elements.indexOf(child);
			if (i >= 0) {
				return this.removeChildAt(i);
			}
		}
		return null;
	},
	removeElement: function (child) {
		return this.removeChild(child);
	},
	removeChildAt: function (index) {
		if (index >= 0 && index < this.childCount()) {
			var child = this._elements[index]; 
			this._elements.splice(index, 1);
            if (this._dom && child._dom) {
                this._dom.removeChild(child._dom);
            } else {
                child._context = null;
            }
			child._parent = null;
            child._dirty = false;
			child.$_detached(this);
			return child;
		}
		return null;
	},
	removeElementAt: function (index) {
		return this.removeChildAt(index);
	},
	clear: function () {
		var i,
			elts = this._elements,
			cnt = elts ? elts.length : 0;
		if (cnt > 0) {
			for (i = 0; i < cnt; i++) {
				elts[i]._parent = null;
				elts[i].$_detached(this);
			}
			this._elements = [];
            if (this._dom) {
                while (this._dom.lastChild) {
                    this._dom.removeChild(this._dom.lastChild);
                }
            }
			this.invalidate();
		}
	},
	hideAll: function () {
		var i,
			elts = this._elements,
			cnt = elts ? elts.length : 0;
        if (this._dom) {
            for (i = 0; i < cnt; i++) {
                elts[i].setVisible(false);
            }
        } else {
            for (i = 0; i < cnt; i++) {
                elts[i]._visible = false;
            }
        }
	},
	setTool: function (tool) {
        var i;
		var elts = this._elements;
		var cnt = elts ? elts.length : 0;
		if (tool) {
			this.$_tool = true;
			for (i = 0; i < cnt; i++) {
				elts[i].setTool(true);
			}
		} else if (this.$_tool) {
			this.$_tool = false;
			for (i = 0; i < cnt; i++) {
				elts[i].setTool(false);
			}
		}
	},
	invalidate: function (force, invalidteChildren) {
		if (force || !this._dirty) {
			var container = this.container();
			if (container) {
				container.invalidateElement(this);
				this._dirty = true;
			}
		}
		if (invalidteChildren) {
			var elts = this._elements;
            if (elts) {
                for (var i = elts.length; i--;) {
                    elts[i].invalidate(force, true);
                }
            }
		}
	},
	validate: function () {
		if (this._dirty) {
			this._dirty = false;
			var container = this.container();
			if (container) {
				container.validateElement(this);
			}
		}
	},
	invalidateLayout: function () {
		var container = this.container();
		if (container) {
			container.invalidateLayout();
		}
	},
	clip: function (g) {
	},
	getBounds: function(r) {
		if (!r) {
			return new Rectangle(this._x, this._y, this._width, this._height);
		} else {
			return r.set(this._x, this._y, this._width, this._height);
		}
	},
	getClientRect: function(r) {
		if (!r) {
			return new Rectangle(0, 0, this._width, this._height);
		} else {
			return r.set(0, 0, this._width, this._height);
		}
	},
	containsInBounds: function (x, y) {
		return (x >= this._x && x < this._x + this._width && y >= this._y && y < this._y + this._height);
	},
	containsInClient: function (x, y) {
		return (x >= 0 && x < this._width && y >= 0 && y < this._height);
	},
	parentToElement: function (parent, x, y) {
		var p = this;
		while (p && p != parent) {
			x -= p._x;
			y -= p._y;
			p = p._parent;
		}
		return { x: x, y: y };
	},
	translateBy: function (descendant, r) {
		var p = descendant;
		if (!r) {
			r = new Rectangle(0, 0, this._width, this._height);
		}
		while (p && p !== this) {
			r.x -= p._x;
			r.y -= p._y;
			p = p._parent;
		}
		return r;
	},
    topBy: function (parent, top) {
        var y = this._y + top;
        var p = this._parent;
        while (p && p !== parent) {
            y += p._y;
            p = p._parent;
        }
        return y;
    },
	boundsBy: function (parent, r) {
		var x = this._x;
		var y = this._y;
		var p = this._parent;
		if (r) {
			x += r.x;
			y += r.y;
		}
		while (p && p !== parent) {
			x += p._x;
			y += p._y;
			p = p._parent;
		}
		return r ? new Rectangle(x, y, r.width, r.height) : new Rectangle(x, y, this._width, this._height);
	},
	boundsByContainer: function (r) {
		var x = this._x;
		var y = this._y;
		if (r) {
			x += r.x;
			y += r.y;
		}
		var p = this._parent;
		while (p && p._x !== UNDEFINED) {
			x += p._x;
			y += p._y;
			p = p._parent;
		}
		return r ? new Rectangle(x, y, r.width, r.height) : new Rectangle(x, y, this._width, this._height);
	},
	boundsByScreen: function (r) {
		r = this.boundsByContainer(r);
		r = this.container().toScreen(r);
		return r;
	},
	containerToElement: function (x, y) {
		var p = this;
		while (p) {
			x -= p._x;
			y -= p._y;
			p = p._parent;
		}
		return { x: x, y: y };
	},
	move: function (x, y) {
		this.setX(x);
		this.setY(y);
	},
	resize: function (width, height) {
		this.setWidth(width);
		this.setHeight(height);
	},
	setSize: function (width, height) {
		this.setWidth(width);
		this.setHeight(height);
	},
	setPosition: function (x, y) {
		this.setX(x);
		this.setY(y);
	},
	setBounds: function (x, y, width, height) {
		this.setX(x);
		this.setY(y);
		this.setWidth(width);
		this.setHeight(height);
	},
	setBoundsI: function (x, y, width, height) {
		/*
		this.setX(x >>> 0);
		this.setY(y >>> 0);
		this.setWidth(width >>> 0);
		this.setHeight(height >>> 0);
		*/
		this.setX(x >> 0);
		this.setY(y >> 0);
		this.setWidth(width >> 0);
		this.setHeight(height >> 0);
	},
	setRect: function (r) {
		this.setX(r.x);
		this.setY(r.y);
		this.setWidth(r.width);
		this.setHeight(r.height);
	},
	setRectI: function (r) {
		this.setX(_floor(r.x));
		this.setY(_floor(r.y));
		this.setWidth(_floor(r.width));
		this.setHeight(_floor(r.height));
	},
	drawCache: function (g, cache) {
		if (this._dirty) {
			var cg = cache._graphics;
			this._dirty = false;
			this._graphics = cg;
			if (cache._element = this) {
				cache.resize(this._width, this._height);
				cache.prepare();
			} else {
				cg.save();
			}
			this._renderCallback ? this._renderCallback(cg) : this._doDraw(cg);
			cache.restore();
			$_validated++;
		}
		g.drawImage(cache._canvas, 0, 0, this._width, this._height, 0, 0, this._width, this._height);
	},
	draw: function (g, needOpaque) {
        this._dirty = false;
        this._renderCallback ? this._renderCallback(g) : this._doDraw(g, needOpaque);
        $_validated++;
	},
	draw2: function (g) {
		if (this._dirty) {
			this._dirty = false;
			this._drawings.clear(g);
			this._renderCallback ? this._renderCallback(this._drawings) : this._doDraw(this._drawings);
			$_validated++;
		} 
		this._drawings._render();
	},
	hitTest: function (x, y) {
		return x >= 0 && x < this._width && y >= 0 && y < this._height;
	},
	containerToLocal: function (pt) {
		var x = pt.x;
		var y = pt.y;
		var p = this;
		while (p) {
			x -= p._x;
			y -= p._y;
			p = p._parent;
		}
		return { x: x, y: y };
	},
	localToContainer: function (pt) {
		var x = pt.x;
		var y = pt.y;
		var p = this;
		while (p) {
			x += p._x;
			y += p._y;
			p = p._parent;
		}
		return { x: x, y: y };
	},
	findChildAt: function (x, y, hitTesting) {
		var i, elt, child, cx, cy;
		var elts = this._elements;
		var cnt = elts ? elts.length : 0;
		if (cnt > 0) {
			for (i = cnt - 1; i >= 0; i--) {
				elt = elts[i];
				if (elt.isVisible()) {
					cx = x - elt._x; 
					cy = y - elt._y;
					if (hitTesting || elt._mouseEnabled) {
						if (elt.isLayer() || elt.hitTest(cx, cy)) {
							child = elt.findChildAt(cx, cy, hitTesting);
							if (child) { 
								return child;
							}
							if (!elt.isLayer() && elt._mouseEnabled) {
								return elt;
							}
						}
					}
				}
			}
		}
		return null;
	},
	$_attached: function (parent) {
		this._doAttached(parent);
	},
	_doAttached: function (parent) {
	},
	$_detached: function (parent) {
		this._doDetached(parent);
	},
	/*
	_setContexted: function () {
		this._contexted = true;
	},
	*/
	_doDetached: function (parent) {
	},
	_doDraw: function (g, needOpaque) {
	},
	_hoveredChanged: function () {
	},
    $_prepareSpan: function () {
        if (!this._span) {
            this._span = document.createElement("span");
            this._span.style.position = "absolute";
            this._dom.appendChild(this._span);
        }
        return this._span;
    }
}, {
    addChild: function (parent, child) {
        parent.addChild(child);
    }
	/*
	addChild: function (parent, child, context) {
		if (child instanceof VisualElement && !parent.contains(child)) {
			if (!parent._elements) {
				parent._elements = [];
			}
			parent._elements.push(child);
			child._parent = parent;
			child._context = context;
			if (child._contexted) {
				VisualElement.$_setContexted(child);
			}
			child.$_attached(this);
		}
		return child;
	},
	$_setContexted: function (element) {
		var elts = element._elements;
		if (elts) {
			for (var i = elts.length; i--;) {
				elts[i]._context = element._context;
				VisualElement.$_setContexted(elts[i]);
			}
		}
	}
	*/
});
var VisualElement$ = VisualElement.prototype;
var RootElement = defineClass("RootElement", VisualElement, {
	init: function (dom, name, container, context) {
		this._super(dom, name);
		this._container = container;
		this._context = context;
	},
	container: function () {
		return this._container;
	}
});
var MaskElement = defineClass("MaskElement", VisualElement, {
	init: function (name, target, render) {
		this._super(false, name);
		this._target = target;
		this._render = render;
	},
	_doDraw: function (g) {
		if (this._render) {
			this._render(g, this._target);
		}
	}
});
var LayerElement = defineClass("LayerElement", VisualElement, {
	init: function (dom, name, clip) {
		this._super(dom, name);
        if (dom) {
            this._dom.style.pointerEvents = "none";
        } else {
            this._clip = clip;
            this._drawRect = null;
        }
	},
	destroy: function() {
		this._destroying = true;
		this._drawRect = null;
		this._super();
	},
	isLayer: function () {
		return true;
	},
	clip: function (g) {
		if (this._clip) {
			var r = this._drawRect = this._drawRect || new Rectangle();
			this.getClientRect(r);
			g.clipRect(r);
		}
	}
});
var Keys = _enum({
    BACK: 8,
    TAB: 9,
    ENTER: 13,
    ESC: 27,
    ESCAPE: 27,
    SPACE: 32,
    PAGEUP: 33,
    PAGEDOWN: 34,
    END: 35,
    HOME: 36,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    INSERT: 45,
    DELETE: 46,
    F2: 113,
    F3: 114,
    A: 65,
    D: 68,
    I: 73,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90
});
var Cursor = _enum({
    DEFAULT: "default",
    AUTO: "auto",
    POINTER: "pointer",
    WAIT: "wait",
    MOVE: "move",
    COL_RESIZE: "col-resize",
    ROW_RESIZE: "row-resize",
    CROSSHAIR: "crosshair",
    HORZ_RESIZE: "ew-resize",
    VERT_RESIZE: "ns-resize",
    NESW_RESIZE: "nesw-resize",
    NWSE_RESIZE: "nwse-resize",
    NO_DROP: "no-drop",
    NOT_ALLOWED: "not-allowed"
});
var _touchToOffset = function (container, touch) {
    if (!touch) { alert("no touch"); return; }
    if (!container) { alert('no container'); return; }
    if (!container._canvas) { alert('no canvas'); return; }
    /*
     이렇게 하면 값이 틀어지는 browser가 있다. androdi tab...
     var r = this._container._canvas.getBoundingClientRect();
     touch.x = touch.clientX - r.left;
     touch.y = touch.clientY - r.top;
     */
    var r = container._canvas.getBoundingClientRect();
    // touch.x = touch.pageX - (r.left + window.scrollX);
    // touch.y = touch.pageY - (r.top + window.scrollY);
     touch.x = touch.clientX - r.left;
     touch.y = touch.clientY - r.top;
    return touch;
}
var TouchManager = defineClass("TouchManager", null, {
    init: function (container) {
        this._super();
        this._container = container;
    },
    touchStart: function (event) {
    },
    touchMove: function (event) {
    },
    touchEnd: function (event) {
    },
    touchCancel: function (event) {
    },
    _toOffset: function (touch) {
        return _touchToOffset(this._container, touch);
    }
});
var DRAG_THRESHOLD = 3;
var VisualTool = defineClass("VisualTool", null, {
    init: function (owner, name) {
        this._super();
        this._owner = owner;
        this._name = name;
        this._dragTracker = null;
        this._clickX = 0;
        this._clickY = 0;
        this._currX = 0;
        this._currY = 0;
    },
    destroy: function() {
        this._destroying = true;
        this._currX = this._currY = this._clickX = this._clickY =  null;
        this._super();
    },
    dragTracker: null,
    owner: function () {
        return this._owner;
    },
    setDragTracker: function (value) {
        if (value !== this._dragTracker) {
            if (this._dragTracker) {
                this._dragTracker.deactivate();
            }
            this._dragTracker = value;
            if (this._dragTracker) {
                this._dragTracker.activate();
            }
        }
    },
    isDragging: function () {
        return this._dragTracker && this._dragTracker.isDragging();
    },
    clickX: function () {
        return this._clickX;
    },
    clickY: function () {
        return this._clickY;
    },
    currX: function () {
        return this._currX;
    },
    currY: function () {
        return this._currY;
    },
    isEditing: function () {
        return false;
    },
    touchManager: function () {
        return null;
    },
    activate: function () {
        this._doActivate();
    },
    deactivate: function () {
        this._doDeactivate();
    },
    keyDown: function (key, ctrl, shift, alt, event) {
        if (key === Keys.ESCAPE && this.isDragging()) {
            this._stopDragTracker(null, null, true);
            this.setDragTracker(null);
            return true;
        } else {
            return this._doKeyDown(key, ctrl, shift, alt, event);
        }
    },
    keyUp: function (key, ctrl, shift, alt, event) {
        return this._doKeyUp(key, ctrl, shift, alt, event);
    },
    keyPress: function(key) {
        return this._doKeyPress(key);
    },
    click: function (event) {
        if (event.offsetX && event.offsetY) {
            this._doClick(event.offsetX, event.offsetY);
        } else {
            this._doClick(event.mouseX, event.mouseY);
        }
    },
    dblclick: function (event) {
        if (event.offsetX && event.offsetY) {
            this._doDblClick(event.offsetX, event.offsetY);
        } else {
            this._doDblClick(event.mouseX, event.mouseY)
        }
    },
    mouseDown: function (event) {
        var x = this._currX = this._clickX = event.mouseX;
        var y = this._currY = this._clickY = event.mouseY;
        if (this.isDragging()) {
            var canceled = this.dragTracker() instanceof DragNDropTracker ? true : false;
            this._stopDragTracker(x, y, canceled);
            this.setDragTracker(null);
        }
        this._doMouseDown(event.mouseX, event.mouseY, event.ctrlKey, event.shiftKey, event.button, event);
    },
    mouseMove: function (event) {
        var x = this._currX = event.mouseX;
        var y = this._currY = event.mouseY;
        var ctrlKey = event.ctrlKey;
        var shiftKey = event.shiftKey
        var tracker = this.dragTracker();
        var request;
        if (tracker) {
            if (tracker.isDragging()) {
                if (event.buttons == undefined || event.buttons > 0 || (_ieOld && event.buttons >= 0)) {
                    if (!tracker.drag(x, y)) {
                        request = tracker.getNextRequest(x, y);
                        if (request) {
                            this._stopDragTracker(x, y, true);
                            this.setDragTracker(this._getDragTracker(request));
                            this._startDragTracker(x, y);
                        }
                    }
                } else {
                    this._stopDragTracker(x, y, true);
                }
            } else if (Math.abs(x - this._clickX) >= DRAG_THRESHOLD || Math.abs(y - this._clickY) >= DRAG_THRESHOLD) {
                this._startDragTracker(x, y);
            } else {
                this._doMouseMove(x, y);
            }
        } else {
            this._doMouseMove(x, y, ctrlKey, shiftKey);
        }
    },
    mouseUp: function (event) {
        var x = this._currX = event.mouseX;
        var y = this._currY = event.mouseY;
        if (this.isDragging()) {
            this.hasOwnProperty("_prevCheckIndex") && !(this._dragTracker instanceof ScrollThumbTracker) && (delete this._prevCheckIndex);
            this._stopDragTracker(x, y, false);
            return;
        } else {
            this._doMouseUp(x, y, event);
        }
    },
    mouseEnter: function (event) {
        this._doMouseEnter(event.mouseX, event.mouseY);
    },
    mouseLeave: function (event) {
        this._doMouseLeave(event.mouseX, event.mouseY);
    },
    mouseOver: function (event) {
        this._doMouseOver(event.mouseX, event.mouseY);
    },
    mouseOutside: function () {
        this._doMouseOutside();
    },
    mouseWheel: function (event) {
        return this._doMouseWheel(event /*event.mouseX, event.mouseY, event.wheelDelta, event.wheelDelta*/ );
    },
    touchStart: function (event) {
        this.touchManager() ? this.touchManager().touchStart(event) : this._doTouchStart(event);
    },
    touchMove: function (event) {
        this.touchManager() ? this.touchManager().touchMove(event) : this._doTouchMove(event);
    },
    touchEnd: function (event) {
        this.touchManager() ? this.touchManager().touchEnd(event) : this._doTouchEnd(event);
    },
    touchCancel: function (event) {
        this.touchManager() ? this.touchManager().touchCancel(event) : this._doTouchCancel(event);
    },
    findElementAt: function (x, y, hitTesting) {
        return this._owner.findElementAt(x, y, hitTesting);
    },
    setFocus: function () {
        return this._doSetFocus();
    },
    _doActivate: function () {
        trace("tool: " + "activated");
    },
    _doDeactivate: function () {
        trace("tool: " + "deactivated");
    },
    _doKeyDown: function (key, ctrl, shift, alt) {
        trace("tool: " + "keyDown(" + key + ")");
        return false;
    },
    _doKeyUp: function (key, ctrl, shift, alt) {
        trace("tool: " + "keyUp(" + key + ")");
        return false;
    },
    _doKeyPress: function(key) {
        trace("tool: " + "keyPress("+ key + ")");
    },
    _doClick: function (x, y) {
        trace("tool: " + "click(" + x + "," + y + ")");
    },
    _doDblClick: function (x, y) {
        trace("tool: " + "dblClick(" + x + "," + y + ")");
    },
    _doMouseDown: function (x, y) {
        trace("tool: " + "mouseDown(" + x + "," + y + ")");
    },
    _doMouseMove: function (x, y) {
        trace("tool: " + "mouseMove(" + x + "," + y + ")");
    },
    _doMouseUp: function (x, y) {
        trace("tool: " + "mouseUp(" + x + "," + y + ")");
    },
    _doMouseEnter: function (x, y) {
        trace("tool: " + "mouseEnter(" + x + "," + y + ")");
    },
    _doMouseLeave: function (x, y) {
        trace("tool: " + "mouseLeave(" + x + "," + y + ")");
    },
    _doMouseOver: function (x, y) {
        trace("tool: " + "mouseOver(" + x + "," + y + ")");
    },
    _doMouseOutside: function () {
    },
    _doMouseWheel: function (event /*x, y, deltaX, deltaY*/ ) {

        trace("tool: " + "mouseWheel(" + event.deltaX + "," + event.deltaY + ")");
        return false;
    },
    _doTouchStart: function (event) {
        trace("tool: " + "touchStart");
    },
    _doTouchMove: function (event) {
        trace("tool: " + "touchMove");
    },
    _doTouchEnd: function (event) {
        trace("tool: " + "touchEnd");
    },
    _doTouchCancel: function (event) {
        trace("tool: " + "touchCancel");
    },
    _startDragTracker: function (x, y, shift) {
        if (this._dragTracker) {
            if (this._dragTracker.start(x, y, shift)) {
                this._doDragTrackerStarted(this._dragTracker);
            } else {
                this._dragTracker = null;
            }
        }
    },
    _stopDragTracker: function (x, y, canceled) {
        if (this.isDragging()) {
            var tracker = this._dragTracker;
            if (canceled) {
                tracker.cancel();
            } else {
                tracker.drop(x, y);
            }
            this.setDragTracker(null);
            this._doDragTrackerFinished(tracker, canceled);
            this._owner && this._owner.invalidate && this._owner.invalidate();
        }
    },
    _doDragTrackerStarted: function (dragTracker) {
        trace("dragTracker started: " + dragTracker.name());
    },
    _doDragTrackerFinished: function (dragTracker, canceled) {
        trace("dragTracker stopped: " + dragTracker.name() + ", " + (canceled ? "canceled" : "completed"));
    },
    _doSetFocus: function () {
    }
});
var EditRequest = defineClass("EditRequest", null, {
    init : function() {
        this._super();
    },
    cursor: function () { return Cursor.AUTO; },
    source: function () { return null; },
    isSelectable: function () { return false; },
    isDblClickable: function () { return false; }
});
var DragTracker = defineClass("DragTracker", null, {
    init : function(container, name, x, y) {
        this._super();
        this._container = container;
        this._name = name;
        this._active = false;
        this._completed = false;
        this._dragging = false;
        this._startX = x;
        this._startY = y;
        this._currentX = 0;
        this._currentY = 0;
    },
    cancelabel: false,
    container: function () {
        return this._container;
    },
    name: function () {
        return this._name;
    },
    isActive: function () {
        return this._active;
    },
    isDragging: function () {
        return this._dragging;
    },
    startWhenCreated: function () {
        return false;
    },
    isCompleted: function () {
        return this._completed;
    },
    activate : function() {
        if (!this._active) {
            this._doActivate();
            this._active = true;
        }
    },
    deactivate : function() {
        if (this._active) {
            this.cancel();
            this._doDeactivate();
            this._active = false;
        }
    },
    start: function (x, y, shift) {
        this.cancel();
        if (this._active && this._doStart(x, y, shift)) {
            this._currentX = this._startX = x;
            this._currentY = this._startY = y;
            this._dragging = true;
            this._completed = false;
            this._showFeedback(x, y);
            return true;
        }
        return false;
    },
    drag: function (x, y) {
        if (this._dragging) {
            this._currentX = x;
            this._currentY = y;
            if (this._doDrag(x, y)) {
                this._moveFeedback(x, y);
                return true;
            }
        }
        return false;
    },
    cancel: function () {
        try {
            if (this._dragging) {
                try {
                    this._dragging = false;
                    this._doCanceled();
                } finally {
                    this._doEnded();
                }
            }
        } finally {
            this._hideFeedback();
        }
    },
    drop: function (x, y) {
        try {
            if (this._dragging) {
                try {
                    this._currentX = x;
                    this._currentY = y;
                    this._dragging = false;
                    if (this._canAccept(x, y)) {
                        this._doCompleted(x, y);
                        this._completed = true;
                    } else {
                        this._doCanceled(x, y);
                    }
                } finally {
                    this._doEnded();
                }
            }
        } finally {
            this._hideFeedback();
        }
    },
    getNextRequest: function (x, y) {
        return null;
    },
    startX: function () {
        return this._startX;
    },
    startY: function () {
        return this._startY;
    },
    currentX: function () {
        return this._currentX;
    },
    currentY: function () {
        return this._currentY;
    },
    offsetX: function () {
        return this._currentX - this._startX;
    },
    offsetY: function () {
        return this._currentY - this._startY;
    },
    _showFeedback: function (x, y) {
    },
    _moveFeedback: function (x, y) {
    },
    _hideFeedback: function () {
    },
    _doActivate : function () {
        trace(this._name + " activated");
    },
    _doDeactivate : function () {
        trace(this._name + " deactivated");
    },
    _doStart: function (x, y) {
        return true;
    },
    _doDrag: function (x, y) {
        return true;
    },
    _doCanceled: function () {
    },
    _canAccept: function (x, y) {
        return true;
    },
    _doCompleted: function () {
    },
    _doEnded: function () {
    },
    _findElementAt: function (x, y, hitTesting) {
        return this._container.findElementAt(x, y, hitTesting);
    }
});
var SingleTouchTracker = defineClass("SingleTouchTracker", null, {
    init: function () {
        this._super();
    },
    start: function (x, y) {
    },
    move: function (x, y) {
    },
    stop: function (x, y) {
    }
});
var $_TAP_THRESHOLD = 4;            // pixels
var $_DOUBLE_TAP_THRESHOLD = 300;   // milliseconds
var $_LONG_TAP_THRESHOLD = 500;     // milliseconds
var $_SWIPE_THRESHOLD = 20;         // pixels
var SingleTouchManager = defineClass("SingleTouchManager", TouchManager, {
    init: function (container) {
        this._super(container);
        this._touchId = undefined;
        this._started = null;
        this._seconded = null;
        this._startX = NaN;
        this._startY = NaN;
        this._tapped = 0;
        this._dragging = false;
        this._prevX = NaN;
        this._prevY = NaN;
        this._longTapTimer = undefined;
        this._tracker = null;
        this._events = [];
        this._touches = [];
        this._longTapDuration = $_LONG_TAP_THRESHOLD;
        this._doubleTapInterval = $_DOUBLE_TAP_THRESHOLD;
        this._tapThreshold = $_TAP_THRESHOLD;
    },
    touchHandler: null,
    tapHandler: null,
    doubleTapHandler: null,
    longTapHandler: null,
    dragStartHandler: null,
    dragHandler: null,
    dragEndHandler: null,
    swipeHandler: null,
    longTapDuration: null,
    doubleTapInterval: null,
    tapThreshold:null,
    isSingleTouch: function () {
        return this._touches.length == 1;
    },
    removeTouches: function (touches) {
        var t, idx;
        for (var i = 0, len = touches.length; i < len; i++) {
            var t = touches[i];
            if ((idx = this._touches.indexOf(t.identifier)) > -1) {
                this._touches.splice(idx, 1);
            }
        }       
    },
    touchStart: function (evt/*TouchEvent*/) {
        clearTimeout(this._longTapTimer);
        var touches = evt.changedTouches;
        _trace("#### touch Start", evt.touches.length, this._touches.length);

        if (evt.touches.length > 1 || this._touches.length > 0) {
            for (var i = 0, len = touches.length; i < len; i++) {
                var t = touches[i];
                this._touches.push(t.identifier);
            }
        } else if (touches.length > 0) {
            var t = this._toOffset(touches[0]);
            if (this._tracker) {
                this._tracker.stop(t.x, t.y);
                this._tracker = null;
            }
            this._touchId = t.identifier;
            this._touches.push(t.identifier);
            this._dragging = false;
            if (this._touchHandler && (this._tracker = this._touchHandler(evt, t.x, t.y))) {
                this._tracker.start(t.x, t.y);
                return;
            }
            if (this._tapped == 0) {
                this._started = getTimer();
                this._prevX = this._startX = t.x;
                this._prevY = this._startY = t.y;
            } else {
                this._seconded = getTimer();
                this._prevX = t.x;
                this._prevY = t.y;
            }
            this._events = [];
            this._events.push({ x: t.x, y: t.y, t: evt.timeStamp });

            this._longTapTimer = setTimeout(function () {
                if (this._longTapHandler && this._longTapHandler(this._startX, this._startY)) {
                    this._touchId = undefined;
                    this._tapped = 0;
                }
            }.bind(this), this._longTapDuration);
        } else {
            alert("no touch ?");
        }
    },
    touchMove: function (evt) {
        var t = this.$_findTouch(evt);
        _trace("#### touch Move", t, this.isSingleTouch());
        if (t && this.isSingleTouch()) {
            // evt.preventDefault();
            if (this._tracker) {
                evt.cancelable && evt.preventDefault();
                this._tracker.move(t.x, t.y);
                return;
            }
            if (this._dragging) {
                var drag = this._dragHandler && this._dragHandler(this._prevX, this._prevY, t.x, t.y);
                if (drag) {
                    evt.cancelable && evt.preventDefault();                    
                }
            } else if (Math.abs(this._prevX - t.x) > this._tapThreshold || Math.abs(this._prevY - t.y) > this._tapThreshold) {
                clearTimeout(this._longTapTimer);
                this._tapped = 0;
                this._dragging = true;
                var drag = this._dragStartHandler && this._dragStartHandler(this._startX, this._startY, t.x, t.y);
                evt.cancelable && evt.preventDefault();
            } else {
                evt.cancelable && evt.preventDefault();
            }
            this._prevX = t.x;
            this._prevY = t.y;
            this._events.push({ x: t.x, y: t.y, t: evt.timeStamp });
            if (this._events.length > 30) this._events.splice(0, 15);
        }
    },
    touchEnd: function (evt) {
        clearTimeout(this._longTapTimer);
        _trace("#### touch end", this.isSingleTouch());
        if (this._touchId === undefined) {
            this.removeTouches(evt.changedTouches);
            return;
        }
        var t = this.$_findTouch(evt);
        if (t && this.isSingleTouch()) {
            evt.cancelable && evt.preventDefault();
            var container = this._container;
            container._currentX = t.x;
            container._currentY = t.y;
            try {
                if (this._tracker) {
                    this._tracker.stop(t.x, t.y);
                } else if (this._dragging) {
                    this._touchId = undefined;
                    this._tapped = 0;
                    this._swipeHandler && this.$_checkSwipe();
                } else if (this._tapped == 0) {
                    this._tapped = 1;
                    this._tapHandler && this._tapHandler(this._startX, this._startY);
                } else if (this._tapped == 1) {
                    this._touchId = undefined;
                    var t = getTimer();
                    if (t - this._started < this._doubleTapInterval) {
                        this._tapped = 0;
                        this._doubleTapHandler && this._doubleTapHandler(this._startX, this._startY);
                    } else {
                        this._tapped = 1;
                        this._started = this._seconded;
                        this._startX = this._prevX;
                        this._starty = this._prevY;
                        this._tapHandler && this._tapHandler(this._prevX, this._prevY);
                    }
                } else {
                    alert("touch end");
                }
            } catch (e) {

            }
        }
        this._tracker = null;
        this.removeTouches(evt.changedTouches);
        _isiOS && (this._touchEndt = getTimer())
    },
    touchCancel: function (evt) {
        evt.preventDefault();
        this.removeTouches(evt.changedTouches);
        clearTimeout(this._longTapTimer);
        var t = this.$_findTouch(evt);
        if (t) {
            if (this._tracker) {
                this._tracker.stop(t.x, t.y);
            }
        }
        this._tracker = null;
    },
    $_findTouch: function (evt) {
        var touches = evt.changedTouches;
        for (var i = 0; i < touches.length; i++) {
            var t = touches[i];
            if (t.identifier == this._touchId) {
                return this._toOffset(t);
            }
        }
        return null;
    },
    $_checkSwipe: function () {
        /*
        var d =  Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        var a = Math.round(Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI);
        if (a < 0) a = 360 + a;
        alert(a + ", " + this._velocity);
        */
        var events = this._events;
        var cnt = events.length;
        if (cnt < 2) return;
        var e2 = events[cnt - 1];
        var e1 = events[cnt - 2];
        for (var i = cnt - 3; i >= 0; i--) {
            if (e2.t - e1.t > 100) {
                break;
            }
            e1 = events[i];
        }
        var x1 = e1.x;
        var y1 = e1.y;
        var x2 = e2.x;
        var y2 = e2.y;
        var d =  Math.sqrt(Math.pow(x1 - x2, 2) + Math.pow(y1 - y2, 2));
        var dt = Math.max(16, e2.t - e1.t);
        var v = d / dt;
        var minv = 0.1;
        var friction = 0.998;
        if (v > minv) {
            var duration = Math.log(minv / v) / Math.log(friction);
            var distance = v * (1 - Math.pow(friction, duration + 1)) / (1 - friction);
            var dir = "right";
            var a = Math.round(Math.atan2(y2 - y1, x2 - x1) * 180 / Math.PI);
            if (a < 0) a = 360 + a;
            if (a > 45 && a <= 135) dir = "bottom";
            else if (a > 135 && a <= 225) dir = "left";
            else if (a > 225 && a <= 315) dir = "top";
            this._swipeHandler(duration, distance, dir);
        }
    }
});
var MobileContextMenu = defineClass("MobileContextMenu", null, {
    init: function () {
        this._super("focusView");
    },
    show: function (menu) {
    },
    close: function () {
    }
});
var MobileContextMenuView = defineClass("MobileContextMenuView", EventAware, {
    init: function (container/*VisualContainer*/) {
        this._super();
        this._container = container;
        this._dom = new Dom(this.$_createElement());
    },
    show: function (menu) {
    },
    close: function () {
    },
    $_createElement: function () {
    }
});
var ValueType = _enum({
	TEXT: "text",
	NUMBER: "number",
	BOOLEAN: "boolean",
	DATETIME: "datetime",
	OBJECT: "object",
	CHAR: "char",
	UNUM: "unum",
	INT: "int",
	UINT: "uint",
	DATE: "date"
});
var RowState = _enum({
	NONE: "none",
	CREATED: "created",
	UPDATED: "updated",
	DELETED: "deleted",
	CREATE_AND_DELETED: "createAndDeleted",
	isDeleted: function (value) {
		return value == RowState.DELETED || value == RowState.CREATE_AND_DELETED;
	}
});
var RestoreMode = _enum({
	NONE: "none",
	AUTO: "auto",
	EXPLICIT: "explicit"
});
var TextInputCase = _enum({
	NORMAL: "normal",
	UPPER: "upper",
	LOWER: "lower",
	DEFAULT: "default"
});
var ItemState = _enum({
	NORMAL: "normal",
	FOCUSED: "focused",
	UPDATING: "updating",
	INSERTING: "inserting",
	APPENDING: "appending",
	DUMMY:"dummy",
	isEditing: function (state) {
		return state == ItemState.UPDATING || state == ItemState.INSERTING || state == ItemState.APPENDING;
	},
	isInserting: function (state) {
		return state == ItemState.INSERTING || state == ItemState.APPENDING;
	}
});
var PagingSource = _enum({
	ROWS: "rows",
	ITEMS: "items"
});
var ColumnGroupOrientation = _enum({
	HORIZONTAL: "horizontal",
	VERTICAL: "vertical"
});
var ButtonState = _enum({
	UP: "up",
	HOVER: "hover",
	DOWN: "down"
});
var ClickBehavior = _enum({
	NONE: 0,
	SORT: 1
});
var HandleVisibility = _enum({
	VISIBLE: "visible",
	HOVERED: "hovered",
	ALWAYS: "always",
	HIDDEN: "hidden"
});
var SortMode = _enum({
    AUTO: "auto",
    EXPLICIT: "explicit"
});
var SortStyle = _enum({
	NONE: "none",
	EXCLUSIVE: "exclusive",
	INCLUSIVE: "inclusive",
	REVERSE: "reverse"
});
var SortDirection = _enum({
	ASCENDING: "ascending",
	DESCENDING: "descending"
});
var SortCase = _enum({
    SENSITIVE: "sensitive",
    INSENSITIVE: "insensitive"
});
var FilterMode = _enum({
    AUTO: "auto",
    EXPLICIT: "explicit"
});
var CellButton = _enum({
	NONE: "none",
	ACTION: "action",
	POPUP: "popup",
	IMAGE: "image"
});
var ButtonVisibility = _enum({
    ALWAYS: "always",
    DEFAULT: "default",
    VISIBLE: "visible",
    HIDDEN: "hidden",
    ROWFOCUSED:"rowfocused"
});
var LookupCase = _enum({
	SENSITIVE: "sensitvie",
	INSENSITIVE: "insensitive",
	LOWER: "lower",
	UPPER: "upper"
});
var ValidationLevel = _enum({
	ERROR: "error",
	WARNING: "warning",
	INFO: "info",
	IGNORE: "ignore"
});
var IndicatorValue = _enum({
	NONE: "none",
	INDEX: "index",
	ROW: "row"
});
var GridFitStyle = _enum({
	NONE: "none",
	EVEN: "even",
	EVEN_FILL: "evenFill",
	FILL: "fill"
});
var RowGroupAdornments = _enum({
	BOTH: "both",
	HEADER: "header",
	FOOTER: "footer",
	NONE: "none",
	SUMMARY:"summary",
	isHeader: function (v) {
		return v == "both" || v == "header";
	},
	isFooter: function (v) {
		return v == "both" || v == "footer";
	},
	isFooterOnly: function(v) {
		return v == "footer" || v == "summary";
	}
});
var RowGroupCellDisplay = _enum({
	NORMAL: "normal",
	MERGE: "merge",
	HIDE: "hide"
});
var RowGroupFooterVisibility = _enum({
	ALWAYS: "always",
	MULTI_ROWS_ONLY: "multiRowsOnly"
});
var SummaryMode = _enum({
	NONE: "none",
	AGGREGATE: "aggregate",
	STATISTICAL: "statistical"
});
var SelectionMode = _enum({
	NONE: "none",
	SINGLE: "single",
	EXTENDED: "extended"
});
var SelectionStyle = _enum({
	BLOCK: "block",
	ROWS: "rows",
	COLUMNS: "columns",
	SINGLE_ROW: "singleRow",
	SINGLE_COLUMN: "singleColumn",
	SINGLE: "single",
	NONE: "none",
	isSingle: function (value) {
		return value && (value == SelectionStyle.SINGLE_ROW || value == SelectionStyle.SINGLE_COLUMN || value == SelectionStyle.SINGLE);
	},
	isRow: function (value) {
		return value && (value == SelectionStyle.ROWS || value == SelectionStyle.SINGLE_ROW);			
	},
	isColumn: function (value) {
		return value && (value == SelectionStyle.COLUMNS || value == SelectionStyle.SINGLE_COLUMN);			
	}
});
var BlankState = _enum({
	NONE: "none",
	HEAD: "head",
	BODY: "body",
	TAIL: "tail"
});
var MenuItemType = _enum({
    NORMAL: "normal",
    CHECK: "check",
    RADIO: "radio",
    SEPARATOR: "separator"
});
var ColumnHeaderItemLocation = _enum({
    NONE: "none",
    LEFT_EDGE: "leftEdge",
    RIGHT_EDGE: "rightEdge",
    TOP_EDGE: "topEdge",
    BOTTOM_EDGE: "bottomEdge",
    LEFT: "left",
    RIGHT: "right",
    TOP: "top",
    BOTTOM: "bottom",
    CENTER: "center"
});
var SubTextLocation = _enum({
    DEFAULT: "default",
    NONE: "none",
    LEFT: "left",
    RIGHT: "right",
    UPPER: "upper",
    LOWER: "lower",
	LEFT_FILL: "leftFill",
	RIGHT_FILL: "rightFill",
	UPPER_FILL: "upperFill",
	LOWER_FILL: "lowerFill"
});
var TextWrapMode = _enum({
	NONE: "none",
	EXPLICIT: "explicit",
	ELLIPSE: "ellipse",
	NORMAL: "normal"
});
var TextOverflow = _enum({
	CLIP: "clip",
	ELLIPSIS: "ellipsis",
	PATH: "path"
});
var Alignment = _enum({
	NEAR: "near",
	CENTER: "center",
	FAR: "far"
});
var IconLocation = _enum({
	LEFT: "left",
	RIGHT: "right",
	TOP: "top",
	BOTTOM: "bottom",
	CENTER: "center",
	NONE: "none"
});
var ContentFit = _enum({
	NONE: "none",
	CENTER: "center",
	BOTH: "both",
	WIDTH: "width",
	HEIGHT: "height",
	AUTO: "auto"
});
var SelectionDisplay = _enum({
	MASK: "mask",
	INVERSION: "inversion"
});
var ValidationLevel = {
	ERROR: "error",
	WARNING: "warning",
	INFO: "info",
	IGNORE: "ignore"
};
var ValidationMode = {
	ALWAYS: "always", 
	UPDATE: "update",
	INSERT: "insert"
};
var VerticalMovingStep = _enum({
	ROW: "row",
	CELL: "cell",
	DEFAULT: "default"
});
var StateMark = _enum({
	DEFAULT: "default",
	TEXT: "text",
	NONE: "none",
	IMAGE: "image"
});
var HeaderHeightFill = _enum({
	DEFAULT: "default",
	FIXED: "fixed"
});
var RowFocusMask = _enum({
	ROW: "row",
	DATA: "data",
	FILL: "fill",
	CELL: "cell"
});
var ChangingMode = _enum({
	BEFORE_EDITCOMMIT: "beforeEditCommit",
	NORMAL: "normal"
});
var EdgeMark = _enum({
    LEFT_TOP: "leftTop",
    LEFT_BOTTOM: "leftBottom",
    RIGHT_TOP: "rightTop",
    RIGHT_BOTTOM: "rightBottom"
});    
var BackgroundImageLocation = _enum({
	LEFT: "left",
	RIGHT: "right",
	TOP: "top",
	BOTTOM: "bottom",
	LEFT_TOP: "leftTop",
	LEFT_BOTTOM: "leftBottom",
	RIGHT_TOP: "rightTop",
	RIGHT_BOTTOM: "rightBottom",
	CENTER: "center"
});
var DropDownValueLabel = _enum({
	VALUE: "value",
	LABEL: "label",
	VALUE_LABEL: "valueLabel",
	LABEL_VALUE: "labelValue"
});
var DefaultShowDate = _enum({
	NORMAL: "normal",
	TODAY: "today",
	TODAY_WHEN_NULL: "todayWhenNull"
})

var ScrollOnEditing = _enum({
	DEFAULT: "default",
	CANCEL: "cancel",
	COMMIT: "commit"
})
var SearchOptions = function (source) {
	this.allFields = true;
	this.caseSensitive = false;
	this.partialMath = false;
	this.regularExpression = false;
	source && _extend(this, source);
};
var SearchCellOptions = function (source) {
	this.fields = null;
	this.caseSensitive = false;
	this.partialMatch = false;
	this.regularExpression = false;
	this.columns = null;
	source && _extend(this, source);
};
var Dimension = defineClass("Dimension", null, {
	init: function (size) {
		this._super();
		this._value = NaN;
		this._valuePercent = false;
		this._minimum = NaN;
		this._minimumPercent = false;
		this._maximum = NaN;
		this._maximumPercent = false;
		if (size) {
			this.setSize(size);
		}
	},
	size: null,
	minSize: null,
	maxSize: null,
	setSize: function (value) {
		if (value != this.size) {
			this._size = value;
			var sz = this.parse(value);
			this._value = sz.value;
			this._valuePercent = sz.percent;
		}
	},
	setMinSize: function (value) {
		if (value != this.minSize) {
			this._minSize = value;
			var sz = this.parse(value);
			this._minimum = sz.value;
			this._minimumPercent = sz.percent;
		}
	},
	setMaxSize: function (value) {
		if (value != this.maxSize) {
			this._maxSize = value;
			var sz = this.parse(value);
			this._maximum = sz.value;
			this._maximumPercent = sz.percent;
		}
	},
	getDimension: function (bounds) {
		var v,
			d = bounds;
		if (!isNaN(this._value)) {
			d = this._value ? (this._valuePercent ? this._value * bounds / 100 : this._value) : 0;
		}
		if (!isNaN(this._minimum)) {
			v = this._minimum ? (this._minimumPercent ? this._minimum * bounds / 100 : this._minimum) : 0;
			d = Math.max(v, d);
		}
		if (!isNaN(this._maximum)) {
			v = this._maximum ? (this._maximumPercent ? this._maximum * bounds / 100 : this._maximum) : 0;
			d = Math.min(v, d);
		}
		return d;
	},
	equals: function (d) {
		return this._value == d._value &&
			this._valuePercent == d._valuePercent &&
			this._minimum == d._minimum &&
			this._minimumPercent == d._minimumPercent &&
			this._maximum == d._maximum &&
			this._maximumPercent == d._maximumPercent;
	},
	toString: function () {
		return this._size || "";
	},
	parse: function (size) {
		var v = { value: NaN, percent:false };
		if (size) {
			size = String(size).trim();
			if (size) {
				var len = size.length;
				v.percent = size.charAt(len - 1) == "%";
				if (v.percent) {
					size = size.substring(0, len - 1);
					len = size.length;
					if (len > 0) {
						v.value = Number(size);	
					}
				} else {
					v.value = Number(size);
				}
			}
		}
		return v;
	}
}, {
	createFrom: function (value) {
		var d = null;
		if (value) {
			var s = value.trim();
			var len = s.length;
			if (len > 0) {
				var arr = s.split(",");
				if (arr.length > 0) {
					s = arr[o] && arr[0].trim();
					if (s) {
						d = new Dimension();
						d.setSize(s);
					}
				}
				if (arr.length > 1) {
					s = arr[1] && arr[1].trim();
					if (s) {
						d = new Dimension();
						d.setMinSize(s);
					}
				}
				if (arr.length > 2) {
					s = arr[2] && arr[2].trim();
					if (s) {
						d = new Dimension();
						d.setMaxSize(s);
					}
				}
			}
		}
		return d;
	},
	areEquals: function (v1, v2) {
		if (v1 === v2) return true;
		if (!v1 || !v2) return false;
		return v1.equals(v2);
	}
});

var CellIndex = defineClass("CellIndex", null, {
	init: function (grid, itemIndex, column, step) {
		this._super(true);
		this._grid = grid;
		this._itemIndex = isNaN(itemIndex) ? -1 : itemIndex;
		this._column = column;
		this._verticalStep = step ? step : VerticalMovingStep.DEFAULT;
		this._item = null;
	},
	verticalStep: VerticalMovingStep.DEFAULT,
	grid: function () {
		return this._grid;
	},
	itemIndex: function (value) {
		if (arguments.length > 0) {
			this._itemIndex = value;
			return this;
		} else {
			return this._itemIndex;
		}
	},
	setItemIndex: function (value) {
		this._itemIndex = value;
		return this;
	},
	column: function (value) {
		if (arguments.length > 0) {
			this._column = value;
			return this;
		} else {
			return this._column;
		}
	},
	setColumn: function (value) {
		this._column = value;
	},
	dataColumn: function () {
		return (this._column instanceof DataColumn) && this._column;
	},
	valueColumn: function () {
		return (this._column instanceof ValueColumn) && this._column;
	},
	group: function () {
		return (this._column instanceof ColumnGroup) && this._column;
	},
	I: function () {
		return this._itemIndex;
	},
	C: function () {
		return this._column;
	},
	col: function () {
		return this._column.index();
	},
	dataField: function () {
		return (this._column instanceof DataColumn) ? this._column.dataIndex() : -1;
	},
	item: function () {
		return (this._grid && this._grid.getItem(this._itemIndex)) || this._item;
	},
	dataRow: function () {
		var item = this.item();
		return item ? item.dataRow() : -1;
	},
	dataId: function () {
		var item = this.item();
		return item ? item.dataId() : -1;
	},
	value: function () {
		var column = this._column;
		if (column instanceof DataColumn) {
			var fld = column.dataIndex();
			if (fld < 0) {
				throw new Error("Not exists data field: " + column.fieldName());
			}
			var item = this.item();
			if (!item) {
				throw new Error("Invalid item index: " + this._itemIndex);
			}
			return item.getData(fld);
		}
		return UNDEFINED;
	},
	isFixed: function () {
		if (this._grid && this._column && this._column.isVisible()) {
			var lm = this._grid.layoutManager();
			var rootIndex = this._column.root().displayIndex();
			return rootIndex < lm.fixedColCount() || rootIndex >= lm.rfixedStartCol() || 
				 (this._itemIndex >= 0 && this._itemIndex < lm.fixedItemCount());
		}
		return false;
	},
    isFixedCol: function () {
        if (this._grid && this._column && this._column.isVisible()) {
            var lm = this._grid.layoutManager();
            var rootIndex = this._column.root().displayIndex();
            return rootIndex < lm.fixedColCount();
        }
        return false;
    },
    isRightFixedCol: function () {
        if (this._grid && this._column && this._column.isVisible()) {
            var lm = this._grid.layoutManager();
            var rootIndex = this._column.root().displayIndex();
            return rootIndex >= lm.rfixedStartCol();
        }
        return false;
    },
    isFixedRow: function () {
        if (this._grid && this._column) {
            var lm = this._grid.layoutManager();
            return this._itemIndex < lm.fixedItemCount();
        }
        return false;
    },
	isTop: function () {
		var column = this._column;
		if (column && column.group()) {
			return ColumnGroup.isTop(column);
		} else {
			return true;
		}
	},
	isBottom: function () {
		var column = this._column;
		if (column && column.group()) {
			return ColumnGroup.isBottom(column);
		} else {
			return true;
		}
	},
	isLeft: function () {
		var column = this._column;
		if (column) {
			if (column.group()) {
				return column.group().displayIndex() == 0 && ColumnGroup.isLeft(column); 
			} else {
				return column.displayIndex() == 0;
			}
		}
		return false;
	},
	isRight: function () {
		var column = this._column;
		if (column) {
			if (column.group()) {
				return column.group().displayIndex() == 0 && ColumnGroup.isRight(column); 
			} else {
				return column.displayIndex() == this._grid.visibleColumnCount() - 1;
			}
		}
		return false;
	},
    isFirst: function () {
        if (this._column) {
            if (this._grid && this._grid.visibleColumnCount() > 0) {
                var column = this._grid.getVisibleColumn(0);
                column = column instanceof ValueColumn ? column : column.root().first();
                return column == this._column;
            }
        }
        return false;
    },
    isEditableFirst: function() {
    	var grid = this._grid;
    	var column;
    	if (grid && this._column) {
    		var columns = grid.collectColumns(true, true, true);
    		var idx = columns.indexOf(this._column);
    		for (var i=idx-1; i-- ;) {
    			column = columns[i];
    			if (column instanceof SeriesColumn) {
    				return false;
    			}
    			if (column.isEditable() && !column.isReadOnly() && column.isVisible()) {
    				return false;
    			}
    		}
    	}
    	return true;
    },
    isLast: function () {
        if (this._column) {
            if (this._grid && this._grid.visibleColumnCount() > 0) {
                var column = this._grid.getVisibleColumn(this._grid.visibleColumnCount() - 1);
                column = column instanceof ValueColumn ? column : column.root().last();
                return column == this._column;
            }
        }
        return false;
    },
    isEditableLast:function() {
    	var grid = this._grid;
    	var column;
    	if (grid && this._column) {
    		var columns = grid.collectColumns(true, true, true);
    		var idx = columns.indexOf(this._column);
    		for (var i=idx+1,cnt=columns.length; i < cnt ; i++) {
    			column = columns[i];
    			if (column instanceof SeriesColumn) {
    				return false;
    			}
    			if (column.isEditable() && !column.isReadOnly() && column.isVisible()) {
    				return false;
    			}
    		}
    	}
    	return true;
    },
	editable: function () {
		var item = this.item();
		return item && (item.dataRow() >= 0 || item.itemState() == ItemState.INSERTING || item.itemState() == ItemState.APPENDING);
	},
	clone: function () {
		return new CellIndex(this._grid, this._itemIndex, this._column, this._verticalStep);
	},
	assign: function (source) {
		if (source) {
			source.grid && (this._grid = source._grid);
			this._itemIndex = source._itemIndex;
			this._column = source._column;
			this._verticalStep = source._verticalStep;
			this._item = source._item ? source._item : null;
		} else {
			this._itemIndex = -1;
			this._column = null;
			this._item = null;
		}
		return this;
	},
	proxy: function () {
		return {
			itemIndex: isNaN(this._itemIndex) ? -1 : this._itemIndex,
			column: (this._column ? this._column.name() : null),
			dataRow: this.dataRow(),
			fieldIndex: (this.dataColumn() ? this._column.dataIndex() : -1),
			fieldName: (this.dataColumn() ? this._column.fieldName() : null)
		};
	},
	set: function (grid, itemIndex, column) {
		if (arguments.length >= 3) {
			this._grid = grid;
			this._itemIndex = itemIndex;
			this._column = column;
		} else if (arguments.length == 2) {
			this._itemIndex = grid;
			this._column = itemIndex;
		}
	},
	isValid: function () {
		return this._grid && this._grid.isValid(this);
	},
	normalize: function (grid, isNullFocus) {
		if (grid) {
			this._grid = grid;
			if (!this._column) {
				this._column = grid.getFirstColumn();
			}
			this._itemIndex = isNullFocus && this._itemIndex == -1 ? -1 : Math.max(0, Math.min(this._itemIndex, grid.itemCount() - 1));
		}
		return this;
	},
	isMath: function (dataRow, column) {
		if (this._column === column) {
			var item = this.item();
			if (dataRow >= 0) {
				return item && item.dataRow() == dataRow;
			} else {
				return !item || item.dataRow() == dataRow;
			}
		}
		return false;
	},
	incRow: function (delta) {
		if (this._grid) {
			this._itemIndex = Math.max(0, Math.min(this._grid.itemCount() - 1, this._itemIndex + delta));
		}
	},
	first: function () {
		if (this._grid) {
			this._itemIndex = 0;
		}
	},
	last: function () {
		if (this._grid) {
			this._itemIndex = this._grid.itemCount() - 1;
		}
	},
	right: function () {
		var column = $$_cellIndex_getRight(this._grid, this._column);
		if (column) {
			this._column = column;
		}
	},
	left: function () {
		var column = $$_cellIndex_getLeft(this._grid, this._column);
		if (column) {
			this._column = column;
		}
	},
	next: function () {
		var column = $$_cellIndex_getNext(this._grid, this._column);
		if (column) {
			this._column = column;
			return true;
		}
		return false;
	},
	prev: function () {
		var column = $$_cellIndex_getPrev(this._grid, this._column);
		if (column) {
			this._column = column;
			return true;
		}
		return false;
	},
	lower: function (editing) {
		if (this._verticalStep === VerticalMovingStep.ROW && !editing) {
			if (this._itemIndex < this._grid.itemCount() - 1) {
				this.incRow(1);
				return true;
			} else {
				return false;
			}
		} else if (this._verticalStep === VerticalMovingStep.CELL) {
			if (this.isBottom()) {
				if (this._itemIndex < this._grid.itemCount() - 1) {
					this.incRow(1);
					this._column = ColumnGroup.getTop(this._column);
					return true;
				} else {
					return false;
				}
			} else {
				this._column = ColumnGroup.getLower(this._column);
				return true;
			}
		} else {
			if (this.isBottom()) {
				if (this._itemIndex < this._grid.itemCount() - 1) {
					this.incRow(1);
					return true;
				} else {
					return false;
				}
			} else {
				this._column = ColumnGroup.getLower(this._column);
				return true;
			}
		}
	},
	upper: function (editing) {
		if (this._verticalStep === VerticalMovingStep.ROW && !editing) {
			if (this._itemIndex > 0) {
				this.incRow(-1);
				return true;
			} else {
				return false;
			}
		} else if (this._verticalStep === VerticalMovingStep.CELL) {
			if (this.isTop()) {
				if (this._itemIndex > 0) {
					this.incRow(-1);
					this._column = ColumnGroup.getBottom(this._column);
					return true;
				} else {
					return false;
				}
			} else {
				this._column = ColumnGroup.getUpper(this._column);
				return true;
			}			
		} else {				
			if (this.isTop()) {
				if (this._itemIndex > 0) {
					this.incRow(-1);
					return true;
				} else {
					return false;
				}
			} else {
				this._column = ColumnGroup.getUpper(this._column);
				return true;
			}
		}
	},
	home: function () {
		var grid = this._grid;
		if (grid && grid.visibleColumnCount() > 0) {
			var column = grid.getVisibleColumn(0);
			this._column = column instanceof ValueColumn ? column : column.root().first();
		}
	},
	end: function () {
		var grid = this._grid;
		if (grid && grid.visibleColumnCount() > 0) {
			var column = grid.getVisibleColumn(grid.visibleColumnCount() - 1);
			this._column = column instanceof ValueColumn ? column : column.root().last();
		}
	},
	down: function (editing, crossTab) {
		if ((this._verticalStep == VerticalMovingStep.ROW && !editing) || this.isBottom() || crossTab) {
			if (this._itemIndex < this._grid.itemCount() - 1) {
				this.incRow(1);
				if (this._verticalStep == VerticalMovingStep.CELL)
					this._column = ColumnGroup.getTop(this._column);
			}
		} else {
			this._column = ColumnGroup.getLower(this._column);
		}
	},
	up: function (editing) {
		if ((this._verticalStep == VerticalMovingStep.ROW && !editing) || this.isTop()) {
			if (this._itemIndex > 0) {
				this.incRow(-1);
				if (this._verticalStep == VerticalMovingStep.CELL)
					this._column = ColumnGroup.getBottom(this._column);
			}
		} else {
			this._column = ColumnGroup.getUpper(this._column);
		}
	},
	toString: function () {
		var root = this._column ? this._column.root() : null;
		var dataRoot = this._column ? this._column.dataRoot() : null;
		var s = "(" + (root ? root.displayIndex() : "null") + "," + (dataRoot ? dataRoot.displayIndex() : "null") + "," + this._itemIndex + ")";
		return s;
	}
}, {
	NULL: null,
	$_temp: null,
	temp: function (grid, itemIndex, column) {
		CellIndex.$_temp._grid = grid;
		CellIndex.$_temp._itemIndex = itemIndex;
		CellIndex.$_temp._column = column;
		CellIndex.$_temp._item = null;
		return CellIndex.$_temp;
	},
	areEquals: function (idx1, idx2) {
		return (idx1 === idx2) || 
			(idx1 && idx2 && idx1._grid === idx2._grid && idx1._itemIndex === idx2._itemIndex && idx1._column === idx2._column);
	},
	nullProxy: function () {
		return {
			itemIndex: -1,
			column: null,
			dataRow: -1,
			fieldIndex: -1,
			fieldName: null
		};
	}
}, function (f) {
	f.NULL = new f();
	f.$_temp = new f();
});
var $$_cellIndex_getRight = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
	var i, cnt, idx,
		lm = grid.layoutManager(),
		column = ColumnGroup.getRight(start);
	if (column) {
		return column;
	}
	if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (i = idx + 1, cnt = lm.columnCount(); i < cnt; i++) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.first();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var $$_cellIndex_getLeft = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
	var i, idx,
		lm = grid.layoutManager(),
		column = ColumnGroup.getLeft(start);
	if (column) {
		return column;
	}
	if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (i = idx - 1; i >= 0; i--) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.last();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var $$_cellIndex_getNext = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
	var i, cnt, idx,
		lm = grid.layoutManager(),
		column = ColumnGroup.getNext(start);
	if (column) {
		return column;
	}
	if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (i = idx + 1, cnt = lm.columnCount(); i < cnt; i++) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.first();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var $$_cellIndex_getPrev = function (grid, start) {
	if (!grid || !start) {
		return null;
	}
	var i, idx,
		lm = grid.layoutManager(),
		column = ColumnGroup.getPrev(start);
	if (column) {
		return column;
	}
	if (start.group()) {
		idx = start.root().displayIndex();
	} else {
		idx = start.displayIndex();
	}
	for (i = idx - 1; i >= 0; i++) {
		column = lm.getColumn(i);
		if (column instanceof ValueColumn) {
			return column;
		} else if (column instanceof ColumnGroup) {
			column = column.last();
			if (column) {
				return column;
			}
		}
	}
	return null;
};
var GridRange = defineClass("GridRange", null, {
	init: function () {
		this._super();
		this._row1 = 0;
		this._col1 = null;
		this._row2 = -1;
		this._col2 = null;
	},
	isEmpty: function () {
		return (this._row2 < this._row1) || (this._col2 == null && this._col2 == null);
	},
	R1: function () {
		return this._row1;
	},
	C1: function () {
		return this._col1;
	},
	R2: function () {
		return this._row2;
	},
	C2: function () {
		return this._col2;
	},
	top: function () {
		return this._row1 <= this._row2 ? this._row1 : this._row2;
	},
	bottom: function () {
		return this._row1 <= this._row2 ? this._row2 : this._row1;
	},
	firstCell: function () {
		var index = new CellIndex();
		index.setItemIndex(this._row1 <= this._row2 ? this._row1 : this._row2);
		if (this._col1.dataRoot().distance() <= this._col2.dataRoot().distance()) {
			index._column = this._col1;
		} else {
			index._column = this._col2;
		}
		return index;
	},
	lastCell: function () {
		var index = new CellIndex();
		index.setItemIndex(this._row1 >= this._row2 ? this._row1 : this._row2);
		if (this._col1.dataRoot().distance() >= this._col2.dataRoot().distance()) {
			index._column = this._col1;
		} else {
			index._column = this._col2;
		}
		return index;
	},
	contains: function (itemIndex, column) {
		if (column) {
			var i = column.root().displayIndex();
			return (itemIndex >= this._row1) && (itemIndex <= this._row2) &&
				(i >= this._col1.root().displayIndex()) && (i <= this._col2.root().displayIndex());
		}
		return false;
	},
	containsIndex: function (index) {
		return index && this.contains(index._itemIndex, index._column);
	},
	normalize: function () {
		if (this._row1 > this._row2) {
			var r = this._row1;
			this._row1 = this._row2;
			this._row2 = r;
		}
		if (this._col1.dataRoot().distance() > this._col2.dataRoot().distance()) {
			var c = this._col1;
			this._col1 = this._col2;
			this._col2 = c;
		}
        return this;
	},
	normalizeData: function () {
		this.normalize();
		var g = this._col1;
		if (g instanceof ColumnGroup) {
			this._col1 = ColumnGroup.getFirstDataRoot(g);
		}
		g = this._col2;
		if (g instanceof ColumnGroup) {
			this._col2 = ColumnGroup.getLastDataRoot(g);
		}
        return this;
	}
}, {
	$_setRange: function (range, r1, c1, r2, c2) {
		range._row1 = r1 <= r2 ? r1 : r2;
		range._row2 = r1 <= r2 ? r2 : r1;
		if (c1 === c2) {
			range._col1 = range._col2 = c1;
		} else {

			range._col1 = c1.dataRoot().distance() <= c2.dataRoot().distance() ? c1 : c2;
			range._col2 = c1.dataRoot().distance() <= c2.dataRoot().distance() ? c2 : c1;
		}

		return range;
	},
	create: function (index1, index2) {
		if (!index2 || index1 === index2) {
			var r = new GridRange();
			r._row1 = r._row2 = index1._itemIndex;
			r._col1 = r._col2 = index1._column;
			return r;
		} else {
			return GridRange.$_setRange(new GridRange(), index1._itemIndex, index1._column, index2._itemIndex, index2._column);
		}
	},
	temp: function (index1, index2) {
		var r = GridRange.$_TEMP;
		if (!index2 || index1 === index2) {
			r._row1 = r._row2 = index1._itemIndex;
			r._col1 = r._col2 = index1._column;
			return r;
		} else {
			return GridRange.$_setRange(r, index1._itemIndex, index1._column, index2._itemIndex, index2._column);
		}
	},
	createRange: function (r1, c1, r2, c2) {
		return GridRange.$_setRange(new GridRange(), r1, c1, r2, c2);
	}
});
GridRange.NULL = new GridRange();
GridRange.$_TEMP = new GridRange();

var IconElement = defineClass("IconElement", VisualElement, {
    init: function (dom, name) {
        this._super(dom, name);
        this._image = null;
    },
    setImage: function (value) {
        if (value != this._image) {
            this._image = value;
            this.invalidate();
        }
    },
    iconWidth: function () {
        return this._image ? this._image.width : 0;
    },
    iconHeight: function () {
        return this._image ? this._image.height : 0;
    },
    _hoverChanged: function () {
    },
    _doDraw: function (g) {
        var img = this._image;
        if (img) {
            var w = Math.min(this.width(), img.width);
            var h = Math.min(this.height(), img.height);
            var x = (this.width() - w) / 2;
            var y = (this.height() - h) / 2;
            g.drawImage(img, x, y, w, h);
        }
    }
});
var GridSummarizer = defineClass("GridSummarizer", null, {
    init: function() {
        this._super();
    },
    getCount: function() {
    },
    getSum: function(field) {
    },
    getMax: function(field) {
    },
    getMin: function(field) {
    },
    getAvg: function(field) {
    },
    getVar: function(field) {
    },
    getVarp: function(field) {
    },
    getStdev: function(field) {
    },
    getStdevp: function(field) {
    },
    getDataCount: function(field) {
    },
    getDataAvg: function(field) {
    }
});
var DefaultSummarizer = defineClass("DefaultSummarizer", GridSummarizer, {
    init: function(provider) {
        this._super();
        this._provider = provider;
    },
    getCount: function() {
        return this._provider.itemCount();
    },
    getSum: function(field) {
        return this._provider.getSum(field);
    },
    getMax: function(field) {
        return this._provider.getMax(field);
    },
    getMin: function(field) {
        return this._provider.getMin(field);
    },
    getAvg: function(field) {
        return this._provider.getAvg(field);
    },
    getVar: function(field) {
        return this._provider.getVar(field);
    },
    getVarp: function(field) {
        return this._provider.getVarp(field);
    },
    getStdev: function(field) {
        return this._provider.getStdev(field);
    },
    getStdevp: function(field) {
        return this._provider.getStdevp(field);
    },
    getDataCount: function(field) {
    	return this._provider.getDataCount(field);
    },
    getDataAvg: function(field) {
    	return this._provider.getDataAvg(field);
    }
});
var /* @internal */ BarCode = defineClass("BarCode", null, {
	init: function () {
		this._super();
		this._value = null;
		this._error = null;
	},
	value: function () {
		return this._value;
	},
	setValue: function (v) {
		if (v != this._value) {
			this._value = v;
			try {
				this._error = null;
				this._parse(v);
			} catch (err) {
				this._error = err;
			}
		}
	},
	error: function () {
		return this._error;
	},
	render: function (g, r) {
		if (!this._error) {
			this._doRender(g, r);
		} else {
			trace("Barocde error: " + this._error);
		}
	},
	_parse: function (value) {
	},
	_doRender: function(g, r) {
	}
});
var /* @internal */ LinearBarcode = defineClass("LinearBarcode", BarCode, {
	init: function () {
		this._super();
	},
	barFill: null,
	integralBar: true,
	minBarWidth: 1,
	maxBarWidth: 0,
	barWidth: 0,
	_doRender: function (g, r) {
		if (!this._barFill) {
			return;
		}
		var len = this._getBarLength();
		if (len < 1) {
			return;
		}
		var w = this._barWidth;
		if (w <= 0) {
			if (this._integralBar) {
				w = Math.floor(r.width / len);
			} else {
				w = r.width / len;
			}
			w = Math.max(this._minBarWidth, w);
			if (this._maxBarWidth > 0) {
				w = Math.min(this._maxBarWidth, w);
			}
		}
		len = w * len;
		r.x += (r.width - len) / 2;
		if (this._integralBar) {
			r.x = Math.floor(r.x);
		}
		this._drawBars(g, this._barFill, r.x, r.y, w, r.height);
	},
	_getBarLength: function () {
		return 0;
	},
	_drawBars: function(g, fill, x, y, barWidth, barHeight) {
	}
});
var $$_C128_BAR_WEIGHTS = [
	0x212222, 0x222122, 0x222221, 0x121223, 0x121322, 0x131222, 0x122213, 0x122312, 0x132212, 0x221213, 
	0x221312, 0x231212, 0x112232, 0x122132, 0x122231, 0x113222, 0x123122, 0x123221, 0x223211, 0x221132, 
	0x221231, 0x213212, 0x223112, 0x312131, 0x311222, 0x321122, 0x321221, 0x312212, 0x322112, 0x322211, 
	0x212123, 0x212321, 0x232121, 0x111323, 0x131123, 0x131321, 0x112313, 0x132113, 0x132311, 0x211313, 
	0x231113, 0x231311, 0x112133, 0x112331, 0x132131, 0x113123, 0x113321, 0x133121, 0x313121, 0x211331, 
	0x231131, 0x213113, 0x213311, 0x213131, 0x311123, 0x311321, 0x331121, 0x312113, 0x312311, 0x332111, 
	0x314111, 0x221411, 0x431111, 0x111224, 0x111422, 0x121124, 0x121421, 0x141122, 0x141221, 0x112214, 
	0x112412, 0x122114, 0x122411, 0x142112, 0x142211, 0x241211, 0x221114, 0x413111, 0x241112, 0x134111, 
	0x111242, 0x121142, 0x121241, 0x114212, 0x124112, 0x124211, 0x411212, 0x421112, 0x421211, 0x212141, 
	0x214121, 0x412121, 0x111143, 0x111341, 0x131141, 0x114113, 0x114311, 0x411113, 0x411311, 0x113141, 
	0x114131, 0x311141, 0x411131, 0x211412, 0x211214, 0x211232, 0x2331112
];
var $$_C128_STOP_CODE = 106;
var $$_C128_TYPE_A = 0;
var $$_C128_TYPE_B = 1;
var $$_C128_TYPE_C = 2;
var $$_C128_START_CODES = [103, 104, 105];
var $$_C128_MASKS = [
	0xF000000, 0x0F00000, 0x00F0000, 0x000F000, 0x0000F00, 0x00000F0, 0x000000F
];
var /* @internal */ Code128 = defineClass("Code128", LinearBarcode, {
	init: function() {
		this._super();
		this._weights = [];
	},
	quietZoneWidth: 10,
	_parse: function(value) {
		this._weigthts = [];
		var len = value ? value.length : 0;
		if (len < 1) {
			return;
		}
		var type = this._detectType(value);
		if (type == $$_C128_TYPE_C && len % 2 == 1) {
			value = "0" + value;
			len++;
		}
		var i, s;
		var c = $$_C128_START_CODES[type];
		var w = $$_C128_BAR_WEIGHTS[c];
		var check = c;
		this._weigthts.push(w);
		if (type == $$_C128_TYPE_C) {
			for (i = 0; i < len; i += 2) {
				s = value.substr(i, 2);
				c = parseInt(s);
				c = this._convert(type, c);
				w = $$_C128_BAR_WEIGHTS[c];
				this._weigthts.push(w);
				check += c * (i + 1);
			}
		} else {
			for (i = 0; i < len; i++) {
				c = value.charCodeAt(i);
				c = this._convert(type, c);
				w = $$_C128_BAR_WEIGHTS[c];
				this._weigthts.push(w);
				check += c * (i + 1);
			}
		}
		check = check % 103;
		this._weigthts.push($$_C128_BAR_WEIGHTS[check]);
		this._weigthts.push($$_C128_BAR_WEIGHTS[$$_C128_STOP_CODE]);
	},
	_getBarLength: function() {
		return this._quietZoneWidth + (this._weigthts.length - 1) * 11 + 13 + this._quietZoneWidth;
	},
	_drawBars: function(g, fill, x, y, barWidth, barHeight) {
		x += 10 * barWidth;
		var i, j, code, b;
		var cnt = this._weigthts.length - 1;
		for (i = 0; i < cnt; i++) {
			code = this._weigthts[i];
			for (j = 0; j < 6; j ++) {
				b = (code & $$_C128_MASKS[j + 1]) >> ((5 - j) * 4);
				b *= barWidth;
				if (j % 2 == 0) {
					this._integralBar ?
					g.drawBoundsI(fill, null, x, y, b, barHeight) :
					g.drawBounds(fill, null, x, y, b, barHeight);
				}
				x += b;
			}
		}
		code = this._weigthts[cnt];
		for (j = 0; j < 7; j ++) {
			b = (code & $$_C128_MASKS[j]) >> ((6 - j) * 4);
			b *= barWidth;
			if (j % 2 == 0) {
				this._integralBar ?
				g.drawBoundsI(fill, null, x, y, b, barHeight) :
				g.drawBounds(fill, null, x, y, b, barHeight);
			}
			x += b;
		}
	},
	_convert: function (type, char) {
		switch (type) {
		case $$_C128_TYPE_A:
			if (char >= 0 && char < 32) 
				return char + 64;
			if (char >= 32 && char < 96) 
				return char - 32;
		case $$_C128_TYPE_B:
			if (char >= 32 && char < 128) 
				return char - 32;
		case $$_C128_TYPE_C:
			if (char >= 0 && char <= 99)
				return char;
		}
		throw new Error("Invalid code128 charactor: " + char);
	},
	_detectType: function (value) {
		var pattern = /^[0-9]+$/;
		if (pattern.test(value)) {
			return $$_C128_TYPE_C;
		}
		pattern = /[a-z]/;
		if (pattern.test(value)) {
			return $$_C128_TYPE_B;
		}
		return $$_C128_TYPE_A;
	}
});
var $$_C39_CODES = {
	"0": "nnnwwnwnn",
	"1": "wnnwnnnnw",
	"2": "nnwwnnnnw",
	"3": "wnwwnnnnn",
	"4": "nnnwwnnnw",
	"5": "wnnwwnnnn",
	"6": "nnwwwnnnn",
	"7": "nnnwnnwnw",
	"8": "wnnwnnwnn",
	"9": "nnwwnnwnn",
	"A": "wnnnnwnnw",
	"B": "nnwnnwnnw",
	"C": "wnwnnwnnn",
	"D": "nnnnwwnnw",
	"E": "wnnnwwnnn",
	"F": "nnwnwwnnn",
	"G": "nnnnnwwnw",
	"H": "wnnnnwwnn",
	"I": "nnwnnwwnn",
	"J": "nnnnwwwnn",
	"K": "wnnnnnnww",
	"L": "nnwnnnnww",
	"M": "wnwnnnnwn",
	"N": "nnnnwnnww",
	"O": "wnnnwnnwn",
	"P": "nnwnwnnwn",
	"Q": "nnnnnnwww",
	"R": "wnnnnnwwn",
	"S": "nnwnnnwwn",
	"T": "nnnnwnwwn",
	"U": "wwnnnnnnw",
	"V": "nwwnnnnnw",
	"W": "wwwnnnnnn",
	"X": "nwnnwnnnw",
	"Y": "wwnnwnnnn",
	"Z": "nwwnwnnnn",
	"-": "nwnnnnwnw",
	".": "wwnnnnwnn",
	" ": "nwwnnnwnn",
	"$": "nwnwnwnnn",
	"/": "nwnwnnnwn",
	"+": "nwnnnwnwn",
	"%": "nnnwnwnwn",
	"*": "nwnnwnwnn"
};
var /* @internal */ Code39 = defineClass("Code39", LinearBarcode, {
	init: function() {
		this._super();
		this._codes = [];
		this._wideWidth = 3;
	},
	_parse: function(value) {
		this._codes = [];
		if (!value) {
			return;
		}
		var i, c, code;
		var cnt = value.length;
		this._codes.push($$_C39_CODES["*"]);
		for (i = 0; i < cnt; i++) {
			c = value.charAt(i);
			code = $$_C39_CODES[c];
			if (!code) {
				throw new Error("Invalid Code39 character: " + c);
			}
			this._codes.push(code);
		}
		this._codes.push($$_C39_CODES["*"]);
	},
	_getBarLength: function() {
		var len = this._codes.length;
		return len * (3 * this._wideWidth + 6) + (len - 1);
	},
	_drawBars: function(g, fill, x, y, barWidth, barHeight) {
		var i, code, j, b;
		var cnt = this._codes.length;
		for (i = 0; i < cnt; i++) {
			code = this._codes[i];
			for (j = 0; j < 9; j ++) {
				b = code.charAt(j) == "n" ? 1 : this._wideWidth;
				b *= barWidth;
				if (j % 2 == 0) {
					this._integralBar ?
					g.drawBoundsI(fill, null, x, y, b, barHeight) :
					g.drawBounds(fill, null, x, y, b, barHeight);
				}
				x += b;
			}
			if (i < cnt - 1) {
				x += barWidth;
			}
		}
	}
});
function ExpressionStatementError(message, pos) {
	this.message = message;
	this.tokenPos = pos;
};
ExpressionStatementError.prototype = new Error();
ExpressionStatementError.prototype.constructor = ExpressionStatementError;
var $$_SEP_HEAD = "${";
var $$_SEP_TAIL = "}";
var /* internal */ ExpressionStatement = function (source, silentError) {
	var _source = null;
	var _silentError = silentError;
	var _tokens = [];
	var _createLiteral = function (literal) {
		return {
			literal: literal,
			evaluate: function (token, runtime) {
				return token.literal;
			}
		};
	};
	var _createIdent = function (ident) {
		return {
			ident: ident,
			idKey: -1,
			evaluate: function (token, runtime) {
				if (token.idKey < 0) {
					token.idKey = runtime.isIdentifier(token.ident);
				}
				return runtime.evaluateIdentifier(token.idKey);
			}
		};
	};
	var _createIndexerIdent = function (ident) {
		return {
			ident: ident,
			idKey : -1,
			evaluate: function(token, runtime) {
				var ident = token.ident;
				var bo = ident.indexOf("["), bc = ident.indexOf("]");
				if (bo < bc) {
					var s = ident.substr(0, bo).trim();
					var strIdx = ident.substring(bo+1,bc).replace(/'|"/g,"").trim();
					if (token.idKey < 0) {
						token.idKey = runtime.isIdentifier(s);
					}
					return runtime.evaluateIndexerS(token.idKey, strIdx, this._capital)
				}
			}
		};
	};
	var _parse = function (str) {
		_tokens.splice(0, _tokens.length);
		if (!str) {
			return;
		}
		var p, q, s, token;
		var len = str.length;
		var i = 0;
		while (i < len) {
			p = str.indexOf($$_SEP_HEAD, i);
			if (p >= 0) {
				q = str.indexOf($$_SEP_TAIL, p + 2);
				if (q >= 0) {
					if (p > i) {
						s = str.substring(i, p);
						token = _createLiteral(s);
						_tokens.push(token);
					}
					s = str.substring(p + 2, q).trim();
					if (s) {
						var bo, bc;
						if ( (bo = s.indexOf("[")) && (bc = s.indexOf("]")) && (bo < bc)) {
							token = _createIndexerIdent(s);
						} else {
							token = _createIdent(s);	
						}
						_tokens.push(token);
					}
					i = q + 1;
				} else {
					p = -1;
				}
			} 
			if (p < 0) {
				s = str.substr(i, len);
				token = _createLiteral(s);
				_tokens.push(token);
				break;
			}
		}
	};
	this.source = function () {
		return _source;
	};
	this.setSource = function (value) {
		if (value != _source) {
			_source = value;
			_parse(value);
		}
	};
	this.evaluate = function (runtime) {
		try {
			var v;
			var s = "";
			for (var i = 0, cnt = _tokens.length; i < cnt; i++) {
				v = _tokens[i].evaluate(_tokens[i], runtime);
				s += v || "";
			}
			return s;
		} catch (err) {
			if (!_silentError) {
				throw err;
			}
		}
		return null;
	};
	_parse(source);
};
var DataTag = defineClass("DataTag", null, {
	init: function() {
		this._super();
	},
	connect: function (provider) {
	},
	disconnect: function () {
	},
	clearRows: function () {
	},
	setRows: function () {
	},
	setRowCount: function (newCount) {
	},
	insertRow: function (row) {
	},
	insertRows: function (row, count) {
	},
	removeRow: function (row) {
	},
	removeRows: function (rows) {
	},
	updateRow: function (row) {
	},
	updateRows: function (row, count) {
	},
	setValue: function (row, field) {
	},
	moveRow: function (row, newRow) {
	},
	moveRows: function (row, count, newRow) {
	}
});
var DataTagCollection = defineClass("DataTagCollection", null, {
	init: function(owner) {
		this._super();
		this._owner = owner;
		this._tags = [];
	},
	destroy: function() {
		this._tags = null;
		this._super();
	},
	add: function (tag) {
		if (tag) {
			var tags = this._tags || (this._tags = []);
			if (tags.indexOf(tag) < 0) {
				tags.push(tag);
			}
			tag.connect(this._owner);
		}
	},
	remove: function (tag) {
		if (tag && this._tags) {
			var idx = this._tags.indexOf(tag);
            if (idx >= 0) {
                this._tags.splice(idx, 1);
                tag.disconnect();
            }
        }
	},
	clearRows: function () {
		if (this._tags) {
            var tags = this._tags;
			for (var i = tags.length; i--;) {
				tags[i].clearRows();
			}
		}
	},
	setRows: function () {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].setRows();
            }
		}
	},
	setRowCount: function (newCount) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].setRowCount(newCount);
            }
		}
	},
	insertRow: function (row) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].insertRow(row);
            }
		}
	},
	insertRows: function (row, count) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].insertRows(row, count);
            }
		}
	},
	removeRow: function (row) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].removeRow(row);
            }
		}
	},
	removeRows: function (rows) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].removeRows(rows);
            }
		}
	},
	updateRow: function (row) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].updateRow(row);
            }
		}
	},
	updateRows: function (row, count) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].updateRows(row, count);
			}
		}
	},
	setValue: function (row, field) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].setValue(row, field);
			}
		}
	},
	moveRow: function (row, newRow) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].moveRow(row, newRow);
			}
		}
	},
	moveRows: function (row, count, newRow) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].moveRows(row, count, newRow);
			}
		}
	}
});
var DataField = defineClass("DataField", EventAware, {
	init: function (fieldName, dataType, length) {
		this._super();
		this._owner = null;
		this._index = -1;
		this._orgFieldName = null;
		this._orgAttrName = null;
		this._orgBaseField = null;
		this._boolParser = null;
		this._dateParser = null;
		this._ownerBoolParser = null;
		this._ownerDateParser = null;
		if (fieldName) {
			this.setFieldName(fieldName);
		}
		if (dataType !== undefined) {
			this._dataType = dataType == "numeric" ? ValueType.NUMBER : dataType == "date" ? ValueType.DATETIME : dataType;
		}
		if (length != undefined) {
            var len = parseInt(length);
			this._length = isNaN(len) ? 0 : len;
		}
		this._runType = undefined;
		this._ranged = false;
		this._runSet = null;
		this._runMax = undefined;
		this._runMin = undefined;
		this._typeLock = false;
        this.equalValues = null;
        this.sameValues = null;
		this.readValue = null;
		this.nullValue = undefined;
		this._calculated = false;
		this._objectKey = null;
		this._objectCallback = null;
	},
	fieldName: null,
	dataType: ValueType.TEXT,
	subTypeEnabled: true,
	subType: null,
	subtypeEnabled: true,
	subtype: null,
	length: 0,
	set: null,
	header: null,
	minimum: undefined,
	maximum: undefined,
	required: false,
    updatable: true,
	defaultValue: undefined,
	baseField: null,
	booleanFormat: null,
	dateFormat: null,
	datetimeFormat: null,
	amText: null,
	pmText: null,
	baseYear: NaN,
	calculateExpression: null,
	calculateCallback: null,
	objectKey:null,
	objectCallback:null,
	comparer:null,
	hash: function () {
		return this._fieldName;
	},
	index: function () {
		return this._index;
	},
	$_setIndex: function (value) {
		this._index = value;
	},
	setFieldName: function (value) {
		value = value && value.trim();
		if (!value) {
			throw new Error("Field name must be exists.");
		}
		if (value != this._orgFieldName) {
			this._orgFieldName = value;
			this._orgAttrName = "@" + value;
			this._fieldName = value.toUpperCase();
			this._changed();
		}
	},
	orgFieldName: function () {
		return this._orgFieldName;
	},
	orgAttrName: function () {
		return this._orgAttrName;
	},
	setDataType: function (value) {
		if (value == "numeric") {
			value = ValueType.NUMBER;
		} else if (value == "date") {
			value = ValueType.DATETIME;
		}
		if (value != this._dataType) {
			this._dataType = value;
			this._resetTypes();
			this._changed();
		}
	},
	runType: function () {
		return this._runType;
	},
	setSubType: function (value) {
		value = value || null;
		if (value != this._subType) {
			this._subType = value;
			this._resetTypes();
			this._changed();
		}
	},
	setSubTypeEnabled: function (value) {
		if (value != this._subTypeEnabled) {
			this._subTypeEnabled = value;
			this._resetTypes();
			this._changed();
		}
	},
	getSubtype_: function () {
		return this._subType;
	},
	setSubtype: function (value) {
		this.setSubType(value);
	},
	isSubtypeEnabled: function () {
		return this._subtypeEnabled;
	},
	setSubtypeEnabled: function (value) {
		this.setSubTypeEnabled(value);
	},
	setLength: function (value) {
		if (value != this._length) {
			this._length = value;
			this._resetTypes();
			this._changed();
		}
	},
	setSet: function (value) {
		if (value !== this._set && _isArray(value)) {
			this._set = value;
			this._resetTypes();
			this._changed();
		}
	},
	setMinimum: function (value) {
		if (value != this._minimum) {
			this._minimum = value;
			this._resetTypes();
			this._changed();
		}
	},
	setMaximum: function (value) {
		if (value != this._maximum) {
			this._maximum = value;
			this._resetTypes();
			this._changed();
		}
	},
	setRequired: function (value) {
		if (value != this._required) {
			this._required = value;
			this._changed();
		}
	},
	setHeader: function (value) {
		if (value != this._header) {
			this._header = value;
			this._changed();
		}
	},
	setDefaultValue: function (value) {
		if (value != this._defaultValue) {
			this._defaultValue = value;
		}
	},
	setBaseField: function (value) {
		if (value != this._orgBaseField) {
			this._orgBaseField = value;
			this._baseField = value && value.toUpperCase();
			this._changed();
		}
	},
	booleanFormat_: function () {
		return this._boolFormat;
	},
	setBooleanFormat: function (value) {
		this.setBoolFormat(value);
	},
	setBoolFormat: function (value) {
		if (value != this._boolFormat) {
			this._boolFormat = value;
			if (value) {
				this._boolParser = new BooleanConverter(value);
			} else {
				this._boolParser = null;	
			}
			this._changed();
		}
	},
	datetimeFormat_: function () {
		return this._dateFormat;
	},
	setDatetimeFormat: function (value) {
		this.setDateFormat(value);
	},
	setDateFormat: function (value) {
		if (value != this._dateFormat) {
			this._dateFormat = value;
			if (value) {
				this._dateParser = new DateTimeReader(value);
				this._dateParser.setAmText(this._amText);
				this._dateParser.setPmText(this._pmText);
				this._dateParser.setBaseYear(this._baseYear);
			} else {
				this._dateParser = null;	
			}
			this._changed();
		}
	},
	setAmText: function (value) {
		if (value != this._amText) {
			this._amText = value;
			if (this._dateParser) {
				this._dateParser.setAmText(value);
			}
			this._changed();
		}
	},
	setPmText: function (value) {
		if (value != this._pmText) {
			this._pmText = value;
			if (this._dateParser) {
				this._dateParser.setPmText(value);
			}
			this._changed();
		}
	},
	setBaseYear: function (value) {
		if (value != this._baseYear) {
			this._baseYear = value;
			if (this._dateParser) {
				this._dateParser.setBaseYear(value);
			}
			this._changed();
		}
	},
	isEmpty: function (value) {
		var v = value === undefined || value === null || value === "";
		if (!v && this._dataType == ValueType.NUMBER) {
			v = isNaN(value);
		}
		return v;
	},
	getBool: function (parser, value) {
		if (typeof value === "boolean") {
			return value;
		} else {
			return this._boolParser ? this._boolParser.toBool(value) : parser.toBool(value);
		}
	},
	getDate: function (parser, value) {
		if (value instanceof Date || typeof value == "number") {
			return new Date(value);
		} else {
			return this._dateParser ? this._dateParser.toDate(value) : parser.toDate(value);
		}
	},
	setCalculateExpression: function (value) {
		if (value != this._calculateExpression) {
			this._calculateExpression = value;
			this._updatable = (this._calculateExpression || this._calculateCallback) ? false : this._updatable;
		}
	},
	setCalculateCallback: function (value) {
		if (value != this._calculateCallback) {
			this._calculateCallback = value;
			this._updatable = (this._calculateExpression || this._calculateCallback) ? false : this._updatable;
		}
	},

	isCalculated: function () {
		return this._calculateCallback || this._calculateExpression;
	},
    /*
	equalValues: function (v1, v2) {
		if (v1 === undefined) {
			return v2 === undefined;
		}
		if (v2 === undefined) {
			return false;
		}
		switch (this._dataType) {
			case ValueType.TEXT:
				return v1 == v2;
			case ValueType.NUMBER:
				if (isNaN(v1)) {
					return isNaN(v2);
				}
				if (isNaN(v2)) {
					return false;
				}
				return v1 == v2;
			case ValueType.DATETIME:
				if (!(v1 instanceof Date)) {
					return !(v2 instanceof Date);
				}
				if (!(v2 instanceof Date)) {
					return false;
				}
				return v1.getTime() == v2.getTime();
			case ValueType.BOOLEAN:
				return Boolean(v1) == Boolean(v2);
			default:
				return v1 == v2;
		}
	},
	*/
	isNull: function (value) {
		if (value === undefined || value === null) {
			return true;
		}
		switch (this._runType) {
			case ValueType.TEXT:
			case ValueType.CHAR:
				if (String(value).length == 0) {
					return true;
				}
				break;
			case ValueType.NUMBER:
			case ValueType.UNUM:
			case ValueType.INT:
			case ValueType.UINT:
				if (isNaN(value)) {
					return true;
				}
				break;
		}
		return false;
	},
	propertyChanged: function (prop, newValue) {
		this._changed();
	},
	clone: function () {
		var obj = this._super();
		obj._orgFieldName = this._orgFieldName;
		obj._orgAttrName = this._orgAttrName;
		obj._boolParser = this._boolParser;
		obj._dateParser = this._dateParser;
		return obj;
	},
	/*
	clone: function () {
		var fld = new DataField();
	fieldName: null,
	dataType: ValueType.TEXT,
	length: 0,
	header: null,
	minimum: undefined,
	maximum: undefined,
	required: false,
	defaultValue: UNDEFINED,
	baseField: null,
	boolFormat: null,
	dateFormat: null,
	amText: null,
	pmText: null,
	baseYear: NaN,
		fld._orgFieldName = this._orgFieldName;
		fld._fieldName = this._fieldName;
		fld._dataType = this._dataType;
		fld._length = this._length;
		fld._header = this._header;
		fld._required = this._required;
		fld._defaultValue = this._defaultValue;
		fld._baseField = this._baseField;
		fld._boolFormat = this._boolFormat;
		fld._dateFormat = this._dateFormat;
		fld._amText = this._amText;
		fld._pmText = this._pmText;
		fld._baseYear = this._baseYear;
		return fld;
	},
	*/
	_prepare: function (owner) {
		this._owner = owner;
	},
	_changed: function () {
		if (this._owner) {
		}
	},
	_resetTypes: function (provider) {
		if (this._typeLock) {
			return;
		}
		if (provider) {
			this._ownerBoolParser = provider._boolParser;
			this._ownerDateParser = provider._dateParser;
		}
		var i, d;
		var type = this._dataType;
		var stype = this._subType;
		this._runType = type;
		this._ranged = false;
		if ((!this._owner || this._owner.isSubTypeEnabled()) && this._subTypeEnabled) {
			if (stype) {
				switch (type) {
					case ValueType.TEXT:
						if (stype == ValueType.CHAR && this._length > 0) {
							type = stype;
						}
						break;
					case ValueType.NUMBER:
						if (stype == ValueType.UNUM || stype == ValueType.INT || stype == ValueType.UINT) {
							type = stype;
						}
						break;
					case ValueType.DATETIME:
						if (stype == ValueType.DATE/* || stype == GridValueType.TIME*/) {
							type = stype;
						}
						break;
				}
			}
			this._runType = type;
			this._runSet = null;
			if (this._set && this._set.length) {
				if (this._runType == ValueType.DATETIME) {
					this._runSet = [];
					for (i = 0; i < this._set.length; i++) {
						d = this.getDate(this._ownerDateParser, this._set[i]);
						if (d) {
							this._runSet.push(d.getTime())
						}
					}
					if (this._runSet.length < 1) {
						this._runSet = null;
					}
				} else if (this._runType == ValueType.DATE) {
					this._runSet = [];
					for (i = 0; i < this._set.length; i++) {
						d = this.getDate(this._ownerDateParser, this._set[i]);
						if (d) {
							var d2 = new Date(d);
							this._runSet.push(d2.setHours(0, 0, 0, 0));
						}
					}
					if (this._runSet.length < 1) {
						this._runSet = null;
					}
				} else {
					this._runSet = this._set;
				}
				this._ranged = true;
			}
			if (!this._ranged) {
				switch (this._dataType) {
					case ValueType.NUMBER:
						this._runMin = Number(this._minimum);
						this._runMax = Number(this._maximum);
						if (!isNaN(this._runMin) && !isNaN(this._runMax)) {
							this._ranged = this._runMin <= this._runMax;
						} else {
							this._ranged = !isNaN(this._runMin) || !isNaN(this._runMax);
						}
						break;
					case ValueType.DATETIME:
						this._runMin = this.getDate(this._ownerDateParser, this._minimum);
						this._runMax = this.getDate(this._ownerDateParser, this._maximum);
						if (this._runMin && this._runMax) {
							this._ranged = this._runMin.getTime() <= this._runMax.getTime();
						} else {
							this._ranged = this._runMin || this._runMax;
						}
						break;
				}
			}
			switch (this._runType) {
				case ValueType.TEXT:
                    this.equalValues = this._equalTextValues;
                    this.sameValues = this._sameTextValues;
					this.readValue = this._readTextValue;
					this.nullValue = null;
					break;
				case ValueType.CHAR:
                    this.equalValues = this._equalTextValues;
                    this.sameValues = this._sameTextValues;
					this.readValue = this._readCharValue;
					this.nullValue = null;
					break;
				case ValueType.NUMBER:
                    this.equalValues = this._equalNumberValues;
                    this.sameValues = this._sameNumberValues;
					this.readValue = this._readNumberValue;
					this.nullValue = NaN;
					break;
				case ValueType.UNUM:
                    this.equalValues = this._equalNumberValues;
                    this.sameValues = this._sameNumberValues;
					this.readValue = this._readUnumValue;
					this.nullValue = NaN;
					break;
				case ValueType.INT:
                    this.equalValues = this._equalNumberValues;
                    this.sameValues = this._sameNumberValues;
					this.readValue = this._readIntValue;
					this.nullValue = NaN;
					break;
				case ValueType.UINT:
                    this.equalValues = this._equalNumberValues;
                    this.sameValues = this._sameNumberValues;
					this.readValue = this._readUintValue;
					this.nullValue = NaN;
					break;
				case ValueType.DATETIME:
                    this.equalValues = this._equalDateValues;
                    this.sameValues = this._sameDateValues;
					this.readValue = this._readDatetimeValue;
					this.nullValue = null;
					break;
				case ValueType.DATE:
                    this.equalValues = this._equalDateValues;
                    this.sameValues = this._sameDateValues;
					this.readValue = this._readDateValue;
					this.nullValue = null;
					break;
				case ValueType.BOOLEAN:
                    this.equalValues = this._equalBoolValues;
                    this.sameValues = this._sameBoolValues;
					this.readValue = this._readBooleanValue;
					this.nullValue = false;
					break;
				case ValueType.OBJECT:
					this.equalValues = this._equalObjectValues;
					this.sameValues = this._sameObjectValues;
					this.readValue = this._readObjectValues;
					this.nullValue = false;
					break;
				default:
                    this.equalValues = this._equalDummyValues;
                    this.sameValues = this._sameDummyValues;
					this.readValue = this._readDummyValue;
					this.nullValue = undefined;
					break;
			}
		}
	},
	_refreshFormats: function (owner) {
		this._owner = owner;
		if (this._dateParser) {
			if (!this._dateParser.baseYear) {
				this._dateParser.setBaseYear(owner.baseYear());
			}
			if (!this._dateParser.amText) {
				this._dateParser.setAmText(owner.amText());
			}
			if (!this._dateParser.pmText) {
				this._dateParser.setPmText(owner.pmText());
			}
		}
		this._ownerBoolParser = owner._boolParser;
		this._ownerDateParser = owner._dateParser;
	},
    _equalDummyValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        return v1 == v2;
    },
    _sameDummyValues: function (v1, v2) {
        if (v1 === undefined || v1 === null) {
            return v2 === undefined || v2 === null;
        }
        if (v2 === undefined || v2 === null) {
            return false;
        }
        return v1 == v2;
    },
    _equalTextValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        return v1 == v2;
    },
    _sameTextValues: function (v1, v2) {
        if (v1 === undefined || v1 === null || v1 == "") {
            return v2 === undefined || v2 === null || v2 == "";
        }
        if (v2 === undefined || v2 === null || v2 == "") {
            return false;
        }
        return v1 == v2;
    },
    _equalNumberValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        if (isNaN(v1)) {
            return isNaN(v2);
        }
        if (isNaN(v2)) {
            return false;
        }
        return v1 == v2;
    },
    _sameNumberValues: function (v1, v2) {
        if (isNaN(v1)) {
            return isNaN(v2);
        }
        if (isNaN(v2)) {
            return false;
        }
        return v1 == v2;
    },
    _equalDateValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        if (!(v1 instanceof Date)) {
            return !(v2 instanceof Date);
        }
        if (!(v2 instanceof Date)) {
            return false;
        }
        return v1.getTime() == v2.getTime();
    },
    _sameDateValues: function (v1, v2) {
        if (!(v1 instanceof Date)) {
            return !(v2 instanceof Date);
        }
        if (!(v2 instanceof Date)) {
            return false;
        }
        return v1.getTime() == v2.getTime();
    },
    _equalBoolValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        return Boolean(v1) == Boolean(v2);
    },
    _sameBoolValues: function (v1, v2) {
        if (v1 === undefined) {
            return v2 === undefined;
        }
        if (v2 === undefined) {
            return false;
        }
        return Boolean(v1) == Boolean(v2);
    },
    _equalObjectValues: function( v1, v2) {
    	if (v1 === undefined || v2 === undefined) {
    		return (v1 === undefined) == (v2 === undefined);
    	}
    	return v1 === v2;
    },
    _sameObjectValues: function(v1, v2) {
    	if (v1 == undefined || v2 == undefined) {
    		return v1 == undefined && v2 == undefined;
    	}
    	return v1 == v2;
    },
	_readDummyValue: function (v) {
		return v;
	},
	_readTextValue: function (v) {
		if (v === undefined) {
			return v;
		}
		var s = (v === null) ? null : String(v);
		if (this._ranged && this._runSet) {
			if (this._runSet.indexOf(s) < 0) {
				return undefined;
			}
		}
		return s;
	},
	_readCharValue: function (v) {
		if (v === undefined) {
			return v;
		}
		var s = (v === null) ? null : String(v);
		if (s) {
			s = s.substr(0, this._length);
		}
		if (this._ranged && this._runSet) {
			if (this._runSet.indexOf(s) < 0) {
				return undefined;
			}
		}
		return s;
	},
	_readNumberValue: function (v) {
		if (v === undefined || v === null || v === "") {
			return undefined;
		}
		var n = Number(v);
		if (this._ranged) {
			if (this._runSet) {
				if (this._runSet.indexOf(n) < 0) {
					return undefined;
				}
			} else {
				if (!isNaN(this._runMin)) {
					n = Math.max(this._runMin, n);
				}
				if (!isNaN(this._runMax)) {
					n = Math.min(this._runMax, n);
				}
			}
		}
		return n;
	},
	_readUnumValue: function (v) {
		if (v === undefined || v === null || v === "") {
			return undefined;
		}
		var n = Math.max(0, Number(v));
		if (this._ranged) {
			if (this._runSet) {
				if (this._runSet.indexOf(n) < 0) {
					return undefined;
				}
			} else {
				if (!isNaN(this._runMin)) {
					n = Math.max(this._runMin, n);
				}
				if (!isNaN(this._runMax)) {
					n = Math.min(this._runMax, n);
				}
			}
			n = Math.max(0, n);
		}
		return n;
	},
	_readIntValue: function (v) {
		if (v === undefined || v === null || v === "") {
			return undefined;
		}
		var n = v >= 0 ? Math.floor(v) : Math.ceil(v);
		if (this._ranged) {
			if (this._runSet) {
				if (this._runSet.indexOf(n) < 0) {
					return undefined;
				}
			} else {
				if (!isNaN(this._runMin)) {
					n = Math.max(this._runMin, n);
				}
				if (!isNaN(this._runMax)) {
					n = Math.min(this._runMax, n);
				}
			}
			n = n >= 0 ? Math.floor(n) : Math.ceil(n);
		}
		return n;
	},
	_readUintValue: function (v) {
		if (v === undefined || v === null || v === "") {
			return undefined;
		}
		var n = Math.max(0, Math.floor(Math.floor(v)));
		if (this._ranged) {
			if (this._runSet) {
				if (this._runSet.indexOf(n) < 0) {
					return undefined;
				}
			} else {
				if (!isNaN(this._runMin)) {
					n = Math.max(this._runMin, n);
				}
				if (!isNaN(this._runMax)) {
					n = Math.min(this._runMax, n);
				}
			}
			n = Math.max(0, Math.floor(Math.floor(n)));
		}
		return n;
	},
	_readDatetimeValue: function (v) {
		if (v === undefined) {
			return undefined;
		}
		if (v === null) {
			return this.nullValue;
		}
		var d = this.getDate(this._ownerDateParser, v);
		if (d && this._ranged) {
			if (this._runSet) {
				var found = false;
				for (var i = this._runSet.length; i--;) {
					if (d.getTime() == this._runSet[i]) {
						found = true;
						break;
					}
				}
				if (!found) {
					return undefined;
				}
			} else {
				if (this._runMin) {
					if (d.getTime() < this._runMin.getTime()) {
						d = new Date(this._runMin);
					}
				}
				if (this._runMax) {
					if (d.getTime() > this._runMax.getTime()) {
						d = new Date(this._runMax);
					}
				}
			}
		}
		return d;
	},
	_readDateValue: function (v) {
		if (v === undefined) {
			return undefined;
		}
		if (v === null) {
			return this.nullValue;
		}
		var d = this.getDate(this._ownerDateParser, v);
		if (d) {
			d.setHours(0, 0, 0, 0);
			if (this._ranged) {
				if (this._runSet) {
					var found = false;
					for (var i = this._runSet.length; i--;) {
						if (d.getTime() == this._runSet[i]) {
							found = true;
							break;
						}
					}
					if (!found) {
						return undefined;
					}
				} else {
					if (this._runMin) {
						if (d.getTime() < this._runMin.getTime()) {
							d = new Date(this._runMin);
						}
					}
					if (this._runMax) {
						if (d.getTime() > this._runMax.getTime()) {
							d = new Date(this._runMax);
						}
					}
				}
			}
		}
		return d;
	},
	_readBooleanValue: function (v) {
		if (v === undefined) {
			return v;
		}
		if (v === null) {
			return false;
		}
		var b = this.getBool(this._ownerBoolParser, v);
		return b;
	},
	_readObjectValues: function(v) {
		if (typeof v === "string") {
			try {
				v = JSON.parse(v);
			} catch (e) {
				throw new Error("Invalid Object String "+e+"\r\n"+v)
			}
		} else if (typeof v != "object") {
			try {
				v = JSON.parse(v);
			} catch (e) {

			}
		}
		return v;
	},
	$_compareObject: function (v1, v2, row1, row2) {
		var key = this._objectKey;
		var fn = this._objectCallback;
		var v1 = fn ? fn(this.orgFieldName(), row1, v1) : key && v1.hasOwnProperty(key) ? v1[key] : null;
		var v2 = fn ? fn(this.orgFieldName(), row2, v2) : key && v2.hasOwnProperty(key) ? v2[key] : null;
		return v1 > v2 ? 1 : v1 < v2 ? 0 : -1;
	},
	_calculateValue: function (runtime, rowId, fieldName, fields, orgFields, values) {
		if (this._calculateCallback) {
			return this._calculateCallback(rowId, fieldName, orgFields, values);
		} else if (this._calculateExpression) {
			if (!this._exprNode)
				this._exprNode = ExpressionParser.Default.parse(this._calculateExpression, DataField.CAPITAL_INDEXERS);
			runtime.setValues(values, fields);
			return this._exprNode.evaluate(runtime);
		}
		return undefined;
	},
	proxy: function() {
		return $$_getFieldProxy(this);
	}
}, {
	CAPITAL_INDEXERS: ["value", "values"]
});
var DataSourceError = defineClass("DataSourceError", null, {
	init: function (message) {
		this._super();
		this._message = message;
	},
	message: function () {
		return this._message;
	}
});
var /* @internal */ SimpleDataComparer = defineClass("SimpleDataComparer", null, {
	init: function () {
		this._super();
	},
	dataType: ValueType.TEXT,
	compare: function (field, value1, value2) {
		if (field._dataType == ValueType.NUMBER) {
			return Number(value1) - Number(value2);
		} else {
			return value1 > value2 ? 1 : (value1 < value2 ? -1 : 0);
		}
	}
});
var DataOutputOptions = defineClass("DataOutputOptions", null, {
    init: function (config) {
        this._super();
        this._datetimeWriter = null;
        this._booleanFormatter = null;
        this._numberFormatter = null;
        config && this.assign(config);
    },
    datetimeFormat: undefined,
    booleanFormat: undefined,
    numberFormat: undefined,
    datetimeCallback: null,
    booleanCallback: null,
    numberCallback: null,
    nullDateText: null,
    nullText: null,
    nanText: null,
    setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
            if (value) {
                this._datetimeWriter = new DateTimeWriter(value);
            } else {
                this._datetimeWriter = null;
            }
        }
    },
    setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._booleanFormatter = new BooleanFormatter(value);
            } else {
                this._booleanFormatter = null;
            }
        }
    },
    setNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
            if (value) {
                this._numberFormatter = new DecimalFormatter(value);
            } else {
                this._numberFormatter = null;
            }
        }    	
    }
});
var ClientEditingError = function () {
	this.message = ClientEditingError.message;
};
ClientEditingError.message = "Client is editing (call grid.commit() or grid.cancel() first)";

var /* abstract */ DataSource = defineClass("DataSource", EventAware, {
	init: function () {
		this._super();
		this._fields = [];
		this._calcFields = [];
		this._fieldNames = [];
		this._fieldMap = {};
		this._defComparer = new SimpleDataComparer();
		this._comparers = [];
		this._boolParser = BooleanConverter.Default;
		this._dateParser = DateTimeReader.Default;
		this._eventLock = 0;
		this._clients = [];
		this._calculateRuntime = null;
	},
	destroy: function() {
		this._destroying = true;
		try {
			this.$_internalClearFields();
			this._fieldMap = null;
		} catch (err) {

		}
		this._fields = null;
		this._calcFields = null;
		this._fieldNames = null;
		this._comparers = null;
		this._clients = null;
		this._super(true);
	},
	subTypeEnabled: true,
	subtypeEnabled: true,
	insertable: true,
	updatable: true,
	deletable: true,
	softDeleting: false,
	deleteCreated: false,
	checkStates: true,
	restoreMode: RestoreMode.NONE,
    strictRestore: false,
	booleanFormat: null,
	datetimeFormat: null,
	dateFormat: null,
	baseYear: 2000,
	amText: "AM",
	pmText: "PM",
	alertClientError: true,
	throwClientError: false,
	commitBeforeDataEdit: false,
	calculateRuntime: function () {
		if (!this._calculateRuntime) {
			this._calculateRuntime = new CalculateExpressionRuntime();
		}
		return this._calculateRuntime;
	},
	setSubTypeEnabled: function (value) {
		if (value != this._subTypeEnabled) {
			this._subTypeEnabled = value;
			for (var i = this._fields.length; i--;) {
				this._fields[i]._resetTypes();
			}
		}
	},
	subtypeEnabled_: function () {
		return this._subTypeEnabled;
	},
	setSubtypeEnabled: function (value) {
		this.setSubtypeEnabled(value);
	},
	setCheckStates: function (value) {
		if (value != this._checkStates) {
			this._checkStates = value;
			this._doCheckStatesChanged();
		}
	},
	setRestoreMode: function (value) {
		if (value != this._restoreMode) {
			var old = this._restoreMode;
			this._restoreMode = value;
			this._doRestoreModeChanged(old, value);
		}
	},
	fieldCount: function () {
		return this._fields.length;
	},
    rowCount: function () {
        throwAbstractError();
    },
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			this._boolParser = value ? new BooleanConverter(value) : BooleanConverter.Default;	
		}
	},
	$_createDateReader: function () {
		if (this._datetimeFormat) {
			this._dateParser = new DateTimeReader(this._datetimeFormat);
			this._dateParser.setAmText(this._amText);
			this._dateParser.setPmText(this._pmText);
			this._dateParser.setBaseYear(this._baseYear);
		} else {
			this._dateParser = DateTimeReader.Default;
		}
	},
	setDateFormat: function (value) {
		if (value != this._datetimeFormat) {
			this._datetimeFormat = value;
			this.$_createDateReader();
		}
	},
	setAmText: function (value) {
		if (value != this._amText) {
			this._amText = value;
			this.$_createDateReader();
		}
	},
	setPmText: function (value) {
		if (value != this._pmText) {
			this._pmText = value;
			this.$_createDateReader();
		}
	},
	
	getDatetimeFormat_: function () {
		return this._dateFormat;
	},
	setDatetimeFormat: function (value) {
		this.setDateFormat(value);
	},
	
	getField: function (index) {
		if (index >= 0 && index < this._fields.length) {
			return this._fields[index];
		}
		return null;
	},
	isLocal: function () {
		return true;
	},
	isImmediateUpdate: function () {
		return false;
	},
	isSummarized: function () {
		return false;
	},
	$_addField: function (fieldName, dataType, length) {
		if (!fieldName) {
			throw new Error("fieldName must be exists.");
		}
		if (this.getFieldIndex(fieldName) >= 0) {
			throw new Error("fieldName is already exists: " + fieldName);
		}
		var field = new DataField(fieldName, dataType, length);
		this.$_internalInsertField(this._fields.length, field);
		return field;
	},
	$_internalAddField:function(fld) {
		var field = null;
		if (typeof fld === "string") {
			field = this.$_addField(fld, ValueType.TEXT, 0);
		} else if (fld instanceof DataField) {
			field = fld.clone();
			this.$_internalInsertField(this._fields.length, field);
		} else {
			field = this.$_addField(fld.fieldName, fld.dataType || ValueType.TEXT, fld.length);
			if ("defaultValue" in fld) {
				field._defaultValue = fld.defaultValue;
			}
			if ("baseField" in fld) {
				field._baseField = fld.baseField;
			}
			if ("booleanFormat" in fld) {
				field.setBooleanFormat(fld.booleanFormat);
			}
			if ("datetimeFormat" in fld) {
				field.setDatetimeFormat(fld.datetimeFormat);
			}
			if ("amText" in fld) {
				field._amText = fld.amText;
			}
			if ("pmText" in fld) {
				field._pmText = fld.pmText;
			}
			if ("baseYear" in fld) {
				field._baseYear = fld.baseYear;				
			}
			if ("header" in fld) {
			   field._header = fld.header;
			}
			if ("objectKey" in fld) {
				field._objectKey = fld.objectKey;
			}
			if ("objectCallback" in fld) {
				field._objectCallback = fld.objectCallback;
			}
		}
		return field;
	},	
	addField: function (source, resetFields, calculateData) {
		var field;
		if (!this._checkClientState()) return;
		this.beginUpdate();
		try {
			field = this.$_internalAddField(source);
			field && field._resetTypes(this);
			return field;
		} finally {
			resetFields && this._doFieldsReset();
			if (calculateData) {
				for (var i = 0; i < this._values.length; i++) {
					this._values[i] && this.$_internalCalculateValues(this._values[i], i);
				}
			};
			this.endUpdate();
		};
		return;
	},
	clearFields: function () {
		if (this._fields.length > 0) {
			if (!this._checkClientState()) return;
			this.$_internalClearFields();
			this._doFieldsReset();
		}
	},
	setFields: function (fields) {
		if (!this._checkClientState()) return;
		this.beginUpdate();
		try {
			this.$_internalClearFields();
			if (_isArray(fields)) {
				var i,
					cnt = fields.length,
					field;
				for (i = 0; i < cnt; i++) {
					field = null;
					field = this.$_internalAddField(fields[i]);
					if (field) {
						field._resetTypes(this);
					}
				}
			}
		} finally {
			this.endUpdate();
			this._doFieldsReset();
		}
	},
	getFields: function () {
		return this._fields.slice();
	},
	fieldByName: function (name) {
		if (name) {
			var uppname = name.toUpperCase();
			for (var i = 0, cnt = this._fields.length; i < cnt; i++) {
				var field = this._fields[i];
				if (field.fieldName() == uppname) {
					return field;
				}
			}
		}
		return null;
	},
	getFieldNames: function () {
		var i,
			cnt = this._fields.length,
			names = [];
		for (i = 0; i < cnt; i++) {
			names.push(this._fields[i]._fieldName);
		}
		return names;
	},
	getOrgFieldNames: function () {
		var i,
			cnt = this._fields.length,
			names = [];
		for (i = 0; i < cnt; i++) {
			names.push(this._fields[i]._orgFieldName);
		}
		return names;
	},
	getFieldName: function (field) {
		this._checkFieldIndex(field);
		return this._fields[field]._fieldName;
	},
	getOrgFieldName: function (field) {
		this._checkFieldIndex(field);
		return this._fields[field]._orgFieldName;
	},
	getFieldIndex: function (fieldName) {
		if (fieldName) {
			var s = fieldName.toUpperCase();
			if (s in this._fieldMap) {
				return this._fieldMap[s];
			}
		}
		return -1;
	},
	getFieldIndexC: function (fieldName) {
		if (fieldName in this._fieldMap) {
			return this._fieldMap[fieldName];
		}
		return -1;
	},
	getBaseField: function (field) {
		if (field >= 0 && field < this._fields.length) {
			return this.getFieldIndex(this._fields[field]._baseField);
		} else {
			return -1;
		}
	},
	getFieldIndexOf: function (field) {
		return typeof field == "string" ? this.getFieldIndex(field) : parseInt(field);
	},
	getValueType: function (field) {
		return this._fields[field]._dataType;
	},
	getDefaultValue: function (field) {
		return this._fields[field]._defaultValue;
	},
	getRowState: function (row) {
		throwAbstractError();
	},
	setRowState: function (row, state, force) {
		throwAbstractError();
	},
	clearRowStates: function (deleteRows, rowEvents) {
		throwAbstractError();
	},
	getStateRows: function (state) {
		throwAbstractError();
	},
	getAllStateRows: function () {
		throwAbstractError();
	},
	setRowStates: function (rows, state, force, rowEvents) {
		throwAbstractError();
	},
	getRowStateCount: function (states) {
		throwAbstractError();
	},
	restoreUpdatedStates: function (rows) {
		throwAbstractError();
	},
	restoreUpdatedRows: function (rows) {
		throwAbstractError();
	},
	getUpdatedCells:function(rows) {
		throwAbstractError();	
	},
	beginUpdate: function () {
		this._checkClientState();
		this._eventLock++;
	},
	endUpdate: function (refresh) {
		this._checkClientState();
		refresh = arguments.length > 0 ? refresh : true;
		this._eventLock = Math.max(0, this._eventLock - 1);
		if (this._eventLock == 0 && refresh) {
			this._fireRefresh();
		}	
	},
	hasData: function (row) {
		return false;
	},
	canUpdateField: function (row, field) {
		if (field >= 0 && field < this._fields.length) {
            var fld = this._fields[field];
            if (!fld._updatable && row >= 0) {
                try {
                    var st = this.getRowState(row);
                    return !st || st == RowState.CREATED || st == RowState.CREATE_AND_DELETED;
                } catch (err) {
                    return false;
                }
            }
            return true;
        }
        return false;
	},
	getDataComparer: function (field) {
		if (field >= 0) {
			var comparer = this._comparers[field];
			if (comparer) {
				return comparer;
			} else {
				return null;
			}
		}
		// this._defComparer.dataType = field >= 0 ? this.getValueType(field) : ValueType.TEXT;
		// return this._defComparer;
	},
	setDataComparer: function (field, comparer) {
		if (comparer) {
			this._comparers[field] = comparer;
		} else {
			this._comparers[field] = undefined;
		}
	},
	canSummarize: function (field) {
		if (field >= 0 && field < this.fieldCount()) {
			var t = this.getValueType(field);
			if (t == ValueType.BOOLEAN || t == ValueType.NUMBER || ValueType.DATE) {
				return true;
			}
		}
		return false;
	},
	findRow: function (fields, values) {
		return -1;
	},
	getDistinctValues: function (field, maxCount, sortDir) {
		return null;
	},
	exportToJson: function () {
	},
	exportToCsv: function (options) {
		new DataProviderCsvExporter()["export"](this, options);		
	},
	exportToXml: function () {
	},
	registerClient: function (client) {
		if (client && this._clients.indexOf(client) < 0) {
			this._clients.push(client);
		}
	},
	unregisterClient: function (client) {
		if (client) {
			var index = this._clients.indexOf(client);
			index >= 0 && this._clients.splice(index, 1);
		}
	},
	cancelClients: function () {
		for (var i = this._clients.length; i--;) {
			this._clients[i].cancelDataEditing();
		}
	},
	commitClients: function () {
		for (var i = this._clients.length; i--;) {
			this._clients[i].commitDataEditing();
		}
	},
	refreshClients: function () {
		this._fireRefreshClients();
	},
	_checkClientState: function () {
		var busyInfo = this.$_isClientsBusy();
		if (busyInfo.busy) {
			// 편집중인 그리드가 1개인경우 편집중인 그리드를 commit한다.
			// 2개이상인 경우 clientError발생.//
			if (this._commitBeforeDataEdit && busyInfo.cnt == 1) {
				listeners = busyInfo.client._listeners;
				var hasCommit = true;
				for (var i=0, cnt = listeners.length; i< cnt; i++) {
					var isCommit = listeners[i].commit(false,true);
					hasCommit = hasCommit && (isCommit || (listeners[i].isEditing && !listeners[i].isEditing()));
				}
				if (hasCommit) return true;
			}
			if (this._throwClientError) {
				throw new ClientEditingError();
			}
			if (this._alertClientError) {
				alert(ClientEditingError.message);
			}
			return false;
		}
		return true;
	},
	_doCheckStatesChanged: function () {
	},
	_doRestoreModeChanged: function (oldMode, newMode) {
	},
	$_isClientsBusy: function () {
		var ret = {busy:false, cnt:0, client:null}
		if (this._destroying) {
			return ret;
		};
		for (var i = this._clients.length; i--;) {
			if (this._clients[i].isDataEditing()) {
				ret.busy = true;
				ret.cnt++;
				ret.client = this._clients[i];
			}
		}
		return ret;
	},
	_checkFieldIndex: function (field) {
		if (field < 0 || field >= this._fields.length) {
			throw new Error("Invalid field index: " + field);
		}
	},
	$_internalClearFields: function () {
		this._checkClientState();
		for (var i = this._fields.length; i--;) {
			this._fields[i].$_setIndex(-1);
		}
		this._fields.splice(0, this._fields.length);
		this._calcFields.splice(0, this._calcFields.length);
		this._fieldNames.splice(0, this._fieldNames.length);
		this._fieldMap = {};
	},
	$_internalInsertField: function (index, field) {
		this._checkClientState();
		var len = this._fields.length;
		if (index < 0 || index > len) {
			if ($_debug) debugger;
			throw new Error("index is out of bounds:" + index);
		}
		if (field) {
			field._prepare(this);
			this._fields.splice(index, 0, field);
			this._fieldNames.splice(index, 0, field._fieldName);
			if (field.isCalculated())
				this._calcFields.push(field);
			field.$_setIndex(index);
			this._fieldMap[field.fieldName()] = index;
			for (var i = index + 1; i <= len; i++) {
				field = this._fields[i];
				field.$_setIndex(i);
				this._fieldMap[field.fieldName()] = i;
			}
			return index;
		}
		return -1;
	},
	$_internalCalculateValues: function (values, row) {
		var fields = this._calcFields;
		if (fields.length > 0) {
			var rvalues = [];
			for (var i = 0; i < values.length; i++) {
				rvalues[i] = this.getField(i).readValue(values[i]);
			}
			for (i = 0, len = fields.length; i < len; i++) {
				var field = fields[i];
				var fldIdx = this._fieldMap[field.fieldName()];
				values[fldIdx] = rvalues[fldIdx] = field.readValue(field._calculateValue(this._calculateRuntime, row, field.orgFieldName(), this._fieldNames, this.getOrgFieldNames(), rvalues));
			}
		}
	},
	refreshFieldFormats: function () {
		for (var i = this._fields.length; i--;) {
			this._fields[i]._refreshFormats(this);
		}
	},
	refreshFieldFormat: function (field) {
		field && field._refreshFormats(this);
	},
	_doFieldsReset: function () {
	},
    $_createOutputRows: function (rows, options, startIdx) {
		startIdx = arguments.length > 2 ? startIdx : 0;
        var fldCount = this.fieldCount();
        var rowCount = rows.length;
        var r, row;
        if (!(options instanceof DataOutputOptions)) {
            options = new DataOutputOptions(options);
        }
        var nullDate = options.nullDateText();
        var nullText = options.nullText();
        var nanText = options.nanText();
        for (var i = 0; i < fldCount; i++) {
            var field = this.getField(i);
            var prop = field.orgFieldName();
            var callback, writer;
            if (field._dataType == ValueType.DATETIME && ((callback = options._datetimeCallback) || (writer = options._datetimeWriter) || (nullDate != null && nullDate != undefined) )) {
                if (callback) {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        row[prop] = callback(r + startIdx, prop, row[prop]);
                    }
                } else {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        var d = row[prop];
                        row[prop] = d ? writer ? writer.getText(row[prop]) : d : nullDate;
                    }
                }
            } else if (field._dataType == ValueType.BOOLEAN && ((callback = options._booleanCallback) || (writer = options._booleanFormatter))) {
                if (callback) {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        row[prop] = callback(r + startIdx, prop, row[prop]);
                    }
                } else {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        row[prop] = writer.formatValue(row[prop]);
                    }
                }
            } else if (field._dataType == ValueType.NUMBER && ((callback = options._numberCallback) || (writer = options._numberFormatter) || (nanText != null && nanText != undefined))) {
                if (callback) {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        row[prop] = callback(r + startIdx, prop, row[prop]);
                    }
                } else {
                    for (r = 0; r < rowCount; r++) {
                        row = rows[r];
                        var v = row[prop];
                        row[prop] = v == null || isNaN(v) ? nanText : writer ? writer.format(v) : v;
                    }
                }
            } else if (nullText != null && nullText != undefined) {
                for (r = 0; r < rowCount; r++) {
                    row = rows[r];
                    var v = row[prop];
                    row[prop] = v == null || v == undefined ? nullText : v;
                }
            }
        }
    },
	$_sortRows: function (rows, field, compFunc, left, right) {
		return rows.sort( function(r1, r2) { return compFunc(field, r1, r2)} );
		/*
		var i, j, row, m, r, v, t;
		do {
			i = left;
			j = right;
			row = _int((left + right) / 2);
			m = rows[row];
			do {
				while (i <= j) {
					r = rows[i];
					v = compFunc(field, m, r);
					if (v <= 0)
						break;
					i++;
				}
				while (i <= j) {
					r = rows[j];
					v = compFunc(field, m, r);
					if (v >= 0)
						break;
					j--;
				}
				if (i <= j) {
					if (i != j) {
						t = rows[i];
						rows[i] = rows[j];
						rows[j] = t;
					}
					i++;
					j--;
				}
			} while (i <= j);
			if (left < j) {
				this.$_sortRows(rows, field, compFunc, left, j);
			}
			left = i;
		} while (left < right);
		*/
	}
});
var DataSource$ = DataSource.prototype;
var /* @abstract */ DataProvider = defineClass("DataProvider", DataSource, {
	init: function () {
		this._super();
		this._eventLock = 0;
		this._resetLock = 0;
		this._countLock = 0;
		this._tags = new DataTagCollection(this);
		this._filters = null;
		this._filterRuntime = null;
	},
	filterRuntime: function () {
		if (!this._filterRuntime) {
			this._filterRuntime = new DataFilterRuntime(this);
		}
		return this._filterRuntime;
	},
	addTag: function (tag) {
		this._tags.add(tag);
	},
	removeTag: function (tag) {
		this._tags.remove(tag);
	},
	deletedCount: function () {
		return 0;
	},
	setFilters: function (filters, filterMode) {
        filterMode = arguments.length > 0 ? filterMode : "and";
        if (!filters || filters instanceof DataFilterCollection) {
			this._filters = filters;
			if (filterMode) {
				this._filters.setFilterMode(filterMode);
			}
		} else {
			this._filters = new DataFilterCollection(this.filterRuntime(), filters, filterMode);
		}
	},
	beginUpdate: function () {
		if (!this._checkClientState()) return;
		this._eventLock++;
	},
	endUpdate: function (refresh) {
		if (!this._checkClientState()) return;
		refresh = arguments.length > 0 ? refresh : true;
		this._eventLock = Math.max(0, this._eventLock - 1);
		if (this._eventLock == 0 ) {
			if (refresh) {
				if (this._resetLock > 0) {
					this._fireReset();
				} else {
					this._fireRefresh();
				}
				if (this._countLock > 0) {
					this._fireRowCountChanged();
				}
			}
			this._resetLock = this._countLock = 0;
		}
	},
	setRowCount: function (count, fillDefaults, defaultValues, rowState) {
		throwAbstractError();
	},
	clearRows: function () {
		throwAbstractError();
	},
	setRows: function (rows, start, count) {
		throwAbstractError();
	},
	setXmlRows: function (rows, start, count) {
		throwAbstractError();
	},
	addRows: function (rows, start, count, rowEvents) {
		throwAbstractError();
	},
	insertRows: function (row, rows, start, count, rowEvents) {
		throwAbstractError();
	},
	insertXmlRows: function (row, rows, start, count, rowEvents) {
		throwAbstractError();
	},
	updateRows: function (row, rows, start, count, rowEvents) {
		throwAbstractError();
	},
	updateStrictRows: function (row, rows, start, count, rowEvents) {
		throwAbstractError();
	},
	updateXmlRows: function (row, rows, start, count, rowEvents) {
		throwAbstractError();
	},
	appendXmlRows: function (rows, start, count, rowEvents) {
		throwAbstractError();
	},
	getRows: function (startRow, endRow) {
		throwAbstractError();
	},
	getRowObjects: function (startRow, endRow) {
		throwAbstractError();
	},
    getOutputObject: function (options, startRow, endRow) {
        throwAbstractError();
    },
	getValue: function (row, fieldIndex) {
		throwAbstractError();
	},
	setValue: function (row, fieldIndex, value) {
		throwAbstractError();
	},
	getRow: function (row) {
		throwAbstractError();
	},
	getRowObject: function (row) {
		if (row < 0 || row >= this.getRowCount())
			throw new RangeError("row is out of range: " + row);
		var i,
			fld,
			v,
			cnt = this.fieldCount(),
			vals = {};
		for (i = 0; i < cnt; i++) {
			fld = this.getOrgFieldName(i);
			v = this.getValue(row, i);
			vals[fld] = v;
		}
		return vals;
	},
	getColumn: function (field, startRow, endRow) {
		throwAbstractError();
	},
	hasData: function (row) {
		throwAbstractError();
	},
	insertRow: function (row, values) {
		throwAbstractError();
	},
	appendRow: function (values) {
		throwAbstractError();
	},
	removeRow: function (row) {
		throwAbstractError();
	},
	removeRows: function (rows) {
		throwAbstractError();
	},
	updateRow: function (row, values) {
		throwAbstractError();
	},
	updateStrictRow: function (row, values) {
		throwAbstractError();
	},
	moveRow: function (row, newRow) {
		throwAbstractError();
	},
	moveRows: function (row, count, newRow) {
		throwAbstractError();
	},
	canUpdateRow: function (row) {
		return false;
	},
	canAppendRow: function () {
		return false;
	},
	canInsertRow: function (row) {
		return false;
	},
	canDeleteRow: function (row) {
		return false;
	},
	objectToRow: function (values) {
		var row = [];
		if (values) {
			var i, fld,
				cnt = this.fieldCount();
			for (i = 0; i < cnt; i++) {
				fld = this.getOrgFieldName(i);
				if (values.hasOwnProperty(fld)) {
					row[i] = values[fld];
				}
			}
		}
		return row;
	},
	equalValues: function (field, row1, row2) {
		if (row1 !== row2) {
			var fld = this._fields[field];
			var v1 = this.getValue(row1, field);
			var v2 = this.getValue(row2, field);
			return fld.equalValues(v1, v2);
		} else {
			return true;
		}
	},
    equalTexts: function (field, row1, row2) {
        if (row1 !== row2) {
            var fld = this._fields[field];
            var v1 = this.getValue(row1, field);
            var v2 = this.getValue(row2, field);
            if (v1 === undefined || v1 === null) {
                return v2 === undefined || v2 === null;
            }
            if (v2 === undefined || v2 === null) {
                return false;
            }
            return v1.toLowerCase() == v2.toLowerCase();
        } else {
            return true;
        }
    },
    sameValues: function (field, row1, row2) {
        if (row1 !== row2) {
            var fld = this._fields[field];
            var v1 = this.getValue(row1, field);
            var v2 = this.getValue(row2, field);
            return fld.sameValues(v1, v2);
        } else {
            return true;
        }
    },
	compareValues: function (field, row1, row2) {
		return 0;
	},
	compareTexts: function (field, row1, row2) {
		return 0;
	},
	compareNumbers: function (field, row1, row2) {
		return 0;
	},
	compareBools: function (field, row1, row2) {
		return 0;
	},
	compareObjects: function (field, row1, row2) {
		return 0;
	},
	summarize: function (field, calcVars) {
		return false;
	},
	summarizeRange: function (field, rows, calcVars) {
		return false;
	},
    copyRows: function (sourceRow, count, targetRow, noStates) {
    },
	hideCount: function() {
		return 0;
	},    
	_doFieldsReset: function () {
		this._fireReset();
	},
	refreshClients: function () {
		this._fireRefreshClients();
	},
	tags: function () {
		return this._tags;
	},
	isEventLocked: function () {
		return this._eventLock > 0;
	},
	filters: function () {
		return this._filters || null;
	},
	getHandler:function() {
		return this.fireObjectEvent(DataProvider.GET_HANDLER);
	},
	_fireDisposed: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.DISPOSED);
		} 
	},
	_fireReset: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.RESET);
		} else {
			this._resetLock++;
		}
	},
	_fireRefresh: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.REFRESH);
		}
	},
	_fireRefreshClients: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.REFRESH);
		} 
	},
	_fireRowCountChanged: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROW_COUNT_CHANGED);
		} else {
			this._countLock++;
		}
	},
	_fireRowInserting: function (row, values) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(DataProvider.ROW_INSERTING, row, values);
		} 
		return true; 
	},
	_fireRowInserted: function (row, itemIndex) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROW_INSERTED, row, itemIndex);
			this.fireEvent(DataProvider.DATA_CHANGED);
		}
	},
	_fireRowsInserted: function (row, count, itemIndex) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROWS_INSERTED, row, count, itemIndex);
			this.fireEvent(DataProvider.DATA_CHANGED);
		}
	},
	_fireRowRemoving: function (row) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(DataProvider.ROW_REMOVING, row);
		} 
		return true; 
	},
	_fireRowRemoved: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROW_REMOVED, row);
			this.fireEvent(DataProvider.DATA_CHANGED);
		}
	},
	_fireRowsRemoving: function (rows) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(DataProvider.ROWS_REMOVING, rows);
		} 
		return true; 
	},
	_fireRowsRemoved: function (rows) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROWS_REMOVED, rows);
			this.fireEvent(DataProvider.DATA_CHANGED);
		}
	},
	_fireRowUpdating: function (row, values) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(DataProvider.ROW_UPDATING, row, values);
		}
		return true; 
	},
	_fireRowUpdated: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROW_UPDATED, row);
			this.fireEvent(DataProvider.DATA_CHANGED);
		}
	},
	_fireRowsUpdated: function (row, count) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROWS_UPDATED, row, count);
			this.fireEvent(DataProvider.DATA_CHANGED);
		}
	},
	_fireRowMoving: function (row, newRow) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(DataProvider.ROW_MOVING, row, newRow);
		} 
		return true; 
	},
	_fireRowMoved: function (row, newRow) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROW_MOVED, row, newRow);
		} 
	},
	_fireRowsMoving: function (row, count, newRow) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(DataProvider.ROWS_MOVING, row, count, newRow);
		} 
		return true; 
	},
	_fireRowsMoved: function (row, count, newRow) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROWS_MOVED, row, count, newRow);
		} 
	},
	fireValueChanging: function (row, field, value) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(DataProvider.VALUE_CHANGING, row, field, value);
		}
		return true; 
	},
	_fireValueChanged: function (row, field) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.VALUE_CHANGED, row, field);
			this.fireEvent(DataProvider.DATA_CHANGED);
		}
	},
	_fireRowStateChanged: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.STATE_CHANGED, row);
		} 
	},
	_fireRowStatesChanged: function (rows) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.STATES_CHANGED, rows);
		} 
	},
	_fireRowStatesCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.STATES_CLEARED);
		} 
	},
	_fireRestoreRows: function() {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.RESTOREROWS);
		}
	},
	_fireRowHided: function(rows, hide) {
		if (this._eventLock <= 0) {
			this.fireEvent(DataProvider.ROW_HIDED, rows, hide);
		}
	}
});
DataProvider.DISPOSED = "onDataProvderDisposed";
DataProvider.RESET = "onDataProviderReset";
DataProvider.REFRESH = "onDataProviderRefresh";
DataProvider.REFRESH_CLIENT = "onDataProviderRefreshClient";
DataProvider.ROW_COUNT_CHANGED = "onDataProviderRowCountChanged";
DataProvider.ROW_INSERTING = "onDataProviderRowInserting";
DataProvider.ROW_INSERTED = "onDataProviderRowInserted";
DataProvider.ROWS_INSERTED = "onDataProviderRowsInserted";
DataProvider.ROW_REMOVING = "onDataProviderRowRemoving";
DataProvider.ROW_REMOVED = "onDataProviderRowRemoved";
DataProvider.ROWS_REMOVING = "onDataProviderRowsRemoving";
DataProvider.ROWS_REMOVED = "onDataProviderRowsRemoved";
DataProvider.ROW_UPDATING = "onDataProviderRowUpdating";
DataProvider.ROW_UPDATED = "onDataProviderRowUpdated";
DataProvider.ROWS_UPDATED = "onDataProviderRowsUpdated";
DataProvider.ROW_MOVING = "onDataProviderRowMoving";
DataProvider.ROW_MOVED = "onDataProviderRowMoved";
DataProvider.ROWS_MOVING = "onDataProviderRowsMoving";
DataProvider.ROWS_MOVED = "onDataProviderRowsMoved";
DataProvider.VALUE_CHANGING = "onDataProviderValueChanging";
DataProvider.VALUE_CHANGED = "onDataProviderValueChanged";
DataProvider.DATA_CHANGED = "onDataProviderDataChanged";
DataProvider.STATE_CHANGED = "onDataProviderStateChanged";
DataProvider.STATES_CHANGED = "onDataProviderStatesChanged";
DataProvider.STATES_CLEARED = "onDataProviderStatesCleared";
DataProvider.RESTOREROWS = "onDataProviderRestoreRows";
DataProvider.ROW_HIDED = "onDataProviderRowHided";
DataProvider.GET_HANDLER = "getHandler";

var DataProvider$ = DataProvider.prototype;
var /* @internal */ DataProviderObserver = defineClass("DataProviderObserver", null, {
	init: function () {
		this._super();
	},
	onDataProvderDisposed: function (provider) {
	},
	onDataProviderReset: function (provider) {
	},
	onDataProviderRefresh: function (provider) {
	},
	onDataProviderRefreshClient: function (provider) {
	},
	onDataProviderRowCountChanged: function (provider, newCount) {
	},
	onDataProviderRowInserting: function (provider, row, values) {
		return true;
	},
	onDataProviderRowInserted: function (provider, row) {
	},
	onDataProviderRowsInserted: function (provider, row, count) {
	},
	onDataProviderRowRemoving: function (provider, row) {
		return true;
	},
	onDataProviderRowRemoved: function (provider, row) {
	},
	onDataProviderRowsRemoving: function (provider, rows) {
		return true;
	},
	onDataProviderRowsRemoved: function (provider, rows) {
	},
	onDataProviderRowUpdating: function (provider, row, values) {
		return true;
	},
	onDataProviderRowUpdated: function (provider, row) {
	},
	onDataProviderRowsUpdated: function (provider, row, count) {
	},
	onDataProviderRowMoving: function (provider, row, newRow) {
		return true;
	},
	onDataProviderRowMoved: function (provider, row, newRow) {
	},
	onDataProviderRowsMoving: function (provider, row, count, newRow) {
		return true;
	},
	onDataProviderRowsMoved: function (provider, row, count, newRow) {
	},
	onDataProviderValueChanging: function (provider, row, field, value) {
		return true;
	},
	onDataProviderValueChanged: function (provider, row, field) {
	},
	onDataProviderStateChanged: function (provider, row) {
	},
	onDataProviderStatesChanged: function (provider, rows) {
	},
	onDataProviderStatesCleared: function (provider) {
	}
});
var /* @internal */ DataFilterRuntime = defineClass("DataFilterRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._provider = null;
		this._fieldCount = 0;
		this._row = -1;
		this._values = null;
	},
	prepare: function (provider) {
		this._provider = provider;
		this._fieldCount = provider ? provider.fieldCount() : 0;
	},
	setRow: function (row, values) {
		this._row = row;
		this._values = values;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataFilterRuntime.IDENTS.hasOwnProperty(token)) {
			return DataRowExpressionRuntime.IDENTS[token];
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
		case DataRowExpressionRuntime.ID_ROW:
			return this._item.index();
		}
		if ($_debug) debugger;
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (index < 0 || index >= this._fieldCount) {
			if ($_debug) debugger;
			throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
		}
		switch (idKey) {
			case DataRowExpressionRuntime.ID_VALUE:
			case DataRowExpressionRuntime.ID_VALUES:
				return this._values[index];
		}
		if ($_debug) debugger;
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		switch (idKey) {
			case DataRowExpressionRuntime.ID_VALUE:
			case DataRowExpressionRuntime.ID_VALUES:
				var field = this.$_getField(index, capitalized);
				return this._values[field];
		}
		if ($_debug) debugger;
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	$_getField: function (index, capitalized) {
		var	fld = capitalized ? this._provider.getFieldIndexC(index) : this._provider.getFieldIndex(index);
		if (fld < 0 || fld >= this._fieldCount) {
			if ($_debug) debugger;
			throw new ExpressionEvaluationError("Data field is not exits:" + index);
		}
		return fld;	
	}
}, {
	ID_ROW: 0,
	ID_VALUE: 1,
	ID_VALUES: 2
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		value: f.ID_VALUE,
		values: f.ID_VALUES
	};
});
var DataFilter = defineClass("DataFilter", null, {
	init: function (runtime, criteria) {
		this._super();
		this._runtime = runtime;
		this._exproNode = null;
		this._active = false;
		this.setCriteria(criteria);
	},
	criteria: null,
	active: true,
	setCriteria: function (value) {
		if (value != this._criteria) {
			this._criteria = value;
			if (value) {
				this._exprNode = ExpressionParser.Default.parse(value, DataFilter.CAPITAL_INDEXERS);
			} else {
				this._exprNode = null;
			}
		}
	},
	select: function (row, values) {
		if (this._exprNode) {
			this._runtime.setRow(row, values);
			return this._exprNode.evaluate(this._runtime);
		} else {
			return true;
		}
	}
}, {
	CAPITAL_INDEXERS: ["value", "values", "len"]
});
var DataFilterCollection = defineClass("DataFilterCollection", null, {
	init: function(runtime, source, filterMode) {
		this._super();
		this._runtime = runtime;
		this._isOr = false;
		this.load(source);
		if (filterMode) {
			this.setFilterMode(filterMode);
		}
	},
	filterMode: "and",
	setFilterMode: function (value) {
		var s = value ? value.toLocaleLowerCase() : value;
		if (s != this._filterMode) {
			this._filterMode = s;
			this._isOr = this._filterMode == DataFilterCollection.FILTER_OR;
		}
	},
	load: function (source) {
		if (!_isArray(source) && source) {
			source = [source];
		}
		this._filters = [];
		if (source) {
			for (var i = 0, cnt = source.length; i < cnt; i++) {
				var filter = null;
				var f = source[i];
				if (f) {
					if (typeof f === "string") {
						filter = new DataFilter(this._runtime, f);
					} else if (f.criteria) {
						filter = new DataFilter(this._runtime, f.criteria);
					}
				}
				if (filter) {
					this._filters.push(filter);
				}
			}
		}
	},
	prepare: function (provider) {
		this._runtime.prepare(provider);
	},
	select: function(row, values) {
		var i,
			filters = this._filters,
			cnt = filters.length;
		if (this._isOr) {
			for (i = 0; i < cnt; i++) {
				if (filters[i].select(row, values) == true) {
					return true;
				}
			}
			return false;
		} else {
			for (i = 0; i < cnt; i++) {
				if (filters[i].select(row, values) == false) {
					return false;
				}
			}
			return true;
		}
	}
}, {
	FILTER_AND: "and",
	FILTER_OR: "or"
});

var /* @internal */ DataHelper = {
	csvToArray: function (provider, source, start, count, quoted, delimiter) {
		start = arguments.length > 2 ? Math.max(start,0) : 0;
		count = arguments.length > 3 ? count : -1;
		delimiter = arguments.length > 5 ? delimiter : ",";
		var c, next;
		var lines = [];
		var line = [];
		var len = source.length;
		var i = 0;
		var quoting, started;
		var s = [];
		while (i < len) {
			c = source.charAt(i);
			// next = i < len -1 ? source.charAt(i+1) : '';
			if (c == '"') {
				if (!started) { // 시작 
					started = quoting = true;
					!quoted && s.push(c);
				} else if (quoting && source.charAt(i+1) == '"') { //quoting 시 따옴표 두개
					s.push(c);
					i++;
				} else if (quoting) { //quoting 시 따옴표 한개 
					quoting = false;
					!quoted && s.push(c);
				} else { //quoting 바깥쪽의 따옴표 
					s.push(c);
				}
			} else if (!quoting && (c == delimiter || c == '\r' || c == '\n')) {
				if (c == delimiter) {
					line.push(s.join(""));
				} else if (c == '\r' || c == '\n') {
					line.push(s.join(""));
					lines.push(line);
					line = [];
					if (source.charAt(i+1) == '\n')
						i++;
				}
				s = [];
				started = false;
			} else {
				started = true;
				s.push(c);
			}
			i++;
		}
		// 개행문자로 끝나지 않은 경우 처리
		if (quoting)
			s.splice(0,0,'"');
		if (s.length > 0)  // \t로 끝나는 경우 다음 cell의 값이 공백...
			line.push(s.join(""));
		if (line.length > 0) {
			lines.push(line);
		}
		if (start > 0) {
			if (count <= 0) {
				lines.splice(0,start);
			} else {
				lines = lines.splice(start, count);
			}
		}
		var flds = provider.getFields();
		var fieldCount = flds.length;
		var hasFlds = fieldCount > 0;
		for (i = 0, cnt = lines.length ; i < cnt ; i++) {
			line = lines[i];
			if (hasFlds && line.length > fieldCount) {
				line.length = fieldCount;
			}
			for (var j = 0; j < fieldCount; j++) {
				line[j] = flds[j].readValue(line[j]);
			}
		}
		s = line = null;
		return lines;
	},
	/*
	csvToArray: function (provider, source, start, count, quoted, delimiter) {
		start = arguments.length > 2 ? start : 0;
		count = arguments.length > 3 ? count : -1;
		delimiter = arguments.length > 5 ? delimiter : ",";
		var rows = null;
		if (source) {
			var i;
			var s;
			var len;
			var lines = source.split("\r\n");// source.split(/(\r\n|\n|\r)/);
			if (lines.length == 1) {
				lines = source.split("\n");
			}
			if (lines.length == 1) {
				lines = source.split("\r");
			}
			for (i = lines.length - 1; i >= 0; i--) {
				s = lines[i];
				s = s ? s.trim() : null;
				if (s && s.length > 0) {
					break;
				}
				lines.pop();
			}
			len = lines.length;
			if (len > 0) {
				start = Math.max(0, start);
				if (count < 0) {
					count = len;
				}
				count = Math.min(len - start, count);
				if (count > 0) {
					var r;
					var line;
					var vals;
					var flds = provider.getFields();
					var fieldCount = flds.length;
					var hasFlds = fieldCount > 0;
					rows = new Array(count);
					if (quoted) {
						for (r = 0; r < count; r++) {
							line = lines[r + start];
							vals = $_parseCSV(line, delimiter);
							if (hasFlds && vals.length > fieldCount) {
								vals.splice(vals.length, fieldCount - vals.length);
							}
							for (var i = 0; i < fieldCount; i++) {
								vals[i] = flds[i].readValue(vals[i]);
							}
							rows[r] = vals;
						}
					} else {
						for (r = 0; r < count; r++) {
							line = lines[r + start];
							vals = line.split(delimiter);
							if (hasFlds && vals.length > fieldCount) {
								vals.splice(vals.length, fieldCount - vals.length);
							}
							for (var i = 0; i < fieldCount; i++) {
								vals[i] = flds[i].readValue(vals[i]);
							}
							rows[r] = vals;
						}
					}
				}
			}
		}
		return rows;
	},
	*/
	xmlToRow: function (xml, fields, fieldNames) {
		var nodes = xml.childNodes;
		var fldCnt = fields.length;
		var vals = new Array(fldCnt);
		var j, len;

		for (j = 0, len = nodes.length; j < len; j++) {
			var node = nodes[j];
			var c;
			if ((c = fieldNames.indexOf(node.tagName)) >= 0) {
				var nodeValue = node.nodeValue;
				if (nodeValue == null && node.hasChildNodes()) {
					nodeValue = _included(node.childNodes[0].nodeType, 3, 4) ? node.childNodes[0].nodeValue : undefined;	
				}
				nodeValue != null && (vals[c] = fields[c].readValue(nodeValue));
			}
		}

		for (j= 0; j < fldCnt; j++) {
			if (vals[j] === undefined) {
				var nodeValue = _getXmlAttr(xml, fieldNames[j]);
				nodeValue != null && (vals[j] = fields[j].readValue(nodeValue));
			}
		}
		return vals;
	},
	xmlToArray: function (provider, xmlList, start, count) {
		start = arguments.length > 2 ? start : 0;
		count = arguments.length > 3 ? count : -1;
		var rows = null;
		var xmlToRow = DataHelper.xmlToRow;
		var cnt = xmlList ? xmlList.length : 0;
		if (cnt) {
			start = Math.max(0, start);
			if (count < 0) {
				count = cnt;
			}
			count = Math.min(cnt - start, count);
			if (count) {
				var flds = provider.getFields();
				var fldNames = provider.getOrgFieldNames();
				var fldCnt = flds.length;
				rows = new Array(count);
				for (var i = 0; i < count; i++) {
					var xml = xmlList[i + start];
					var vals = xmlToRow(xml, flds, fldNames);
					rows[i] = vals;
				}
			}
		}
		return rows;
	}
};
var $_parseCSV = function (line, delimiter) {
	var words = [];
	if (line && line.length > 0) {
		var c;
		var d;
		var prev = 0;
		var q1 = -1;
		var q2 = -1;
		var q = false;
		var qq = false;
		var len = line.length;
		var w = null;
		for (var i = 0; i < len; i++) {
			c = line.charAt(i);
			if (c == delimiter) {
				if (!q) {
					d = i - prev;
					if (d <= 0) {
						w = "";
					} else if (q2 == i - 1 && q1 == prev) {
						w = line.substring(q1 + 1, q2);
						if (qq) {
							w = w.replace('""', '"');
						}
					} else {
						w = line.substring(prev, i);
					}
					words.push(w);
					q = qq = false;
					prev = i + 1;
				}
			} else if (c == '"') {
				if (!q) {
					q1 = i;
					q2 = -1;
					q = true;
				} else if (q2 < 0) {
					q2 = i;
					q = false;
				} else if (q2 == i - 1) {
					qq = true;
					q = true;
					q2 = -1;
				}
			} /*else {
				w += c;
			}*/
		}
		if (prev < len) {
			if (q2 == len - 1 && q1 == prev) {
				w = line.substring(q1 + 1, q2);
				if (qq) {
					w = w.replace('""', '"');
				}
			} else {
				w = line.substring(prev, len);
			}
			words.push(w);
		}
	}
	return words;
};
var /* @internal */ FieldSummary = function (field) {
	this.field = field;
	this.count = 0;
	this.sum = NaN;
	this.max = NaN;
	this.min = NaN;
	this.avg = NaN;
	this.vars = NaN;
	this.datacount = 0;
	this.dataavg = NaN;
};
FieldSummary.prototype.clear = function () {
	this.count = this.datacount = 0;
	this.sum = this.max = this.min = this.avg = this.vars = this.dataavg = NaN;
};
var LocalDataProvider = defineClass("LocalDataProvider", DataProvider, {
	init: function () {
		DataProvider$.init.call(this);
		this._points = [];
		this._nextPoint = 0;
		this._values = [];
		this._rowIds = [];
		this._rowStates = [];
		this._orgValues = null;
		this._needRestore = false;
		this._deletedCount = 0;
		this._nextRowId = 0;
		this._hideRowIds = [];
		this.calculateRuntime();
	},
	destroy: function() {
		this._destroying = true;
		this._values = null;
		this._rowIds = null;
		this._rowStates = null;
		this._points = null;
		this._orgValues = null;
		this._hideRowIds = null;
		this._super();
	},
	getRowId: function (row) {
		return this._rowIds[row];
	},
	getDataRowById: function(rowId) {
		return this._rowIds.indexOf(rowId);
	},
	addRow: function (values) {
		var r = this.rowCount();
		return this.insertRow(this._values.length, values) ? r : -1;
	},
	rowCount: function () {
		return this._values.length;
	},
	isSummarized: function () {
		return true;
	},
	deletedCount: function () {
		return this._deletedCount;
	},
	getOptions: function () {
		return this._super();
	},
	setOptions: function (value) {
		this._super(value);
	},
	$_internalInsertField: function (index, field) {
		index = this._super(index, field);
		if (index >= 0) {
			var r, vals;
			var	rows = this._values.length;
			for (r = 0; r < rows; r++) {
				vals = this._values[r];
				vals && vals.splice(index, 0, undefined);
			}
			if (this._orgValues) {
				rows = Math.min(rows, this._orgValues.length);
				for (r = 0; r < rows; r++) {
					vals = this._orgValues[r];
					vals && vals.splice(index, 0, undefined);
				}
			}
		}
		return index;
	},
	internalClearFields: function () {
		DataProvider$.internalClearFields.call(this);
		this.$_clearRows();
	},
	hasData: function (row) {
		return row >= 0 && row < this._values.length && this._values[row] !== undefined;
	},
	setRowCount: function (newCount, fillDefaults, defaultValues, rowState) {
		if (!this._checkClientState()) return;
		fillDefaults = arguments.length > 1 ? fillDefaults : false;
        defaultValues = arguments.length > 2 ? defaultValues : null;
        rowState = arguments.length > 3 ? rowState : "none";
		var values = this._values;
		var oldCount = values.length;
		var count = Math.max(0, newCount);
		if (count == oldCount) {
			return;
		}
		var ids = this._rowIds;
		var states = this._rowStates;
		var i, j, fld, vals, flds, defaults;
		this.refreshFieldFormats();
		values.length = ids.length = states.length = count;
		if (this._orgValues && this._orgValues.length > count) {
			this._orgValues.length = count;
		}
		if (count > oldCount && (fillDefaults || defaultValues)) {
			flds = this._fields.length;
			defaults = defaultValues;
			if (!_isArray(defaults) && defaults && _isObject(defaults)) {
				defaults = this.objectToRow(defaults);
			}
			if (defaults && defaults.length < 1) {
				defaults = null;
			}
			if (fillDefaults || defaults) {
				var v;
				var defCount = defaults ? Math.min(defaults.length, flds) : 0;
				for (i = oldCount; i < count; i++) {
					vals = [];
					if (fillDefaults) {
						for (j = 0; j < flds; j++) {
							fld = this._fields[j];
							vals[j] = fld._defaultValue !== undefined ? fld._defaultValue : fld._nullValue;
						}
					}
					if (defCount > 0) {
						for (j = 0; j < defCount; j++) {
							v = defaults[j];
							if (v !== undefined) {
								vals[j] = this._fields[j].readValue(v);
							}
						}
					}
					values[i] = vals;
				}
			}
		} else if (count < oldCount && this._deletedCount > 0) {
			for (i = oldCount - 1; i >= count; i--) {
				if (states[i] == RowState.DELETED || states[i] == RowState.CREATE_AND_DELETED) {
					this._deletedCount--;
				}
				states[i] = RowState.NONE;
			}
		}
		rowState = this.isCheckStates() && rowState ? rowState : RowState.NONE;
		for (i = oldCount; i < count; i++) {
			states[i] = rowState;
			ids[i] = this._nextRowId++;
		}
		for (i = this._hideRowIds.length-1; i >= 0; i--) {
			j = this._hideRowIds[i];
			ids.indexOf(j) < 0 && this._hideRowIds.splice(i,1);
		}
		this.tags().setRowCount(count);
		this._fireRefresh();
		this._fireRowCountChanged();
	},
	$_clearRows: function () {
		this._values.length = 0;
		this._values = [];
		this._rowIds.length = 0;
		this._rowIds = [];
		this._rowStates.length = 0;
		this._rowStates = [];
		this._hideRowIds.length = 0;
		this._hideRowIds = [];
		if (this._orgValues) {
			this._orgValues.length = 0;
			this._orgValues = [];
		} else {
			this._orgValues = null;
		}
		this._deletedCount = 0;
		this.tags().clearRows();
	},
	clearRows: function () {
		if (!this._checkClientState()) return;
		this.$_clearRows();
		this._fireRefresh();
		this._fireRowCountChanged();
	},
	setRows: function (rows, start, count) {
		if (!this._checkClientState()) return;
		start = arguments.length > 1 ? start : 0;
		count = arguments.length > 2 ? count : -1;
		if (count == 0) {
			return;
		}
		var t = getTimer();
		_trace(">>>>>> set rows..." + t);
		this.refreshFieldFormats();
		this.beginUpdate();
		try {
			this.$_clearRows();
			var checkSt = this.isCheckStates();
			var filters = this._filters;
			var len, end, n, r, i, row;
			if (rows && (len = rows.length) > 0 && start < len) {
				start = Math.max(0, start);
				if (count < 0) { 
					count = len;
				} else {
					count = Math.min(count, len - start);
				}
				if (filters) {
					this._values.length = this._rowIds.length = this._rowStates.length = count;
					filters.prepare(this);
					end = len;
					r = n = 0;
					for (i = start; i < end && r < count; i++) {
						row = rows[i];
						if (!_isArray(row)) {
							row = this.objectToRow(row);
						}
						if (filters.select(n++, row)) {
							this._internalSetRow(r++, row, checkSt);
						}
					}
					this._values.length = this._rowIds.length = this._rowStates.length = r;
				} else {
					end = Math.min(len, start + count);
					if (end > start) {
						this._values.length = this._rowIds.length = this._rowStates.length = end - start;
						r = 0;
						for (i = start; i < end; i++) {
							row = rows[i];
							if (!_isArray(row)) {
								row = this.objectToRow(row);
							}
							this._internalSetRow(r++, row, checkSt);
						}
					}
				}
			}
		} finally {
			this.endUpdate(false);
		}
		this.tags().setRows();
		this._fireRefresh();
		this._fireRowCountChanged();
	},
	setXmlRows: function (rows, start, count) {
		if (!this._checkClientState()) return;
		start = arguments.length > 1 ? start : 0;
		count = arguments.length > 2 ? count : -1;
		if (count == 0) return;
		rows = DataHelper.xmlToArray(this, rows, start, count);
		this.setRows(rows);
	},
	addRows: function (rows, start, count, rowEvents) {
		start = arguments.length > 1 ? start : 0;
		count = arguments.length > 2 ? count : -1;
        rowEvents = arguments.length > 3 ? rowEvents : false;
        this.insertRows(this.rowCount(), rows, start, count, rowEvents);
	},
	appendRows: function (rows, start, count, rowEvents) {
		start = arguments.length > 1 ? start : 0;
		count = arguments.length > 2 ? count : -1;
		rowEvents = arguments.length > 3 ? rowEvents : false;
		this.insertRows(this.rowCount(), rows, start, count, rowEvents);
	},
	insertRows: function (row, rows, start, count, rowEvents, itemIndex) {
		start = arguments.length > 2 ? start : 0;
		count = arguments.length > 3 ? count : -1;
        rowEvents = arguments.length > 4 ? rowEvents : false;
		var len;
		if (!rows || (len = rows.length) < 1) {
			return;
		}
		var i, end, r, v;
		count = (count < 0) ? len : Math.min(len, count);
		if (count == 0) {
			return;
		}
		this._checkClientState();
		if (row < 0 || row > this._values.length) {
			throw new RangeError("row is out of bounds:" + row);
		}
		this.refreshFieldFormats();

		start = Math.max(0, start);
		end = Math.min(len, start + count);
		if (rowEvents) {
			r = row;
			for (i = start; i < end; i++) {
				if (this._fireRowInserting(r)) {
					v = rows[i];
					if (!_isArray(v)) {
						v = this.objectToRow(v);
					}
					this._internalInsertRow(r, v);
					this.tags().insertRow(r);
					this._fireRowInserted(r);
					this._fireRowCountChanged();
					r++;
				}
			}
		} else {
			r = row;
			for (i = start; i < end; i++, r++) {
				v = rows[i];
				if (!isArray(v)) {
					v = this.objectToRow(v);
				}
				this._internalInsertRow(r, v);
			}
			this.tags().insertRows(row, count = end - start);
			this._fireRowsInserted(row, count, itemIndex);
			this._fireRowCountChanged();
		}
	},
	appendXmlRows: function (rows, start, count, rowEvents) {
		this.insertXmlRows(this.rowCount(), rows, start, count, rowEvents);
	},
	insertXmlRows: function (row, rows, start, count, rowEvents, itemIndex) {
		if (!this._checkClientState()) return;
		start = arguments.length > 2 ? start : 0;
		count = arguments.length > 3 ? count : -1;
		rows = DataHelper.xmlToArray(this, rows, start, count);
		this.insertRows(row, rows, start, count, rowEvents, itemIndex);
	},
	updateRows: function (row, rows, start, count, rowEvents) {
		this.$_updateRows(row, rows, start, count, false, rowEvents);
	},
	updateStrictRows: function (row, rows, start, count, rowEvents) {
		this.$_updateRows(row, rows, start, count, true, rowEvents);
	},
	$_updateRows: function (row, rows, start, count, strict, rowEvents) {
		if (!this._checkClientState()) return;
        start = arguments.length > 2 ? start : 0;
        count = arguments.length > 3 ? count : -1;
        rowEvents = arguments.length > 4 ? rowEvents : false;
		var len;
		if (!rows || (len = rows.length) < 1) { 
			return;
		}
		count = (count < 0) ? len : Math.min(len, count);
		if (count == 0) {
			return;
		}
		this.refreshFieldFormats();
		var i, r, end, v;
		var rowCount = this.rowCount();
		start = Math.max(0, start);
		end = Math.min(len, start + count);
		if (end <= start) {
			return;
		}
		if (rowEvents) {
			r = row;
			for (i = start; i < end; i++, r++) {
				if (r >= rowCount) {
					break;
				}
				if (this._fireRowUpdating(r)) {
					v = rows[i];
					this._internalUpdateRow(r, v, strict, true);
					this.tags().updateRow(r);
					this._fireRowUpdated(r);
				}
			}
		} else {
			var list = [];
			r = row;
			for (i = start; i < end; i++, r++) {
				if (r >= rowCount) {
					break;
				}
				if (this._rowStates[r] == RowState.NONE) {
					list.push(r);
				}
				v = rows[i];
				this._internalUpdateRow(r, v, strict, false);
			}
			if (list.length > 0) {
				this._fireRowStatesChanged(list);
			}
			this.tags().updateRows(row, count = end - start);
			this._fireRowsUpdated(row, count);
		}
	},
	updateXmlRows: function (row, rows, start, count, rowEvents) {
		if (!this._checkClientState()) return;
		rows = DataHelper.xmlToArray(this, rows, start, count);
		this.updateRows(row, rows, start, count, rowEvents);
	},
	getValue: function (row, field) {
		this._checkRowIndex(row);
		this._checkFieldIndex(field);
		var vals = this._values[row];
		return vals ? vals[field] : UNDEFINED;
	},
	setValue: function (row, field, value) {
		if (!this._checkClientState()) {
            return false;
        }
		this._checkRowIndex(row);
		this._checkFieldIndex(field);
        var fld = this._fields[field];
        var state = this._rowStates[row];
        if (!fld._updatable && (state == RowState.NONE || state == RowState.UPDATED)) {
            return false;
        }
		var vals = this._values[row];
		var newVal = fld.readValue(value);
		if (vals && fld.equalValues(newVal, vals[field])) {
			return false;
		}
		this.refreshFieldFormat(fld);
		var oldVals;
		var needState = this.isCheckStates() && (state == RowState.NONE || !state);
		if (!vals) {
			this._values[row] = vals = [];
		}
		if (needState && this._orgValues) {
			oldVals = vals.concat();
		}
		vals[field] = newVal;
		this.$_internalCalculateValues(vals, row);

		if (needState) {
			if (oldVals) {
				this._orgValues[row] = oldVals;
			}
			this._changeRowState(row, RowState.UPDATED, true);
		} else if (this._needRestore) {
			this.$_restoreState(row);
		}
		this.tags().setValue(row, field);
		this._fireValueChanged(row, field);
        return true;
	},
	getRow: function (row) {
		this._checkRowIndex(row);
		var vals = this._values[row];
		return vals ? vals.slice() : [];
	},
	$_getRowObject: function (row, fldCount) {
		var	data = {};
		var	vals = this._values[row];
		if (vals) {
			for (var i = 0; i < fldCount; i++) {
				var fld = this.getOrgFieldName(i);
				data[fld] = vals[i];
			}
		}
		return data;
	},
	getRowObject: function (row) {
		this._checkRowIndex(row);
		return this.$_getRowObject(row, this.fieldCount());
	},
	getRows: function (startRow, endRow) {
        startRow = arguments.length > 0 ? startRow : 0;
        endRow = arguments.length > 1 ? endRow : -1;
        var rowCount = this._values.length;
		var r1 = Math.max(0, startRow);
		var r2 = endRow < 0 ? rowCount - 1 : Math.min(rowCount - 1, endRow);
		if (r1 >= rowCount || r2 < r1) {
			return [];
		}
		var i;
		var cnt = r2 - r1 + 1;
		var rows = new Array(cnt);
		for (i = 0; i < cnt; i++) {
			rows[i] = this._values[i + r1] || [];
		}
		return rows;
	},
	getRowObjects: function (startRow, endRow) {
        startRow = arguments.length > 0 ? startRow : 0;
        endRow = arguments.length > 1 ? endRow : -1;
        var rowCount = this._values.length;
		var r1 = Math.max(0, startRow);
		var r2 = endRow < 0 ? rowCount - 1 : Math.min(rowCount - 1, endRow);
		if (r1 >= rowCount || r2 < r1) {
			return [];
		}
		var fldCount = this.fieldCount();
		var cnt = r2 - r1 + 1;
		var rows = new Array(cnt);
		for (var i = 0; i < cnt; i++) {
			rows[i] = this.$_getRowObject(i + r1, fldCount);
		}
		return rows;
	},
    getOutputObjects: function (options, startRow, endRow) {
        var rows = this.getRowObjects(startRow, endRow);
        options && this.$_createOutputRows(rows, options, startRow);
        return rows;
    },
	getOutputObject: function (options, row) {
		var r = this.getRowObject(row);
		options && this.$_createOutputRows([r], options);
		return r;
	},
	getColumn: function (field, startRow, endRow) {
		startRow = arguments.length > 1 ? startRow : 0;
		endRow = arguments.length > 2 ? endRow : -1;
		this._checkFieldIndex(field);
		var rowCount = this._values.length;
		endRow = endRow < 0 ? rowCount - 1 : Math.min(rowCount - 1, endRow);
		startRow = Math.max(0, startRow);
		if (startRow >= rowCount || endRow < startRow) {
			return null;
		}
		var values = new Array(endRow - startRow + 1);
		for (var i = startRow; i <= endRow; i++) {
			var vals = this._values[i];
			values[i - startRow] = vals && vals[field];
		}
		return values;
	},
	/* 중복 코드
	hasData: function (row) {
		if (row >= 0 && row < this._values.length) {
			return  this._values[row] !== UNDEFINED;
		} else {
			return false;
		}
	},*/
	updateRow: function (row, values) {
		return this.$_updateRow(row, values, false);
	},
	updateStrictRow: function (row, values) {
		return this.$_updateRow(row, values, true);
	},
	$_updateRow: function (row, values, strict) {
		if (!this._checkClientState()) return;
		this._checkRowIndex(row);
		this.refreshFieldFormats();
		if (values && this._fireRowUpdating(row)) {
			this._internalUpdateRow(row, values, strict, true);
			this.tags().updateRow(row);
			this._fireRowUpdated(row);
			return true;
		}
		return false;
	},
	insertRow: function (row, values, itemIndex) {
		if (!this._checkClientState()) return false;
		if (row < 0 || row > this._values.length) {
			throw new RangeError("row is out of bounds:" + row);
		}
		this.refreshFieldFormats();
		if (values && this._fireRowInserting(row, values)) {
			if (!isArray(values)) {
				values = this.objectToRow(values);
			}
			this._internalInsertRow(row, values);
			this.tags().insertRow(row);
			this._fireRowInserted(row, itemIndex);
			this._fireRowCountChanged();
			return true;
		}
		return false;
	},
	appendRow: function (values) {
		var r = this.rowCount();
		return this.insertRow(this._values.length, values) ? r : -1;
	},
	$_deleteRow: function (row) {
		if (this._fireRowRemoving(row)) {
			var state = this._rowStates[row];
			this._internalRemoveRow(row);
			if (RowState.isDeleted(state)) {
				this._deletedCount--;
			}
			this.tags().removeRow(row);
			this._fireRowRemoved(row);
			this._fireRowCountChanged();
			return true;
		}
		return false;
	},
	removeRow: function (row) {
		if (!this._checkClientState()) return;
		this._checkRowIndex(row);
		if (this._softDeleting && this._checkStates) {
			var state = this._rowStates[row];
			switch (state) {
			case RowState.CREATED:
				if (this._deleteCreated) {
					this.$_deleteRow(row);	
				} else {
					this._changeRowState(row, RowState.CREATE_AND_DELETED, true, true, true);
				}
				break;
			case RowState.DELETED:
			case RowState.CREATE_AND_DELETED:
				break;
			default:
				this._changeRowState(row, RowState.DELETED, true, true, true);
				break;
			}
			return true;
		} else {
			return this.$_deleteRow(row);
		}
	},
	removeRows: function (rows, rowEvents) {
		if (!this._checkClientState()) return;
		var i, cnt, changed, row, state,
			deleteCreated = this.isDeleteCreated();
		if (!rows || (cnt = rows.length) < 1) {
			return;
		}
		if (this._softDeleting && this._checkStates) {
			var changed;
			var stateRows = rowEvents ? null : [];
			for (i = cnt; i--;) {
				row = rows[i];
				this._checkRowIndex(row);
				changed = false;
				state = this._rowStates[row];
				switch (state) {
					case RowState.CREATED:
						if (!deleteCreated) {
							changed = this._changeRowState(row, RowState.CREATE_AND_DELETED, rowEvents, false, true);
							rows.splice(i, 1);
						}
						break;
					case RowState.DELETED:
					case RowState.CREATE_AND_DELETED:
						rows.splice(i, 1);
						break;
					default:
						changed = this._changeRowState(row, RowState.DELETED, rowEvents, false, true);
						rows.splice(i, 1);
						break;
				}
				if (stateRows && changed) {
					stateRows.push(row);
				}
			}
			if (!rowEvents) {
				if (stateRows && stateRows.length > 0) {
					this._fireRowStatesChanged(stateRows);
				}
			}
		} 
		if ((cnt = rows.length) > 0) {
			if (cnt > 1) {
				rows.sort(function (v1, v2) {
					return v1 - v2;
				});
			}
			if (rowEvents) {
				for (i = cnt; i--;) {
					row = rows[i];
					this._checkRowIndex(row);
					this.$_deleteRow(row);
				}
			} else if (this._fireRowsRemoving(rows)) {
				for (i = cnt; i--;) {
					row = rows[i];
					this._checkRowIndex(row);
					state = this._rowStates[row];
					this._internalRemoveRow(row);
					if (RowState.isDeleted(state)) {
						this._deletedCount--;
					}
				}
				this.tags().removeRows(rows);
				this._fireRowsRemoved(rows);
				this._fireRowCountChanged();
			}
		}
	},
	moveRow: function (row, newRow) {
		if (!this._checkClientState()) return;
		if (row == newRow) {
			return;
		}
		this._checkRowIndex(row);
		this._checkRowIndex(newRow);
		if (this._fireRowMoving(row, newRow)) {
			this._internalMoveRow(row, newRow);
			this.tags().moveRow(row, newRow);
			this._fireRowMoved(row, newRow);
		}
	},
	moveRows: function (row, count, newRow) {
		if (!this._checkClientState()) return;
		if (count < 1 || row == newRow) {
			return;
		}
		this._checkRowIndex(row);
		this._checkRowIndex(newRow);
		if (this._fireRowsMoving(row, count, newRow)) {
			this._internalMoveRows(row, count, newRow);
			this.tags().moveRows(row, count, newRow);
			this._fireRowsMoved(row, count, newRow);
		}
	},
	getRowState: function (row) {
		this._checkRowIndex(row);
		return this._rowStates[row] || RowState.NONE;
	},
	$_checkDeleted: function (oldState, newState) {
		if (RowState.isDeleted(newState)) {
			this._deletedCount++;
		} else if (RowState.isDeleted(oldState) && !RowState.isDeleted(newState)) {
			this._deletedCount--;
		}
	},
	setRowState: function (row, state, force) {
		if (!this._checkClientState()) return;
		this._checkRowIndex(row);
		if (this._orgValues) {
			this._changeRowStateEx(row, state, true, force);
		} else {
			this._changeRowState(row, state, true, force);
		}
	},
	setRowStates: function (rows, state, force, rowEvents) {
		if (!this._checkClientState()) return;
		var i, cnt, row, list, states, oldState;
		if (!rows || (cnt = rows.length) < 1) {
			return;
		}
		if (rowEvents) {
			for (i = 0; i < cnt; i++) {
				row = rows[i];
				this._checkRowIndex(row);
				this._changeRowStateEx(row, state, true, force);
			}
		} else {
			list = [];
			states = this._rowStates;
			for (i = 0; i < cnt; i++) {
				row = rows[i];
				this._checkRowIndex(row);
				oldState = states[row];
				if (state != oldState) {
					states[row] = state;
					list.push(row);
					this.$_checkDeleted(oldState, state);
					if (this._orgValues) {
						this.$_prepareOrgValues(row, oldState, state);
					}
				}
			}
			if (list.length > 0) {
				this._fireRowStatesChanged(list);
			}
		}
	},
	clearRowStates: function (deleteRows, rowEvents) {
		if (!this._checkClientState()) return;
        rowEvents = arguments.length > 1 ? rowEvents : false;
        var i, state;
		var states = this._rowStates;
		var rows = [];
		for (i = states.length; i--;) {
			state = states[i];
			switch (state) {
			case RowState.CREATE_AND_DELETED:
			case RowState.DELETED:
				if (deleteRows) {
					if (rowEvents) {
						this.$_deleteRow(i);
					} else {
						this._internalRemoveRow(i);
						this._deletedCount--;
					}
					rows.push(i);
				} else {
					this._changeRowState(i, RowState.NONE, rowEvents);
					this._deletedCount--;
				}
				break;
			default:
				this._changeRowState(i, RowState.NONE, rowEvents);
				break;
			}
		}
		this.$_resetOrgValues();
		if (!rowEvents) {
			if (rows.length > 0) {
				this._fireRowsRemoved(rows);
				this._fireRowCountChanged();
			}
			this._fireRowStatesCleared();
		}
	},
	getStateRows: function (state) {
		var i, cnt,	st,
			rows = [];
		if (state) {
			for (i = 0, cnt = this._rowStates.length; i < cnt; i++) {
				st = this._rowStates[i];
				if (st == state) {
					rows.push(i);
				}
			}
		}
		return rows;
	},
	getAllStateRows: function () {
		var i, cnt,	st;
		var rows = {};
		var created = rows.created = [];
		var updated = rows.updated = [];
		var deleted = rows.deleted = [];
		var cdeleted = rows.createAndDeleted = [];
		for (i = 0, cnt = this._rowStates.length; i < cnt; i++) {
			st = this._rowStates[i];
			if (st === RowState.CREATED) {
				created.push(i);
			} else if (st === RowState.UPDATED) {
				updated.push(i);
			} else if (st === RowState.DELETED) {
				deleted.push(i);
			} else if (st === RowState.CREATE_AND_DELETED) {
				cdeleted.push(i);
			}
		}
		return rows;
	},
	getRowStateCount: function (states) {
		var i, state;
		var len = states ? states.length : 0;
		var cnt = this._rowStates.length; 
		var count = 0;
		if (len && cnt) {
			if (len > 1) {
				for (i = 0; i < cnt; i++) {
					state = this._rowStates[i];
					if (states.indexOf(state) >= 0) {
						count++;
					}
				}
			} else {
				state = states[0];
				for (i = 0; i < cnt; i++) {
					if (this._rowStates[i] === state) {
						count++;
					}
				}
			}
		}
		return count;
	},
	$_restoreState: function (row) {
		var state = this._rowStates[row];
		if (state === RowState.UPDATED) {
			var orgs = this._orgValues[row];
			if (orgs) {
				var vals = this._values[row];
                var strict = this.isStrictRestore();
                for (var i = 0, cnt = this._fields.length; i < cnt; i++) {
                    var v1 = vals.length > i ? vals[i] : undefined;
                    var v2 = orgs.length > i ? orgs[i] : undefined;
                    if (strict) {
                        if (!this._fields[i].equalValues(v1, v2)) {
                            return false;
                        }
                    } else {
                        if (!this._fields[i].sameValues(v1, v2)) {
                            return false;
                        }
                    }
                }
                this._rowStates[row] = RowState.NONE;
                return true;
			}
		}
		return false;
	},
	restoreUpdatedStates: function (rows) {
		if (!this._orgValues) return;
		if (!this._checkClientState()) return;
		var i, cnt, r;
		var list = [];
		rows = typeof rows === "number" ? [rows] : rows;
		if (_isArray(rows)) {
			for (i = 0, cnt = rows.length; i < cnt; i++) {
				r = rows[i];
				if (r >= 0 && r < this._values.length) {
					if (this.$_restoreState(r)) {
						list.push(r);
					}
				}
			}
		} else {
			for (i = 0, cnt = this._values.length; i < cnt; i++) {
				if (this.$_restoreState(i)) {
					list.push(i);
				}
			}
		}
		if (list.length > 0) {
			this._fireRowStatesChanged(list);
		}
	},
	$_restoreRow: function (row) {
		var state = this._rowStates[row];
		if (state === RowState.UPDATED) {
			var orgs = this._orgValues[row];
			if (orgs) {
				var vals = this._values[row];
				for (var i = 0, cnt = Math.min(orgs.length, this._fields.length); i < cnt; i++) {
					vals[i] = orgs[i];
				}
				this._rowStates[row] = RowState.NONE;
				return true;
			}
		}
		return false;
	},
	restoreUpdatedRows: function (rows) {
		if (!this._orgValues) return;
		if (!this._checkClientState()) return;
		var i, cnt, r;
		var list = [];

        if (_isArray(rows)) {
			for (i = 0, cnt = rows.length; i < cnt; i++) {
				r = rows[i];
				if (r >= 0 && r < this._values.length) {
					if (this.$_restoreRow(r)) {
						list.push(r);
					}
				}
			}
		} else if (rows || rows == 0) {		
			r = rows;		
			if (r >= 0 && r < this._values.length) {		
				if (this.$_restoreRow(r)) {		
					list.push(r);		
				}		
			}
		} else {
			for (i = 0, cnt = this._values.length; i < cnt; i++) {
				if (this.$_restoreRow(i)) {
					list.push(i);
				}
			}
		}
		if (list.length > 0) {
			this._fireRestoreRows(list);
			this._fireRowStatesChanged(list);
		}
	},
	getUpdatedCells: function (rows) {
		var mode = this.restoreMode();
		if (!this._orgValues || !(mode == RestoreMode.AUTO || mode == RestoreMode.EXPLICIT)) return null;
		if (rows == null) {
			rows = this.getStateRows(RowState.UPDATED);
		} else if (!_isArray(rows)) {
			if (typeof rows == "number") {
				rows = [rows];
			}
		}
		if (!_isArray(rows)) {
			return null;
		}
		var ret = [];
		for (var i=0, cnt=rows.length; i<cnt; i++) {
			var row = rows[i];
			var orgs = row >= 0 && this._orgValues && row < this._orgValues.length ? this._orgValues[row] : null;
			if (orgs) {
				var vals = this._values[row];
				var strict = this.isStrictRestore();
				var updateCells = [];
                for (var j = 0, fcnt = this._fields.length; j < fcnt; j++) {
                    var v1 = vals.length > j ? vals[j] : undefined;
                    var v2 = orgs.length > j ? orgs[j] : undefined;
                    if (this._fields[j].isCalculated()) continue;
                    if (strict) {
                        if (!this._fields[j].equalValues(v1, v2) ) {
                            updateCells.push({
                            	fieldName:this.getOrgFieldName(j),
                            	oldValue:orgs[j],
                            	newValue:vals[j]
                            })
                        }
                    } else {
                        if (!this._fields[j].sameValues(v1, v2)) {
                            updateCells.push({
                            	fieldName:this.getOrgFieldName(j),
                            	oldValue:orgs[j],
                            	newValue:vals[j]
                            })
                        }
                    }
                }
                if (updateCells.length > 0) {
                	ret.push({	__rowId:row,
								updatedCells:updateCells
                	         })
                }
			}
		}
		return ret;
	},
	findRow: function (fields, values) {
		if (!fields || fields.length < 1 || !values || values.length < fields.length) {
			return -1;
		}
		var i, c, cnt, row, len, found, 
			flds = [],
			vals = [],
			rows = this._values;
		cnt = fields.length;
		for (i = 0; i < cnt; i++) {
			if (typeof fields[i] === "string") {
				c = this.getFieldIndex(fields[i]);
			} else {
				c = Number(fields[i]);
			}
			if (c >= 0 && c < this.fieldCount() && flds.indexOf(c) < 0) {
				flds.push(c);
				vals.push(values[i]);
			}
		}
		len = flds.length;
		for (i = 0; i < len; i++) {
			flds[i] = this._fields[flds[i]];
		}
		cnt = rows.length;
		for (i = 0; i < cnt; i++) {
			row = rows[i];
			found = true;
			for (c = 0; c < len; c++) {
				if (!flds[c].equalValues(vals[c], row[c])) {
					found = false;
					break;
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	},
	savePoint: function (saveStates) {
		if (!this._checkClientState()) return;
		saveStates = arguments.length > 0 ? arguments : true;
		var values = this._values;
		var flds = this._fields.length;
        var i, cnt, row, rows, states;
		if (flds > 0 && values && (cnt = values.length) > 0) {
			rows = new Array(cnt);
			for (i = 0; i < cnt; i++) {
				row = values[i];
				if (row) {
					row = row.concat();
				}
				rows[i] = row;
			}
			states = saveStates ? this._rowStates.concat() : null;
			i = this._nextPoint++;
			this._points.push({
				id: i,
				data: rows,
				states: states
			});
			return i;
		}
		return -1;
	},
	rollback: function (savePoint) {
		if (!this._checkClientState()) return;
		for (var i = this._points.length - 1; i >= 0; i--) {
			var point = this._points[i];
			if (point.id == savePoint) {
				this.$_removeSavePoints(i + 1);
				this.setRows(point.data);
                var states = point.states;
				if (states) {
					this._rowStates = states.concat();
				}
				break;
			}
		}
	},
	$_removeSavePoints: function (index) {
		var points = this._points;
        var point;
		for (var i = points.length - 1; i >= index; i--) {
			point = points[i];
			point.data = null;
			points.pop();
		}
	},
	clearSavePoints: function () {
		this.$_removeSavePoints(0);
	},
	getSavePoints: function () {
		var points = [];
		for (var i = 0, cnt = this._points.length; i < cnt; i++) {
			points.push(this._points[i].id);
		}
		return points;
	},
	canUpdateRow: function (row) {
		return true;
	},
	canAppendRow: function () {
		return true;
	},
	canInsertRow: function (row) {
		return true;
	},
	canDeleteRow: function (row) {
		return true;
	},
	$_getSortedRows: function (field) {
		var compFunc;
		var rows = new Array(this._values.length);
		switch (this.getField(field).dataType()) {
			case ValueType.NUMBER:
				compFunc = this.compareNumbers.bind(this);
				break;
			case ValueType.DATETIME:
				compFunc = this.compareDates.bind(this);
				break;
			case ValueType.BOOLEAN:
				compFunc = this.compareBools.bind(this);
				break;
			case ValueType.OBJECT:
				compFunc = this.compareObjects.bind(this);
				break;
			default:
				compFunc = this.compareValues.bind(this);
				break;
		}
		for (var i = rows.length; i--;) {
			rows[i] = i;
		}
		this.$_sortRows(rows, field, compFunc, 0, rows.length - 1);
		return rows;
	},
	getDistinctValues: function (field, maxCount, sortDir) {
		maxCount = arguments.length > 1 ? maxCount : -1;
		this._checkFieldIndex(field);
		var values = [];
		if (maxCount < 0) {
			maxCount = this._values.length;
		}
		if (maxCount > 0) {
			var i, cnt, value;
			var isNum = this.getField(field).dataType() == ValueType.NUMBER;
			var rows = this.$_getSortedRows(field);
			sortDir === SortDirection.DESCENDING && rows.reverse();
			var row = this._values[rows[0]];
			values.push(row ? row[field] : undefined);
			for (i = 1, cnt = rows.length; i < cnt; i++) {
				if (values.length >= maxCount) {
					break;
				}
				if (!this.equalValues(field, rows[i - 1], rows[i])) {
					row = this._values[rows[i]];
					value = row ? row[field] : undefined;
					if (values.indexOf(value) == -1 && (!isNum || !isNaN(value) )) {// undefined나 NaN이 중복들어가는것을 방지
						values.push(value);
					}
				}
			}
		}
		return values;
	},
	compareValues: function (field, row1, row2) {
		var vals1 = this._values[row1];
		var vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? vals1[field] : null;
			var v2 = vals2 ? vals2[field] : null;
			if (v1 === UNDEFINED || v1 === null) {
				return (v2 === UNDEFINED || v2 === null) ? 0 : -1;
			}
			if (v2 === UNDEFINED || v2 === null) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		}
	},
	compareTexts: function (field, row1, row2) {
		var vals1 = this._values[row1];
		var vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? vals1[field] : null;
			var v2 = vals2 ? vals2[field] : null;
			if (v1 === UNDEFINED || v1 === null) {
				return (v2 === UNDEFINED || v2 === null) ? 0 : -1;
			}
			if (v2 === UNDEFINED || v2 === null) {
				return 1;
			}
			v1 = String(v1).toLocaleLowerCase();
			v2 = String(v2).toLocaleLowerCase();
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		}
	},
	compareNumbers: function (field, row1, row2) {
		var vals1 = this._values[row1];
		var vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? vals1[field] : NaN;
			var v2 = vals2 ? vals2[field] : NaN;
			if (isNaN(v1)) {
				return (isNaN(v2)) ? 0 : -1;
			}
			if (isNaN(v2)) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		}
	},
	compareDates: function (field, row1, row2) {
		var vals1 = this._values[row1];
		var vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? vals1[field] : null;
			var v2 = vals2 ? vals2[field] : null;
			if (!(v1 instanceof Date)) {
				return !(v2 instanceof Date) ? 0 : -1;
			}
			if (!(v2 instanceof Date)) {
				return 1;
			}
			return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
		}
	},
	compareBools: function (field, row1, row2) {
		var vals1 = this._values[row1];
		var vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? Boolean(vals1[field]) : false;
			var v2 = vals2 ? Boolean(vals2[field]) : false;
			return (v1 && !v2) ? 1 : (!v1 && v2) ? -1 : 0;
		}
	},
	compareObjects: function (field, row1, row2) {
		var vals1 = this._values[row1];
		var vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? vals1[field] : null;
			var v2 = vals2 ? vals2[field] : null;
			if (!v1) {
				return !v2 ? 0 : -1;
			};
			if (!v2) {
				return 1;
			}
			var fld = this.getField(field);
			return fld.$_compareObject(v1, v2, row1, row2);
		}
	},
	summarize: function (field, calcVars) {
		if (field == null) {
			return false;
		}
		field.clear();
		var count = this.rowCount();
		if (count < 1) {
			return false;
		}
		var i,
			vals,
			v,
			n = 0,
			f = field.field,
			sum = 0,
			min = NaN,
			max = NaN;
		i = 0;
		while (i < count) {
			vals = this._values[i++];
			v = vals ? (vals[f] == null ? undefined : vals[f]) : NaN;
			if (!isNaN(v)) {
				sum = min = max = v;
				n++;
				break;
			}
		}
		while (i < count) {
			vals = this._values[i++];
			v = vals ? (vals[f] == null ? undefined : vals[f]) : NaN;
			if (!isNaN(v)) {
				sum += v;
				if (v < min) min = v;
				if (v > max) max = v;
				n++;
			}
		}
		field.count = count;
		if (n > 0) {
			field.sum = sum;
			field.min = min;
			field.max = max;
			field.avg = sum / count;
			field.datacount = n;
			field.dataavg = sum / n;
			if (calcVars) {
				var vars = 0,
					avg = field.avg;
				for (i = 0; i < count; i++) {
					vals = this._values[i];
					v = vals ? (vals[f] == null ? undefined : vals[f]) : NaN;
					if (!isNaN(v)) {
						vars += Math.pow(v - avg, 2);
					}
				}
				field.varsp = vars / count;
				field.vars = vars / (count - 1);
			} else {
				field.varsp = NaN;
				field.vars = NaN;
			}
		}
		return true;
	},
	summarizeRange: function (field, rows, calcVars) {
		if (field == null || rows == null) {
			return false;
		}
		field.clear();
		var count = rows.length;
		if (count < 1)
			return false;
		var i,
			r,
			vals,
			v,
			n = 0,
			f = field.field,
			sum = 0,
			min = NaN,
			max = NaN;
		i = 0;
		while (i < count) {
			r = rows[i++];
			vals = this._values[r];
			v = vals ? (vals[f] == null ? undefined : vals[f]) : NaN;
			if (!isNaN(v)) {
				sum = min = max = v;
				n++;
				break;
			}
		}
		while (i < count) {
			r = rows[i++];
			vals = this._values[r];
			v = vals ? (vals[f] == null ? undefined : vals[f]) : NaN;
			if (!isNaN(v)) {
				sum += v;
				if (v < min) min = v;
				if (v > max) max = v;
				n++;
			}
		}
		field.count = count;
		if (n > 0) {
			field.sum = sum;
			field.min = min;
			field.max = max;
			field.avg = sum / count;
			field.datacount = n;
			field.dataavg = sum / n;
			if (calcVars) {
				var vars = 0,
					avg = field.avg;
				for (i = 0; i < count; i++) {
					r = rows[i];
					vals = this._values[r];
					v = vals ? (vals[f] == null ? undefined : vals[f]) : NaN;
					if (!isNaN(v)) {
						vars += Math.pow(v - avg, 2);
					}
				}
				field.varsp = vars / count;
				field.vars = vars / (count - 1);
			} else {
				field.varsp = NaN;
				field.vars = NaN;
			}
		}
		return true;
	},
	_doFieldsReset: function () {
		this.$_clearRows();
		this._super();
	},
	_doCheckStatesChanged: function () {
		this.$_resetOrgValues();
	},
	_doRestoreModeChanged: function (oldMode, newMode) {
		this.$_resetOrgValues();
	},
    copyRows: function (sourceRow, count, targetRow, noStates) {
        this._checkRowIndex(sourceRow);
        var cnt = this._values.length
        count = Math.max(0, Math.min(count, cnt - sourceRow));
        if (count < 1 || targetRow > cnt) {
            return;
        }
        var rows = [];
        for (var i = 0; i < cnt; i++) {
            var values = this._values[i + sourceRow];
            var row = [];
            for (var f = 0, len = this._fields.length; f < len; f++) {
                var v = values[f];
                if (this._fields[f].dataType() == ValueType.DATE) {
                    row[f] = typeof v == Date ? new Date(v) : v;
                } else {
                    row[f] = v;
                }
            }
            rows.push(row);
        }
        var checkStates = this._checkStates;
        if (noStates) {
            this._checkStates = false;
        }
        try {
            this.insertRows(targetRow, rows);
        } finally {
            this._checkStates = checkStates;
        }
    },
	_checkRowIndex: function (row) {
		if (row < 0 || row >= this._values.length) {
			if ($_debug) debugger;
			throw new RangeError("row is out of bounds: " + row);
		}
	},
	$_resetOrgValues: function () {
		var mode = this.restoreMode();
		this._orgValues = (!this.isCheckStates() || mode == RestoreMode.NONE) ? null : [];
		this._needRestore = this._orgValues && mode == RestoreMode.AUTO;
	},
	_arrayToRow: function (values, row) {
		var c,
			cols = Math.min(values ? values.length : 0, this._fields.length),
			vals = new Array(cols);
		for (c = 0; c < cols; c++) {
			vals[c] = this._fields[c].readValue(values[c]);
		}
		this.$_internalCalculateValues(vals, row);
		return vals;
	},
	_internalInsertRow: function (row, values) {
		var vals = this._arrayToRow(values, row),
			append = row == this._values.length;
		if (append) {
			this._values.push(vals);
			this._rowIds.push(this._nextRowId++);
		} else {
			this._values.splice(row, 0, vals);
			this._rowIds.splice(row, 0, this._nextRowId++);
		}
		if (append) {
			this._rowStates.push(this.isCheckStates() ? RowState.CREATED : RowState.NONE);
		} else {
			this._rowStates.splice(row, 0, this.isCheckStates() ? RowState.CREATED : RowState.NONE);
			if (this._orgValues) {
				this._orgValues.splice(row, 0, undefined);
			}
		}
	},
	_internalSetRow: function (row, values, checkState) {
		var vals = this._arrayToRow(values, row);
		this._values[row] = vals;
		this._rowIds[row] = this._nextRowId++;
		if (this.isCheckStates()) {
			this._rowStates[row] = RowState.NONE;
		}
	},
	_xmlToRow: function (xml) {
	},
	_internalInsertXmlRow: function (row, xml, stateEvent) {
	},
	_internalSetXmlRow: function (row, xml) {
	},
	_internalUpdateRow: function (row, values, strict, stateEvent) {
		var c, v, oldVals, fld;
        var fields = this._fields;
		var isAry = _isArray(values)
		var	cnt = Math.min(fields.length, isAry ? values.length : fields.length);
		var	vals = this._values[row];
		var state = this._rowStates[row];
		var needState = this.isCheckStates() && (state == RowState.NONE || !state);
		if (!vals) {
			this._values[row] = vals = [];
		}
		if (needState && this._orgValues) {
			oldVals = vals.concat();
		}
		var changed = false;
		for (c = 0; c < cnt; c++) {
            fld = fields[c];
            if (fld._updatable || state == RowState.CREATED || state == RowState.CREATE_AND_DELETED) {
				if (isAry || values.hasOwnProperty(fld.orgFieldName())) { 
					v = isAry ? values[c] : values[fld.orgFieldName()];
					if (!strict || v !== UNDEFINED) {
						if (this._needRestore) {
							changed = changed || (strict ? !fld.equalValues(vals[c], fld.readValue(v)) : !fld.sameValues(vals[c], fld.readValue(v))); 
						} else {
							changed = true;
						}
						vals[c] = fld.readValue(v);
					}
                }
            }
		}
		if (changed)
			this.$_internalCalculateValues(vals, row);
		if (needState && changed) {
			if (oldVals) {
				this._orgValues[row] = oldVals;
			}
			this._changeRowState(row, RowState.UPDATED, stateEvent);
		} else if (this._needRestore) {
			this.$_restoreState(row);
		}
	},
	_internalUpdateXmlRow: function (row, xml, stateEvent) {
	},
	_internalRemoveRow: function (row) {
		var rowId = this._rowIds[row];
		this._hideRowIds.indexOf(rowId) >= 0 && this._hideRowIds.splice(this._hideRowIds.indexOf(rowId),1);
		this._values.splice(row, 1);
		this._rowIds.splice(row, 1);
		if (this._orgValues && this._orgValues.length > row) {
			this._orgValues.splice(row, 1);
		}
		this._rowStates.splice(row, 1);
	},
	_internalMoveRow: function (row, newRow) {
		var vals = this._values[row];
		var id = this._rowIds[row];
		var state = this._rowStates[row];
		this._values.splice(row, 1);
		this._rowIds.splice(row, 1);
		this._rowStates.splice(row, 1);
		this._values.splice(newRow, 0, vals);
		this._rowIds.splice(newRow, 0, id);
		this._rowStates.splice(newRow, 0, state);
		if (this._orgValues && this._orgValues.length > row) {
			vals = this._orgValues[row];
			this._orgValues.splice(row, 1);
			this._orgValues.splice(newRow, 0, vals);
		}
	},
	_internalMoveRows: function (row, count, newRow) {
		var rows = this._values.splice(row, count);
		var ids = this._rowIds.splice(row, count);
		var states = this._rowStates.splice(row, count);
		for (var i = 0, cnt = rows.length; i < cnt; i++) {
			this._values.splice(newRow + i, 0, rows[i]);
			this._rowIds.splice(newRow + i, 0, ids[i]);
			this._rowStates.splice(newRow + i, 0, states[i]);
		}
		if (this._orgValues && this._orgValues.length > row) {
			rows = this._orgValues.splice(row, count);
			this._orgValues.splice(newRow + i, 0, rows[i]);
		}
	},
	_changeRowState: function (row, newState, fireEvent, force, checkDeleted) {
		if (this.isCheckStates() || force) {
			var state = this._rowStates[row];
			newState = newState || RowState.NONE;
			if (newState != state) {
				this._rowStates[row] = newState;
				if (checkDeleted) {
					if (!RowState.isDeleted(state) && RowState.isDeleted(newState)) {
						this._deletedCount++;
					} else if (RowState.isDeleted(state) && !RowState.isDeleted(newState)) {
						this._deletedCount--;
					}
				}
				if (fireEvent) {
					this._fireRowStateChanged(row);
				}
				return true;
			}
		}
		return false;
	},
	$_prepareOrgValues: function (row, oldState, newState) {
		if (newState == RowState.UPDATED) {
			this._orgValues[row] = this._values[row] ? this._values[row].concat() : [];
		} else if (oldState == RowState.UPDATED) {
			if (this._orgValues[row]) {
				this._orgValues[row] = undefined;
			}
		}
	},
	_changeRowStateEx: function (row, newState, fireEvent, force, checkDeleted) {
		var oldState = this._rowStates[row];
		if (this._changeRowState(row, newState, false, force, checkDeleted)) {
			if (this._orgValues) {
				this.$_prepareOrgValues(row, oldState, newState);
			}

			if (fireEvent) {
				this._fireRowStateChanged(row);
			}
			return true;
		}
		return false;
	},
	/* */
	$_searchDataRow: function(fields, values, options, startDataRow, endDataRow) {
		var rows = this.rowCount();
		if (rows < 1) {
			return -1;
		}
		var flds = Math.min(fields.length, values.length);
		if (flds < 1) {
			return -1;
		}
		var i, item, found, c, v;
		var all = !options || options.allFields;
		var sensitive = options && options.caseSensitive;
		var partial = options && options.partialMatch;
		var dateConvert = null;
		var fieldTypes = [];
		for (c = 0; c < flds; c++) {
			fieldTypes[c] = this.getField(fields[c]).dataType();
		}
		startDataRow = Math.max(0, startDataRow);
		endDataRow = Math.min(rows - 1, endDataRow);
		for (i = startDataRow; i <= endDataRow; i++) {
			found = true;
			if (found) {
				for (c = 0; c < flds; c++) {
					v =  this.getValue(i, fields[c]);
					switch (fieldTypes[c]) {
						case ValueType.DATETIME :
						case ValueType.DATE :
							if (values[c] instanceof Date) {
								found = $$_compareTextValue(values[c], v, sensitive, partial);
							} else {
								if (!dateConvert) {
									var fmt = /[.]/.test(values[c]) ? "yyyy.MM.dd" : /[/]/.test(values[c]) ? "yyyy/MM/dd" : /[-]/.test(values[c]) ? "yyyy-MM-dd" : "yyyyMMdd";
									dateConvert = new DatetimeConverter(fmt);
								}
								found = $$_compareTextValue(values[c], v ? dateConvert.getText(v) : v, sensitive, partial);
							}
							break;
						default :
							found = $$_compareTextValue(values[c], v, sensitive, partial);
							break;
					}
					if (found && !all) {
						return i;
					}
					if (!found && all) {
						break;
					}
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	},
	searchDataRow: function(fields, values, options, startDataRow, wrap) {
		startDataRow = arguments.length > 3 ? startDataRow : 0;
		wrap = arguments.length > 4 ? wrap : true;
		options = options instanceof SearchOptions ? options : options ? new SearchOptions(options) : null;

		var result = -1;
		if (fields && fields.length > 0 && values && values.length > 0) {
			var c, n, f, index;
			var cnt = fields.length;
			var flds = [];
			for (c = 0; c < cnt; c++) {
				n = parseFloat(fields[c]);
				if (!isNaN(n) && n | 0 == n) {
					flds.push(n);
				} else {
					f = this.getFieldIndex(fields[c]);
					if (f >= 0) {
						flds.push(f);
					}
				}
			}
			if (flds.length > 0) {
				cnt = this.rowCount();
				startDataRow = Math.max(0, startDataRow);
				result = startDataRow < cnt ? this.$_searchDataRow(flds, values, options, startDataRow, cnt - 1) : -1;
				if (result < 0 && wrap && startDataRow > 0) {
					result = this.$_searchDataRow(flds, values, options, 0, startDataRow - 1);
				}
			}
		}
		return result;
	},
	$_searchData: function(fields, value, options, startDataRow, endDataRow, startFieldIndex) {
		var rows = this.rowCount();
		if (rows < 1) {
			return null;
		}
		var i, item, found, c, v;
		var sensitive = options && options.caseSensitive;
		var partial = options && options.partialMatch;
		var fldCount = this.fieldCount();
        var fldLen = fields.length;
        var dateConvert = null;
        var fieldTypes = [];
        for (c = 0; c < fldCount; c++) {
        	fieldTypes[c] = this.getField(c).dataType();
        }
		startDataRow = Math.max(0, startDataRow);
		endDataRow = Math.min(rows - 1, endDataRow);
		startFieldIndex = Math.max(0, startFieldIndex);
		if (startFieldIndex >= fields.length) {
			startDataRow++;
			startFieldIndex = 0;
		}
		for (i = startDataRow; i <= endDataRow; i++) {
            c = (i > startDataRow) ? 0 : startFieldIndex;
			for (; c < fldLen; c++) {
				var f = fields[c];
				if (f >= 0 && f < fldCount) {
					v = this.getValue(i, f);
					switch (fieldTypes[f]) {
						case ValueType.DATETIME :
						case ValueType.DATE :
							if (value instanceof Date) {
								found = $$_compareTextValue(value, v, sensitive, partial);	
							} else {
								if (!dateConvert) {
									var fmt = /[.]/.test(value) ? "yyyy.MM.dd" : /[/]/.test(value) ? "yyyy/MM/dd" : /[-]/.test(value) ? "yyyy-MM-dd" : "yyyyMMdd";
									dateConvert = new DatetimeConverter(fmt);
								}
								found = $$_compareTextValue(value, v ? dateConvert.getText(v) : v, sensitive, partial);
							}
							break;
						default :
							found = $$_compareTextValue(value, v, sensitive, partial);
							break;
					}
					if (found) {
						var returnObj = {
							dataRow: i,
							fieldIndex: f,
							searchFieldIndex: c
						};
						return returnObj;
					}
				}
			}
		}
		return null;
	},
	searchData: function (fields, value, options/* SearchCellOptions */, startDataRow, startFieldIndex, wrap) {
		startDataRow = arguments.length > 3 ? startDataRow : 0;
		startFieldIndex = arguments.length > 4 ? startFieldIndex : 0;
		wrap = arguments.length > 5 ? wrap : true;
		options = options instanceof SearchCellOptions ? options : options ? new SearchCellOptions(options) : null;
		var result = null;
		if (!fields || fields.length < 1) {
			fields = [];
			var arr = this.getFields();
			for (var i = 0; i < arr.length; i++) {
				fields.push(arr[i].orgFieldName());
			}
		}
		if (fields && fields.length > 0 && value != null) {
			var c, n;
			var cnt = fields.length;
			var flds = [];
			for (c = 0; c < cnt; c++) {
				n = parseFloat(fields[c]);
				if (!isNaN(n) && n | 0 == n) {
					flds.push(n);
				} else {
					flds.push(this.getFieldIndex(fields[c]));
				}
			}
			if (flds.length > 0) {
				cnt = this.rowCount();
				startDataRow = Math.max(0, startDataRow);
				startFieldIndex = Math.max(0, startFieldIndex);
				result = startDataRow < cnt ? this.$_searchData(flds, value, options, startDataRow, cnt - 1, startFieldIndex) : null;
				if (!result && wrap && startDataRow > 0) {
					result = this.$_searchData(flds, value, options, 0, startDataRow - 1, 0);
				}
				if (result) {
					result.fieldName = this.getOrgFieldName(result["fieldIndex"]);
				}
			}
		}
        return result;
	},
	isDataChanged: function(row, fieldIndex) {
		if (this._rowStates[row] !== RowState.UPDATED || !this._orgValues) {
			return false;
		}
		this._checkRowIndex(row);
		this._checkFieldIndex(fieldIndex);
		if (this._orgValues && this._orgValues[row]) {
			var v1 = this._orgValues[row][fieldIndex];
			var v2 = this.getValue(row,fieldIndex);
			var field = this._fields[fieldIndex];
			return field && field.dataType() !== ValueType.OBJECT && !field.sameValues(v1,v2);
		}
		return false;
	},
	$_hideDataRows: function(dataRows, hide) {
		if (dataRows == null) {
			return;
		};
		var idx, rowId;
		var ids = [];
		var oldCnt = this._hideRowIds.length;
		dataRows = _isArray(dataRows) ? dataRows : [dataRows];
		for (var i = 0, cnt = dataRows.length; i < cnt ; i++) {
			rowId = this.getRowId(dataRows[i]);
			if (rowId != undefined) {
				ids.push(dataRows[i]);
				if (hide) {
					this._hideRowIds.indexOf(rowId) < 0 && this._hideRowIds.push(rowId);
				} else {
					idx = this._hideRowIds.indexOf(rowId);
					idx >= 0 && this._hideRowIds.splice(idx, 1);
				}
			}
		}
		 this._hideRowIds.length !== oldCnt && this._fireRowHided(ids, hide);
	},
	hideDataRows: function(dataRows) {
		this.$_hideDataRows(dataRows, true);
	},
	showDataRows: function(dataRows) {
		this.$_hideDataRows(dataRows, false);
	},
	clearHideDataRows:function() {
		if (this._hideRowIds.length > 0) {
			this._hideRowIds = [];
			this._fireRowHided([],false);
		}
	},
	getHideDataRows: function() {
		var ret = [],
			dataRow = null;
		for (var i = 0, cnt = this._hideRowIds.length; i < cnt ; i++) {
			dataRow = this._rowIds.indexOf(this._hideRowIds[i]);
			dataRow >= 0 && ret.push(dataRow);
		}
		ret.sort(function(a,b) {return a - b});
		return ret;
	},
	isHideDataRow: function(dataRow) {
		var rowId = this._rowIds[dataRow];
		return this._hideRowIds.indexOf(rowId) >= 0;
	},
	hideCount: function() {
		return !!this._hideRowIds && this._hideRowIds.length;
	},
});
var /* @internal */ DataPath = defineClass("DataPath", null, {
    init : function() {
        Base.init.call(this);
    }
}, {
    extractJson: function (source, path) {
        var data = source;
        path = path && path.trim(path);
        if (path) {
            var segs = path.split(".");
            for (var k = 0; k < segs.length; k++) {
                var seg = segs[k] && segs[k].trim();
                if (seg) {
                    var i = seg.indexOf("[");
                    var j = seg.lastIndexOf("]");
                    if (i > 0 && j > i) {
                        var s = seg.substring(0, i);
                        var arr = (s != "$") ? data[s] : data;
                        if (_isArray(arr)) {
                            s = seg.substring(i + 1, j);
                            var idx = parseInt(s);
                            if (idx >= 0 && idx < arr.length) {
                                data = arr[idx];
                            } else {
                                data = null;
                            }
                        } else {
                            data = null;
                        }
                    } else if (seg != "$") {
                        data = data[seg];
                    }
                    if (!data) {
                        break;
                    }
                }
            }
        }
        return _isArray(data) ? data : null;
    },
    /**
     * row => root의 "row" elements
     * row.row => root -> row[0] -> "row" elements 즉, row[0].row 와 같다.
     * row[0].row => root -> row[0] -> "row"
     */
    extractXml: function (root, path) {
        var data = null;
        path = path && path.trim();
        if (path) {
            var segs = path.split(".");
            for (var k = 0; k < segs.length; k++) {
                var seg = segs[k] && segs[k].trim();
                if (seg) {
                    var i = seg.indexOf("[");
                    var j = seg.lastIndexOf("]");
                    if (i > 0 && j > i) {
                        var s = seg.substring(0, i);
                        var idx;
                        if (data) {
                            data = _getXmlList(data[0], s);
                        } else {
                            data = _getXmlList(root, s);
                        }
                        if (data) {
                            s = seg.substring(i + 1, j);
                            idx = parseInt(s);
                            data = data[idx];
                        }
                    } else {
                        if (data) {
                            data = _getXmlList(data[0], seg);
                        } else {
                            data = _getXmlList(root, seg);
                        }
                    }
                    if (!data) {
                        break;
                    }
                }
            }
        }
        return data;
    }
});
var DataPath$ = DataPath.prototype;
var DataFillMode = _enum({
	SET: "set",
	APPEND: "append",
	INSERT: "insert",
	UPDATE: "update"
});
var /* @internal */ DataFillOptions = function (source) {
	this.fillMode = DataFillMode.SET;
	this.fillPos = 0;
	this.count = -1;
	this.rootArray = true;
	this.rows = "row";
	this.start = 0;
	this.delimiter = ",";
	this.quoted = false;
	this.parentId = 0;;
	this.childrenField = null;
	this.treeField = null;
	this.iconField = null;
	this.needSorting = false;
	if (source) {
		if (source.hasOwnProperty("append")) {
			this.fillMode = DataFillMode.APPEND;
		}
		if (source.hasOwnProperty("fillMode")) {
			this.fillMode = source.fillMode;
		}
		if (source.hasOwnProperty("fillPos")) {
			this.fillPos = source.fillPos;
		}
		if (source.hasOwnProperty("count")) {
			this.count = source.count;
		}
		if (source.hasOwnProperty("rootArray")) {
			this.rootArray = source.rootArray;
		}
		if (source.hasOwnProperty("rows")) {
			this.rows = source.rows;
		}
		if (source.hasOwnProperty("start")) {
			this.start = source.start;
		}
		if (source.hasOwnProperty("delimiter")) {
			this.delimiter = source.delimiter;
		}
		if (source.hasOwnProperty("quoted")) {
			this.quoted = source.quoted;
		}
		if (source.hasOwnProperty("itemIndex")) {
			this.itemIndex = source.itemIndex;
		}
		for (var p in source) {
			if (source[p] !== undefined) {
				this[p] = source[p];
			}
		}
		this.parentId = source.parentId || source.parent;
		this.childrenField = source.childrenField || source.children;
		this.treeField = source.treeField || source.tree;
		this.iconField = source.iconField || source.icon;
		this.needSorting = source.needSorting || source.sorting;
	}
};
var DataLoader = defineClass("DataLoader", null, {
	init: function (provider) {
		Base.init.call(this);
		this._provider = provider;
	},
	load: function (type, data, options) {
		options = new DataFillOptions(options);
		if (this.$_checkEmpty(data, options)) {
			return 0;
		}
		this.$_prepareLoad(data, options);
		type = type && type.toLowerCase();
		switch (type) {
			case "json": return this.$_loadJson(data, options);
			case "xml": return this.$_loadXml(data, options);
			case "csv": return this.$_loadCsv(data, options);
		}
		return 0;
	},
	/**
	 * @param data Json array 이거나 Json object.
	 * @param options DataLoadOptions.
	 */
	$_loadJson: function (data, options) {
		if (typeof data === "string") {
			data = JSON.parse(data);
		}
		var rows = null;
		if (options.rootArray) {
			rows = _asArray(data);
		}
		if (!rows) {
			rows = DataPath.extractJson(data, options.rows);
		}
		if (rows) {
			var fillPos = options.fillPos;
			var start = options.start;
			var count = options.count;
			var itemIndex = options.itemIndex;
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.addRows(rows, start, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertRows(fillPos, rows, start, count, false, itemIndex);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateRows(fillPos, rows, start, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setRows(rows, start, count);
					break;
			}
			return rows.length;
		} else {
			this.$_fillEmpty(options)
			return 0;
		}
	},
	/**
	 * @param data Xml dom 객체이거나 Xml string.
	 * @param options DataLoadOptions.
	 */
	$_loadXml: function (data, options) {
		if (typeof data === "string") {
			data = _parseXml(data);
		}
		if (data && data.documentElement) {
			var fillPos = options.fillPos;
			var start = options.start;
			var count = options.count;
			var rowProp = options.rows;
			var itemIndex = options.itemIndex;
			var rows = DataPath.extractXml(data.documentElement, rowProp);
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.appendXmlRows(rows, start, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertXmlRows(fillPos, rows, start, count, false, itemIndex);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateXmlRows(fillPos, rows, start, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setXmlRows(rows, start, count);
					break;
			}
			return rows.length;
		} else {
			this.$_fillEmpty(options);
			return 0;
		}
	},
	/**
	 * @param data csv text.
	 * @param options DataLoadOptions.
	 */
	$_loadCsv: function (data, options) {
		var fillPos = options.fillPos;
		var start = options.start;
		var count = options.count;
		var quoted = options.quoted;
		var delimiter = options.delimiter;
		var itemIndex = options.itemIndex;
		var rows = DataHelper.csvToArray(this._provider, data, start, count, quoted, delimiter);
		if (rows && (count = rows.length) > 0) {
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.addRows(rows, 0, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertRows(fillPos, rows, 0, count, false, itemIndex);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateRows(fillPos, rows, 0, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setRows(rows, 0, count);
					break;
			}
			return rows.length;
		} else {
			this.$_fillEmpty(options);
			return 0;
		}
	},
	$_fillEmpty: function (options) {
		if (options.fillMode === DataFillMode.SET) {
			this._provider.setRows(null);
		}
	},
	$_checkEmpty: function (data, options) {
		if (!data) {
			this.$_fillEmpty(options);
			return true;
		}
		return false;
	},
	$_prepareLoad: function (options) {
		var filters = null;
		if (options.filters) {
			filters = new DataFilterCollection(this._provider.filterRuntime(), options.filters);
			options.filterMode && filters.setFilterMode(options.filterMode);
		}
	}
});
var ITEM_EXT_CHECKED 	= 0x00000001;
var ITEM_EXT_SAVECHECK 	= 0x00000002;
var ITEM_UNCHECKABLE    = 0x00000004;
var ITEM_EXT_READONLY	= 0x00000008;
var ITEM_EXT_SAVEEXPAND = 0x00000010;
var ITEM_EXT_FILTERED   = 0x00000020;
var ITEM_EXT_HEIGHT		= 0xFF800000;
var $$_grid_item_id = 0;
var GridItem = defineClass("GridItem", null, {
	init: function () {
		this._super(true);
		this._id = $$_grid_item_id++;
		this._index = -1;
		this._parent = null;
		this._extents = 0;
	},
	id: function () {
		return this._id;
	},
	index: function () {
		return this._index;
	},
	parent: function () {
		return this._parent;
	},
	parentIndex: function () {
		return this._parent ? this._parent._index : -1;
	},
	root: function () {
		var p = this;
		while (p.level() > 1) {
			p = p.parent();
		}
		return p;
	},
	childIndex: function () {
		return this._parent ? this._parent.indexOf(this) : -1;
	},
	level: function () {
		return this._parent.level() + 1;
	},
	isLeaf: function () {
		return true;
	},
	isVisible: function () {
        return this._parent && this._index >= 0;
	},
	displayLevel: function () {
		return this.level();
	},
	provider: function () {
		return this._parent.provider();
	},
	dataSource: function () {
		return this._parent.dataSource();
	},
	dataRow: function () {
		return -1;
	},
	dataId: function () {
		return -1;
	},
	rowState: function () {
		var ds,
			row = this.dataRow();
		if (row >= 0) {
			ds = this.dataSource();
			return ds ? ds.getRowState(row) : RowState.NONE;
		} else {
			return RowState.NONE;
		}
	},
	itemState: function () {
		return ItemState.NORMAL;
	},
	isChecked: function () {
		return (this._extents & ITEM_EXT_CHECKED) != 0;
	},
	setChecked: function (value, checkEvent) {
		this._parent.provider().checkItem(this, value, undefined, checkEvent);
	},
	$_setChecked: function (value) {
		this._extents = value ? (this._extents | ITEM_EXT_CHECKED) : (this._extents & ~ITEM_EXT_CHECKED);
	},
	/*
	saveCheck: function (value) {
		this._extents = value ? (this._extents | ITEM_EXT_SAVECHECK) : (this._extents & ~ITEM_EXT_SAVECHECK);
	},
	restoreCheck: function () {
		this._extents = (this._extents & ITEM_EXT_SAVECHECK) ? (this._extents | ITEM_EXT_CHECKED) : (this._extents & ~ITEM_EXT_CHECKED);
	},
	*/
	isCheckable: function () {
		return (this._extents & ITEM_UNCHECKABLE) == 0;
	},
	setCheckable: function (value) {
		this._parent.provider().setCheckable(this, value);
	},
	$_setCheckable: function (value) {
		this._extents = value ? (this._extents & ~ITEM_UNCHECKABLE) : (this._extents | ITEM_UNCHECKABLE);
	},
	isEditable: function () {
		return false;
	},
	isReadOnly: function () {
		return (this._extents & EXT_READONLY) != 0;
	},
	setReadOnly: function (value) {
		this._extents = value ? (this._extents | EXT_READONLY) : (this._extents & ~EXT_READONLY);
	},
	isResizable: function () {
		return false;
	},
	getAncestor: function (level) {
		if (level < this.level()) {
			var p = this._parent;
			while (p.level() > level) {
				p = p._parent;
			}
			return p;
		}
		return null;
	},
	getAncestors: function () {
		var items = null;
		var p = this._parent;
		if (p) {
			items = [];
			do {
				items.push(p);
				p = p._parent;
			} while (p);
		}
		return items;
	},
	isDescendantOf: function (group) {
		if (group) {
			var p = this._parent;
			while (p && p != group) {
				p = p._parent;
			}
			return p === group;
		}
		return false;
	},
	getData: function (field) {
		var ds = this.dataSource();
		var dataRow = this instanceof MergedGroupHeader || this instanceof GroupItemImpl ? this.firstItem().dataRow() : ( this instanceof MergedGroupFooter ? this.parent().firstItem().dataRow() : this.dataRow() );
		return ds ? ds.getValue(dataRow, field) : UNDEFINED;
		// return ds ? ds.getValue(this.dataRow(), field) : UNDEFINED;
	},
	setData: function (field, value) {
		var ds = this.dataSource();
		if (ds) {
			ds.setValue(dataRow, field, value);
		}
	},
	getRowData: function () {
		var row = this.dataRow();
		if (row >= 0) {
			var ds = this.dataSource();
			if (ds) {
				return ds.getRow(row);
			}
		}
		return null;
	},
	getRowObject: function () {
		var ds = this.dataSource();
		if (ds) {
			return ds.getRowObject(dataRow);
		}
		return null;
	},
	canEdit: function () {
		return false;
	},
	makeVisible: function () {
		this._parent.setExpanded(true);
		this._parent.makeVisible();
	},
	isMerged: function () {
		return false;
	},
	setIndex: function (value) {
		this._index = value;
	}
});
var GridRow = defineClass("GridRow", GridItem, {
	init: function (dataRow) {
		this._super();
		this._dataRow = dataRow;
		this._dataRowId = undefined;  // dataProvider가 refresh(insert, delete, move)될때 
		this._displayLevel = -1;
	},
	getDataRow: function () {
		return this._dataRow;
	},
	dataRow: function () {
		return this._dataRow;
	},
	dataId: function () {
		return this.dataSource().getRowId(this._dataRow);
	},
	isEditable: function () {
		return true;
	},
	isResizable: function () {
		return true;
	},
	displayLevel: function () {
		return this._displayLevel >= 0 ? this._displayLevel : this.level();
	},
	canEdit: function () {
		return true;
	},
	getData: function (field) {
		return this.dataSource().getValue(this._dataRow, field);
	},
	setData: function (field, value) {
		this.dataSource().setValue(this._dataRow, field, value);
	}
});
var GroupItem = defineClass("GroupItem", GridItem, {
	init: function () {
		this._super();
		this._children = [];
		this._descendantCount = 0;
		this._summaries = null;
		this._rows = null;
	},
	expanded: false,
	count: function () {
		return this._children.length;
	},
	children: function () {
		return this._children.slice();
	},
	setExpanded: function (value, recursive, force) {
		if (value != this._expanded || force) {
			if (value) {
				this.provider().expand(this, recursive, force);
			} else {
				this.provider().collapse(this, recursive);
			}
		}
	},
	isCollapsed: function () {
		return !this.isExpanded();
	},
	footer: function () {
		return null;
	},
	first: function () {
		return this._children.length > 0 ? this._children[0] : null;
	},
	last: function () {
		var len = this._children.length;
		return len > 0 ? this._children[len - 1] : null;
	},
	firstItem: function () {
		if (this._children.length > 0) {
			var item = this._children[0];
			return (item instanceof GroupItem) ? item.firstItem() : item;
		}
		return null;
	},
	firstDataItem: function () {
		if (this._children.length > 0) {
			for (var i = 0, cnt = this._children.length ; i < cnt ; i++) {
				if (this._children[i] instanceof GroupItem) {
					return this._children[i].firstDataItem();
				} else if (this._children[i] instanceof GridRow) {
					return this._children[i];
				};
			}
		}
		return null;
	},
	lastItem: function (checkFooter) {
		var cnt, item;
		if (this._children.length > 0) {
			cnt = this._children.length;
			for (;cnt;cnt--) {
				item = this._children[cnt-1];
				if (checkFooter && !this._hasFooter && item instanceof MergedGroupFooter) {
					continue;
				};
				break;
			}
			// var item = this._children[this._children.length - 1];
			return (item instanceof GroupItem) ? item.lastItem(checkFooter) : item;
		}
		return null;
	},
	lastDataItem: function () {
		if (this._children.length > 0) {
			var cnt = this._children.length,
				item;
			for (;cnt;cnt--) {
				item = this._children[cnt-1];
				if (item instanceof GroupItem) {
					return item.lastDataItem();
				} else if (item instanceof GridRow) {
					return item;
				}
			}
		}
		return null;
	},
	descendantCount: function () {
		return this._descendantCount;
	},
    firstVisibleItem: function (isSummary) {
    	var item;
    	if (isSummary) {
    		if (this._hasFooter && this.footer().isVisible) {
    			return this.footer();
    		}
    		for (var i = 0, len = this._children.length; i < len; i++) {
    			item = this._children[i];
    			if (item instanceof GroupItem) {
    				item = item.firstVisibleItem(isSummary);
    			} else if (item.isVisible()) {
    				return item;
    			}
    			if (item) {
    				return item;
    			}
    		}
    		return null;
    	}
        for (var i = 0, len = this._children.length; i < len; i++) {
            item = this._children[i];
            if (item.isVisible()) {
                return item;
            } else {
            	if (item instanceof GroupItem) {
            		var c = item.firstVisibleItem(isSummary);
            		if (c) {
            			return c;
            		}
            	}
            }
        }
        return null;
    },
	isExpandable: function () {
		return true;
	},
	isCollapsable: function () {
		return true;
	},
	getItem: function (index) {
		if (index < 0 || index >= this._children.length)
			throw new RangeError("index is invalid: " + index);
		return this._children[index];
	},
	itemOfRow: function (dataRow) {
		for (var i = this._children.length; i--;) {
			if (this._children[i].dataRow() == dataRow) {
				return this._children[i];
			}
		}
		return null;
	},
	indexOf: function (item) {
		var i,
			cnt = this._children.length;
		for (i = 0; i < cnt; i++) {
			if (this._children[i] == item) {
				return i;
			}
		}
		return -1;
	},
	isDescendant: function (item) {
		if (item && item !== this) {
			var g = item._parent;
			while (g && g != this) {
				g = g._parent;
			}
			return g === this;
		}
		return false;
	},
	getDescendants: function (visibleOnly) {
		function collectItems(p/*GroupItem*/, items/*[GridItem]*/) {
			var i, item, g;
			var cnt = p.count();
			for (i = 0; i < cnt; i++) {
				items.push(item = p.getItem(i));
				g = _cast(item, GroupItem);
				if (g && (!visibleOnly || g.isExpanded())) {
					collectItems(g, items);
				}
			}
		}
		if ((!visibleOnly || this._expanded) && this._children && this._children.length > 0) {
			var items = [];
			collectItems(this, items);
			return items;
		}
		return null;
	},
	clear: function () {
		this._summaries = null;
		this._children.splice(0, this._children.length);
		this._descendantCount = 0;
	},
	insert: function (index, item) {
		this._addChild(item, index);
	},
	add: function (item) {
		this._addChild(item, -1);
	},
	addAll: function (items) {
		this._addChildren(items);
	},
	remove: function (item) {
		var idx = this.indexOf(item);
		if (idx >= 0) {
			this._children.splice(idx, 1);
			if (item instanceof GridItem) {
				item._parent = null;
			}
		}
	},
	setItem: function (item, newItem) {
		if (item && newItem && item != newItem) {
			var idx = this._removeChild(item);
			this._insertChild(idx, newItem);
			if (newItem instanceof GridItem) {
				newItem._index = item.index();
			}
		}
	},
	getNumber: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.count;
		} else if (summary) {
			return summary.length;
		}
		return this._descendantCount;
	},
	getSum: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.sum;
		} else if (summary) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v = NaN;
			var v2;
			var i;
			for (i = 0; i < cnt; i++) {
				v2 = ds.getValue(summary[i], field);
				if (!isNaN(v2)) {
					v = (isNaN(v) ? 0 : v) + v2;
				}
			}
			return v;
		}
		return NaN;
	},
	getMax: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.max;
		} else if (summary) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v;
			var v2;
			var i;
			if (cnt > 1) {
				v = NaN;
				i = 0;
				do {
					v = ds.getValue(summary[i++], field);
				} while (isNaN(v = v == null ? undefined : v) && i < cnt);
				while (i < cnt) {
					v2 = ds.getValue(summary[i++], field);
					if (!isNaN(v2 = v2 == null ? undefined : v2) && v2 > v) {
						v = v2;
					}
				}
				return v;
			} else if (cnt == 1) {
				v = ds.getValue(summary[0], field);
				return v == null ? undefined : v;
			}
		}
		return NaN;
	},
	getMin: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.min;
		} else if (summary) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v;
			var v2;
			var i;
			if (cnt > 1) {
				v = NaN;
				i = 0;
				do {
					v = ds.getValue(summary[i++], field);
				} while (isNaN(v = v == null ? undefined : v) && i < cnt);
				while (i < cnt) {
					v2 = ds.getValue(summary[i++], field);
					if (!isNaN(v2 = v2 == null ? undefined : v2) && v2 < v) {
						v = v2;
					}
				}
				return v;
			} else if (cnt == 1) {
				v = ds.getValue(summary[0], field);
				return v == null ? undefined : v;
			}
		}
		return NaN;
	},
	getAvg: function (field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.avg;
		} else if (summary) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v;
			var i;
			if (cnt > 1) {
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += ds.getValue(summary[i], field);
				}
				return v / cnt;
			} else if (cnt == 1) {
				v = ds.getValue(summary[0], field);
				return v;
			}
		}
		return NaN;
	},
	getVar: function (field, n) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return n = 0 ? summary.varsp : summary.vars;
		} else if (summary && this.summaryMode() == SummaryMode.STATISTICAL) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v;
			var i;
			var avg;
			if (cnt > 1) {
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += ds.getValue(summary[i], field);
				}
				avg = v / cnt;
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += Math.pow(ds.getValue(summary[i], field) - avg, 2);
				}
				v = v / (cnt - n);
				return v;
			} else if (cnt == 1) {
				return 0;
			}
		}
		return NaN;
	},
	getStdev: function (field, n) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return n == 0 ? Math.sqrt(summary.varsp) : Math.sqrt(summary.vars);
		} else if (summary && this.summaryMode() == SummaryMode.STATISTICAL) {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v;
			var i;
			var avg;
			if (cnt > 1) {
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += ds.getValue(summary[i], field);
				}
				avg = v / cnt;
				v = 0;
				for (i = 0; i < cnt; i++) {
					v += Math.pow(ds.getValue(summary[i], field) - avg, 2);
				}
				v = Math.sqrt(v / (cnt - n));
				return v;
			} else if (cnt == 1) {
				return 0;
			}
		}
		return NaN;
	},
	getDataCount: function(field) { // 2건인 경우 따로 계산하지 않는다.
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.datacount;
		} else {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v = 0;
			var i;
			if (cnt > 0) {
				for (i = 0; i < cnt; i++) {
					if (ds.getValue(summary[i], field) != null) v++;
				}
				return v;
			}
		}
		return 0;
	},
	getDataAvg: function(field) {
		var summary = this.$_getSummary(field);
		if (summary instanceof FieldSummary) {
			return summary.dataavg;
		} else {
			var ds = this.dataSource();
			var cnt = summary.length;
			var v = 0, sum = 0;
			var i;
			if (cnt > 0) {
				for (i = 0; i < cnt; i++) {
					if (ds.getValue(summary[i], field) != null) {
						v++;
						sum += ds.getValue(summary[i], field);
					}
				}
				return v > 0 ? sum / v : 0;
			}
		}
		return NaN;
	},
	summaryMode: function () {
		return this.provider().summaryMode();
	},
	_setExpanded: function (value) {
		this._expanded = value;
	},
	_incDescendants: function (inc) {
		this._descendantCount += inc;
	},
	_insertChild: function (index, item) {
		this._children.splice(index, 0, item);
		if (item instanceof GridItem) {
			item._parent = this;
		}
	},
	_addChild: function (item, index) {
		if (item && this.indexOf(item) < 0) {
			if (index < 0) {
				this._children.push(item);
			} else {
				this._children.splice(index, 0, item);
			}
			item._parent = this;
		}
	},
	_addChildren: function (items) {
		var cnt;
		if (items && (cnt = items.length) > 0) {
			var i, item;
			for (i = 0; i < cnt; i++) {
				item = items[i];
				if (item && this.indexOf(item) < 0) {
					item._parent = this;
					this._children.push(item);
				}
			}
		}
	},
	_removeChild: function (item) {
		var idx = this.indexOf(item);
		if (idx >= 0) {
			this._children.splice(idx, 1);
			if (item instanceof GridItem) {
				item._parent = null;
			}
		}
		return idx;
	},
	attachItem: function (item) {
		if (item) {
			item._parent = this;
		}
	},
	detachItem: function (item) {
		if (item && item_parent == this) {
			item._parent = null;
		}
	},
	_exchangeItems: function (index1, index2) {
		if (index1 < 0 || index1 >= this._children.length)
			throw new RangeError("index1 is out of range: " + index1);
		if (index2 < 0 || index2 >= this._children.length)
			throw new RangeError("index2 is out of range: " + index2);
		if (index1 === index2)
			return;
		var t = this._children[index1];
		this._children[index1] = this._children[index2];
		this._children[index2] = t;
	},
	_moveChild: function (index, delta) {
		var count = this._children.length;

		if (index < 0 || index >= count)
			throw new RangeError("index is out of range: " + index);

		var newIndex = Math.min(Math.max(index+delta,0),count-1);
		var child = this._children[index];
		if (delta < 0) {
			for (var i = index; i > newIndex; i--) 
				this._children[i] = this._children[i-1];
		} else {
			for (var i = index; i < newIndex; i++)
				this._children[i] = this._children[i+1];			
		}
		this._children[newIndex] = child;
	},
	_changeParent: function (parent, index, expand) {
		var old = this._parent;
		old.remove(this);
		parent._addChild(this, index);
		if (expand)
			parent.setExpanded(true);
	},
	$_getRows: function () {
		var rows = [];
		this.$_collectRows(this, rows);
		return rows;
	},
	$_collectRows: function (group, rows) {
		var i,
			cnt = group.count(),
			item;
		for (i = 0; i < cnt; i++) {
			item = group.getItem(i);
			if (item instanceof GroupItem) {
				this.$_collectRows(item, rows);
			} else {
				var row = item.dataRow();
				if (row >= 0) {
					rows.push(row);
				}
			}
		}
	},
	$_getSummary: function (field) {
		var ds = _cast(this.dataSource(), DataProvider);
		if (!ds) {
			return null;
		}
		if (this._summaries == null) {
			this._summaries = {};
		}
		var fs = this._summaries ? this._summaries[field] : null;
		if (!fs) {
			if (ds.canSummarize(field)) {
				fs = this.$_summarize(field, ds);
				if (fs) {
					this._summaries[field] = fs;
				}
			}
		}
		return fs;
	},
	$_summarize: function (field, ds) {
		var THRESHOLD = 3;
		var mode = this.summaryMode();
		if (mode != SummaryMode.NONE) {
			if (this._rows == null) {
				this._rows = [];
				this.$_collectRows(this, this._rows);
			}
			if (this._rows.length > THRESHOLD && ds.canSummarize(field)) {
				var fs = new FieldSummary(field);
				ds.summarizeRange(fs, this._rows, mode == SummaryMode.STATISTICAL);
				return fs;
			} else {
				return this._rows;
			}
		}
		return null;
	}
});
var GroupItemImpl = defineClass("GroupItemImpl", GroupItem, {
	init: function (field) {
		this._super();
		this._groupField = field;
		this._footer = null;
		this._header = null;
	},
	groupField: function () {
		return this._groupField;
	},
	footer: function () {
		return this._footer;
	},
	_addChild: function (item, index) {
		this._super(item, index);
		if (item instanceof GroupFooter) {
			this._footer = item;
		}
	}
});
var GroupFooter = defineClass("GroupFooter", GridItem, {
	init: function() {
		this._super();
	},
	expandable: false,
	displayLevel: function() {
		return this._expandable ? this.level() - 1 : this.level();
	}
});
var /* @internal */ RootItem = defineClass("RootItem", GroupItemImpl, {
	init: function(provider) {
		this._super(-1);
		this._provider = provider;
	},
	provider: function () { return this._provider; },
	level: function() { return 0; },
	isExpanded: function () { return false; },
	isLeaf: function () { return false; },
	isVisible: function () { return true; },
	dataSource: function () { return this._provider.dataSource(); },
	isExpandable: function () { return false; },
	isCollapsable: function () { return false; }
});
var /* @abstract */ ItemProvider = defineClass("ItemProvider", EventAware, {
	init: function (indexing) {
		this._super();
		this._indexing = indexing;
		this._rootItem = this._createRootItem();
		this._eventLock = 0;
	},
	hideDeleted: false,
	dataSource: function () {
		throwAbstractError();
	},
	itemCount: function () {
		throwAbstractError();
	},
	getItem: function (index) {
		throwAbstractError();
	},
	getItems: function (index, count) {
		throwAbstractError();
	},
	attachItem: function (item) {
		if (item) {
			item._parent = this._rootItem;
		}
	},
	refreshItems: function () {
		throwAbstractError();
	},
	getItemsByIndices: function (indices) {
		var items = [];
		if (indices) {
			for (var i = 0, cnt = indices.length; i < cnt; i++) {
				var item = this.getItem(indices[i]);
				item && items.push(item);
			}
		}
		return items;
	},
	getIndexOfRow: function (dataRow) {
		var item = this.getItemOfRow(dataRow);
		return item ? item.index() : -1;
	},
	getIndicesOfRows: function (dataRows) {
		var items = [];
		var cnt = dataRows ? dataRows.length : 0;
		if (cnt) {
			for (var i = 0; i < cnt; i++) {
				var item = this.getItemOfRow(dataRows[i]);
				items.push(item ? item.index() : -1);
			}
		}
		return items;
	},
	getItemOfRow: function (dataRow) {
		throwAbstractError();
	},
	getItemsByRows: function (dataRows, force) {
		var i, item;
		var items = [];
		var cnt = dataRows ? dataRows.length : 0;
		for (i = 0; i < cnt; i++) {
			item = this.getItemOfRow(dataRows[i], force);
			if (item) {
				items.push(item);
			}
		}
		return items;
	},
	exchange: function (index1, index2) {
		throwAbstractError();
	},
	setCheckable: function (item, value) {
		if (item) {
			if (value != item.isCheckable()) {
				item.$_setCheckable(value);
				this._fireCheckableChanged(item);
			}
		}
	},
	_clearChecked: function () {
		for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
			this.getItem(i).$_setChecked(false);
		}
	},
	checkItem: function (item, checked, exclusive, checkEvent) {
		if (item) {
			var prev = item.isChecked();
			if (exclusive) {
				this._clearChecked();
				if (checked) {
					item.$_setChecked(true);
				}
				if ((checked != prev) && checkEvent) {
					this._fireItemChecked(item);
				}
				this._fireRefreshClient();
			} else if (checked != prev) {
				item.$_setChecked(checked);
				checkEvent ? this._fireItemChecked(item):this._fireRefreshClient();
			};
			this._fireItemCheckChanged([item], checked);
		}
	},
	checkItems: function (items, checked, checkEvent) {
		if (items && items.length > 0) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var item = items[i];
				item instanceof GridItem && item.$_setChecked(checked);
			}
			checkEvent ? this._fireItemsChecked(items, checked):this._fireRefreshClient();	
		};
		this._fireItemCheckChanged(items, checked);
	},
	checkAll: function (checked, visibleOnly, checkableOnly, checkEvent) {
		var i, item, cnt = this.itemCount();
		if (checkableOnly) {
			for (i = 0; i < cnt; i++) {
				item = this.getItem(i);
				if (item.isCheckable()) {
					item.$_setChecked(checked);
				}
			}
		} else {
			for (i = 0; i < cnt; i++) {
				this.getItem(i).$_setChecked(checked);
			}
		}
		checkEvent ? this._fireItemAllChecked(checked):this._fireRefreshClient();
		this._fireItemCheckChanged(null, checked);
	},
	_setCheckItem: function (item, checked) {
		item.$_setChecked(checked);
	},
	_clearDisplayLevels: function () {
	},
	hasCellStyle: function () {
		return false;
	},
	setCellStyle: function (row, field, style) {
	},
	setCellStyles: function (provider, rows, fieldMap) {
	},
	clearCellStyles: function () {
	},
	removeCellStyle: function (style) {
	},
	getCellStyle: function (dataRow, field) {
		return null;
	},
	canUpdate: function (item, field) {
		if (item) {
			var row = item.dataRow();
			var ds = this.dataSource();
			var state = item.itemState();
            var inserting = ItemState.isInserting(state) || state === ItemState.DUMMY;
			return (row >= 0 || inserting) && ds && (inserting || ds.canUpdateRow(row)) && ds.canUpdateField(row, field);
		}
		return false;
	},
	canAppend: function () {
		var ds = this.dataSource();
		return ds && ds.canAppendRow();
	},
	canInsert: function (item) {
		if (item) {
			var	row = item.dataRow();
			var ds = this.dataSource();
			return /*(row >= 0) &&*/ ds && ds.canInsertRow(row);
		}
		return false;
	},
	canDelete: function (item) {
		if (item) {
			var row = item.dataRow();
			var ds = this.dataSource();
			return (row >= 0) && ds && ds.canDeleteRow(row);
		}
		return false;
	},
	getAllItems: function () {
		throwAbstractError();
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		throwAbstractError();
	},
	getSum: function (field) {
		return NaN;
	},
	getMax: function (field) {
		return NaN;
	},
	getMin: function (field) {
		return NaN;
	},
	getAvg: function (field) {
		return NaN;
	},
	getVar: function (field) {
		return NaN;
	},
	getStdev: function (field) {
		return NaN;
	},
	getDataCount: function (field) {
		return 0;
	},
	getDataAvg: function (field) {
		return NaN;
	},
	isIndexing: function () {
		return this._indexing;
	},
	_createRootItem: function () {
		return new RootItem(this);
	},
	_resetItemIndicies: function (fromIndex) {
		if (this._indexing && !this._updateLock) {
			var i = fromIndex,
				cnt = this.itemCount();
			for (; i < cnt; i++) {
				this.getItem(i)._index = i;
			}
		}
	},
	_setExpanded: function (group, value) {
		group._setExpanded(value);
	},
	_resetItemIndex: function (index) {
		var item = this.getItem(index);
		if (item) {
			item._index = index;
		}
	},
	_incDescendents: function (group, count) {
		group._descendantCount += count;
		if (group.parent()) {
			this._incDescendents(group.parent(), count);
		}
	},
	_copyExtents: function (source, target) {
		if (source instanceof GridItem && target instanceof GridItem) {
			target._extents = source._extents;
		}
	},
	_fireReset: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.RESET);
		}
	},
	_fireRefresh: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.REFRESH);
		}
	},
	_fireRefreshClient: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.REFRESH_CLIENT);
		}
	},
	_fireItemInserted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ITEM_INSERTED, item);
		}
	},
	_fireItemDeleted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ITEM_DELETED, item);
		}
	},
	_fireItemUpdated: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ITEM_UPDATED, item);
		}
	},
	_fireCheckableChanged: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.CHECKABLE_CHANGED, item);
		}
	},
	_fireItemChecked: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ITEM_CHECKED, item);
		}
	},
	_fireItemsChecked: function (items, checked) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ITEMS_CHECKED, items, checked);
		}
	},
	_fireItemAllChecked: function (checked) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ITEM_ALL_CHECKED, checked);
		}
	},
	_fireItemCheckChanged: function (items, checked) {
		this.fireEvent(ItemProvider.ITEMCHECK_CHANGED, items, checked);
	},
	_fireRowStateChanged: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ROW_STATE_CHANGED, item);
		}
	},
	_fireRowStatesChanged: function (items) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ROW_STATES_CHANGED, items);
		}
	},
	_fireRowStatesCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.ROW_STATES_CLEARED);
		}
	},
	_fireSort: function (fields, directions, cases) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.SORT, fields, directions, cases);
		}
	},
	_fireSorted: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.SORTED);
		}
	},
	_fireFilterAdded: function (field, criteria) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.FILTER_ADDED, field, criteria);
		}
	},
	_fireFilterRemoved: function (field, filter) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.FILTER_REMOVED, field, filter);
		}
	},
	_fireFilterCleared: function (field) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.FILTER_CLEARED, field);
		}
	},
	_fireFilterAllCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.FILTER_ALL_CLEARED);
		}
	},
	_fireFiltered: function (filterCollection, filter) {
		if (this._eventLock <= 0) {
			this.fireEvent(ItemProvider.FILTERED, filterCollection, filter);
		}
	}
});
ItemProvider.RESET = "onItemProviderReset";
ItemProvider.REFRESH = "onItemProviderRefresh";
ItemProvider.REFRESH_CLIENT = "onItemProviderRefreshClient";
ItemProvider.ITEM_INSERTED = "onItemProviderItemInserted";
ItemProvider.ITEM_DELETED = "onItemProviderItemDeleted";
ItemProvider.ITEM_UPDATED = "onItemProviderItemUpdated";
ItemProvider.CHECKABLE_CHANGED = "onItemProviderCheckableChanged";
ItemProvider.ITEM_CHECKED = "onItemProviderItemChecked";
ItemProvider.ITEMS_CHECKED = "onItemProviderItemsChecked";
ItemProvider.ITEM_ALL_CHECKED = "onItemProviderItemAllChecked";
ItemProvider.ROW_STATE_CHANGED = "onItemProviderRowStateChanged";
ItemProvider.ROW_STATES_CHANGED = "onItemProviderRowStatesChanged";
ItemProvider.ROW_STATES_CLEARED = "onItemProviderRowStatesCleared";
ItemProvider.SORT = "onItemProviderSort";
ItemProvider.SORTED = "onItemProviderSorted";
ItemProvider.FILTER_ADDED = "onItemProviderFilterAdded";
ItemProvider.FILTER_REMOVED = "onItemProviderFilterRemoved";
ItemProvider.FILTER_CLEARED = "onItemProviderFilterCleared";
ItemProvider.FILTER_ALL_CLEARED = "onItemProviderFilterAllCleared";
ItemProvider.FILTERED = "onItemProviderFiltered";
ItemProvider.ITEMCHECK_CHANGED = "onItemProviderItemCheckChanged";
var /* @internal */ CellEditableMap = defineClass("CellEditableMap", DataTag, {
	init: function(itemProvider) {
		this._super();
		this._editableMap = [];
	},
	destroy : function() {
		this._editableMap = null;
		this._super();
	},
	isEmpty: function () {
		return this._styleMap.length == 0 && !this._styleMap[-1];
	},
	setReadOnly: function (row, column, value) {
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._readOnly = value;
	},
	setEditable: function (row, column, value) {
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._editable = value;
	},
	getReadOnly: function (row, column) {
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._readOnly;
	},
	getEditable: function (row, column) {
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._editable
	},
	setCursor: function (row, column, value) {
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._cursor = value;
	},
	getCursor: function (row, column) {
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._cursor
	},
	setEditor: function(row, column, value) {
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._editor = value;
	},
	getEditor: function(row, column, value) {
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._editor
	},
	removeEditableMap: function (row, column) {
		if (row == null) {
			return;
		}
		column = arguments.length < 2 ? -1 : column;
		if (column < 0) {
			delete this._editableMap[row];
		} else {
			var map = this._editableMap[row];
			map && (delete map[column]);
		}
	},
	clearEditableMap: function () {
		if (this._editableMap.length === 0 && this._editableMap[-1] == null) {
			return false;
		}
		this._editableMap = [];
		return true;
	},
	getWritable: function (row, column) {
		var readOnly = this.getReadOnly(row, column);
		var editable = this.getEditable(row, column);
		return !readOnly && editable;
	},
	connect: function (provider) {
	},
	disconnect: function () {
	},
	// grid render시 초기화 하기 때문에 dataProvider의 변경은 관리하지 않는다.
	clearRows: function () {
		return this.clearEditableMap();
	},
	setRows: function () {
	},
	setRowCount: function (newCount) {
	},
	insertRow: function (row) {
	},
	insertRows: function (row, count) {
	},
	removeRow: function (row) {
	},
	removeRows: function (rows) {
	},
	updateRow: function () {
	},
	updateRows: function (row, count) {
	},
	setValue: function (row, field) {
	},
	moveRow: function (row, newRow) {
	},
	moveRows: function (row, count, newRow) {
	}	
})
var /* @internal */ CellStyleMap = defineClass("CellStyleMap", DataTag, {
	init: function(itemProvider) {
		this._super();
		this._owner = itemProvider;
		this._styleMap = [];
	},
	destroy: function() {
		this._destroying = true;
		this._styleMap = null;
		this._super();
	},
	isEmpty: function () {
		return this._styleMap.length == 0 && !this._styleMap[-1];
	},
	setCellStyle: function (row, field, style) {
		if (field < 0) {
			this._styleMap[row] = style;
		} else {
			var styles,
				oldStyle = this._styleMap[row];
			if (oldStyle) {
				if (_isArray(oldStyle)) {
					oldStyle[field] = style;
				} else {
					var i,
						cnt = this._owner.dataSource().fieldCount();
					styles = [];
					for (i = 0; i < cnt; i++) {
						styles[i] = oldStyle;
					}
					this._styleMap[row] = styles;
				}
			}
			styles = this._styleMap[row];
			if (!styles) {
				styles = [];
			}
			styles[field] = style;
			this._styleMap[row] = styles;
		}
	},
	setCellStyles: function (provider, rows, fieldMap) {
		function setArray(self, ds, rows, fields) {
			var r;
			var cnt = rows.length;
			var flds = Math.min(fields.length, ds.fieldCount());
			var f;
			var fld;
			var style;
			var vals;
			for (r = 0; r < cnt; r++) {
				vals  = rows[r];
				if (_isArray(vals)) {
					for (f = 0; f < flds; f++) {
						fld = fields[f];
						if (fld >= 0) {
							style = provider.getStyle(vals[fld]);
							if (style) {
								self.setCellStyle(r, f, style);
							}
						}
					}
				}
			}
		}
		function setObjects(self, rows, fields) {
			for (var r = 0, cnt = rows.length; r < cnt; r++) {
				var row  = rows[r];
				if (row) {
					for (var f in fields) {
						var fld = fields[f];
						var style = provider.getStyle(row[f]);
                        if (style) {
							self.setCellStyle(r, fld, style);
						}
					}
				}
			}
		}
		if (!rows || rows.length < 1 || !fieldMap) {
			return;
		}
		var ds = this._owner.dataSource();
		var fldCount = ds.fieldCount();
		var fields = fieldMap;
        var i, fld, cnt;
		if (_isArray(fields)) {
			fields = fields.concat();
			cnt = Math.min(fldCount, fields.length);
			for (i = 0; i < cnt; i++) {
				fld = parseInt(fields[i]);
				if (isNaN(fld) || fld < 0) {
					fields[i] = -1;
				} else {
					fields[i] = fld;
				}
			}
			setArray(this, ds, rows, fields);
		} else {
			fields = {};
			for (var f in fieldMap) {
				fld = parseInt(fieldMap[f]);
				if (isNaN(fld)) {
					fld = ds.getFieldIndex(fieldMap[f]);
				}
				if (fld >= 0 && fld < fldCount) {
					fields[f] = fld;
				}
			}
			setObjects(this, rows, fields);
		}
	},
	removeCellStyle: function (style) {
		for (var r = 0, cnt = this._styleMap.length; r < cnt; r++) {
			var styles = this._styleMap[r];
			if (_isArray(styles)) {
				for (var i = styles.length - 1; i >= 0; i--) {
					if (styles[i] === style) {
						styles[i] = null;
					}
				}
			} else {
				if (this._styleMap[r] === style) {
					delete this._styleMap[r];
				}
			}
		}
	},
	clearCellStyles: function () {
		this._styleMap = [];
	},
	checkCellStyle: function (dataRow, field) {
		var style = this._styleMap[dataRow];
		if (_isArray(style)) {
			return !!style[field];
		} else {
			return !!style;
		}
	},
	getCellStyle: function (dataRow, field) {
		var style = this._styleMap[dataRow];
		if (_isArray(style)) {
			return style[field];
		} else {
			return style;
		}
	},
	connect: function (provider) {
	},
	disconnect: function () {
	},
	clearRows: function () {
		this._styleMap = [];
	},
	setRows: function () {
		if (this._owner.dataSource()) {
			this._styleMap.length = Math.min(this._styleMap.length, this._owner.dataSource().rowCount());
		}
	},
	setRowCount: function (newCount) {
		this._styleMap.length = newCount;
	},
	insertRow: function (row) {
		this._styleMap.splice(row, 0, null);
	},
	insertRows: function (row, count) {
		for (var i = 0; i < count; i++) {
			this._styleMap.splice(row, 0, null);
		}
	},
	removeRow: function (row) {
		this._styleMap.splice(row, 1);
	},
	removeRows: function (rows) {
		for (var i = rows.length - 1; i >= 0; i--) {
			this._styleMap.splice(rows[i], 1);
		}
	},
	updateRow: function () {
	},
	updateRows: function (row, count) {
	},
	setValue: function (row, field) {
	},
	moveRow: function (row, newRow) {
		var styles = this._styleMap.splice(row, 1);
		this._styleMap.splice(newRow, 0, styles[0]);
	},
	moveRows: function (row, count, newRow) {
		var styles = this._styleMap.splice(row, count);
		for (var i = 0; i < count; i++) {
			this._styleMap.splice(newRow + i, 0, styles[i]);
		}
	}
});
var /* @internal */ ItemCheckableTag = defineClass("ItemCheckableTag", null, {
	init : function(owner, expression) {
		this._super();
		this._owner = owner;
		this._exprNode = ExpressionParser.Default.parse(expression, ["value", "values"]);
		this._runtime = new CheckableExpressionRuntime();
	},
	connect: function (provider) {
		this._runtime.setDataSource(provider);
	},
	disconnect: function () {
	},
	clearRows: function () {
		ItemCheckableTag.clearCheckables(this._owner);
	},
	setRows: function () {
		var item;
		for (var i = this._owner._rows.length; i --;) {
			item = this._owner._rows[i];
			this.$_setCheckable(item);
		}
	},
	insertRow: function (row) {
		this.$_setCheckable(row);
	},
	insertRows: function (row, count) {
		for (var i = 0; i < count; i++) {
			var item = this._owner.getItemOfRow(row + i);
			if (item instanceof GridItem) {
				this.$_setCheckable(item);
			}
		}
	},
	updateRow: function (row) {
		this.$_setCheckable(row);
	},
	updateRows: function (row, count) {
		for (var i = 0; i < count; i++) {
			var item = this._owner.getItemOfRow(row + i);
			if (item instanceof GridItem) {
				this.$_setCheckable(item);
			}
		}
	},
	changeStates: function (rows) {
		if (rows) {
			for (var i = rows.length; i--;) {
				var item = this._owner.getItemOfRow(rows[i]);
				if (item instanceof GridItem) {
					this.$_setCheckable(item);
				}
			}
		}
	},
	$_setCheckable: function (item) {
		this._runtime.setItem(item);
		item.$_setCheckable(this._exprNode.evaluate(this._runtime));
	}
}, {
	clearCheckables: function (items) {
		for (var i = items.itemCount(); i--;) {
			items.getItem(i).$_setCheckable(true);
		}
	}
});
var DefaultItemProvider = defineClass("DefaultItemProvider", ItemProvider, {
    init: function (indexing) {
        this._super(indexing);
        this._dataSource = null;
        this._rows = [];
        this._filteredItems = [];
        this._pageItems = [];
        this._sortedItems = [];
        this._pubItems = this._items = this._rows;
        this._distinctRows = [];
        this._cellStyles = new CellStyleMap(this);
        this._editableMap = new CellEditableMap(this);
        this._fixedCount = 0;
        this._fixedSorting = false;
        this._maxItemCount = 0;
        this._itemCount = 0;
        this._pubCount = 0;
        this._filtered = false;
        this._hideDeleted = false;
        this._filters = [];
        this._filterRuntime = new ColumnFilterRuntime();
        this._filterLock = 0;
        this._fixedFiltering = false;
        this._sorted = false;
        this._sortFields = [];
        this._sortDirections = [];
        this._sortCases = [];
        this._labelComparer = {};
        this._sorter = null;
        this._paging = false;
        this._pagingSource = PagingSource.ROWS;
        this._pageSize = 10;
        this._pageCount = -1;
        this._pageStartIndex = -1;
        this._currPage = 0;
        this._pageStart = 0;
        //this._sortMode = SortMode.AUTO;
        //this._filterMode = FilterMode.AUTO;
        this._summaryMode = SummaryMode.AGGREGATE;
        this._summaryMap = null;
        this._checkableExpression = null;
        this._checkableTag = null;
        this._pageSorting = false;
        this._updateLock = false;
    },
    destroy: function() {
        this._destroying = true;
        this.setDataSource(null);
        this._rows = null;
        this._pubItems = null;
        this._items = null;
        this._filteredItems = null;
        this._pageItems = null;
        this._sortedItems = null;
        this._distinctRows = null;
        this._filters = null;
        this._sortFields = null;
        this._sortDirections = null;
        this._sortCases = null;
        this._summaryMap = null;
        this._super();
    },
    hideDeleted: false,
    setHideDeleted: function (value) {
        if (value != this._hideDeleted) {
            this._hideDeleted = value;
            this.$_buildItems();
            this._fireRefresh();
        }
    },
    filterOr: false,
    setFilterOr: function(value) {
        if (value != this._filterOr) {
            this._filterOr = value;
            this.$_buildItems();
            this._fireRefresh();
        }
    },
    isFiltered: function () {
        return this._filtered;
    },
    isSorted: function () {
        return this._sorted;
    },
    isPaging: function () {
        return this._paging;
    },
    pageStartIndex: function () {
        return this._pageStart;
    },
    sorter: function () {
        return this._sorter || this._defSorter;
    },
    setSorter: function (value) {
        this._sorter = value;
    },
    setSummaryMode: function (value) {
        if (value != this._summaryMode) {
            this._summaryMode = value;
            this.$_resetSummary();
            this.$_buildItems();
            this._fireRefresh();
        }
    },
    beginUpdate: function() {
        this._updateLock = true;
    },
    endUpdate: function() {
        this._updateLock = false;
    },
    sortMode: SortMode.AUTO,
    filterMode : FilterMode.AUTO,
    checkableExpression: function () {
        return this._checkableExpression;
    },
    setCheckableExpression: function (value) {
        if (value != this._checkableExpression) {
            this._checkableExpression = value;
            if (this._checkableTag) {
                this._checkableTag.disconnect();
                this._checkableTag = null;
            }
            if (value) {
                this._checkableTag = new ItemCheckableTag(this, value);
                if (this._dataSource) {
                    this._checkableTag.connect(this._dataSource);
                }
            }
        }
    },
    getFieldDomain: function (field) {
        var rows = this._rows,
            i,
            cnt = rows.length,
            values = [],
            curr = UNDEFINED,
            prev = UNDEFINED;
        for (i = 0; i < cnt; i++) {
            curr = this._dataSource.getValue(i, field);
            if (curr != prev && values.indexOf(curr) < 0) {
                values.push(curr);
            }
            prev = curr;
        }
        return values;
    },
    beginFilter: function () {
        this._filterLock++;
    },
    endFilter: function (apply, filterCollection, filter) {
        apply = arguments.length > 0 ? apply : true;
        if (this._filterLock > 0) {
            this._filterLock = Math.max(0, this._filterLock - 1);
            if (this._filterLock == 0 && apply) {
                this.applyFilters(true, filterCollection, filter);
            }
        }
    },
    hasFilter: function (field) {
        var filters = this._filters[field];
        return filters && filters.length > 0;
    },
    addFilter: function (field, refFilter) {
        var criteria = refFilter && refFilter.criteria();
        if (field >= 0) {
            this._fireFilterAdded(field, criteria);
            var filters = this._filters[field];
            if (!filters) {
                filters = [];
                this._filters[field] = filters;
            }
            var filter = new ColumnFilterRun(refFilter);
            filters.push(filter);
            this.applyFilters();
            return filter;
        }
    },
    removeFilter: function (field, filter) {
        if (this._filtered && this._filters[field]) {
            this._fireFilterRemoved(field, filter);
            var filters = this._filters[field];
            var i = filters.indexOf(filter);
            if (i >= 0) {
                filters.splice(i, 1);
                this.applyFilters();
            }
        }
    },
    clearFilters: function (field) {
        if (this._filtered && this._filters[field]) {
            this._fireFilterCleared(field);
            var filters = this._filters[field];
            if (filters.length > 0) {
                filters.length = 0;
                delete this._filters[field];
                this.applyFilters();
            }
        }
    },
    clearAllFilters: function () {
        if (this._filtered) {
            this._fireFilterAllCleared();
            this._filters = [];
            this.applyFilters();
        }
    },
    hasFilters: function () {
        var i,
            filters,
            cnt = this._filters.length;
        for (i = 0; i < cnt; i++) {
            filters = this._filters[i];
            if (filters && filters.length > 0) {
                return true;
            }
        }
        return false;
    },
    applyFilters: function (fireEvent, filterCollection, filter) {
        fireEvent = arguments.length > 0 ? fireEvent : true;
        if (this._filterLock > 0) {
            return;
        }
        this.$_buildItems();
        try {
            if (fireEvent) {
                this._fireRefresh();
            }
        } finally {
            this._fireFiltered(filterCollection, filter);
        }
    },
    orderBy: function (fields, directions, cases, fireEvent) {
        fireEvent = arguments.length > 3 ? fireEvent : true;
        this._fireSort(fields, directions, cases);
        this._sortFields = [];
        this._sortDirections = [];
        this._sortCases = [];
        var cnt = fields ? fields.length : 0;
        var len = directions ? directions.length : 0;
        var clen = cases ? cases.length : 0;
        for (var i = 0; i < len; i++) {
            !_included(directions[i], SortDirection.ASCENDING, SortDirection.DESCENDING) && (directions[i] = SortDirection.ASCENDING);
        };
        for (var i = 0; i < cnt; i++) {
            this._sortFields.push(fields[i]);
            if (len > i) {
                this._sortDirections.push(directions[i]);
            } else if (len > 0) {
                this._sortDirections.push(directions[len - 1]);
            } else {
                this._sortDirections.push(SortDirection.ASCENDING);
            }
            if (clen > i) {
                this._sortCases.push(cases[i]);
            } else if (clen > 0) {
                this._sortCases.push(cases[clen - 1]);
            } else {
                this._sortCases.push(SortCase.SENSITIVE);
            }
        }
        this._sorted = this.$_checkSorted();
        this.$_buildItems();
        try {
            if (fireEvent) {
                this._fireRefresh();
            }
        } finally {
            this._fireSorted();
        }
    },
    getSortFields: function () {
        return this._sortFields.slice();
    },
    getSortDirections: function () {
        return this._sortDirections.slice();
    },
    getSortCases: function () {
        return this._sortCases.concat();
    },
    getLabelComparer: function() {
        return this._labelComparer;
    },
    setLabelComparer: function(comparer) {
        this._labelComparer = comparer;
    },
    setPaging: function (paging, pageSize, pageCount, source) {
        pageSize = arguments.length > 1 ? pageSize : 10;
        pageCount = arguments.length > 2 ? pageCount : -1;
        pageSize = Math.max(pageSize, 1);
        pageCount = Math.max(pageCount, -1);
        if (paging != this._paging || pageSize != this._pageSize || pageCount != this._pageCount || source != this._pagingSource) {
            this._currPage = 0;
            this._paging = paging;
            this._pagingSource = source;
            this._pageSize = pageSize;
            this._pageCount = pageCount;
            this.$_buildItems();
            this._fireRefresh();
        }
    },
    getPage: function () {
        return this._paging ? this._currPage : -1;
    },
    page: function () {
        return this._paging ? this._currPage : -1;
    },
    setPage: function (newPage, startIndex) {
        newPage = isNaN(newPage) ? 0 : newPage;
        startIndex = arguments.length > 0 ? startIndex : -1;
        if (this._paging) {
            newPage = Math.max(0, Math.min(this.pageCount() - 1, newPage));
            startIndex = Math.max(-1, startIndex);
            if (newPage != this._currPage || startIndex != this._pageStartIndex) {
                this._currPage = newPage;
                this._pageStartIndex = startIndex;
                this.$_buildPage();
                this._fireRefresh();
            }
        }
    },
    pageCount: function () {
        if (this._paging) {
            if (this._pageCount >= 0) {
                return this._pageCount;
            } else {
                return _int((this._dataSource.rowCount() + this._pageSize - 1) / this._pageSize);
            }
        } else {
            return 0;
        }
    },
    setPageCount: function (value) {
        if (this._paging) {
            value = Math.max(-1, value);
            if (value != this._pageCount) {
                this._pageCount = value;
                this.$_buildPage();
                this._fireRefresh();
            }
        }
    },
    setPageSorting: function (value) {
        if (this._paging && value != this._pageSorting) {
            this._pageSorting = value;
        } else {
            this._pageSorting = value;
        }
    },
    getCheckedRows: function (allRows) {
        var i;
        var item;
        var cnt = allRows ? this._dataSource.rowCount() : this.itemCount();
        var rows = [];
        for (i = 0; i < cnt; i++) {
            item = allRows ? this._rows[i] : this._pubItems[i];
            if (item.isChecked()) {
                rows.push(item.dataRow());
            }
        }
        return rows;
    },
    resetCheckables: function () {
        for (var i = this._rows.length; i--;) {
            this._rows[i].$_setCheckable(true);
        }
        this._fireRefresh();
    },
    applyCheckables: function () {
        if (this._checkableTag) {
            this._checkableTag.setRows();
        } else {
            ItemCheckableTag.clearCheckables(this);
        }
        this._fireRefresh();
    },
    dataSource: function () {
        return this._dataSource;
    },
    setDataSource: function (value) {
        if (value !== this._dataSource) {
            this.$_clearRows();
            if (this._dataSource) {
                this._dataSource.removeTag(this._cellStyles);
                this._dataSource.removeTag(this._editableMap);
                this._checkableTag && this._checkableTag.disconnect();
                this._dataSource.removeListener(this);
            }
            this._dataSource = value;
            if (this._dataSource) {
                this._checkableTag && this._checkableTag.connect(this._dataSource);
                this.$_buildRows();
                this._dataSource.addListener(this);
                this._dataSource.addTag(this._cellStyles);
                this._dataSource.addTag(this._editableMap)
            }
            if (!this._destroying) {
                this.$_resetSummary();
                this._fireReset();
            }
        }
    },
    itemCount: function () {
        return this._pubCount;
    },
    fixedCount: function () {
        return this._fixedCount;
    },
    maxItemCount: function () {
        return this._maxItemCount;
    },
    setMaxItemCount: function (value) {
        value = Math.max(0, value);
        if (value != this._maxItemCount) {
            this._maxItemCount = value;
            this.refreshItems();
        }
    },
    getItem: function (index) {
        if (index < 0 || index >= this._pubCount) {
            return null;
        }
        return this._pubItems[index];
    },
    getItems: function (index, count) {
        return this._pubItems.slice(index, index + count);
    },
    getIndexOfRow: function (dataRow) {
        if (dataRow >= 0 && dataRow < this._rows.length) {
            var row = this._rows[dataRow];
            return row && this._pubItems.indexOf(row) >= 0 ? row._index : -1
            // return this._rows[dataRow]._index;
        }
        return -1;
    },
    getItemOfRow: function (dataRow, force) {
        if (dataRow >= 0 && dataRow < this._rows.length) {
            var item = this._rows[dataRow];
            return item._index >= 0 || force ? item : null;
        }
        return null;
    },
    refreshItems: function () {
        var saveExtents = {};
        this.$_saveExtents(saveExtents);
        this.$_clearRows();
        this.$_buildRows(saveExtents);
        this._fireRefresh();
    },
    setFixed: function (count, sorting, filtering) {
        count = Math.max(0, count);
        if (count != this._fixedCount || sorting != this._fixedSorting || filtering != this._filtering) {
            this._fixedCount = count;
            this._fixedSorting = sorting;
            this._fixedFiltering = filtering;
            this.$_buildItems();
            this._fireRefresh();
        }
    },
    exchange: function (index1, index2) {
        if (index1 == index2) {
            return;
        }
        if (!this._sorted && !this._filtered) {
            if (index1 < 0 || index1 >= this._rows.length) {
                throw new Error("index1 is out of bounds: " + index1);
            }
            if (index2 < 0 || index2 >= this._rows.length) {
                throw new Error("index2 is out of bounds: " + index1);
            }
            var t = this._rows[index1];
            this._rows[index1] = this._rows[index2];
            this._rows[index2] = t;
        }
    },
    clearDisplayLevels: function () {
        var i;
        var rows = this._rows;
        var cnt = rows.length;
        for (i = 0; i < cnt; i++) {
            rows[i]._displayLevel = -1;
        }
    },
    getAllItems: function () {
        return this._pubItems.slice();
    },
    hasCellStyle: function () {
        return !this._cellStyles.isEmpty();
    },
    setCellStyle: function (row, field, style) {
        this._cellStyles.setCellStyle(row, field, style);
    },
    setCellStyles: function (provider, rows, fieldMap) {
        this._cellStyles.setCellStyles(provider, rows, fieldMap);
    },
    removeCellStyle: function (style) {
        this._cellStyles.removeCellStyle(style);
    },
    clearCellStyles: function () {
        this._cellStyles.clearCellStyles();
    },
    checkCellStyle: function (dataRow, field) {
        return this._cellStyles.checkCellStyle(dataRow, field);
    },
    getCellStyle: function (dataRow, field) {
        return this._cellStyles.getCellStyle(dataRow, field);
    },
    setCellEditable: function (dataRow, column, value) {
        this._editableMap.setEditable(dataRow, column, value);
    },
    setCellReadOnly: function(dataRow, column, value) {
        this._editableMap.setReadOnly(dataRow, column, value);
    },
    getCellEditable: function (dataRow, column) {
        return this._editableMap.getEditable(dataRow, column);
    },
    getCellReadOnly: function(dataRow, column) {
        return this._editableMap.getReadOnly(dataRow, column);
    },
    setCellCursor: function(dataRow, column, value) {
        return this._editableMap.setCursor(dataRow, column, value);
    },
    getCellCursor: function (dataRow, column) {
        return this._editableMap.getCursor(dataRow, column);
    },
    setCellEditor: function(dataRow, column, value) {
        return this._editableMap.setEditor(dataRow, column, value);
    },
    getCellEditor: function(dataRow, column) {
        return this._editableMap.getEditor(dataRow, column);
    },
    clearEditableMap: function() {
        return this._editableMap.clearEditableMap();
    },
    getNumber: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.count : this.itemCount();
    },
    getSum: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.sum : NaN;
    },
    getMax: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.max : NaN;
    },
    getMin: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.min : NaN;
    },
    getAvg: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.avg : NaN;
    },
    getVar: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.vars : NaN;
    },
    getVarp: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.varsp : NaN;
    },
    getStdev: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? Math.sqrt(fs.vars) : NaN;
    },
    getStdevp: function (field) {
        var fs = this.$_getSummary(field);
        return fs ? Math.sqrt(fs.varsp) : NaN;
    },
    getDataCount: function(field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.datacount : 0;
    },
    getDataAvg: function(field) {
        var fs = this.$_getSummary(field);
        return fs ? fs.dataavg : NaN;
    },
    $_saveExtents: function (exts) {
        var row;
        var rowId;
        for (var i = 0, cnt = this._rows.length; i < cnt ; i++) {
            var row = this._rows[i];
            row._dataRowId >= 0 && (exts[row._dataRowId] = row._extents);
        }
    },
    $_clearRows: function () {
        this._rows.length = 0;
        this._filteredItems.length = 0;
        this._filtered = false;
        this._sorted = false;
        this._sortedItems.length = 0;
        this._pubItems = this._rows;
        this.$_clearDistincts();
    },
    $_clearIndicies: function () {
        for (var i = this._rows.length; i--;) {
            this._rows[i]._index = -1;
        }
    },
    $_clearDistincts: function () {
        for (var i = this._distinctRows.length; i--;) {
            this._distinctRows[i] = null;
        }
        this._distinctRows.length = 0;
    },
    $_checkFiltered: function () {
        if (this._dataSource) {
            this._filters.length = this._dataSource.fieldCount();
            return this.hasFilters() || (this._hideDeleted && this._dataSource.deletedCount() > 0) || (this._dataSource.hideCount() > 0);
        }
        return false;
    },
    $_select: function (filters, item, field) {
        var cnt = filters.length;
        for (var i = 0; i < cnt; i++) {
            if (filters[i].select(this._filterRuntime, item, field)) {
                return true;
            }
        }
        return false;
    },
    $_checkSorted: function () {
        for (var i = this._sortFields.length - 1; i >= 0; i--) {
            if (this._sortFields[i] > this._dataSource.fieldCount()) {
                this._sortFields.splice(i, 1);
                this._sortDirections.splice(i, 1);
                this._sortCases.splice(i, 1);
            }
        }
        return this._sortFields && this._sortFields.length > 0;
    },
    $_buildRows: function (saveExtents) {
        var ds = this._dataSource;
        if (!ds) {
            return;
        }
        var t = getTimer();
        _trace(">>>>>> B U I L D I T E M S... " + t);
        this._filtered = this.$_checkFiltered();
        this._sorted = this.$_checkSorted();
        this._rowCount = ds.rowCount();
        if (!this._filtered && !this._paging && this.maxItemCount() > 0) {
            this._rowCount = Math.min(this._rowCount, this.maxItemCount());
        }
        this._rows = new Array(this._rowCount);
        for (var i = 0, cnt = this._rows.length; i < cnt; i++) {
            var row = this._rows[i] = this.$_createRow(i);
            saveExtents && saveExtents.hasOwnProperty(row.dataId()) && (row._extents = saveExtents[row.dataId()]);
        }
        this.$_buildItems();
        this._checkableTag && this._checkableTag.setRows();
        _trace("####### B U I L D I T E M S: " + (getTimer() - t));
    },
    $_resetCounts: function () {
        if (this._filtered) {
            this._pubCount = this._itemCount = this._items.length;
        } else {
            this._pubCount = this._itemCount = this._rowCount = this._rows.length;
        }
    },
    $_buildItems: function (noFilter, noSort) {
        var maxCount = this.maxItemCount() > 0 ? this.maxItemCount() : this._rows.length;
        var i, cnt, row, state, hide;
        var hideDataRow = this._dataSource.hideCount();
        this._rowCount = this._rows.length;
        this._pubItems = this._items = this._rows;
        this._pubCount = this._itemCount = this._rows.length;
        this._filtered = this.$_checkFiltered();
        this._sorted = this.$_checkSorted();
        if (this._filtered || this._paging) {
            this.$_clearIndicies();
        }
        if (this._filtered) {
            this._filteredItems.length = 0;
            if (this._hideDeleted || hideDataRow > 0) {
                for (i = 0; i < this._rowCount; i++) {
                    row = this._rows[i];
                    state = this._dataSource.getRowState(this._rows[i]._dataRow);
                    hide = this._dataSource.isHideDataRow(this._rows[i]._dataRow);
                    if (this._hideDeleted && RowState.isDeleted(state) || hide) {
                        row._index = -1;
                    } else {
                        row._index = 0;
                    }
                }
            } else {
                for (i = 0; i < this._rowCount; i++) {
                    this._rows[i]._index = 0;
                }
            }
            var filters, c;
            var fixedCount = this.fixedCount();
            var exceptFiltering = (fixedCount > 0) && !this._fixedFiltering;
            var nMax = this._rows.length;
            if (!noFilter) {
                for (var i = 0, len = this._filters.length; i < len; i++) {
                    filters = this._filters[i];
                    if (filters) {
                        for (c = 0; c < filters.length; c++) {
                            filters[c].prepare(this._filterRuntime, this._dataSource);
                        }
                    }
                }
            }
            if (!this._paging) {
                nMax = Math.min(nMax, maxCount);
            }
            cnt = 0;
            for (i = 0; i < this._rowCount && cnt < nMax; i++) {
                row = this._rows[i];
                if (row._index >= 0) {
                    if (noFilter || exceptFiltering && cnt < fixedCount) {
                        this._filteredItems.push(row);
                        cnt++;
                    } else {
                        var selected = !this._filterOr; // filterOr 선택된 filter중 하나라도 만족하면 select;
                        var fltCnt = 0;
                        for (var y = 0, len = this._filters.length; y < len; y++) {
                            filters = this._filters[y];
                            filters && fltCnt++;
                            if (this._filterOr) {
                                if (filters && this.$_select(filters, row, y)) {
                                    selected = true;
                                    break;
                                };
                            } else {
                                if (filters && !this.$_select(filters, row, y)) {
                                    selected = false;
                                    break;
                                }
                            }
                        }
                        if (selected || fltCnt === 0) {
                            this._filteredItems.push(row);
                            cnt++;
                        }
                    }
                }
            }
            this._pubItems = this._items = this._filteredItems;
            this._pubCount = this._itemCount = this._items.length;
        } else {
            this._filteredItems.length = 0;
        }
        if (this._sorted && (!this._paging || !this._pageSorting)) {
            if (noSort) {
                var items = this._sortedItems;
                for (i = items.length; i--;) {
                    if (items[i]._index < 0) {
                        items.splice(i, 1);
                    }
                }
            } else {
                this.$_sortRows();
            }
            this._pubItems = this._sortedItems;
        } else {
            this._sortedItems.length = 0;
        }
        if (this._paging) {
            this.$_buildPageItems();
        }
        this.$_clearSummary();
        this._resetItemIndicies(0);
    },
    $_buildPageItems: function () {
        var items = this._sorted && !this._pageSorting ? this._sortedItems : this._filtered ? this._filteredItems : this._items;
        this._pageItems.length = 0;
        var i = this._pageStart = this._pageStartIndex >= 0 ? this._pageStartIndex : this._currPage * this._pageSize;
        var itemCount = items.length;
        var maxCount = this.maxItemCount() > 0 ? this.maxItemCount() : itemCount;
        var cnt = Math.min(this._pageSize, maxCount);
        for (; i < itemCount && cnt > 0; i++, cnt--) {
            this._pageItems.push(items[i]);
        };
        if (this._pageSorting && this._sorted) {
            this.$_sortRows(this._pageItems);
        }
        this._pubItems = this._pageItems;
        this._pubCount = this._pubItems.length;
    },
    $_buildPage: function () {
        this.$_clearIndicies();
        this.$_buildPageItems();
        this._resetItemIndicies(0);
    },
    $_compareFuncs: function(sortFields, sortDirections, sortCases) {
        var comparers = {};
        var ds = this._dataSource;
        for (var i = 0, cnt = sortFields.length; i < cnt ; i++) {
            var field = ds.getField(sortFields[i]);
            if (field) {
                var compFunc = field._comparer ? field._comparer : ds.getDataComparer(field.index()) ? ds.getDataComparer(field.index()) : this._labelComparer[field.index()];
                var t = field.dataType();
                var ignoreCase = sortCases[i] == SortCase.INSENSITIVE;
                if (!compFunc) {
                    switch (t) {
                        case ValueType.DATETIME:
                        case ValueType.NUMBER:
                            compFunc = ds.compareNumbers.bind(ds);
                            break;
                        case ValueType.BOOLEAN:
                            compFunc = ds.compareBools.bind(ds);
                            break;
                        case ValueType.OBJECT:
                            compFunc = ds.compareObjects.bind(ds);
                            break;
                        default:
                            compFunc = ignoreCase ? ds.compareTexts.bind(ds) : ds.compareValues.bind(ds);
                            break;
                    }
                }
                if (compFunc) {
                    comparers[sortFields[i]] = compFunc;
                }
            }
        }
        return comparers;
    },
    $_sortRows: function (items) {
        var sortRows = items || this._items.slice();
        var fixedRows = [];
        if (this._fixedCount > 0 && !this._fixedSorting) {
            fixedRows = sortRows.splice(0, this._fixedCount);
        };
        var comparers = this.$_compareFuncs(this._sortFields, this._sortDirections, this._sortCases);
        sortRows.sort(function(r1, r2) {
            var diff = 0;
            var compFunc;
            var i, cnt;
            var sortDirection, checkRow;
            for (i = 0, cnt = this._sortFields.length; i < cnt ; i++) {
                sortDirection = this._sortDirections[i];
                checkRow = this._sortFields.length == i+1;
                if (compFunc = comparers[this._sortFields[i]]) {
                    diff = compFunc(this._sortFields[i], r1._dataRow, r2._dataRow);
                    if (diff !== 0) {
                        break;
                    }
                }
            }
            diff = diff * ( sortDirection === SortDirection.DESCENDING ? -1 : 1);
            diff = diff === 0 && checkRow ? (sortDirection === SortDirection.DESCENDING ? r2._dataRow - r1._dataRow : r1._dataRow - r2._dataRow) : diff;
            return diff;
        }.bind(this));
        this._sortedItems = fixedRows.concat(sortRows);
        return;
        /*
        // 기존 sort의 경우 특정상황에서 stack overflow를 발생시킨다.
        // array의 sort를 이용해서 정렬하도록 변경한다.
        this._sortedItems = items || this._items.concat();
        var rows = this._sortedItems.length;
        if (this._fixedCount > 0 && !this._fixedSorting) {
            this.$_sort(0, this._fixedCount, rows - 1);
        } else {
            this.$_sort(0, 0, rows - 1);
        }
        */
    },
    /*
    $_sort: function (level, startIndex, endIndex) {
        var t = _getTimer();
        this.$_sortLevel(level, startIndex, endIndex);
        t = _getTimer() - t;
        trace("### DefaultItemProvider.sort in " + t + " ms.");
    },
    $_sortLevel: function (level, startIndex, endIndex) {
        if (startIndex >= endIndex) {
            return;
        }
        var ds = this._dataSource;
        var fld = this._sortFields[level];
        var field = ds.getField(fld);
        if (field) {
            var ascending = this._sortDirections[level] != SortDirection.DESCENDING;
            var ignoreCase = this._sortCases[level] == SortCase.INSENSITIVE;
            var t = field.dataType();
            var equalFunc;
            var compFunc = field._comparer ? field._comparer : ds.getDataComparer(field.index()) ? ds.getDataComparer(field.index()) : this._labelComparer[field.index()];
            if (!compFunc) {
                switch (t) {
                    case ValueType.DATETIME:
                    case ValueType.NUMBER:
                        compFunc = ds.compareNumbers.bind(ds);
                        break;
                    case ValueType.BOOLEAN:
                        compFunc = ds.compareBools.bind(ds);
                        break;
                    case ValueType.OBJECT:
                        compFunc = ds.compareObjects.bind(ds);
                        break;
                    default:
                        compFunc = ignoreCase ? ds.compareTexts.bind(ds) : ds.compareValues.bind(ds);
                        break;
                }
            }
            if (t == ValueType.TEXT && ignoreCase) {
                equalFunc = ds.equalTexts.bind(ds);
            } else {
                equalFunc = ds.equalValues.bind(ds);
            }
            this.$_sortRange(fld, ascending, ignoreCase, compFunc, startIndex, endIndex, level + 1 == this._sortFields.length);
            if (level + 1 < this._sortFields.length) {
                var i = startIndex,
                    pi = i,
                    items = this._sortedItems;
                while (i < endIndex) {
                    i++;
                    if (!equalFunc(fld, items[i]._dataRow, items[i - 1]._dataRow)) {
                        this.$_sortLevel(level + 1, pi, i - 1);
                        pi = i;
                    }
                }
                if (pi < endIndex) {
                    this.$_sortLevel(level + 1, pi, endIndex);
                }
            }
        }
    },
    $_sortRange: function (field, ascending, ignoreCase, compFunc, left, right, checkRow) {
        var i, j, row, m, r, v;
        var items = this._sortedItems;
        do {
            i = left;
            j = right;
            row = _floor((left + right) / 2);
            m = items[row]._dataRow;
            do {
                if (ascending) {
                    while (i <= j) {
                        r = items[i]._dataRow;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = m - r;
                        if (v <= 0)
                            break;
                        i++;
                    }
                    while (i <= j) {
                        r = items[j]._dataRow;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = m - r;
                        if (v >= 0)
                            break;
                        j--;
                    }
                } else {
                    while (i <= j) {
                        r = items[i]._dataRow;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = r - m;
                        if (v >= 0)
                            break;
                        i++;
                    }
                    while (i <= j) {
                        r = items[j]._dataRow;
                        v = compFunc(field, m, r);
                        if (v == 0 && checkRow) v = r - m;
                        if (v <= 0)
                            break;
                        j--;
                    }
                }
                if (i <= j) {
                    if (i != j) {
                        var t = items[i];
                        items[i] = items[j];
                        items[j] = t;
                    }
                    i++;
                    j--;
                }
            } while (i <= j);
            if (left < j) {
                this.$_sortRange(field, ascending, ignoreCase, compFunc, left, j, checkRow);
            }
            left = i;
        } while (left < right);
    },
    */
    $_createRow: function (row) {
        var item = new GridRow(row);
        this.attachItem(item);
        item._dataRowId = item.dataId();
        return item;
    },
    $_createAllRow: function () {
        for (var i = 0; i < this._rowCount; i++) {
            if (!this._rows[i]) {
                this._rows[i] = this.$_createRow(i);
            }
        }
    },
    $_resetSummary: function () {
        this._summaryMap = [];
    },
    $_clearSummary: function () {
        if (this._summaryMap) {
            for (var i = this._summaryMap.length - 1; i >= 0; i--) {
                this._summaryMap[i] && this._summaryMap[i].clear();
            }
        }
    },
    $_getSummary: function (field) {
        var fs = this._summaryMap[field];
        if (!fs) {
            var ds = this._dataSource;
            if (ds && ds.canSummarize(field)) {
                fs = new FieldSummary(field);
                this._summaryMap[field] = fs;
            }
        }
        if (fs && fs.count == 0 && this.itemCount() > 0) {
            this.$_summarize(fs);
        }
        return fs;
    },
    $_summarize: function (fld) {
        var ds = this._dataSource;
        if (ds) {
            if (this._filtered) {
                var cnt = this._items.length;
                var rows = new Array(cnt);
                for (var i = 0; i < cnt; i++) {
                    // rows[i] = this._pubItems[i]._dataRow;
                    rows[i] = this._items[i]._dataRow;
                }
                ds.summarizeRange(fld, rows, this._summaryMode == SummaryMode.STATISTICAL);
            } else {
                ds.summarize(fld, this._summaryMode == SummaryMode.STATISTICAL);
            }
        }
    },
    $_needSort: function () {
        return this._sorted && this._sortMode == SortMode.AUTO;
    },
    $_needFilter: function () {
        return this._filtered && this._filterMode == FilterMode.AUTO;
    },
    onDataProviderDisposed: function (provider) {
        provider.removeTag(this._cellStyles);
        provider.removeTag(this._editableMap);
        this._checkableTag && this._checkableTag.disconnect();
        this.$_clearRows();
        this.$_resetSummary();
        this._fireReset();
        this.setDataSource(null);
    },
    onDataProviderReset: function (provider) {
        this.$_clearRows();
        this.$_buildRows();
        this.$_resetSummary();
        this._fireReset();
    },
    onDataProviderRefresh: function (provider) {
        this.refreshItems();
    },
    onDataProviderRefreshClient: function (provider) {
        this._fireRefreshClient();
    },
    onDataProviderRowCountChanged: function (provider, newCount) {
        this._fireRefreshClient();
    },
    onDataProviderRowInserting: function (provider, row, values) {
        return true;
    },
    onDataProviderRowInserted: function (provider, row, itemIndex) {
        var rows = this._rows;
        var posRow = row < rows.length ? rows[row] : null;
        var item, items;
        item = this.$_createRow(row);
        rows.splice(row, 0, item);
        for (var i = row, cnt = rows.length; i < cnt; i++) {
            rows[i]._dataRow = i;
        }
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildItems();
        } else {
            if (this._filtered) {
                items = this._filteredItems;
                row = itemIndex != null ? itemIndex : Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                items.splice(row, 0, item);
            }
            if (this._sorted) {
                items = this._sortedItems;
                row = itemIndex != null ? itemIndex : Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                // row = Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                items.splice(row, 0, item);
            }
            this.$_clearSummary();
            this.$_resetCounts();
            !this._updateLock && this._resetItemIndicies(this._sorted ? 0 : row);
        }
        this._checkableTag && this._checkableTag.insertRow(item);
        this._fireItemInserted(item);
    },
    onDataProviderRowsInserted: function (provider, row, count, itemIndex) {
        if (count < 0) {
            return;
        }
        var rows = this._rows;
        var posRow = row < rows.length ? rows[row] : null;
        var list = [];
        var i, item, items;
        for (i = 0; i < count; i++) {
            list.push(item = this.$_createRow(row + i));
            rows.splice(row + i, 0, item);
        }
        var cnt = rows.length;
        for (i = row; i < cnt; i++) {
            rows[i]._dataRow = i;
        }
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildItems();
        } else {
            if (this._filtered) {
                items = this._filteredItems;
                row = itemIndex != null ? itemIndex : Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                for (i = 0; i < list.length; i++) {
                    items.splice(row + i, 0, list[i]);
                }
            }
            if (this._sorted) {
                items = this._sortedItems;
                row = itemIndex != null ? itemIndex : Math.max(0, posRow ? items.indexOf(posRow) : items.length);
                for (i = 0; i < list.length; i++) {
                    items.splice(row + i, 0, list[i]);
                }
            }
            this.$_clearSummary();
            this.$_resetCounts();
            !this._updateLock && this._resetItemIndicies(row);
        }
        this._checkableTag && this._checkableTag.insertRows(row, count);
        this._fireRefresh();
    },
    onDataProviderRowRemoving: function (provider, row) {
        return true;
    },
    $_silentRemoveRow: function (item) {
        var items, r;
        if (this._filtered) {
            items = this._filteredItems;
            r = items.indexOf(item);
            r >= 0 && items.splice(r, 1);
        }
        if (this._sorted) {
            items = this._sortedItems;
            r = items.indexOf(item);
            r >= 0 && items.splice(r, 1);
        }
        this.$_clearSummary();
        this.$_resetCounts();
        !this._updateLock && this._resetItemIndicies(0);
    },
    onDataProviderRowRemoved: function (provider, rowIndex) {
        var rows = this._rows;
        var item = rows[rowIndex];
        rows.splice(rowIndex, 1);
        for (var i = rows.length - 1; i >= rowIndex; i--) {
            rows[i]._dataRow = i;
        }
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildItems();
        } else {
            this.$_silentRemoveRow(item);
        }
        this._fireItemDeleted(item);
    },
    onDataProviderRowsRemoving: function (provider, rows) {
        return true;
    },
    $_silentRemoveRows: function (list) {
        var i, items, item, row;
        if (this._filtered) {
            items = this._filteredItems;
            for (i = 0; i < list.length; i++) {
                item = list[i];
                row = items.indexOf(item);
                row >= 0 && items.splice(row, 1);
            }
        }
        if (this._sorted) {
            items = this._sortedItems;
            for (i = 0; i < list.length; i++) {
                item = list[i];
                row = items.indexOf(item);
                row >= 0 && items.splice(row, 1);
            }
        }
        this.$_clearSummary();
        this.$_resetCounts();
        !this._updateLock && this._resetItemIndicies(0);
    },
    onDataProviderRowsRemoved: function (provider, rows) {
        if (!rows || rows.length < 1) {
            return;
        }
        if (rows.length > 1) {
            rows.sort(function (v1, v2) {
                return v1 - v2;
            });
        }
        var items = this._rows;
        var row = rows[0];
        var list = [];
        var i;
        for (i = rows.length - 1; i >= 0; i--) {
            list.push(items[rows[i]]);
            items.splice(rows[i], 1);
        }
        for (i = this._rows.length - 1; i >= row; i--) {
            items[i]._dataRow = i;
        }
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildItems();
        } else {
            this.$_silentRemoveRows(list);
        }
        this._fireRefresh();
    },
    onDataProviderRowUpdating: function (provider, row, values) {
        return true;
    },
    onDataProviderRowUpdated: function (provider, row) {
        if (this.$_needFilter() || this.$_needSort()/* || this._paging */) {
            this.$_buildItems();
        } else {
            this.$_clearSummary();
        }
        this._checkableTag && this._checkableTag.updateRow(this._rows[row]);
        this._rows[row] && this._fireItemUpdated(this._rows[row]);
    },
    onDataProviderRowsUpdated: function (provider, row, count) {
        if (this.$_needFilter() || this.$_needSort()/* || this._paging*/) {
            this.$_buildItems();
        } else {
            this.$_clearSummary();
        }
        this._checkableTag && this._checkableTag.updateRows(row, count);
        this._fireRefresh();
    },
    onDataProviderValueChanging: function (provider, row, field, value) {
        return true;
    },
    onDataProviderValueChanged: function (provider, row, field) {
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildItems();
        } else {
            this.$_clearSummary();
        }
        this._checkableTag && this._checkableTag.updateRow(this._rows[row]);
        this._rows[row] && this._fireItemUpdated(this._rows[row]);
    },
    onDataProviderRowMoving: function (provider, row, newRow) {
        return true;
    },
    onDataProviderRowMoved: function (provider, row, newRow) {
        var rows = this._rows;
        var r = rows.splice(row, 1);
        rows.splice(newRow, 0, r[0]);
        var len = rows.length;
        row = Math.min(row, newRow);
        for (var i = row; i < len; i++) {
            rows[i]._dataRow = i;
        }
        if (this._sorted || this._paging || this._hideDeleted) {
            this.$_buildItems();
            this._resetItemIndicies(0);
        }
        this._fireRefresh();
    },
    onDataProviderRowsMoving: function (provider, row, count, newRow) {
        return true;
    },
    onDataProviderRowsMoved: function (provider, row, count, newRow) {
        this.refreshItems();
    },
    onDataProviderStateChanged: function (provider, row) {
        if (this._hideDeleted) {
            var item = this._rows[row];
            if (RowState.isDeleted(item.rowState())) {
                 if (this.$_needFilter() || this.$_needSort() || this._paging) {
                     this.$_buildItems();
                 } else {
                    if ( (this.$_checkFiltered() && (!this._filteredItems || this._filteredItems.length <= 0)) || ( this.isSorted() && (!this._sortedItems || this._sortedItems.length <= 0))) {
                        this.$_buildItems(true,true);
                    } else {
                        this.$_silentRemoveRow(item);
                    }
                    // this.$_buildItems(true,true);
                 }
                 this._fireRefresh();
            }
        }
        this._checkableTag && this._checkableTag.updateRow(this._rows[row]);
        this._fireRowStateChanged(this._rows[row]);
    },
    onDataProviderRowHided: function(provider, rows, hide) {
        this._filtered = this.$_checkFiltered();
        if (hide) {
            if (this.$_needFilter() || this.$_needSort() || this._paging) {
                this.$_buildItems();  
            } else {// 최초 dataLoad후 filter, sort가 되지 않은 상태.
                if ((this.$_checkFiltered() && (!this._filteredItems || this._filteredItems.length <= 0)) || ( this.isSorted() && (!this._sortedItems || this._sortedItems.length <= 0))) {
                    this.$_buildItems(true,true);   
                } else {
                    var list = this.getItemsByRows(rows);
                    this.$_silentRemoveRows(list);
                }
            }
            this._fireRefresh();
        } else {
            this.refreshItems();
        }
    },
    onDataProviderStatesChanged: function (provider, rows) {
        if (this._hideDeleted) {
            var deleted = false;
            var i, cnt, r, list;
            for (i = 0, cnt = rows.length; i < cnt; i++) {
                r = rows[i];
                r = this._rows[r];
                if (RowState.isDeleted(r.rowState())) {
                    deleted = true;
                    break;
                }
            }
            if (deleted) {
                if (this.$_needFilter() || this.$_needSort() || this._paging) {
                    this.$_buildItems();// filter,sort를 하거나 paging인경우 item을 다시 만든다.
                } else {
                    if ((this.$_checkFiltered() && (!this._filteredItems || this._filteredItems.length <= 0)) || ( this.isSorted() && (!this._sortedItems || this._sortedItems.length <= 0))) {
                        this.$_buildItems(true,true);   
                    } else {
                        list = this.getItemsByRows(rows);
                        this.$_silentRemoveRows(list);
                    }
                    // this.$_buildItems(true,true); //
                }
                this._fireRefresh();
            }
        }
        this._checkableTag && this._checkableTag.changeStates(rows);
        this._fireRowStatesChanged(this.getItemsByRows(rows));
    },
    onDataProviderRestoreRows: function(provider, rows) {
        if (this.$_needFilter() || this.$_needSort() || this._paging) {
            this.$_buildItems();
        } else {
            this.$_clearSummary();
        }
        this._checkableTag && this._checkableTag.changeStates(rows);
        this._fireRowStatesChanged(this.getItemsByRows(rows));
        this._fireRefresh();
    },
    onDataProviderStatesCleared: function (provider) {
        if (this._pubCount != provider.rowCount()) {
            this.refreshItems();
        }
        this._fireRowStatesCleared();
    }
});
var /* @abstract */ ProxyItemProvider = defineClass("ProxyItemProvider", ItemProvider, {
	init: function (source, indexing) {
		this._super(indexing);
		this._initialize();
		this.setSource(source);
	},
    source: null,
	setSource: function (value) {
		if (value != this._source) {
			if (this._source) {
				this._source.removeListener(this);
			}
			this._clearItems();
			this._source = value;
			if (this._source) {
				this._populateItems();
				this._source.addListener(this);
			}
		}
	},
	dataSource: function () {
		return this._source ? this._source.dataSource() : null;
	},
	fixedCount: function () {
		return this._source ? this._source.fixedCount() : 0;
	},
	maxItemCount: function () {
		return this._source ? this._source.maxItemCount() : 0;
	},
	setMaxItemCount: function (value) {
		if (this._source) {
			this._source.setMaxItemCount(value);
		}
	},
	setFixed: function (count, sorting, filtering) {
		if (this._source) {
			this._source.setFixed(count, sorting, filtering);
		}
	},
	getIndexOfRow: function (dataRow) {
		return this._source ? this._source.getIndexOfRow(dataRow) : -1;
	},
	getItemOfRow: function (dataRow) {
		return this._source ? this._source.getItemOfRow(dataRow) : null;
	},
	refreshItems: function () {
		this._source &&	this._source.refreshItems();
	},
	_clearDisplayLevels: function () {
		this._source && this._source._clearDisplayLevels();
	},
	setCellStyle: function (row, field, style) {
		this._source && this._source.setCellStyle(row, field, style);
	},
	removeCellStyle: function (style) {
		this._source && this._source.removeCellStyle(style);
	},
	clearCellStyles: function () {
		this._source && this._source.clearCellStyles();
	},
	_initialize: function () {
	},
	_clearItems: function () {
	},
	_populateItems: function () {
		this._resetItemIndicies(0);
	},
	onItemProviderReset: function (itemProvider) {
		this._populateItems();
		this._fireReset();
	},
	onItemProviderRefresh: function (itemProvider) {
		this._populateItems();
		this._fireRefresh();
	},
	onItemProviderRefreshClient: function (itemProvider) {
		this._fireRefreshClient();
	},
	onItemProviderItemInserted: function (itemProvider, item) {
		this._resetItemIndicies(0);
		this._fireItemInserted(item);
	},
	onItemProviderItemDeleted: function (itemProvider, item) {
		this._resetItemIndicies(0);
		this._fireItemDeleted(item);
	},
	onItemProviderItemUpdated: function (itemProvider, item) {
		this._resetItemIndicies(0);
		this._fireItemUpdated(item);
	},
	onItemProviderCheckableChanged: function (itemProvider, item) {
		this._fireCheckableChanged(item);
	},
	onItemProviderItemChecked: function (itemProvider, item) {
		this._fireItemChecked(item);
	},
	onItemProviderItemsChecked: function (itemProvider, items, checked) {
		this._fireItemsChecked(items, checked);
	},
	onItemProviderItemAllChecked: function (itemProvider, checked) {
		this._fireItemAllChecked(checked);
	},
	onItemProviderItemCheckChanged: function (itemProvider, items, checked) {
		this._fireItemCheckChanged(items, checked);
	},
	onItemProviderRowStateChanged: function (itemProvider, item) {
		this._fireRowStateChanged(item);
	},
	onItemProviderRowStatesChanged: function (itemProvider, items) {
		this._fireRowStatesChanged(items);
	},
	onItemProviderRowStatesCleared: function (itemProvider) {
		this._fireRowStatesCleared();
	},
	onItemProviderFilterAdded: function (provider, field, criteria) {
	},
	onItemProviderFilterRemoved: function (provider, field, filter) {
	},
	onItemProviderFilterCleared: function (provider, field) {
	},
	onItemProviderFilterAllCleared: function (provider) {
	},
	onItemProviderFiltered: function (provider) {
	},
	onItemProviderSort: function (provider, fields, directions) {
	},	
	onItemProviderSorted: function (provider) {
	}
});

var /* @internal */ GroupedVisibleItems = function (provider) {
	var _provider = provider;
	var _fixedCount = 0;
	var _items = [];
	var _list = [];
	/*
		mergeMode에서는 expandedAdornments가 both인경우 header, footer 모두 존재
		                                     header인경우 header만 존재
		                                     summary인경우 footer가 위에 존재
		                                     footer인경우 footer가 아래에 존재
		                                     none인경우 header, footer가 없다.
		                collapsedAdornments가 both인경우 header, footer모두 존재
		                                      header인경우 header만 존재
		                                      summary, footer인경우 footer만 존재.
		                                      none일수는 없다.
		normalMode expandedAdornments가 both인경우 header, footer모두 존재
										header인경우 header만 존재.
		                                footer인경우는 존재하지 않는다.
		                                summary인경우 footer가 위에 있으면서 expander를 가진다.
		            collapseAdornments가 both 인경우 header, footer존재
		            					header인경우 header만 존재
		            					footer, summary인경우 footer만 있으면서 footer가 expander를 가진다.
		       		expandedAdornments, collapsedAdornments모두 none을 가질수 없다.
	*/	
	var _collectChildren = function (parent, list, recursive, setFlag, level) {
		var i;
		var cnt;
		var item;
		var group;
		var fc = _provider._createFooterCallback;
		if (setFlag && parent instanceof GroupItem) {
			parent._setExpanded(true);
		}
		if (_provider.isMergeMode()) {
			if (!(parent instanceof RootItem)) {
				if (_provider.expandedAdornments() == RowGroupAdornments.HEADER || _provider.expandedAdornments() == RowGroupAdornments.BOTH) {
					list.push(parent);
				} else if (_provider.expandedAdornments() == RowGroupAdornments.SUMMARY) {
					(!fc || fc(_provider._handler, $$_getItemProxy(parent, true))) ? list.push(parent.footer()) : parent._hasFooter = false;
				}
			}
			for (i = 0, cnt = parent.count(); i < cnt; i++) {
				item = parent.getItem(i);
				if (item instanceof GroupItem) {
					group = item;
					if (recursive && (!level || group.level() <= level )|| group.isExpanded()) {
						_collectChildren(group, list, recursive, setFlag, level);
					} else {
						switch (_provider.collapsedAdornments()) {
							case RowGroupAdornments.BOTH:
								list.push(group);
								group.footer && list.push(group.footer());
								break;
							case RowGroupAdornments.SUMMARY:
							case RowGroupAdornments.FOOTER:
								list.push(group.footer());
								break;
							case RowGroupAdornments.HEADER:
							default:
								list.push(group);
								break;
							/*
							case ROWGROUPADORNMENTS.NONE:
								list.push(group.firstItem());
								break;
							*/
						}
					}
				} else if (item != parent.footer()) { 
					list.push(item);
				}
			}
			if (!(parent instanceof RootItem) && 
				(_provider.expandedAdornments() == RowGroupAdornments.FOOTER || _provider.expandedAdornments() == RowGroupAdornments.BOTH)) {
				(!fc || fc(_provider._handler, $$_getItemProxy(parent, true))) ? list.push(parent.footer()) : parent._hasFooter = false;
			}
		} else {
			if (!(parent instanceof RootItem)) {
				if (_provider.expandedAdornments() == RowGroupAdornments.SUMMARY) {
					var footer = parent.footer();
					footer._expandable = true;
					list.push(footer) 
				} else {
					list.push(parent);
				}
			}
			for (i = 0, cnt = parent.count(); i < cnt; i++) {
				item = parent.getItem(i);
				if (item instanceof GroupItem) {
					group = item;
					if (recursive && (!level || group.level() <= level)|| group.isExpanded()) {
						_collectChildren(group, list, recursive, setFlag, level);
					} else {
						switch (_provider.collapsedAdornments()) {
						case RowGroupAdornments.HEADER:
							list.push(group);
							break;
						case RowGroupAdornments.FOOTER:
						case RowGroupAdornments.SUMMARY:
							var footer = group.footer();
							footer._expandable = true;
							list.push(footer);
							break;
						case RowGroupAdornments.BOTH:
						default:
							list.push(group);
							if (group.footer()) {
								var footer = group.footer();
								footer._expandable = false;
								list.push(group.footer());
							}
							break;
						}
					}
				} else if (!(item instanceof GroupFooter)) { // footer는 제일 마지막에
					list.push(item);
				}
			}
			if (!(parent instanceof RootItem)) {
				if (_provider.expandedAdornments() == RowGroupAdornments.BOTH) {
					var footer = parent.footer();
					footer._expandable = (parent._expanded || parent.isVisible()) ? false : true;
					list.push(footer);
				}
			}
		}
	};
	var _expandItem = function (group, recursive, setFlag, level) {
		var idx;				
		if (group instanceof RootItem) {
			idx = _fixedCount;
		} else if (_provider.isMergeMode()) {
			/*
			 * 현재, collapsed 상태에서만 여기가 호출된다고 가정한다.
			 * group item 이 포함되지 않는 경우가 있다.
			 * collapsed style 별로 기존 아이템들을 제거한다.
		     */
			switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.BOTH:
					idx = group.index();
					_items.splice(idx, 2);
					break;
				case RowGroupAdornments.FOOTER:
				case RowGroupAdornments.SUMMARY:
					idx = group.footer().index();
					_items.splice(idx, 1);
					break;
				case RowGroupAdornments.HEADER:
				default:
					idx = group.index();
					_items.splice(idx, 1);
					break;
			}
			if (setFlag) {
				group._index = -1;
			}
		} else {
			switch(_provider.collapsedAdornments()) {
				case RowGroupAdornments.BOTH:
					idx = group.index();
					_items.splice(idx, 2);
					break;
				case RowGroupAdornments.FOOTER:
				case RowGroupAdornments.SUMMARY:
					idx = group.footer().index();
					_items.splice(idx,1);
					break;
				case RowGroupAdornments.HEADER:
					idx = group.index();
					_items.splice(idx, 1);
					break;
			}
			// if (_provider.collapsedAdornments() == RowGroupAdornments.FOOTER) {
			// 	idx = group.footer().index();
			// 	_items.splice(idx,1);
			// } else {
			// 	idx = group.index();
				
			// 	 * 현재, collapsed 상태에서만 여기가 호출된다고 가정한다.
			// 	 * 기존 group header와 footer를 제거한다.
				 
			// 	_items.splice(idx, 1);
			// 	var collapsedAdornment = _provider.collapsedAdornments();
			// 	if (collapsedAdornment == RowGroupAdornments.BOTH || collapsedAdornment == RowGroupAdornments.FOOTER) {
			// 		_items.splice(idx, 1);
			// 	}
			// }

			if (setFlag) {
				group._index = -1;
			}
		}
		_list.splice(0, _list.length);
		_collectChildren(group, _list, recursive, setFlag, level);
		for (var i = 0, cnt = _list.length; i < cnt; i++) {
			_items.splice(idx + i, 0, _list[i]);
		}
	};
	var _firstIndex = function (group, isSummary) {
		var idx = group.index();
		if (idx >= 0) { 
			return idx;
		};
		if (isSummary) {
			idx = group.footer().index();
			if (idx >= 0) {
				return idx;
			};
			for (var i = 0, cnt = group.count(); i < cnt ; i++) {
				var g = _cast(group.getItem(i), GroupItem);
				if (g) {
					idx = _firstIndex(g, isSummary);
				};
				if (idx >= 0) {
					return idx;
				}
			};
			return -1;
		}
		for (var i = 0, cnt = group.count(); i < cnt; i++) {
			var item = group.getItem(i);
			if (item.index() >= 0) {
				return item.index();
			}
			var g = _cast(item, GroupItem);
			if (g) {
				idx = _firstIndex(g);
				if (idx >= 0) {
					return idx;
				}
			}
		}
		return -1;
	};
	this.provider = function () {
		return _provider;
	};
	this.count = function () {
		return _items.length;
	};
	this.fixedCount = function () {
		return _fixedCount;
	};
	this.getItems = function () {
		return _items.slice();
	};
	this.getItem = function (index) {
		return _items[index];
	},
	this.clear = function (items) {
		items = items ? items : _items;
		for (var i = 0, cnt = items.length; i < cnt; i++) {
			items[i]._parent = provider._rootItem;
			if (items[i] instanceof GroupItemImpl && items[i]._children) {
				this.clear(items[i]._children)
			}
		}
		items.splice(0, items.length);
	};
	this.expand = function (group, recursive, setFlag, level) {
		setFlag = arguments.length > 2 ? setFlag : true;
		_expandItem(group, recursive, setFlag, level);
		return true;
	};
	this.collapse = function (group, recursive) {
		var idx;
		var item;
		var pItem;
		if (group instanceof GroupItem) {
			group._setExpanded(false);
		}
		if (_provider.isMergeMode()) {
			idx = group.index();
			if (idx >= 0) {
				_items.splice(idx, 1);
				group._index = -1;
			} else {
				idx = _firstIndex(group, _provider.expandedAdornments() == RowGroupAdornments.SUMMARY);
				idx < 0 && (idx = _firstIndex(group));
			}
			while (idx < _items.length) {
				item = _items[idx];
				if (!item.isDescendantOf(group)) {
					break;
				}
				_items.splice(idx, 1);
				item._index = -1;
				if (recursive && (item instanceof GroupItem || item instanceof MergedGroupFooter)) {
					pItem = item instanceof GroupItem ? item : item instanceof MergedGroupFooter && item.parent()._expanded ? item.parent() : null;
					pItem && pItem._setExpanded(false);
				}
			}
			switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.BOTH:
					group._index = idx;
					_items.splice(idx, 0, group);
					_items.splice(idx + 1, 0, group.footer());
					break;
				case RowGroupAdornments.FOOTER:
				case RowGroupAdornments.SUMMARY:
					_items.splice(idx, 0, group.footer());
					break;
				case RowGroupAdornments.HEADER:
				default:
					group._index = idx;
					_items.splice(idx, 0, group);
					break;
			}
		} else {
			idx = group.index();
			if (idx >= 0) {
				_items.splice(idx, 1);
				group._index = -1;
			} else {
				var footer = group.footer();
				idx = footer.index();
				_items.splice(idx,1);
				footer._index = -1;
			}
			while (idx < _items.length) {
				item = _items[idx];
				if (!item.isDescendantOf(group)) {
					break;
				}
				_items.splice(idx, 1);
				item._index = -1;
				if (recursive && (item instanceof GroupItem || item instanceof GroupFooter)) {
					pItem = item instanceof GroupItem ? item : item instanceof GroupFooter && item.parent()._expanded ? item.parent() : null;
					pItem && pItem._setExpanded(false);
				}
			}
			switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.BOTH:
					group._index = idx;
					_items.splice(idx, 0, group);
					var footer = group.footer();
					footer._index = idx;
					footer._expandable = false;
					_items.splice(idx + 1, 0, group.footer());
					break;
				case RowGroupAdornments.FOOTER:
				case RowGroupAdornments.SUMMARY:
					var footer = group.footer();
					footer._index = idx;
					footer._expandable = true;
					_items.splice(idx, 0, footer);
					break;
				case RowGroupAdornments.HEADER:
				default:
					group._index = idx;
					_items.splice(idx, 0, group);
					break;
			}
/*
			if (_provider.expandedAdornments() == RowGroupAdornments.FOOTER) {
				idx = group.footer().index();
				while (idx < _items.length) {
					item = _items[idx];
					if (!item.isDescendantOf(group)) {
						break;
					}
					_items.splice(idx, 1);
					item._index = -1;
					if (recursive && item instanceof GroupItem) {
						item._setExpanded(false);
					}
				}
				switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.BOTH:
					group._index = idx;
					_items.splice(idx, 0, group);
					_items.splice(idx + 1, 0, group.footer());
					break;
				case RowGroupAdornments.FOOTER:
					_items.splice(idx, 0, group.footer());
					break;
				case RowGroupAdornments.HEADER:
				default:
					group._index = idx;
					_items.splice(idx, 0, group);
					break;
				}
			} else {
				idx = group.index();
				switch (_provider.collapsedAdornments()) {
				case RowGroupAdornments.HEADER:
					idx++;
					while (idx < _items.length && _items[idx].level() > group.level()) {
						item = _items[idx];
						_items.splice(idx, 1);
						if (recursive && item instanceof GroupItem) {
							item._setExpanded(false);
						}
					}
					break;
				case RowGroupAdornments.FOOTER:
					while (idx < _items.length && _items[idx].level() > group.level()) {
						if (_items[idx] == group.footer()) {
							break;
						}
						item = _items[idx];
						_items.splice(idx, 1);
						if (recursive && item instanceof GroupItem) {
							item._setExpanded(false);
						}
					}
					break;
				case RowGroupAdornments.BOTH:
				default:
					idx++;
					while (idx < _items.length && _items[idx].level() > group.level()) {
						if (_items[idx] == group.footer()) {
							break;
						}
						item = _items[idx];
						_items.splice(idx, 1);
						if (recursive && item instanceof GroupItem) {
							item._setExpanded(false);
						}
					}
					if (idx >= _items.length || _items[idx] != group.footer()) {
						item = _items[idx];
						_items.splice(idx, 0, group.footer());
						if (recursive && item instanceof GroupItem) {
							item._setExpanded(false);
						}
					}
					break;
				}
			}
*/			
		}
		return true;
	};
	this.getNext = function (item) {
		if (item != null && item.isVisible() && item.index() < this.count() - 1) {
			return _items[item.index() + 1];
		}
		return null;
	};
	this.getPrior = function (item) {
		if (item != null && item.isVisible() && item.index() > 0) {
			return _items[item.index() - 1];
		}
		return null;
	};
	this._clearAndInit = function (source/* ItemProvider */, fixedCount) {
		this.clear();
		if (source) {
			_fixedCount = Math.min(fixedCount, source.itemCount());
			for (var i = 0; i < _fixedCount; i++) {
				_items.push(source.getItem(i));
			}
		} else {
			_fixedCount = 0;
		}
	};
	this._resetIndices = function (fromIndex) {
		fromIndex = arguments.length > 0 ? fromIndex : 0;
		var i,
			cnt = _items.length;
		for (i = fromIndex; i < cnt; i++) {
			_items[i]._index = i;
		}
	};
};
var GroupInfo = function (startIndex, endIndex) {
	this.level = 0;
	this.startIndex = startIndex;
	this.endIndex = endIndex;
	this.children = [];
	
};
var GroupedItemProvider = defineClass("GroupedItemProvider", ProxyItemProvider, {
	init: function (source, indexing) {
		this._visibleItems = null;
		this._rootItem = null;
		this._groupFields = null;
		this._groupSorting = true;
		this._sortDirection = SortDirection.ASCENDING;
		this._summarizing = false;
		this._grouped = false;
		this._editItem = null;
		this._super(source, indexing);
		this._groupList = {};
	},
	destroy: function() {
		this._destroying = true;
		this._groupList = null;
		this._visibleItems = null;
		this._rootItem = null;
		this._groupFields = null;
		this._createFooterCallback = null;
		this._super();
	},
	treeMode: false,
	expandedAdornments: RowGroupAdornments.BOTH,
	collapsedAdornments: RowGroupAdornments.HEADER,
	createFooterCallback: null,
	expandWhenGrouping: false,
	mergeMode: false,
	summaryMode: SummaryMode.AGGREGATE,
	isGrouped: function () {
		return this._grouped;
	},
	groupList: function() {
		return this._groupList;
	},
	groupCount: function () {
		return this._groupFields ? this._groupFields.length : 0;
	},
	setExpandedAdornments: function (value) {
		if (value != this._expandedAdornments) {
			this._expandedAdornments = value;
			if (this.isGrouped()) {
				this._populateItems();
				this._fireRefresh();
			}
		}
	},
	setCollapsedAdornments: function (value) {
		if (value != this._collapsedAdornments) {
			this._collapsedAdornments = value;
			if (this.isGrouped()) {
				this._populateItems();
				this._fireRefresh();
			}
		}
	},
	setCreateFooterCallback: function (value) {
		if (value != this._createFooterCallback) {
			this._createFooterCallback = value;
			if (this.isGrouped()) {
				this._populateItems();
				this._fireRefresh();
			}
		}
	},
	setMergeMode: function (value) {
		if (value != this._mergeMode) {
			this._mergeMode = value;
			if (!value) {
				this._clearDisplayLevels();
			}
			this._populateItems();
			this._fireRefresh();
		}
	},
	setSummaryMode: function (value) {
		if (value != this._summaryMode) {
			this._summaryMode = value;
			this._populateItems();
			this._fireRefresh();
		}
	},
    canGrouping: function (fields) {
        return this._fireGrouping(fields);
    },
	groupBy: function (fields) {
		this.groupByMode(fields, this._mergeMode);
	},
	groupByMode: function (fields, mergeMode) {
		this._mergeMode = mergeMode;
		this._groupFields = fields ? fields.concat() : null;
		if (!mergeMode) {
			this._clearDisplayLevels();
		}
		this._populateItems();
		try {
			this._fireRefresh();
		} finally {
			this._fireGrouped();
		}
	},
	isGroupedField: function (field) {
		if (this._groupFields) {
			for (var i = this._groupFields.length; i--;) {
				if (this._groupFields[i] == field) {
					return true;
				}
			}
		}
		return false;
	},
	getGroupLevel: function (field) {
		if (this._groupFields && field >= 0) {
			for (var i = this._groupFields.length; i--;) {
				if (this._groupFields[i] == field) {
					return i + 1;
				}
			}
		}
		return 0;
	},
	getGroupedFields: function () {
		return this._groupFields ? this._groupFields.concat(): null;
	},
	expand: function (group, recursive, force, level) {
		if (group && (!group.isExpanded() || force)) {
			this._fireExpand(group);
			if (group.isExpanded()) {
				this._visibleItems.collapse(group, false);
			}
			if (this._visibleItems.expand(group, recursive, true, level)) {
				this._resetItemIndicies(group.index());
				try {
					this._fireRefresh();
				} finally {
					this._fireExpanded(group);
				}
			}
		}
	},
	// 상위 group이 접혀있는 경우 하위 그룹도 접혀있는 상태로 만들기 위해서 사용한다.
	// 반드시 상위 group이 접혀있어야 한다.
	$_collapseChild: function(group, recursive, force) {
		for (var i = 0, cnt = group._children.length; i < cnt ; i++) {
			var child = group._children[i];
			if (child instanceof GroupItemImpl) {
				child._expanded = false;
				this.$_collapseChild(child, recursive, force);
			}
		}
	},
	collapse: function (group, recursive, force) {
		if (!group || !group.isExpanded()) {
			if (group && recursive && force) {
				this.$_collapseChild(group, recursive, force);
			}
			return;
		}
		this._fireCollapse(group);
		if (this._visibleItems.collapse(group, recursive)) {
			this._resetItemIndicies(group.index());
			try {
				this._fireRefresh();
			} finally {
				this._fireCollapsed(group);
			}
		}
	},
	itemCount: function () {
		return this._grouped ? this._visibleItems.count() : this.source().itemCount();
	},
	getItem: function (index) {
		if (this.isGrouped()) {
			if (index >= 0 && index < this._visibleItems.count()) {
				return this._visibleItems.getItem(index);
			} else {
				return null;
			}
		} else {
			return this.source().getItem(index);
		}
	},
	getItems: function (index, count) {
		if (this.isGrouped()) {
			var i;
			var item;
			var items = [];
			var end = Math.min(this._visibleItems.count(), index + count - 1);
			for (i = index; i < end; i++) {
				item = this._visibleItems.getItem(i);
				items.push(item);
			}
			return items;
		} else {
			return this.source().getItems(index, count);
		}
	},
	getAllItems: function () {
		if (this.isGrouped()) {
			var items = new GroupedVisibleItems(this);
			items.expand(this._rootItem, true, false);
			return items.getItems();
		} else if (this.source()) {
			return this.source().getAllItems();
		} else {
			return null;
		}
	},
	getIndexOfRow: function (dataRow) {
		if (this.isGrouped()) {
			for (var i = 0, cnt = this._visibleItems.count(); i < cnt; i++) {
				if (this._visibleItems.getItem(i).dataRow() == dataRow) {
					return i;
				}
			}
			return -1;
		} else {
			return this.source().getIndexOfRow(dataRow);
		}
	},
	getItemOfRow: function (dataRow) {
		if (this.isGrouped()) {
			for (var i = 0, cnt = this._visibleItems.count(); i < cnt; i++) {
				var item = this._visibleItems.getItem(i);
				if (item.dataRow() == dataRow) {
					return item;
				}
			}
			return null;
		} else {
			return this.source().getItemOfRow(dataRow);
		}
	},
	setFixed: function (count, sorting, filtering) {
		this._super(count, sorting, filtering);
	},
	_initialize: function () {
		this._super();
		this._visibleItems = new GroupedVisibleItems(this);
		this._rootItem = new RootItem(this);
	},
	_clearItems: function () {
		this._visibleItems.clear();
		this._rootItem.clear();
		this._groupList = {};
	},
	// dataRowId의 경우 해당 row가 삭제되기 전까지는 값을 유지한다.
	_saveExpand: function(parent, map) {
		for (var i=0, cnt=parent._children.length; i< cnt ; i++) {
			var child = parent._children[i];
			if (child instanceof GroupItemImpl || child instanceof MergedGroupHeader) {
				var rowId = child.firstItem()._dataRowId; 
				var row = this.dataSource().getDataRowById(rowId);//child.firstItem().dataRow();
				var field = child._groupField;
				if (row >= 0 && field >= 0) {
					map[rowId] = {
						expanded:child._expanded,
						children:[]
					}
					this._saveExpand(child,map[rowId].children);
				}
			}
		};
	},
	_restoreExpand: function(parent, map) {
		for (var i=0, cnt=parent._children.length; i<cnt;i++) {
			var child = parent._children[i];
			if (child instanceof GroupItemImpl || child instanceof MergedGroupHeader) {
				var rowId = child.firstItem()._dataRowId; 
				var row = this.dataSource().getDataRowById(rowId);//child.firstItem().dataRow();
				var field = child._groupField;
				if (row >= 0 && field >= 0) {
					if (map[rowId]) {
						child._setExpanded(map[rowId].expanded);
						this._restoreExpand(child,map[rowId].children);	
					}
				}
			}
		}
	},
	_populateItems: function (saveExpand) {
		var expandMap = {};
		var srcCount = this.source().itemCount();
		saveExpand && srcCount > 0 && this._rootItem && this._saveExpand(this._rootItem, expandMap);
		this._clearItems();
		if (!this.source()) {
			return;
		}
		if (this._groupFields) {
			for (var i = this._groupFields.length - 1; i >= 0; i--) {
				if (this._groupFields[i] >= this.dataSource().fieldCount()) {
					this._groupFields.splice(i, 1);
				}
			}
			this._grouped = this._groupFields.length > 0;
		} else {
			this._grouped = false;
		}
		if (this._grouped && srcCount > 0) {
			this._buildGroupItems(srcCount);
			saveExpand && this._restoreExpand(this._rootItem, expandMap)
			this.$_resetVisibleItems();
		}
	},
	_resetItemIndicies: function (fromIndex) {
		if (this.isIndexing() && this.isGrouped()) {
			this._visibleItems._resetIndices(fromIndex);
		} else {
			this._super(fromIndex);
		}
	},
	$_checkChildren: function (p, checked, checkableOnly, groupCheckable) {
		var i, item;
		var cnt = p.count();
		for (i = 0; i < cnt; i++) {
			item = _cast(p.getItem(i), GridItem);
			if (item) {
				if (checkableOnly) {
					(groupCheckable || item instanceof GridRow || item instanceof TreeItem) && item.isCheckable() && item.$_setChecked(checked);
				} else {
					item.$_setChecked(checked);
				}
			}
			if (item instanceof  GroupItem) {
				this.$_checkChildren(item, checked, checkableOnly, groupCheckable);
			}
		}
	},
	_clearChecked: function () {
		if (this.isGrouped()) {
			this.$_checkChildren(this._rootItem, false, false);
		} else {
			this._super();
		}
		this._editItem && this._editItem.$_setChecked(false);
	},
	checkAll: function (checked, visibleOnly, checkableOnly, checkEvent, groupCheckable) {
		if (this._editItem) {
			if (checkableOnly) {
				this._editItem.isCheckable() && this._editItem.$_setChecked(checked);
			} else {
				this._editItem.$_setChecked(checked);
			}
		}
		if (visibleOnly || !this.isGrouped()) {
			this._super(checked, visibleOnly, checkableOnly, checkEvent);
		} else {
			var i;
			var cnt = this._visibleItems.fixedCount();
			if (cnt > 0) {
				if (checkableOnly) {
					for (i = cnt; i--;) {
						var item = this.getItem(i);
						item.isCheckable() && item.$_setChecked(checked);
					}
				} else {
					for (i = cnt; i--;) {
						this.getItem(i).$_setChecked(checked);
					}
				}
			}
			this.$_checkChildren(this._rootItem, checked, checkableOnly, groupCheckable);
			this._fireItemCheckChanged(null, checked);
			checkEvent ? this._fireItemAllChecked(checked):this._fireRefreshClient();	
		}
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		var ds = this.dataSource();
		if (!ds) {
			return -1;
		}
		var rows = this.itemCount();
		if (rows < 1) {
			return -1;
		}
		var flds = Math.min(fields.length, values.length);
		if (flds < 1) {
			return -1;
		}
		var i, item, found, c, v;
		var all = !options || options.allFields;
		var sensitive = options && options.caseSensitive;
		var partial = options && options.partialMatch;
		var dateConvert = null;
		var fieldTypes = [];
		var cb = options.dataComparer;
		var dataRow;
		cb = (cb && typeof cb === "function") ? cb : null;;

		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(rows - 1, endIndex);
		for (c = 0; c < flds; c++) {
			fieldTypes[c] = ds.getField(fields[c]).dataType();
		}
		for (i = startIndex; i <= endIndex; i++) {
			item = this.$_getItem(i);
			found = (dataRow = item.dataRow()) >= 0;
			if (found) {
				for (c = 0; c < flds; c++) {
					v = item.getData(fields[c]);
					switch (fieldTypes[c]) {
						case ValueType.DATETIME :
						case ValueType.DATE :
							if (values[c] instanceof Date) {
								found = cb ? cb(dataRow, fields[i], values[c], v) : $$_compareTextValue(values[c], v, sensitive, partial);
							} else {
								if (!dateConvert) {
									var fmt = /[.]/.test(values[c]) ? "yyyy.MM.dd" : /[/]/.test(values[c]) ? "yyyy/MM/dd" : /[-]/.test(values[c]) ? "yyyy-MM-dd" : "yyyyMMdd";
									dateConvert = new DatetimeConverter(fmt);
								}
								found = cb ? cb(dataRow, fields[i], values[c], v ? dateConvert.getText(v) : v) : $$_compareTextValue(values[c], v ? dateConvert.getText(v) : v, sensitive, partial);	
							}
							break;
						default :
							found = cb ? cb(dataRow, fields[i], values[c], v) : $$_compareTextValue(values[c], v, sensitive, partial);
							break;
					}
					if (found && !all) {
						return i;
					}
					if (!found && all) {
						break;
					}
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	},
	findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
		var ds = this.dataSource();
		if (!ds) {
			return null;
		}
		var rows = this.itemCount();
		if (rows < 1) {
			return null;
		}
		var i, item, found, c, v;
		var sensitive = options && options.caseSensitive;
		var partial = options && options.partialMatch;
		var fldCount = this.dataSource().fieldCount();
        var fldLen = fields.length;
        var dateConvert = null;
		var fieldTypes = [];
		var cb = options.dataComparer;
		var dataRow;
		cb = (cb && typeof cb === "function") ? cb : null;

		for (c = 0; c < fldCount; c++) {
			fieldTypes[c] = ds.getField(c).dataType();
		}
		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(rows - 1, endIndex);
		startFieldIndex = Math.max(0, startFieldIndex);
		if (startFieldIndex >= fields.length) {
			startIndex++;
			startFieldIndex = 0;
		}
		for (i = startIndex; i <= endIndex; i++) {
			item = this.$_getItem(i);
			dataRow = item.dataRow()
			if (dataRow >= 0) {
                c = (i > startIndex) ? 0 : startFieldIndex;
				for (; c < fldLen; c++) {
					var f = fields[c];
					if (f >= 0 && f < fldCount) {
						v = item.getData(f);
						switch (fieldTypes[f]) {
							case ValueType.DATETIME :
							case ValueType.DATE :
								if (value instanceof Date) {
									found = cb ? cb(dataRow, f, value, v) : $$_compareTextValue(value, v, sensitive, partial);
								} else {
									if (!dateConvert) {
										var fmt = /[.]/.test(value) ? "yyyy.MM.dd" : /[/]/.test(value) ? "yyyy/MM/dd" : /[-]/.test(value) ? "yyyy-MM-dd" : "yyyyMMdd";
										dateConvert = new DatetimeConverter(fmt);
									}
									found = cb ? cb(dataRow, f, value, v ? dateConvert.getText(v) : v) : $$_compareTextValue(value, v ? dateConvert.getText(v) : v, sensitive, partial);
								}
								break;
							default :
								found = cb ? cb(dataRow, f, value, v) : $$_compareTextValue(value, v, sensitive, partial);
								break;
						}
						if (found) {
							var returnObj = {
								itemIndex: i,
								fieldIndex: f,
								searchFieldIndex: c
							};
							return returnObj;
						}
					}
				}
			}
		}
		return null;
	},
	onItemProviderReset: function (itemProvider) {
		this._super(itemProvider);
	},
	onItemProviderRefresh: function (itemProvider) {
		if (this.isGrouped()){
			this._populateItems(true);
			this._fireRefresh();
		} else {
			// this._resetItemIndicies(0);
			this._super(itemProvider);
		}
	},
	onItemProviderItemInserted: function (itemProvider, item) {
		if (this.isGrouped()){
			this._populateItems(true);
			this._fireRefresh();
		} else {
			// this._resetItemIndicies(0);
			this._super(itemProvider, item);
		}
	},
	onItemProviderItemDeleted: function (itemProvider, item) {
		if (this.isGrouped()) {
			this._populateItems(true);
			this._fireRefresh();
		} else {
			// this._resetItemIndicies(0);
			this._super(itemProvider, item);
		}
	},
	onItemProviderItemUpdated: function (itemProvider, item) {
		if (this.isGrouped()) {
			this._populateItems(true);
			this._fireRefresh();
		} else {
			// this._resetItemIndicies(0);
			this._super(itemProvider, item);
		}
	},
	$_getItem: function (index) {
		return this._grouped ? this._visibleItems.getItem(index) : this.source().getItem(index);
	},
	$_resetVisibleItems: function () {
		this._visibleItems._clearAndInit(this.source(), this.fixedCount());
		if (this.source()) {
			if (this.source().itemCount() > this._visibleItems.fixedCount()) {
				this._visibleItems.expand(this._rootItem, false);
			}
		}
		this._resetItemIndicies(0);
	},
	_buildGroupItems: function (sourceCount) {
		if (sourceCount > this.fixedCount()) {
			var ginfo = new GroupInfo(this.fixedCount(), sourceCount - 1);
			this._buildGroups(ginfo, this.source(), this._groupFields);
			this._groupList = {};
			this._buildItems(this._rootItem, ginfo, this._groupFields);
			if (this.isMergeMode()) {
				this._clearDisplayLevels();
				this.$_resetDisplayLevels(this._rootItem);
			}
			ginfo = null;
		}
	},
	$_resetDisplayLevels: function (group) {
		var i;
		var g;
		var row;
		var cnt = group.count();
		for (i = 0; i < cnt; i++) {
			g = _cast(group.getItem(i), GroupItem);
			if (g) {
				row = _cast(g.firstItem, GridRow);
				if (row && row._displayLevel < 0) {
					row._displayLevel = g.level;
				}
				this.$_resetDisplayLevels(g);
			}
		}
	},
	_buildGroups: function (parent/*GroupInfo*/, source/*IItemProvider*/, groupFields) {
		if (groupFields.length <= parent.level) {
			return;
		}
		var startIndex = parent.startIndex;
		var endIndex = parent.endIndex;
		if (endIndex < startIndex) {
			return;
		}
		var level = parent.level + 1;
		var field = groupFields[parent.level];
        var fld = this.dataSource().getField(field);
		var ginfo = new GroupInfo(startIndex, startIndex);
		ginfo.level = level;
		parent.children.push(ginfo);
		var priorVal = source.getItem(startIndex).getData(field);
		for (var i = startIndex + 1; i <= endIndex; i++) {
			var val = source.getItem(i).getData(field);
            if (!fld.equalValues(val, priorVal)) {
				if (ginfo) {
					ginfo.endIndex = i - 1;
				}
				ginfo = new GroupInfo(i, i);
				ginfo.level = level;
				parent.children.push(ginfo);
			}
			priorVal = val;
		}
		if (ginfo) {
			ginfo.endIndex = endIndex;
		}
		var cnt = parent.children.length;
		for (i = 0; i < cnt; i++) {
			this._buildGroups(parent.children[i], source, groupFields);
		}
		ginfo = null;
	},
	_buildItems: function (parent/*IGroupItem*/, info, groupFields) {
		var mergeMode = this.isMergeMode();
		var cnt = info.children.length;
		if (cnt > 0) {
			var field = groupFields[info.level];
			for (var i = 0; i < cnt; i++) {
				var group = mergeMode ? new MergedGroupHeader(field) : new GroupItemImpl(field);
				this._groupList[group.id()] = group;
				group._setExpanded(this.isExpandWhenGrouping());
				parent.add(group);
				this._buildItems(group, info.children[i], groupFields);
			}
		} else {
			var rows = info.endIndex - info.startIndex + 1;
			var items = this.source().getItems(info.startIndex, rows);
			parent.addAll(items);
			this._incDescendents(parent, rows);
		}
		var level = parent.level();
		if (level > 0) { // excepts root
			var footer = mergeMode ? new MergedGroupFooter() : new GroupFooter();
			parent.add(footer);
		}
	},
	_setEditItem: function (item) {
		this._editItem = item;
	},
	_setDummyEditItem: function(item) {
		this._dummyEditItem = item;
	},
	_fireGrouping: function (fields) {
		return this.fireConfirmEvent(GroupedItemProvider.GROUPING, fields);
	},
	_fireGrouped: function (fields) {
		this.fireEvent(GroupedItemProvider.GROUPED);
	},
	_fireExpand: function (group) {
		this.fireEvent(GroupedItemProvider.EXPAND, group);
	},
	_fireExpanded: function (group) {
		this.fireEvent(GroupedItemProvider.EXPANDED, group);
	},
	_fireCollapse: function (group) {
		this.fireEvent(GroupedItemProvider.COLLAPSE, group);
	},
	_fireCollapsed: function (group) {
		this.fireEvent(GroupedItemProvider.COLLAPSED, group);
	}
});
GroupedItemProvider.GROUPING = "onGroupedItemProviderGrouping";
GroupedItemProvider.GROUPED = "onGroupedItemProviderGrouped";
GroupedItemProvider.EXPAND = "onGroupedItemProviderExpand";
GroupedItemProvider.EXPANDED = "onGroupedItemProviderExpanded";
GroupedItemProvider.COLLAPSE = "onGroupedItemProviderCollapse";
GroupedItemProvider.COLLAPSED = "onGroupedItemProviderCollapsed";
var DummyEditItem = defineClass("DummyEditItem", GridRow, {
	init: function (provider, target/*GridItem*/, index, dataRow, state/*ItemState*/) {
		this._super(dataRow);
		this._target = target;
		provider.attachItem(this);
		this._index = index;
		this._state = state;
		this._values = [];
		this._displayLevel = target ? target.displayLevel() : 0;
        this._started = false;
        this._checkDiff = false;
        this._strictDiff = false;
	},
    values: null,
    isResizable: function () {
    	return false;
    },
	values_: function () {
	},
	setValues: function (vals) {
	},
	beginEdit: function (checkDiff, strictDiff) {
	},
	setValue: function (fieldIndex, value) {
	},
	itemState: function () {
		return this._state;
	},
	getData: function (field) {
		return null;
	},
	setData: function (field, value) {
	},
	getRowData: function ()  {
		return null;
	},
	getRowObject: function () {
		return null;
	},
	_clearDisplayLevels: function () {
		var i;
		var cnt = this._rows.length;
		for (i = 0; i < cnt; i++) {
			this._rows[i]._displayLevel = -1;
		}
	}
});
var EditItem = defineClass("EditItem", GridRow, {
	init: function (provider, target/*GridItem*/, index, dataRow, state/*ItemState*/) {
		this._super(dataRow);
		this._target = target;
		provider.attachItem(this);
		this._index = index;
		this._state = state;
		this._values = [];
		this._displayLevel = target ? target.displayLevel() : 0;
        this._started = false;
        this._checkDiff = false;
        this._strictDiff = false;
        this._index2 = undefined; // DefaultItemProvider._pubItems에 들어갈 위치를 지정. rowGoruping인경우 위치를 판단하기 위해.
	},
    values: null,
    isResizable: function () {
    	return false;
    },
	values_: function () {
		return this._values.concat();
	},
	setValues: function (vals) {
		var i, f, fld, oldValue, newValue,
			provider = this.provider(),
			ds = this.dataSource(),
			cnt = ds.fieldCount();
		if (_isArray(vals)) {
			cnt = Math.min(cnt, vals.length);
			for (i = 0; i < cnt; i++) {
				fld = ds.getField(i);
				oldValue = this._values[i];
				newValue = fld.readValue(vals[i]);
				this._values[i] = newValue;
				if (this._started && !fld.equalValues(oldValue, newValue)) {
					provider._editItemCellUpdated(this, i, oldValue, newValue);
				}
			}
		} else if (vals) {
			for (i = 0; i < cnt; i++) {
				f = ds.getOrgFieldName(i);
				if (vals.hasOwnProperty(f)) {
					fld = ds.getField(i);
					oldValue = this._values[i];
					newValue = fld.readValue(vals[f]);
					this._values[i] = newValue;
					if (this._started && !fld.equalValues(oldValue, newValue)) {
						provider._editItemCellUpdated(this, i, oldValue, newValue);
					}
				}
			}
		}
	},
	beginEdit: function (checkDiff, strictDiff) {
		this._started = true;
		this._checkDiff = checkDiff;
        this._strictDiff = strictDiff;
	},
	setValue: function (fieldIndex, value) {
		var ds = this.dataSource();
		if (fieldIndex < 0 && fieldIndex >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + fieldIndex);
		}
		var fld = ds.getField(fieldIndex);
		var oldValue = this._values[fieldIndex];
		value = fld.readValue(value);
		this._values[fieldIndex] = value;
		if (this._started && !fld.equalValues(oldValue, value)) {
			this.provider()._editItemCellUpdated(this, fieldIndex, oldValue, value);
		}
	},
	itemState: function () {
		return this._state;
	},
	getData: function (field) {
		if (field < 0 && field >= this.dataSource().fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		return this._values[field];
	},
	setData: function (field, value) {
		var ds = this.dataSource();
		if (field < 0 && field >= ds.fieldCount) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		var fld = ds.getField(field); 
		var oldValue = this._values[field];
		value = fld.readValue(value);
        var can = !this._checkDiff;
        if (!can) {
            if (this._strictDiff) {
                can = !fld.equalValues(oldValue, value);
            } else {
                can = !fld.sameValues(oldValue, value);
            }
        }
		if (can) {
			this._values[field] = value;
			this.provider()._editItemCellUpdated(this, field, oldValue, value);
			this.provider()._editItemCellEdited(this, field);
		}
	},
	getRowData: function ()  {
		return this._values.concat();
	},
	getRowObject: function () {
		var ds = this.dataSource();
		if (ds) {
			var i, fld, 
				cnt = ds.fieldCount(),
				row = {};
			for (i = 0; i < cnt; i++) {
				fld = ds.getOrgFieldName(i);
				row[fld] = this._values[i];
			}
			return row;
		} else {
			return null;
		}
	},
	_clearDisplayLevels: function () {
		var i;
		var cnt = this._rows.length;
		for (i = 0; i < cnt; i++) {
			this._rows[i]._displayLevel = -1;
		}
	}
});
var /* @abstract */ EditableItemProvider = defineClass("EditableItemProvider", ProxyItemProvider, {
	init: function (source, indexing) {
		this._super(source, indexing);
		this._orgItem = null;
		this._editingItem = null;
		this._dummyEditItem = null;
		this._editingState = ItemState.NORMAL;
		this._insertMode = 0;
		this._modified = false;
		this._commiting = false;
		this._saveDs = null;
		if (source && (this._saveDs = source.dataSource())) {
			this._saveDs.registerClient(this);
		}
	},
	isDataEditing: function () {
		return this.isEditing();
	},
	cancelDataEditing: function () {
		if (this.isEditing()) {
			this._fireCancelRequest();
		}
	},
	commitDataEditing: function () {
		if (this.isEditing()) {
			this._fireCommitRequest();
		}
	},
	editingItem: function () {
		return (this._commiting || this.isEditing()) ? this._editingItem : null;
	},
	edit: function (item) {
        if (this.isEditing()) {
            return true;
        } else if (item) {
            try {
                this._beginUpdate(item);
				return true;
            } catch (err) {
                this.cancel();
                throw err;
            }
		}
		return false;
	},
	editData: function (item, field, value) {
		var ds;
		if (item && (ds = this.dataSource()) && field >= 0 && field < ds.fieldCount()) {
			if (!this.isEditing()) {
                try {
                    this._beginUpdate(item);
					return true;
                } catch (err) {
                    this.cancel();
                    throw err;
                }
			}
			this._editingItem.setData(field, value);
		}
		return false;
	},
	appendDummy: function() {
		if (!this.isEditing()) {
			try {
				this._beginAppendDummy();
			} catch (err) {
				this.cancelDummy();
				throw err;
			}
		}
	},
	append: function (defaultValues) {
		if (!this.isEditing()) {
            try {
                this._beginAppend(defaultValues);
				return true;
            } catch (err) {
                this.cancel();
                throw err;
            }
		}
		return false;
	},
	insert: function (item, defaultValues, shift, ctrl) {
		if (!this.isEditing()) {
            try {
                this._beginInsert(item, defaultValues, shift, ctrl);
				return true;
            } catch (err) {
                this.cancel();
                throw err;
            }
		}
		return false;
	},
	remove: function (item) {
	},
	removeAll: function (item) {
	},
	getRemovableRows: function (items) {
		return null;
	},
	removeRows: function (rows) {
	},
	cancelDummy: function() {
		if (this._dummyEditItem) {
			this._cancelDummyEdit();
		}
	},
	cancel: function () {
		if (this.isEditing()) {
			this._cancelEdit();
		}
	},
	commit: function () {
		if (this.isEditing()) {
			this._commiting = true;
			try {
                var ds = this.dataSource();
                if (ds) {
                    if (this._editingState == ItemState.UPDATING && this.isCheckDiff()) {
                        var i;
                        var values = this._editingItem.values();
                        var cnt = values.length;
                        var diff = false;
                        var strict = this.isStrictDiff();
                        for (i = 0; i < cnt; i++) {
                            if (strict) {
                                if (!ds.getField(i).equalValues(this._orgItem.getData(i), values[i])) {
                                    diff = true;
                                    break;
                                }
                            } else {
                                if (!ds.getField(i).sameValues(this._orgItem.getData(i), values[i])) {
                                    diff = true;
                                    break;
                                }
                            }
                        }
                        if (!diff) {
                            this._cancelEdit();
                            return true;
                        }
                    }
                    return this._commitEdit();
                }
			} finally {
				this._commiting = false;
			}
		}
		return true;
	},
	isEditing: function (item) {
		return ItemState.isEditing(this._editingState) && (!item || item === this._editingItem);
	},
	isEdited: function (item) {
		return ItemState.isEditing(this._editingState) && (!item || item === this._editingItem) && this._modified;
	},
	checkDiff: false,
	checkCellDiff: false,
    strictDiff: false,
	isUpdating: function () {
		return this._editingState == ItemState.UPDATING;
	},
	isInserting: function () {
		return this._editingState == ItemState.INSERTING;
	},
	isAppending: function () {
		return this._editingState == ItemState.APPENDING;
	},/* 중복 코드
	isDataEditing: function () {
		return this.isEditing();
	},
	cancelDataEditing: function () {
	},
	commitDataEditing: function () {
	},*/
    setDiffs: function (check, cell, strict) {
        this._checkDiff = check;
        this._checkCellDiff = cell;
        this._strictDiff = strict;
    },
	itemCount: function () {
		return this.source().itemCount();
	},
	onItemProviderReset: function (itemProvider) {
		this._super(itemProvider);
		var ds = this.dataSource();
		if (ds != this._saveDs) {
			this._saveDs && this._saveDs.unregisterClient(this);
			this._saveDs = ds;
			this._saveDs && this._saveDs.registerClient(this);
		}
	},
	onItemProviderRefresh: function (itemProvider) {
		this._super(itemProvider);
	},
	onItemProviderRefreshClient: function (itemProvider) {
		this._super(itemProvider);
	},
	onItemProviderItemInserted: function (itemProvider, item) {
		this._super(itemProvider, item);
	},
	onItemProviderItemRemoved: function (itemProvider, item) {
		this._super(itemProvider, item);
	},
	onItemProviderItemUpdated: function (itemProvider, item) {
		this._super(itemProvider, item);
	},
	_checkEditing: function () {
		if (!this.isEditing()) {
			throw new Error("itemProvider is not editing");
		}
	},
	_checkNotEditing: function () {
		if (this.isEditing()) {
			throw new Error("itemProvider is already editing");
		}
	},
	_beginUpdate: function (item) {
		if (!item) {
			throw new Error("item is null");
		}
		this._checkNotEditing();
		this._modified = false;
		this._editingItem = this._doBeginUpdate(item);
		this._editingItem.beginEdit(this.isCheckCellDiff(), this.isStrictDiff());
		if (this._editingItem) {
			this._orgItem = item;
			this._editingState = ItemState.UPDATING;
			this._fireUpdateStarted(this._editingItem);
		}
	},
	_doBeginUpdate: function (item) {
		return null;
	},
	_beginAppendDummy: function () {
		this._dummyEditItem = this._doBeginAppendDummy();
	},
	_beginAppend: function (defaultValues) {
		this._checkNotEditing();
		this._modified = false;
		this._editingItem = this._doBeginAppend(defaultValues);
		this._editingItem.beginEdit(this.isCheckCellDiff(), this.isStrictDiff());
		if (this._editingItem) {
			this._editingState = ItemState.APPENDING;
			this._fireAppendStarted(this._editingItem);
		}
	},
	_doBeginAppend: function (defaultValues) {
		return null;
	},
	_beginInsert: function (item, defaultValues, shift, ctrl) {
		if (!item) {
			throw "item is null";
		}
		this._checkNotEditing();
		this._modified = false;
		this._editingItem = this._doBeginInsert(item, defaultValues, shift, ctrl);
		this._editingItem.beginEdit(this.isCheckCellDiff(), this.isStrictDiff());
		if (this._editingItem) {
			this._editingState = ItemState.INSERTING;
			this._resetItemIndicies(0);//this._editingItem.index());
			this._fireInsertStarted(this._editingItem);
		}
	},
	_doBeginInsert: function (item, defaultValues) {
		return null;
	},
	_cancelDummyEdit: function() {
		this._dummyEditItem = null;
		this._doCancelDummyEdit();
	},
	_cancelEdit: function () {
		this._checkEditing();
		var saveState = this._editingState;
		try {
			this._editingState = ItemState.NORMAL;
			this._doCancelEdit(saveState, this._orgItem);
		} catch (err) {
			this._editingState = saveState;
			throw err;
		}
		this._modified = false;
		this._fireCanceled();

	},
	_doCancelDummyEdit: function() {
	},
	_doCancelEdit: function (state, orgItem) {
		if (state == ItemState.INSERTING) {
			this._resetItemIndicies(0);
		}
	},
	_updateEditingRow: function (orgItem) {
		return false;
	},
	_insertEditingRow: function (appending) {
		return false;
	},
	_commitEdit: function () {
		this._checkEditing();
		var ds = this.dataSource();
		if (!ds) {
			throw new Error("data provier is null");
		}
		try {
			this._fireItemCommitting(this._editingItem);
		} catch (err) {
			alert(err.message);
		}
		var saveState = this._editingState;
		var completed = false;
		if (this.isUpdating()) {
			try {
				this._editingState = ItemState.NORMAL;
				completed = this._doCompleteUpdate(this._orgItem);
			} catch (err) {
				this._editingState = saveState;
				throw err;
			}
		} else {
			try {
				this._editingState = ItemState.NORMAL;
				completed = this._doCompleteInsert(saveState == ItemState.APPENDING);
			} catch (err) {
				this._editingState = saveState;
				throw err;
			}
		}
		if (completed) {
			this._modified = false;
			this._doCommitEdit(saveState, this._orgItem);
			this._fireCommitted(this._editingItem);
		} else {
			this._editingState = saveState;
		}
		return completed;
	},
	_doCommitEdit: function (state, orgItem) {
		return false;
	},
	_editItemCellEdited: function (item, field) {
		if (item && this.isEditing(item)) {
			this._modified = true;
			this._fireItemCellEdited(item, field);
		}
	},
	_editItemCellUpdated: function (item, field, oldValue, newValue) {
		if (this.isEditing(item)) {
			this._modified = true;
			this._fireItemCellUpdated(item, field, oldValue, newValue);
		}
	},
	_fireUpdateStarted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.UPDATE_STARTED, item);
		} 
	},
	_fireAppendStarted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.APPEND_STARTED, item);
		} 
	},
	_fireInsertStarted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.INSERT_STARTED, item);
		} 
	},
	_fireItemCellEdited: function (item, field) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.CELL_EDITED, item, field);
		} 
	},
	_fireItemCellUpdated: function (item, field, oldValue, newValue) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.CELL_UPDATED, item, field, oldValue, newValue);
		} 
	},
	_fireItemCommitting: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.COMMITTING, item);
		} 
	},
	_fireCommitted: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.COMMITTED, item);
		} 
	},
	_fireCanceled: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.CANCELED);
		} 
	},
	_fireCommitRequest: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.COMMIT_REQUEST);
		}
	},
	_fireCancelRequest: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(EditableItemProvider.CANCEL_REQUEST);
		}
	}
});
EditableItemProvider.UPDATE_STARTED = "onItemEditUpdateStarted";
EditableItemProvider.APPEND_STARTED = "onItemEditAppendStarted";
EditableItemProvider.INSERT_STARTED = "onItemEditInsertStarted";
EditableItemProvider.CELL_EDITED = "onItemEditCellEdited";
EditableItemProvider.CELL_UPDATED = "onItemEditCellUpdated";
EditableItemProvider.COMMITTING = "onItemEditCommitting";
EditableItemProvider.COMMITTED = "onItemEditCommitted";
EditableItemProvider.CANCELED = "onItemEditCanceled";
EditableItemProvider.COMMIT_REQUEST = "onItemEditCommitRequest";
EditableItemProvider.CANCEL_REQUEST = "onItemEditCancelRequest";
var EditableItemProviderImpl = defineClass("EditableItemProviderImpl", EditableItemProvider, {
	init: function (source, indexing) {
		this._super(source, indexing);
		this._insertRow = -1;
	},
	itemCount: function () {
		var cnt = this.source().itemCount();
		cnt += (this.isInserting() || this.isAppending()) ? 1 : 0;
		cnt += (this._dummyEditItem) ? 1 : 0;
		return cnt;
	},
	getItem: function (index) {
		var ret;
		if (this.isEditing() && this._editingItem.index() == index) {
			return this._editingItem;
		} else if (this.isInserting()) {
			if (index > this._editingItem.index()) {
				ret = this.source().getItem(index - 1);
			} else {
				ret = this.source().getItem(index);
			}
		} else if (index < this.source().itemCount()) {
			ret = this.source().getItem(index);
		}
		if (ret) {
			return ret;
		} else if (this._dummyEditItem && index == this.itemCount() - 1) {
			return this._dummyEditItem;
		}
		return null;
	},
	_doBeginUpdate: function (item) {
		this._editingItem = this._createEditItem(item, ItemState.UPDATING, null);
		return this._editingItem;
	},
	_doBeginAppendDummy: function () {
		this._dummyEditItem = this._dummyEditItem ? this._dummyEditItem : this._createDummyEditItem();
		this._dummyEditItem._index = this.itemCount()-1;
		return this._dummyEditItem;
	},
	_doBeginAppend: function (defaultValues) {
		this._editingItem = this._createEditItem(null, ItemState.APPENDING, defaultValues);
		return this._editingItem;
	},
	_doBeginInsert: function (item, defaultValues, shift, ctrl) {
		this._editingItem = this._createEditItem(item, ItemState.INSERTING, defaultValues, shift, ctrl);
		return this._editingItem;
	},
	_doCancelEdit: function (state, orgItem) {
		this._super(state, orgItem);
	},
	_doCommitEdit: function (state, orgItem) {
		this._super(state, orgItem);
	},
	_doCompleteUpdate: function (orgItem) {
		var ds = this.dataSource();
		if (ds) {
			var editItem = this._editingItem;
			this._copyExtents(editItem, orgItem);
			return ds.updateRow(editItem.dataRow(), editItem.values());
		}
		return false;
	},
	_doCompleteInsert: function (appending) {
		var rslt = false;
		var ds = this.dataSource();
		if (ds) {
			var editItem = this._editingItem;
			var r = appending ? ds.rowCount() : Math.max(0, this._insertRow);
			var values = editItem.values();
			rslt = ds.insertRow(r, values, editItem._index2);
			if (rslt) {
				var item = this.getItemOfRow(r);
				this._copyExtents(editItem, item);
			}
		}
		return rslt;
	},
	remove: function (item) {
		var ds = this.dataSource();
		if (item && !this.isEditing(item) && ds) {
			var r = item.dataRow();
			if (r >= 0) {
				ds.removeRow(r);
			}
		}
	},
	removeAll: function (items) {
        if (!items || items.length == 0) {
            return;
        }
		var ds = this.dataSource();
		if (!ds) {
			return;
		}
		var row;
		var cnt = items.length;
		if (cnt > 1) {
			var rows = [];
			for (var i = 0; i < cnt; i++) {
				row = this.getItem(items[i]).dataRow();
				if (row >= 0) {
					rows.push(row);
				}
			}
			if (rows.length > 1) {
				ds.removeRows(rows);
			} else if (rows.length == 1) {
				ds.removeRow(rows[0]);
			}
		} else if (cnt == 1) {
			row = this.getItem(items[0]).dataRow();
			row >= 0 && ds.removeRow();
		}
	},
    revert: function (item) {
        if (!(item instanceof GridItem)) {
            item = this.getItem(item);
        }
        if (item) {
            var ds = this.dataSource();
            if (ds) {
                var r = item.dataRow();
                var st = ds.getRowState(r);
                if (st == RowState.DELETED) {
                    ds.setRowState(r, RowState.NONE);
                } else if (st == RowState.CREATE_AND_DELETED) {
                    ds.setRowState(r, RowState.CREATED);
                }
            }
        }
    },
    revertAll: function (items) {
        if (!items || items.length == 0) {
            return;
        }
        var ds = this.dataSource();
        if (!ds) {
            return;
        }
        for (var i = items.length; i--;) {
            var item = this.getItem(items[i]);
            if (item) {
                var r = item.dataRow();
                var st = ds.getRowState(r);
                if (st == RowState.DELETED) {
                    ds.setRowState(r, RowState.NONE);
                } else if (st == RowState.CREATE_AND_DELETED) {
                    ds.setRowState(r, RowState.CREATED);
                }
            }
        }
    },
	getRemovableRows: function (items) {
		if (!items || items.length == 0) {
			return null;
		}
		var rows = [];
		for (var i = 0, cnt = items.length; i < cnt; i++) {
			var row = this.getItem(items[i]).dataRow();
			row >= 0 &&	rows.push(row);
		}
		return rows;
	},
	removeRows: function (rows) {
		if (rows) {
			if (rows.length > 1) {
				this.dataSource().removeRows(rows);
			} else {
				this.dataSource().removeRow(rows[0]);
			}
		}
	},
	_createDummyEditItem: function () {
		//
		var item = null;
		item = new DummyEditItem(this, null, this.itemCount(), -1/*target.dataRow*/, ItemState.DUMMY);
		return item;
	},
	_createEditItem: function (target, state, defaultValues, shift, ctrl) {
		var ds = this.dataSource();
		if (!ds) {
			return null;
		}
		var i;
		var item = null;
		var flds = ds.fieldCount();
		switch (state) {
		case ItemState.UPDATING:
			item = new EditItem(this, target, target.index(), target.dataRow(), state);
			for (i = 0; i < flds; i++) {
				item.setValue(i, target.getData(i));
			}
			this._copyExtents(target, item);
			break;
		case ItemState.INSERTING:
		case ItemState.APPENDING:
			var provider = this._itemProvider;
			var targetIndex = state == ItemState.INSERTING && target ? ( shift ? target.index()+1 : target.index()) : this.itemCount();
			item = new EditItem(this, target, targetIndex/*target.index()*/, -1/*target.dataRow*/, state);
			if (state == ItemState.INSERTING) {
				var row = target.dataRow();
				var nextItem = target;
				if (row <= -1) {
					var visibleItems = this._source._visibleItems;
					while (nextItem = visibleItems.getNext(nextItem)) {
						if (nextItem instanceof GridRow) {
							break;
						}
					}
					this._insertRow = nextItem ? nextItem.dataRow() : this.dataSource().rowCount();
				} else {
					this._insertRow = shift ? Math.min(this.dataSource().rowCount(), row+1) : row;
				}
				if (target instanceof GridRow && shift && provider) {
					var index2 = provider._pubItems.indexOf(nextItem);
					index2++ >= 0 && index2 <= provider._pubItems.length && (item._index2 = index2);
				}
			}
			if (defaultValues) {
				for (i = 0; i < flds; i++) {
					if (defaultValues.length > i) {
						item.setValue(i, defaultValues[i]);
					}
				}
			}
			break;
		}
		return item;
	}
});
var GridItemProvider = defineClass("GridItemProvider", EditableItemProviderImpl, {
	init: function (indexing) {
		this._super(null, indexing);
		this._updateLock = false;
		this._groupSorting = true;
		this._groupSortDirection = SortDirection.ASCENDING;
        this._groupSortCase = SortCase.SENSITIVE;
		this._itemProvider = new DefaultItemProvider(false);
		this._itemProvider.addListener(this);
		this._groupedProvider = new GroupedItemProvider(this._itemProvider, false);
		this.setSource(this._groupedProvider);
		this._summarizer = new DefaultSummarizer(this._itemProvider);
	},
	destroy: function() {
		this._destroying = true;
		this.setSource(null);
		this._itemProvider.removeListener(this);
		this._super();
	},
	isHideDeleted: function () {
		return this._itemProvider.isHideDeleted();
	},
	setHideDeleted: function (value) {
		this._itemProvider.setHideDeleted(value);
	},
	setFilterOr: function(value) {
		this._itemProvider.setFilterOr(value);
	},
	isFilterOr: function(value) {
		this._itemProvider.isFilterOr();
	},
	setSummaryMode: function (value) {
		this._itemProvider.setSummaryMode(value);
	},
	setRowGroupSummaryMode: function (value) {
		this._groupedProvider.setSummaryMode(value);
	},
	setMergeMode: function (value) {
		this._groupedProvider.setMergeMode(value);
	},
	sortMode: function () {
		return this._itemProvider.sortMode();
	},
    setSortMode: function (value) {
        this._itemProvider.setSortMode(value);
    },
    filterMode: function (value) {
    	return this._itemProvider.filterMode();
    },
    setFilterMode: function (value) {
        this._itemProvider.setFilterMode(value);
    },
    beginUpdate: function () {
    	this._updateLock = true;
    	this._itemProvider.beginUpdate();
    },
    endUpdate: function (force) {
    	this._itemProvider.endUpdate();
    	this._updateLock = false;
        this._resetItemIndicies(0);
    },
	isGrouped: function () {
		return this._groupedProvider.isGrouped();
	},
	groupList: function() {
		return this._groupedProvider.groupList();
	},
	groupLevels: function () {
		return this._groupedProvider.groupCount();
	},
	groupByFields: function () {
		return this._groupedProvider.getGroupedFields();
	},
	summarizer: function () {
		return this._summarizer;
	},
    canGrouping: function (fields) {
        return this._fireGrouping(fields);
    },
	getFieldDomain: function (field) {
		this._itemProvider.getFieldDomain(field);
	},
	isFiltered: function (field) {
		return field != null ? this._itemProvider.hasFilter(field) : this._itemProvider.hasFilters();
	},
	addFilter: function (field, refFiter) {
		this._itemProvider.addFilter(field, refFiter);
	}, 
	removeFilter: function (field, filter) {
		this._itemProvider.removeFilter(filter);
	},
	clearFilters: function (field) {
		this._itemProvider.clearFilters(field);
	},
	clearAllFilters: function () {
		this._itemProvider.clearAllFilters();
	},
	beginFiltering: function () {
		this._itemProvider.beginFilter();
	},
	endFiltering: function (filterCollection, filter) {
		this._itemProvider.endFilter(true, filterCollection, filter);
	},
	setHideDeletedRows: function (value) {
		this._itemProvider.setHideDeleted(value);
	},
	orderBy: function (fields, directions, cases) {
		if (this._groupedProvider.isGrouped() && this._groupSorting) {
            var len = directions ? directions.length : 0;
            var clen = cases ? cases.length : 0;
			var groupFields = this._groupedProvider.getGroupedFields();
			var groupDirs = this._itemProvider.getSortDirections();
            var groupCases = this._itemProvider.getSortCases();
			var list = [];
            var i, cnt, fld, g, dir, c;
			for (i = 0, cnt = groupFields.length; i < cnt; i++) {
				list.push(groupFields[i]);
			}
			for (i = 0, cnt = fields.length; i < cnt; i++) {
				fld = fields[i];
				g = list.indexOf(fld);
				if (len > i) {
					dir = directions[i];
				} else if (len > 0) { // 바로 앞의 것을 따라간다.
					dir = directions[len - 1];
				} else {
					dir = SortDirection.ASCENDING;
				}
                if (clen > i) {
                    c = cases[i];
                } else if (clen > 0) {
                    c = cases[clen - 1];
                } else {
                    c = SortCase.SENSITIVE;
                }
				if (g < 0) {
					list.push(fld);
					groupDirs[list.length - 1] = dir;
                    groupCases[list.length - 1] = c;
				} else {
					groupDirs[g] = dir;
                    groupCases[g] = c;
				}
			}
			groupFields = list;
			this._itemProvider.orderBy(groupFields, groupDirs, groupCases);
		} else {
			this._itemProvider.orderBy(fields, directions, cases);
		}
	},
	getSortFields: function () {
		return this._itemProvider.getSortFields();
	},
	getSortDirections: function () {
		return this._itemProvider.getSortDirections();
	},
    getSortCases: function () {
        return this._itemProvider.getSortCases();
    },
    getLabelComparer: function() {
        return this._itemProvider.getLabelComparer();
    },
    setLabelComparer: function(comparer) {
    	this._itemProvider.setLabelComparer(comparer)
    },
	groupBy: function (fields, sorting, direction, textCase) {
		if ((!fields || fields.length < 1) && !this._groupedProvider.isGrouped()) {
			return;
		}
        if (!this._groupedProvider.canGrouping(fields)) {
            return;
        }
		this._groupSorting = sorting;
		this._groupSortDirection = direction;
        this._groupSortCase = textCase || SortCase.SENSITIVE;
		if (sorting) {// && fields && fields.length > 0) {
			this._itemProvider.orderBy(fields, [direction], [textCase], false);
		}
		this._groupedProvider.groupBy(fields);
	},
	groupByMode: function (fields, mergeMode) {
		if (this._groupSorting) {// && fields && fields.length > 0) {
			this._itemProvider.orderBy(fields, [this._groupSortDirection], [this._groupSortCase], false);
		}
        if (!this._groupedProvider.canGrouping(fields)) {
            return;
        }
		this._groupedProvider.groupByMode(fields, mergeMode);
	},
	addGroupBy: function (index, field) {
		var fields;
		var dirs = [this._groupSortDirection];
		if (this._groupedProvider.groupCount() < 1) {
			fields = [field];
		} else {
			fields = this._groupedProvider.getGroupedFields();
			fields.splice(index, 0, field);
		}
        if (!this._groupedProvider.canGrouping(fields)) {
            return;
        }
		if (this._groupSorting) {
			this._itemProvider.orderBy(fields, dirs, null, false);
		}
		this._groupedProvider.groupBy(fields);
	},
	removeGroupBy: function (field, includeLower) {
		if (!this._groupedProvider.isGrouped()) {
			return;
		}
		var idx = -1;
		var fields = this._groupedProvider.getGroupedFields();
		var cnt = fields.length;
        var i, rcnt = 0;
		for (i = cnt - 1; i >= 0; i--) {
			rcnt++;
			if (fields[i] == field) {
				idx = i;
				break;
			}
		}
		if (idx >= 0) {
			fields.splice(idx, includeLower? rcnt : 1);
            if (!this._groupedProvider.canGrouping(fields)) {
                return;
            }
            if (this._groupSorting) {
				this._itemProvider.orderBy(fields, [this._groupSortDirection], null, false);
			}
			this._groupedProvider.groupBy(fields);
		} else {
            if (!this._groupedProvider.canGrouping(null)) {
                return;
            }
            if (this._groupSorting) {
				this._itemProvider.orderBy(null, null, null, false);
			}
		}
	},
	isMergedRowGrouped: function () {
		return this._groupedProvider.isGrouped() && this._groupedProvider.isMergeMode();
	},
	getGroupLevels: function () {
		return this._groupedProvider.groupCount();
	},
	isGroupedField: function (field) {
		return this._groupedProvider.isGroupedField(field);
	},
	getGroupLevel: function (field) {
		return this._groupedProvider.getGroupLevel(field);
	},
	getGroupByFieldCount: function () {
		return this._groupedProvider.groupCount();
	},
	setExpandWhenGrouping: function (value) {
		this._groupedProvider.setExpandWhenGrouping(value);
	},
	setGroupedStyle: function (expandedAdornments, collapsedAdornments, createFooterCallback, handler) {
		this._groupedProvider._handler = handler;
		this._groupedProvider.setExpandedAdornments(expandedAdornments);
		this._groupedProvider.setCollapsedAdornments(collapsedAdornments);
		this._groupedProvider.setCreateFooterCallback(createFooterCallback);
	},
	setGroupSorting: function (value) {
		this._groupSorting = value;
		this._groupedProvider._groupSorting = value;
	},
	expand: function (group, recursive, force, level) {
		this._groupedProvider.expand(group, recursive, force, level);
	},
	collapse: function (group, recursive, force) {
		this._groupedProvider.collapse(group, recursive, force);
	},
	setPaging: function (paging, pageSize, pageCount, pageSource) {
		this._itemProvider.setPaging(paging, pageSize, pageCount, pageSource);
	},
	page: function () {
		return this._itemProvider.page();
	},
	setPage: function (value, startRow) {
		this._itemProvider.setPage(value, startRow);
	},
	pageCount: function () {
		return this._itemProvider.pageCount();
	},
	setPageCount: function (value) {
		this._itemProvider.setPageCount(value);
	},
	setPageSorting: function (value) {
		this._itemProvider.setPageSorting(value);
	},
	getDisplayItemIndex: function (item) {
		return this._itemProvider.isPaging() ? item.index() + this._itemProvider.pageStartIndex() : item.index(); 
	},
	getCheckedRows: function (allRows) {
		return this._itemProvider.getCheckedRows(allRows);
	},
	setCheckableExpression: function (expr) {
		this._itemProvider.setCheckableExpression(expr);
	},
	resetCheckables: function () {
		this._itemProvider.resetCheckables();
	},
	applyCheckables: function () {
		this._itemProvider.applyCheckables();
	},
	dataSource: function () {
		return this._itemProvider.dataSource();
	},
	setDataSource: function (value) {
		this._itemProvider.setDataSource(value);
	},
	getAllItems: function () {
		return this._groupedProvider.getAllItems();
	},
	getPagingAllItems: function() {
		var provider = this._itemProvider;
		return provider.isSorted() ? provider._sortedItems.slice() : provider._items.slice();
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		return this._groupedProvider.findItem(fields, values, options, startIndex, endIndex);
	},
	findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
		return this._groupedProvider.findCell(fields, value, options, startIndex, endIndex, startFieldIndex);
	},
	checkItems: function (items, checked, checkEvent) {
		this._groupedProvider.checkItems(items, checked, checkEvent);
	},
	checkItem: function (item, checked, exclusive, checkEvent) {
		this._groupedProvider.checkItem(item, checked, exclusive, checkEvent);
	},
	checkAll: function (checked, visibleOnly, checkableOnly, checkEvent, groupCheckable) {
		this._groupedProvider.checkAll(checked, visibleOnly, checkableOnly, checkEvent, groupCheckable);
	},
	hasCellStyle: function () {
		return this._itemProvider.hasCellStyle();
	},
	setCellStyle: function (row, field, style) {
		this._itemProvider.setCellStyle(row, field, style);
	},
	setCellStyles: function (provider, rows, fieldMap) {
		this._itemProvider.setCellStyles(provider, rows, fieldMap);
	},
	clearCellStyles: function () {
		this._itemProvider.clearCellStyles();
	},
	removeCellStyle: function (style) {
		this._itemProvider.removeCellStyle(style);
	},
	getCellStyle: function (dataRow, field) {
		return this._itemProvider.getCellStyle(dataRow, field);
	},
	checkCellStyle: function (dataRow, field) {
		return this._itemProvider.checkCellStyle(dataRow, field);
	},
	setCellEditable: function (dataRow, column, value) {
		this._itemProvider.setCellEditable(dataRow, column, value);
	},
	setCellReadOnly: function (dataRow, column, value) {
		this._itemProvider.setCellReadOnly(dataRow, column, value);
	},
	getCellEditable: function (dataRow, column, value) {
		return this._itemProvider.getCellEditable(dataRow, column, value);
	},
	getCellReadOnly: function (dataRow, column, value) {
		return this._itemProvider.getCellReadOnly(dataRow, column, value);
	},
	setCellCursor: function (dataRow, column, value) {
		this._itemProvider.setCellCursor(dataRow, column, value);
	},
	getCellCursor: function (dataRow, column) {
		return this._itemProvider.getCellCursor(dataRow, column);
	},
	setCellEditor: function (dataRow, column, value) {
		this._itemProvider.setCellEditor(dataRow, column, value);
	},
	getCellEditor: function (dataRow, column) {
		return this._itemProvider.getCellEditor(dataRow, column);
	},
	clearEditableMap:function() {
		return this._itemProvider.clearEditableMap();
	},
	getItemOfRow: function (dataRow, force) {
		return this._itemProvider.getItemOfRow(dataRow, force);
	},
	_doBeginUpdate: function (item) {
		var editItem = this._super(item);
		this._groupedProvider._setEditItem(editItem);
		return editItem;
	},
	_doBeginAppendDummy: function() {
		var dummyEditItem = this._super();
		this._groupedProvider._setDummyEditItem(dummyEditItem);
		return dummyEditItem;
	},
	_doBeginAppend: function (defaultValues) {
		var editItem = this._super(defaultValues);
		this._groupedProvider._setEditItem(editItem);
		return editItem;
	},
	_doBeginInsert: function (item, defaultValues, shift, ctrl) {
		var editItem = this._super(item, defaultValues, shift, ctrl);
		this._groupedProvider._setEditItem(editItem);
		return editItem;
	},
	_doCancelDummyEdit:function() {
		this._super();
		this._groupedProvider._setDummyEditItem(null);
	},
	_doCancelEdit: function (state, orgItem) {
		this._super(state, orgItem);
		this._groupedProvider._setEditItem(null);
	},
	_doCommitEdit: function (state, orgItem) {
		this._super(state, orgItem);
		this._groupedProvider._setEditItem(null);
	},
	onGroupedItemProviderGrouping: function (provider, fields) {
		return this.fireConfirmEvent(GroupedItemProvider.GROUPING, fields);
	},
	onGroupedItemProviderGrouped: function (provider) {
		this.fireEvent(GroupedItemProvider.GROUPED);
	},
	onGroupedItemProviderExpand: function (provider, group) {
		this.fireEvent(GroupedItemProvider.EXPAND, group);
	},
	onGroupedItemProviderExpanded: function (provider, group) {
		this.fireEvent(GroupedItemProvider.EXPANDED, group);
	},
	onGroupedItemProviderCollapse: function (provider, group) {
		this.fireEvent(GroupedItemProvider.COLLAPSE, group);
	},
	onGroupedItemProviderCollapsed: function (provider, group) {
		this.fireEvent(GroupedItemProvider.COLLAPSED, group);
	},
	onItemProviderFilterAdded: function (provider, field, criteria) {
		this._fireFilterAdded(field, criteria);
	},
	onItemProviderFilterRemoved: function (provider, field, filter) {
		this._fireFilterRemoved(field, filter);
	},
	onItemProviderFilterCleared: function (provider, field) {
		this._fireFilterCleared(field);
	},
	onItemProviderFilterAllCleared: function (provider) {
		this._fireFilterAllCleared();
	},
	onItemProviderFiltered: function (provider, filterCollection, filter) {
		this._fireFiltered(filterCollection, filter);
	},
	onItemProviderSort: function (provider, fields, directions) {
		this._fireSort(fields, directions);
	},
	onItemProviderSorted: function (provider) {
		this._fireSorted();
	}
});
var $$_FONT_REG = new RegExp("\\s*,\\s*");
var VisualStyles = defineClass("VisualStyles", EventAware, {
	init: function (owner, name, source, fireEvents) {
		this._super(true);
		this._owner = owner;
		this._name = name;
		this._parent = null;
		this._sysDefault = null;
		this._values = [];
		this._updateLock = 0;
		this._font = null;
		if (fireEvents !== UNDEFINED) {
			this._fireEvents = fireEvents;
		}
		source && this.extend(source);
	},
	destroy: function() {
		return false;
	},
	assign: function(source) {
		this._super(source);
		var attrs = VisualStyles.STYLE_NAMES;
		var attrNames = Object.keys(attrs);
		for(var i = 0, cnt = attrNames.length; i < cnt; i++) {
			var attrname = "_"+attrNames[i];
			this[attrname] = source[attrname];
		}
		this._values = source._values.slice();
	},
	copy: function(source) {
		var attrs = VisualStyles.STYLE_NAMES;
		var attrNames = Object.keys(attrs);
		for(var i = 0, cnt = attrNames.length; i < cnt; i++) {
			var attrname = "_"+attrNames[i];
			if (!this[attrname] && source[attrname]) {
				this[attrname] = source[attrname]
				this._values[attrs[attrNames[i]]] = true;
			}
		}
	},
	noProxy: function () {},
	name: null,
	parent: null,
	sysDefault: null,
	fireEvents: true,
	setParent: function (value, fireEvent) {
		if (value !== this._parent) {
			this._parent = value;
			if ((fireEvent === UNDEFINED || fireEvent) && this._fireEvents) {
				this.changed(VisualStyles.STYLE_ALL);
			}
		}
        return this;
	},
	setSysDefault: function (value, fireEvent) {
		if (value !== this._sysDefault) {
			this._sysDefault = value;
			if ((fireEvent === UNDEFINED || fireEvent) && this._fireEvents) {
				this.changed(VisualStyles.STYLE_ALL);
			}
		}
	},
	setParentAndDefault: function (parent, sysDefault) {
		this._parent = parent,
		this._sysDefault = sysDefault;
	},
	background: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.BACKGROUND] || value !== this._background) {
					this._background = value;
					this._values[VisualStyles.BACKGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.BACKGROUND);
				}
			} else if (this._values[VisualStyles.BACKGROUND]) {
				delete this._background;
				this._values[VisualStyles.BACKGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.BACKGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.BACKGROUND)._background;
		}
	},
	selectedBackground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.SELECTED_BACKGROUND] || value !== this._selectedBackground) {
					this._selectedBackground = value;
					this._values[VisualStyles.SELECTED_BACKGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.SELECTED_BACKGROUND);
				}
			} else if (this._values[VisualStyles.SELECTED_BACKGROUND]) {
				delete this._selectedBackground;
				this._values[VisualStyles.SELECTED_BACKGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.SELECTED_BACKGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.SELECTED_BACKGROUND)._selectedBackground;
		}
	},
	inactiveBackground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.INACTIVE_BACKGROUND] || value !== this._inactiveBackground) {
					this._inactiveBackground = value;
					this._values[VisualStyles.INACTIVE_BACKGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.INACTIVE_BACKGROUND);
				}
			} else if (this._values[VisualStyles.INACTIVE_BACKGROUND]) {
				delete this._inactiveBackground;
				this._values[VisualStyles.INACTIVE_BACKGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.INACTIVE_BACKGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.INACTIVE_BACKGROUND)._inactiveBackground;
		}
	},
	border: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.BORDER] || value !== this._border) {
					this._border = value;
					this._values[VisualStyles.BORDER] = true;
					if (this._fireEvents) this.changed(VisualStyles.BORDER);
				}
			} else if (this._values[VisualStyles.BORDER]) {
				delete this._border;
				this._values[VisualStyles.BORDER] = false;
				if (this._fireEvents) this.changed(VisualStyles.BORDER);
			}
		} else {
			return this.searchStyles(VisualStyles.BORDER)._border;
		}
	},
	borderLeft: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.BORDER_LEFT] || value !== this._borderLeft) {
					this._borderLeft = value;
					this._values[VisualStyles.BORDER_LEFT] = true;
					if (this._fireEvents) this.changed(VisualStyles.BORDER_LEFT);
				}
			} else if (this._values[VisualStyles.BORDER_LEFT]) {
				delete this._borderLeft;
				this._values[VisualStyles.BORDER_LEFT] = false;
				if (this._fireEvents) this.changed(VisualStyles.BORDER_LEFT);
			}
		} else {
			return this.searchStyles(VisualStyles.BORDER_LEFT)._borderLeft;
		}
	},
	borderLeftWidth: function (value) {
		var stroke = this.borderLeft();
		return stroke ? stroke.width() : 0;
	},
	borderRight: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.BORDER_RIGHT] || value !== this._borderRight) {
					this._borderRight = value;
					this._values[VisualStyles.BORDER_RIGHT] = true;
					if (this._fireEvents) this.changed(VisualStyles.BORDER_RIGHT);
				}
			} else if (this._values[VisualStyles.BORDER_RIGHT]) {
				delete this._borderRight;
				this._values[VisualStyles.BORDER_RIGHT] = false;
				if (this._fireEvents) this.changed(VisualStyles.BORDER_RIGHT);
			}
		} else {
			return this.searchStyles(VisualStyles.BORDER_RIGHT)._borderRight;
		}
	},
	borderRightWidth: function (value) {
		var stroke = this.borderRight();
		return stroke ? stroke.width() : 0;
	},
	borderTop: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.BORDER_TOP] || value !== this._borderTop) {
					this._borderTop = value;
					this._values[VisualStyles.BORDER_TOP] = true;
					if (this._fireEvents) this.changed(VisualStyles.BORDER_TOP);
				}
			} else if (this._values[VisualStyles.BORDER_TOP]) {
				delete this._borderTop;
				this._values[VisualStyles.BORDER_TOP] = false;
				if (this._fireEvents) this.changed(VisualStyles.BORDER_TOP);
			}
		} else {
			return this.searchStyles(VisualStyles.BORDER_TOP)._borderTop;
		}
	},
	borderTopWidth: function (value) {
		var stroke = this.borderTop();
		return stroke ? stroke.width() : 0;
	},
	borderBottom: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.BORDER_BOTTOM] || value !== this._borderBottom) {
					this._borderBottom = value;
					this._values[VisualStyles.BORDER_BOTTOM] = true;
					if (this._fireEvents) this.changed(VisualStyles.BORDER_BOTTOM);
				}
			} else if (this._values[VisualStyles.BORDER_BOTTOM]) {
				delete this._borderBottom;
				this._values[VisualStyles.BORDER_BOTTOM] = false;
				if (this._fireEvents) this.changed(VisualStyles.BORDER_BOTTOM);
			}
		} else {
			return this.searchStyles(VisualStyles.BORDER_BOTTOM)._borderBottom;
		}
	},
	borderBottomWidth: function (value) {
		var stroke = this.borderBottom();
		return stroke ? stroke.width() : 0;
	},
	line: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.LINE] || value !== this._line) {
					this._line = value;
					this._values[VisualStyles.LINE] = true;
					if (this._fireEvents) this.changed(VisualStyles.LINE);
				}
			} else if (this._values[VisualStyles.LINE]) {
				delete this._line;
				this._values[VisualStyles.LINE] = false;
				if (this._fireEvents) this.changed(VisualStyles.LINE);
			}
		} else {
			return this.searchStyles(VisualStyles.LINE)._line;
		}
	},
	renderer: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.RENDERER] || value !== this._renderer) {
					this._renderer = value;
					this._values[VisualStyles.RENDERER] = true;
					if (this._fireEvents) this.changed(VisualStyles.RENDERER);
				}
			} else if (this._values[VisualStyles.RENDERER]) {
				delete this._renderer;
				this._values[VisualStyles.RENDERER] = false;
				if (this._fireEvents) this.changed(VisualStyles.RENDERER);
			}
		} else {
			return this.searchStyles(VisualStyles.RENDERER)._renderer;
		}
	},
    fontName: function (value) {
        if (arguments.length > 0) {
            if (value !== UNDEFINED) {
                if (!this._values[VisualStyles.FONT_FAMILY] || value !== this._fontFamily) {
                    this._fontFamily = value;
                    this._values[VisualStyles.FONT_FAMILY] = true;
                    if (this._fireEvents) this.changed(VisualStyles.FONT_FAMILY);
                }
            } else if (this._values[VisualStyles.FONT_FAMILY]) {
                delete this._fontFamily;
                this._values[VisualStyles.FONT_FAMILY] = false;
                if (this._fireEvents) this.changed(VisualStyles.FONT_FAMILY);
            }
        } else {
            return this.searchStyles(VisualStyles.FONT_FAMILY)._fontFamily;
        }
    },
	fontFamily: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.FONT_FAMILY] || value !== this._fontFamily) {
					this._fontFamily = value;
					this._values[VisualStyles.FONT_FAMILY] = true;
					if (this._fireEvents) this.changed(VisualStyles.FONT_FAMILY);
				}
			} else if (this._values[VisualStyles.FONT_FAMILY]) {
				delete this._fontFamily;
				this._values[VisualStyles.FONT_FAMILY] = false;
				if (this._fireEvents) this.changed(VisualStyles.FONT_FAMILY);
			}
		} else {
			return this.searchStyles(VisualStyles.FONT_FAMILY)._fontFamily;
		}
	},
	fontSize: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = parseInt(value);
				if (!this._values[VisualStyles.FONT_SIZE] || value !== this._fontSize) {
					this._fontSize = value;
					this._values[VisualStyles.FONT_SIZE] = true;
					if (this._fireEvents) this.changed(VisualStyles.FONT_SIZE);
				}
			} else if (this._values[VisualStyles.FONT_SIZE]) {
				delete this._fontSize;
				this._values[VisualStyles.FONT_SIZE] = false;
				if (this._fireEvents) this.changed(VisualStyles.FONT_SIZE);
			}
		} else {
			return this.searchStyles(VisualStyles.FONT_SIZE)._fontSize;
		}
	},
	fontBold: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = value && value !== "false";
				if (!this._values[VisualStyles.FONT_BOLD] || value !== this._fontBold) {
					this._fontBold = value;
					this._values[VisualStyles.FONT_BOLD] = true;
					if (this._fireEvents) this.changed(VisualStyles.FONT_BOLD);
				}
			} else if (this._values[VisualStyles.FONT_BOLD]) {
				delete this._fontBold;
				this._values[VisualStyles.FONT_BOLD] = false;
				if (this._fireEvents) this.changed(VisualStyles.FONT_BOLD);
			}
		} else {
			return this.searchStyles(VisualStyles.FONT_BOLD)._fontBold;
		}
	},
	fontItalic: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = value && value !== "false";
				if (!this._values[VisualStyles.FONT_ITALIC] || value !== this._fontItalic) {
					this._fontItalic = value;
					this._values[VisualStyles.FONT_ITALIC] = true;
					if (this._fireEvents) this.changed(VisualStyles.FONT_ITALIC);
				}
			} else if (this._values[VisualStyles.FONT_ITALIC]) {
				delete this._fontItalic;
				this._values[VisualStyles.FONT_ITALIC] = false;
				if (this._fireEvents) this.changed(VisualStyles.FONT_ITALIC);
			}
		} else {
			return this.searchStyles(VisualStyles.FONT_ITALIC)._fontItalic;
		}
	},
	fontUnderline: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = value && value !== "false";
				if (!this._values[VisualStyles.FONT_UNDERLINE] || value !== this._fontUnderline) {
					this._fontUnderline = value;
					this._values[VisualStyles.FONT_UNDERLINE] = true;
					if (this._fireEvents) this.changed(VisualStyles.FONT_UNDERLINE);
				}
			} else if (this._values[VisualStyles.FONT_UNDERLINE]) {
				delete this._fontUnderline;
				this._values[VisualStyles.FONT_UNDERLINE] = false;
				if (this._fireEvents) this.changed(VisualStyles.FONT_UNDERLINE);
			}
		} else {
			return this.searchStyles(VisualStyles.FONT_UNDERLINE)._fontUnderline;
		}
	},
	fontLinethrough: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = value && value !== "false";
				if (!this._values[VisualStyles.FONT_LINETHROUGH] || value !== this._fontLinethrough) {
					this._fontLinethrough = value;
					this._values[VisualStyles.FONT_LINETHROUGH] = true;
					if (this._fireEvents) this.changed(VisualStyles.FONT_LINETHROUGH);
				}
			} else if (this._values[VisualStyles.FONT_LINETHROUGH]) {
				delete this._fontLinethrough;
				this._values[VisualStyles.FONT_LINETHROUGH] = false;
				if (this._fireEvents) this.changed(VisualStyles.FONT_LINETHROUGH);
			}
		} else {
			return this.searchStyles(VisualStyles.FONT_LINETHROUGH)._fontLinethrough;
		}
	},
	textWrap: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.TEXT_WRAP] || value !== this._textWrap) {
					this._textWrap = value;
					this._values[VisualStyles.TEXT_WRAP] = true;
					if (this._fireEvents) this.changed(VisualStyles.TEXT_WRAP);
				}
			} else if (this._values[VisualStyles.TEXT_WRAP]) {
				delete this._textWrap;
				this._values[VisualStyles.TEXT_WRAP] = false;
				if (this._fireEvents) this.changed(VisualStyles.TEXT_WRAP);
			}
		} else {
			return this.searchStyles(VisualStyles.TEXT_WRAP)._textWrap;
		}
	},
	foreground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.FOREGROUND] || value !== this._foreground) {
					this._foreground = value;
					this._values[VisualStyles.FOREGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.FOREGROUND);
				}
			} else if (this._values[VisualStyles.FOREGROUND]) {
				delete this._foreground;
				this._values[VisualStyles.FOREGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.FOREGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.FOREGROUND)._foreground;
		}
	},
	selectedForeground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.SELECTED_FOREGROUND] || value !== this._selectedForeground) {
					this._selectedForeground = value;
					this._values[VisualStyles.SELECTED_FOREGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.SELECTED_FOREGROUND);
				}
			} else if (this._values[VisualStyles.SELECTED_FOREGROUND]) {
				delete this._selectedForeground;
				this._values[VisualStyles.SELECTED_FOREGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.SELECTED_FOREGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.SELECTED_FOREGROUND)._selectedForeground;
		}
	},
	inactiveForeground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.INACTIVE_FOREGROUND] || value !== this._inactiveForeground) {
					this._inactiveForeground = value;
					this._values[VisualStyles.INACTIVE_FOREGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.INACTIVE_FOREGROUND);
				}
			} else if (this._values[VisualStyles.INACTIVE_FOREGROUND]) {
				delete this._inactiveForeground;
				this._values[VisualStyles.INACTIVE_FOREGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.INACTIVE_FOREGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.INACTIVE_FOREGROUND)._inactiveForeground;
		}
	},
	textAlignment: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.TEXT_ALIGNMENT] || value !== this._textAlignment) {
					this._textAlignment = value;
					this._values[VisualStyles.TEXT_ALIGNMENT] = true;
					if (this._fireEvents) this.changed(VisualStyles.TEXT_ALIGNMENT);
				}
			} else if (this._values[VisualStyles.TEXT_ALIGNMENT]) {
				delete this._textAlignment;
				this._values[VisualStyles.TEXT_ALIGNMENT] = false;
				if (this._fireEvents) this.changed(VisualStyles.TEXT_ALIGNMENT);
			}
		} else {
			return this.searchStyles(VisualStyles.TEXT_ALIGNMENT)._textAlignment;
		}
	},
	lineAlignment: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.LINE_ALIGNMENT] || value !== this._lineAlignment) {
					this._lineAlignment = value;
					this._values[VisualStyles.LINE_ALIGNMENT] = true;
					if (this._fireEvents) this.changed(VisualStyles.LINE_ALIGNMENT);
				}
			} else if (this._values[VisualStyles.LINE_ALIGNMENT]) {
				delete this._lineAlignment;
				this._values[VisualStyles.LINE_ALIGNMENT] = false;
				if (this._fireEvents) this.changed(VisualStyles.LINE_ALIGNMENT);
			}
		} else {
			return this.searchStyles(VisualStyles.LINE_ALIGNMENT)._lineAlignment;
		}
	},
	numberFormat: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.NUMBER_FORMAT] || value !== this._numberFormat) {
					this._numberFormat = value;
					this._values[VisualStyles.NUMBER_FORMAT] = true;
					if (this._fireEvents) this.changed(VisualStyles.NUMBER_FORMAT);
				}
			} else if (this._values[VisualStyles.NUMBER_FORMAT]) {
				delete this._numberFormat;
				this._values[VisualStyles.NUMBER_FORMAT] = false;
				if (this._fireEvents) this.changed(VisualStyles.NUMBER_FORMAT);
			}
		} else {
			return this.searchStyles(VisualStyles.NUMBER_FORMAT)._numberFormat;
		}
	},
	datetimeFormat: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.DATETIME_FORMAT] || value !== this._datetimeFormat) {
					this._datetimeFormat = value;
					this._values[VisualStyles.DATETIME_FORMAT] = true;
					if (this._fireEvents) this.changed(VisualStyles.DATETIME_FORMAT);
				}
			} else if (this._values[VisualStyles.DATETIME_FORMAT]) {
				delete this._datetimeFormat;
				this._values[VisualStyles.DATETIME_FORMAT] = false;
				if (this._fireEvents) this.changed(VisualStyles.DATETIME_FORMAT);
			}
		} else {
			return this.searchStyles(VisualStyles.DATETIME_FORMAT)._datetimeFormat;
		}
	},
	booleanFormat: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.BOOLEAN_FORMAT] || value !== this._booleanFormat) {
					this._booleanFormat = value;
					this._values[VisualStyles.BOOLEAN_FORMAT] = true;
					if (this._fireEvents) this.changed(VisualStyles.BOOLEAN_FORMAT);
				}
			} else if (this._values[VisualStyles.BOOLEAN_FORMAT]) {
				delete this._booleanFormat;
				this._values[VisualStyles.BOOLEAN_FORMAT] = false;
				if (this._fireEvents) this.changed(VisualStyles.BOOLEAN_FORMAT);
			}
		} else {
			return this.searchStyles(VisualStyles.BOOLEAN_FORMAT)._booleanFormat;
		}
	},
	prefix: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.PREFIX] || value !== this._prefix) {
					this._prefix = value;
					this._values[VisualStyles.PREFIX] = true;
					if (this._fireEvents) this.changed(VisualStyles.PREFIX);
				}
			} else if (this._values[VisualStyles.PREFIX]) {
				delete this._prefix;
				this._values[VisualStyles.PREFIX] = false;
				if (this._fireEvents) this.changed(VisualStyles.PREFIX);
			}
		} else {
			return this.searchStyles(VisualStyles.PREFIX)._prefix;
		}
	},
	suffix: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.SUFFIX] || value !== this._suffix) {
					this._suffix = value;
					this._values[VisualStyles.SUFFIX] = true;
					if (this._fireEvents) this.changed(VisualStyles.SUFFIX);
				}
			} else if (this._values[VisualStyles.SUFFIX]) {
				delete this._suffix;
				this._values[VisualStyles.SUFFIX] = false;
				if (this._fireEvents) this.changed(VisualStyles.SUFFIX);
			}
		} else {
			return this.searchStyles(VisualStyles.SUFFIX)._suffix;
		}
	},
	paddingLeft: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = parseInt(value);
				if (!this._values[VisualStyles.PADDING_LEFT] || value !== this._paddingLeft) {
					this._paddingLeft = value;
					this._values[VisualStyles.PADDING_LEFT] = true;
					if (this._fireEvents) this.changed(VisualStyles.PADDING_LEFT);
				}
			} else if (this._values[VisualStyles.PADDING_LEFT]) {
				delete this._paddingLeft;
				this._values[VisualStyles.PADDING_LEFT] = false;
				if (this._fireEvents) this.changed(VisualStyles.PADDING_LEFT);
			}
		} else {
			return this.searchStyles(VisualStyles.PADDING_LEFT)._paddingLeft;
		}
	},
	paddingRight: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.PADDING_RIGHT] || value !== this._paddingRight) {
					value = parseInt(value);
					this._paddingRight = value;
					this._values[VisualStyles.PADDING_RIGHT] = true;
					if (this._fireEvents) this.changed(VisualStyles.PADDING_RIGHT);
				}
			} else if (this._values[VisualStyles.PADDING_RIGHT]) {
				delete this._paddingRight;
				this._values[VisualStyles.PADDING_RIGHT] = false;
				if (this._fireEvents) this.changed(VisualStyles.PADDING_RIGHT);
			}
		} else {
			return this.searchStyles(VisualStyles.PADDING_RIGHT)._paddingRight;
		}
	},
	paddingTop: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = parseInt(value);
				if (!this._values[VisualStyles.PADDING_TOP] || value !== this._paddingTop) {
					this._paddingTop = value;
					this._values[VisualStyles.PADDING_TOP] = true;
					if (this._fireEvents) this.changed(VisualStyles.PADDING_TOP);
				}
			} else if (this._values[VisualStyles.PADDING_TOP]) {
				delete this._paddingTop;
				this._values[VisualStyles.PADDING_TOP] = false;
				if (this._fireEvents) this.changed(VisualStyles.PADDING_TOP);
			}
		} else {
			return this.searchStyles(VisualStyles.PADDING_TOP)._paddingTop;
		}
	},
	paddingBottom: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = parseInt(value);
				if (!this._values[VisualStyles.PADDING_BOTTOM] || value !== this._paddingBottom) {
					this._paddingBottom = value;
					this._values[VisualStyles.PADDING_BOTTOM] = true;
					if (this._fireEvents) this.changed(VisualStyles.PADDING_BOTTOM);
				}
			} else if (this._values[VisualStyles.PADDING_BOTTOM]) {
				delete this._paddingBottom;
				this._values[VisualStyles.PADDING_BOTTOM] = false;
				if (this._fireEvents) this.changed(VisualStyles.PADDING_BOTTOM);
			}
		} else {
			return this.searchStyles(VisualStyles.PADDING_BOTTOM)._paddingBottom;
		}
	},
	paddingHorz: function (value) {
		return this.paddingLeft() + this.paddingRight();
	},
	paddingVert: function (value) {
		return this.paddingTop() + this.paddingBottom();
	},
	iconIndex: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.ICON_INDEX] || value !== this._iconIndex) {
					this._iconIndex = value;
					this._values[VisualStyles.ICON_INDEX] = true;
					if (this._fireEvents) this.changed(VisualStyles.ICON_INDEX);
				}
			} else if (this._values[VisualStyles.ICON_INDEX]) {
				delete this._iconIndex;
				this._values[VisualStyles.ICON_INDEX] = false;
				if (this._fireEvents) this.changed(VisualStyles.ICON_INDEX);
			}
		} else {
			return this.searchStyles(VisualStyles.ICON_INDEX)._iconIndex;
		}
	},
	iconLocation: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.ICON_LOCATION] || value !== this._iconLocation) {
					this._iconLocation = value;
					this._values[VisualStyles.ICON_LOCATION] = true;
					if (this._fireEvents) this.changed(VisualStyles.ICON_LOCATION);
				}
			} else if (this._values[VisualStyles.ICON_LOCATION]) {
				delete this._iconLocation;
				this._values[VisualStyles.ICON_LOCATION] = false;
				if (this._fireEvents) this.changed(VisualStyles.ICON_LOCATION);
			}
		} else {
			return this.searchStyles(VisualStyles.ICON_LOCATION)._iconLocation;
		}
	},
	iconAlignment: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.ICON_ALIGNMENT] || value !== this._iconAlignment) {
					this._iconAlignment = value;
					this._values[VisualStyles.ICON_ALIGNMENT] = true;
					if (this._fireEvents) this.changed(VisualStyles.ICON_ALIGNMENT);
				}
			} else if (this._values[VisualStyles.ICON_ALIGNMENT]) {
				delete this._iconAlignment;
				this._values[VisualStyles.ICON_ALIGNMENT] = false;
				if (this._fireEvents) this.changed(VisualStyles.ICON_ALIGNMENT);
			}
		} else {
			return this.searchStyles(VisualStyles.ICON_ALIGNMENT)._iconAlignment;
		}
	},
	iconOffset: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = parseInt(value);
				if (!this._values[VisualStyles.ICON_OFFSET] || value !== this._iconOffset) {
					this._iconOffset = value;
					this._values[VisualStyles.ICON_OFFSET] = true;
					if (this._fireEvents) this.changed(VisualStyles.ICON_OFFSET);
				}
			} else if (this._values[VisualStyles.ICON_OFFSET]) {
				delete this._iconOffset;
				this._values[VisualStyles.ICON_OFFSET] = false;
				if (this._fireEvents) this.changed(VisualStyles.ICON_OFFSET);
			}
		} else {
			return this.searchStyles(VisualStyles.ICON_OFFSET)._iconOffset;
		}
	},
	iconPadding: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = parseInt(value);
				if (!this._values[VisualStyles.ICON_PADDING] || value !== this._iconPadding) {
					this._iconPadding = value;
					this._values[VisualStyles.ICON_PADDING] = true;
					if (this._fireEvents) this.changed(VisualStyles.ICON_PADDING);
				}
			} else if (this._values[VisualStyles.ICON_PADDING]) {
				delete this._iconPadding;
				this._values[VisualStyles.ICON_PADDING] = false;
				if (this._fireEvents) this.changed(VisualStyles.ICON_PADDING);
			}
		} else {
			return this.searchStyles(VisualStyles.ICON_PADDING)._iconPadding;
		}
	},
	contentFit: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.CONTENT_FIT] || value !== this._contentFit) {
					this._contentFit = value;
					this._values[VisualStyles.CONTENT_FIT] = true;
					if (this._fireEvents) this.changed(VisualStyles.CONTENT_FIT);
				}
			} else if (this._values[VisualStyles.CONTENT_FIT]) {
				delete this._contentFit;
				this._values[VisualStyles.CONTENT_FIT] = false;
				if (this._fireEvents) this.changed(VisualStyles.CONTENT_FIT);
			}
		} else {
			return this.searchStyles(VisualStyles.CONTENT_FIT)._contentFit;
		}
	},
	selectionDisplay: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.SELECTION_DISPLAY] || value !== this._selectionDisplay) {
					this._selectionDisplay = value;
					this._values[VisualStyles.SELECTION_DISPLAY] = true;
					if (this._fireEvents) this.changed(VisualStyles.SELECTION_DISPLAY);
				}
			} else if (this._values[VisualStyles.SELECTION_DISPLAY]) {
				delete this._selectionDisplay;
				this._values[VisualStyles.SELECTION_DISPLAY] = false;
				if (this._fireEvents) this.changed(VisualStyles.SELECTION_DISPLAY);
			}
		} else {
			return this.searchStyles(VisualStyles.SELECTION_DISPLAY)._selectionDisplay;
		}
	},
	hoveredMaskBackground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.HOVERED_MASK_BACKGROUND] || value !== this._hoveredMaskBackground) {
					this._hoveredMaskBackground = value;
					this._values[VisualStyles.HOVERED_MASK_BACKGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.HOVERED_MASK_BACKGROUND);
				}
			} else if (this._values[VisualStyles.HOVERED_MASK_BACKGROUND]) {
				delete this._hoveredMaskBackground;
				this._values[VisualStyles.HOVERED_MASK_BACKGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.HOVERED_MASK_BACKGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.HOVERED_MASK_BACKGROUND)._hoveredMaskBackground;
		}
	},
	hoveredMaskBorder: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.HOVERED_MASK_BORDER] || value !== this._hoveredMaskBorder) {
					this._hoveredMaskBorder = value;
					this._values[VisualStyles.HOVERED_MASK_BORDER] = true;
					if (this._fireEvents) this.changed(VisualStyles.HOVERED_MASK_BORDER);
				}
			} else if (this._values[VisualStyles.HOVERED_MASK_BORDER]) {
				delete this._hoveredMaskBorder;
				this._values[VisualStyles.HOVERED_MASK_BORDER] = false;
				if (this._fireEvents) this.changed(VisualStyles.HOVERED_MASK_BORDER);
			}
		} else {
			return this.searchStyles(VisualStyles.HOVERED_MASK_BORDER)._hoveredMaskBorder;
		}
	},
	hoveredBackground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.HOVERED_BACKGROUND] || value !== this._hoveredBackground) {
					this._hoveredBackground = value;
					this._values[VisualStyles.HOVERED_BACKGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.HOVERED_BACKGROUND);
				}
			} else if (this._values[VisualStyles.HOVERED_BACKGROUND]) {
				delete this._hoveredBackground;
				this._values[VisualStyles.HOVERED_BACKGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.HOVERED_BACKGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.HOVERED_BACKGROUND)._hoveredBackground;
		}
	},
	hoveredForeground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.HOVERED_FOREGROUND] || value !== this._hoveredForeground) {
					this._hoveredForeground = value;
					this._values[VisualStyles.HOVERED_FOREGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.HOVERED_FOREGROUND);
				}
			} else if (this._values[VisualStyles.HOVERED_FOREGROUND]) {
				delete this._hoveredForeground;
				this._values[VisualStyles.HOVERED_FOREGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.HOVERED_FOREGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.HOVERED_FOREGROUND)._hoveredForeground;
		}
	},
	figureBackground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.FIGURE_BACKGROUND] || value !== this._figureBackground) {
					this._figureBackground = value;
					this._values[VisualStyles.FIGURE_BACKGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.FIGURE_BACKGROUND);
				}
			} else if (this._values[VisualStyles.FIGURE_BACKGROUND]) {
				delete this._figureBackground;
				this._values[VisualStyles.FIGURE_BACKGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.FIGURE_BACKGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.FIGURE_BACKGROUND)._figureBackground;
		}
	},
	figureInactiveBackground: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getFill(value);
				if (!this._values[VisualStyles.FIGURE_INACTIVE_BACKGROUND] || value !== this._figureInactiveBackground) {
					this._figureInactiveBackground = value;
					this._values[VisualStyles.FIGURE_INACTIVE_BACKGROUND] = true;
					if (this._fireEvents) this.changed(VisualStyles.FIGURE_INACTIVE_BACKGROUND);
				}
			} else if (this._values[VisualStyles.FIGURE_INACTIVE_BACKGROUND]) {
				delete this._figureInactiveBackground;
				this._values[VisualStyles.FIGURE_INACTIVE_BACKGROUND] = false;
				if (this._fireEvents) this.changed(VisualStyles.FIGURE_INACTIVE_BACKGROUND);
			}
		} else {
			return this.searchStyles(VisualStyles.FIGURE_INACTIVE_BACKGROUND)._figureInactiveBackground;
		}
	},
	figureBorder: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				value = this.getStroke(value);
				if (!this._values[VisualStyles.FIGURE_BORDER] || value !== this._figureBorder) {
					this._figureBorder = value;
					this._values[VisualStyles.FIGURE_BORDER] = true;
					if (this._fireEvents) this.changed(VisualStyles.FIGURE_BORDER);
				}
			} else if (this._values[VisualStyles.FIGURE_BORDER]) {
				delete this._figureBorder;
				this._values[VisualStyles.FIGURE_BORDER] = false;
				if (this._fireEvents) this.changed(VisualStyles.FIGURE_BORDER);
			}
		} else {
			return this.searchStyles(VisualStyles.FIGURE_BORDER)._figureBorder;
		}
	},
	figureSize: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.FIGURE_SIZE] || value !== this._figureSize) {
					this._figureSize = VisualStyles.getDimension(value);
					this._values[VisualStyles.FIGURE_SIZE] = true;
					if (this._fireEvents) this.changed(VisualStyles.FIGURE_SIZE);
				}
			} else if (this._values[VisualStyles.FIGURE_SIZE]) {
				delete this._figureSize;
				this._values[VisualStyles.FIGURE_SIZE] = false;
				if (this._fireEvents) this.changed(VisualStyles.FIGURE_SIZE);
			}
		} else {
			return this.searchStyles(VisualStyles.FIGURE_SIZE)._figureSize;
		}
	},
	figureName: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.FIGURE_NAME] || value !== this._figureName) {
					this._figureName = value;
					this._values[VisualStyles.FIGURE_NAME] = true;
					if (this._fireEvents) this.changed(VisualStyles.FIGURE_NAME);
				}
			} else if (this._values[VisualStyles.FIGURE_NAME]) {
				delete this._figureName;
				this._values[VisualStyles.FIGURE_NAME] = false;
				if (this._fireEvents) this.changed(VisualStyles.FIGURE_NAME);
			}
		} else {
			return this.searchStyles(VisualStyles.FIGURE_NAME)._figureName;
		}
	},
	figureState: function (value) {
		if (arguments.length > 0) {
			if (value !== UNDEFINED) {
				if (!this._values[VisualStyles.FIGURE_STATE] || value !== this._figureState) {
					this._figureState = value;
					this._values[VisualStyles.FIGURE_STATE] = true;
					if (this._fireEvents) this.changed(VisualStyles.FIGURE_STATE);
				}
			} else if (this._values[VisualStyles.FIGURE_STATE]) {
				delete this._figureState;
				this._values[VisualStyles.FIGURE_STATE] = false;
				if (this._fireEvents) this.changed(VisualStyles.FIGURE_STATE);
			}
		} else {
			return this.searchStyles(VisualStyles.FIGURE_STATE)._figureState;
		}
	},
	font: function (value) {
		if (arguments.length > 0) {
			value = value && value.trim();
			if (value) {
				var arr = value.split($$_FONT_REG);
				var len = arr.length;
				if (len > 0 && arr[0]) {
					this.fontFamily(arr[0]);
				}
				if (len > 1 && arr[1]) {
					this.fontSize(arr[1]);
				}
				var i;
				var s;
				for (i = 2; i < len; i++) {
					s = arr[i];
					if (s) {
						s = s.toLowerCase();
						switch (s) {
							case "bold":
								this.fontBold(true);
								break;
							case "italic":
								this.fontItalic(true);
								break;
							case "underline":
								this.fontUnderline(true);
								break;
							case "linethrough":
							case "line-through":
								this.fontLinethrough(true);
								break;
						}
					}
				}
			}
		} else {
			var font = [];
			var sz = this.fontSize();
			if (this.fontItalic()) {
				font.push("italic");
			}
			if (this.fontBold()) {
				font.push("bold");
			}
			font.push(sz + "px");
			var family;
			if (family = this.fontFamily()) {
				font.push(family);
			}
			s = font.join(" ");
			return { font: s, size: sz, underline: this.fontUnderline(), linethrough: this.fontLinethrough() };
		}
	},
	beginUpdate: function () {
		this._updateLock++;
	},
	endUpdate: function (fireEvent) {
		fireEvent = arguments.length > 0 ? fireEvent : true;
		this._updateLock--;
		if (this._updateLock == 0 && this._fireEvents) {
			this.changed(VisualStyles.STYLE_ALL, fireEvent);
		}
	},
	hasValue: function (entry) {
		return typeof entry === "string" ? this._values[VisualStyles.STYLE_NAMES[entry]] : this._values[entry];
	},
    getValue: function (entry) {
        return this["_" + entry];
    },
	clearValues: function () {
		this._values = [];
	},
	extend: function (source, fireEvent) {
		fireEvent = arguments.length > 1 ? fireEvent : true;
		this.beginUpdate();
		try {
			if (source instanceof VisualStyles) {
				var values = source._values;
				if (values[VisualStyles.BACKGROUND]) {
					this.background(source._background);
				}
				if (values[VisualStyles.SELECTED_BACKGROUND]) {
					this.selectedBackground(source._selectedBackground);
				}
				if (values[VisualStyles.INACTIVE_BACKGROUND]) {
					this.inactiveBackground(source._inactiveBackground);
				}
				if (values[VisualStyles.BORDER]) {
					this.border(source._border);
				}
				if (values[VisualStyles.BORDER_LEFT]) {
					this.borderLeft(source._borderLeft);
				}
				if (values[VisualStyles.BORDER_RIGHT]) {
					this.borderRight(source._borderRight);
				}
				if (values[VisualStyles.BORDER_TOP]) {
					this.borderTop(source._borderTop);
				}
				if (values[VisualStyles.BORDER_BOTTOM]) {
					this.borderBottom(source._borderBottom);
				}
				if (values[VisualStyles.LINE]) {
					this.line(source._line);
				}
				if (values[VisualStyles.RENDERER]) {
					this.renderer(source._renderer);
				}
				if (values[VisualStyles.FONT_FAMILY]) {
					this.fontFamily(source._fontFamily);
				}
				if (values[VisualStyles.FONT_SIZE]) {
					this.fontSize(source._fontSize);
				}
				if (values[VisualStyles.FONT_BOLD]) {
					this.fontBold(source._fontBold);
				}
				if (values[VisualStyles.FONT_ITALIC]) {
					this.fontItalic(source._fontItalic);
				}
				if (values[VisualStyles.FONT_UNDERLINE]) {
					this.fontUnderline(source._fontUnderline);
				}
				if (values[VisualStyles.FONT_LINETHROUGH]) {
					this.fontLinethrough(source._fontLinethrough);
				}
				if (values[VisualStyles.TEXT_WRAP]) {
					this.textWrap(source._textWrap);
				}
				if (values[VisualStyles.FOREGROUND]) {
					this.foreground(source._foreground);
				}
				if (values[VisualStyles.SELECTED_FOREGROUND]) {
					this.selectedForeground(source._selectedForeground);
				}
				if (values[VisualStyles.INACTIVE_FOREGROUND]) {
					this.inactiveForeground(source._inactiveForeground);
				}
				if (values[VisualStyles.TEXT_ALIGNMENT]) {
					this.textAlignment(source._textAlignment);
				}
				if (values[VisualStyles.LINE_ALIGNMENT]) {
					this.lineAlignment(source._lineAlignment);
				}
				if (values[VisualStyles.NUMBER_FORMAT]) {
					this.numberFormat(source._numberFormat);
				}
				if (values[VisualStyles.DATETIME_FORMAT]) {
					this.datetimeFormat(source._datetimeFormat);
				}
				if (values[VisualStyles.BOOLEAN_FORMAT]) {
					this.booleanFormat(source._booleanFormat);
				}
				if (values[VisualStyles.PREFIX]) {
					this.prefix(source._prefix);
				}
				if (values[VisualStyles.SUFFIX]) {
					this.suffix(source._suffix);
				}
				if (values[VisualStyles.PADDING_LEFT]) {
					this.paddingLeft(source._paddingLeft);
				}
				if (values[VisualStyles.PADDING_RIGHT]) {
					this.paddingRight(source._paddingRight);
				}
				if (values[VisualStyles.PADDING_TOP]) {
					this.paddingTop(source._paddingTop);
				}
				if (values[VisualStyles.PADDING_BOTTOM]) {
					this.paddingBottom(source._paddingBottom);
				}
				if (values[VisualStyles.ICON_INDEX]) {
					this.iconIndex(source._iconIndex);
				}
				if (values[VisualStyles.ICON_LOCATION]) {
					this.iconLocation(source._iconLocation);
				}
				if (values[VisualStyles.ICON_ALIGNMENT]) {
					this.iconAlignment(source._iconAlignment);
				}
				if (values[VisualStyles.ICON_OFFSET]) {
					this.iconOffset(source._iconOffset);
				}
				if (values[VisualStyles.ICON_PADDING]) {
					this.iconPadding(source._iconPadding);
				}
				if (values[VisualStyles.CONTENT_FIT]) {
					this.contentFit(source._contentFit);
				}
				if (values[VisualStyles.SELECTION_DISPLAY]) {
					this.selectionDisplay(source._selectionDisplay);
				}
				if (values[VisualStyles.HOVERED_MASK_BACKGROUND]) {
					this.hoveredMaskBackground(source._hoveredMaskBackground);
				}
				if (values[VisualStyles.HOVERED_MASK_BORDER]) {
					this.hoveredMaskBorder(source._hoveredMaskBorder);
				}
				if (values[VisualStyles.HOVERED_BACKGROUND]) {
					this.hoveredBackground(source._hoveredBackground);
				}
				if (values[VisualStyles.HOVERED_FOREGROUND]) {
					this.hoveredForeground(source._hoveredForeground);
				}
				if (values[VisualStyles.FIGURE_BACKGROUND]) {
					this.figureBackground(source._figureBackground);
				}
				if (values[VisualStyles.FIGURE_INACTIVE_BACKGROUND]) {
					this.figureInactiveBackground(source._figureInactiveBackground);
				}
				if (values[VisualStyles.FIGURE_BORDER]) {
					this.figureBorder(source._figureBorder);
				}
				if (values[VisualStyles.FIGURE_SIZE]) {
					this.figureSize(source._figureSize);
				}
				if (values[VisualStyles.FIGURE_NAME]) {
					this.figureName(source._figureName);
				}
				if (values[VisualStyles.FIGURE_STATE]) {
					this.figureState(source._figureState);
				}
			} else if (source) {
				var v = source.padding;
				if (v !== undefined) {
					this.paddingLeft(v);
					this.paddingRight(v);
					this.paddingTop(v);
					this.paddingBottom(v);
				}
				for (var p in source) {
					var setter = this[p];
					if (setter instanceof Function) {
						setter.call(this, source[p]);
					}
				}
			}
		} finally {
			this.endUpdate(fireEvent);
		}
	},
    toProxy: function (extend) {
    	var ret =  {
            name: this._name,
            background: VisualStyles.getFillText(this.background()),
            selectedBackground: VisualStyles.getFillText(this.selectedBackground()),
            inactiveBackground: VisualStyles.getFillText(this.inactiveBackground()),
            border: VisualStyles.getStrokeText(this.border()),
            borderLeft: VisualStyles.getStrokeText(this.borderLeft()),
            borderRight: VisualStyles.getStrokeText(this.borderRight()),
            borderTop: VisualStyles.getStrokeText(this.borderTop()),
            borderBottom: VisualStyles.getStrokeText(this.borderBottom()),
            line: VisualStyles.getStrokeText(this.line()),
            renderer: this.renderer(),
            fontFamily: this.fontFamily(),
            fontSize: this.fontSize(),
            fontBold: this.fontBold(),
            fontItalic: this.fontItalic(),
            fontUnderline: this.fontUnderline(),
            fontLinethrough: this.fontLinethrough(),
            textWrap: this.textWrap(),
            foreground: VisualStyles.getFillText(this.foreground()),
            selectedForeground: VisualStyles.getFillText(this.selectedForeground()),
            inactiveForeground: VisualStyles.getFillText(this.inactiveForeground()),
            textAlignment: this.textAlignment(),
            lineAlignment: this.lineAlignment(),
            numberFormat: this.numberFormat(),
            datetimeFormat: this.datetimeFormat(),
            booleanFormat: this.booleanFormat(),
            prefix: this.prefix(),
            suffix: this.suffix(),
            paddingLeft: this.paddingLeft(),
            paddingRight: this.paddingRight(),
            paddingTop: this.paddingTop(),
            paddingBottom: this.paddingBottom(),
            iconIndex: this.iconIndex(),
            iconLocation: this.iconLocation(),
            iconAlignment: this.iconAlignment(),
            iconOffset: this.iconOffset(),
            iconPadding: this.iconPadding(),
            contentFit: this.contentFit(),
            selectionDisplay: this.selectionDisplay(),
            hoveredMaskBackground: VisualStyles.getFillText(this.hoveredMaskBackground()),
            hoveredMaskBorder: VisualStyles.getStrokeText(this.hoveredMaskBorder()),
            hoveredForeground: VisualStyles.getFillText(this.hoveredForeground()),
            figureBackground: VisualStyles.getFillText(this.figureBackground()),
            figureInactiveBackground: VisualStyles.getFillText(this.figureInactiveBackground()),
            figureBorder: VisualStyles.getStrokeText(this.figureBorder()),
            figureSize: VisualStyles.getDimensionText(this.figureSize()),
            figureName: this.figureName(),
            figureState: this.figureState()
        };
        if (extend === false) {
			var values = this._values,
				styleId,
				noProxy = {};
			if (ret) {
				for (var attr in ret) {
					if ( (styleId = VisualStyles.STYLE_NAMES[attr]) != null && values[styleId]) {
						noProxy[attr] = ret[attr];
					}
				}
			}
			return noProxy;
        }
        return ret;
    },
	applyPaddings: function (r) {
		var v;
		r.x += (v = this.paddingLeft());
		r.width -= v + this.paddingRight();
		r.y += (v = this.paddingTop());
		r.height -= v + this.paddingBottom();
		return r;
	},
	searchStyles: function (entry) {
		if (this._values[entry]) {
			return this;
		}
		var p = this._parent;
		while (p) {
			if (p._values[entry]) {
				return p;
			}
			p = p._parent;
		}
		if (this._sysDefault && this._sysDefault._values[entry]) {
			return this._sysDefault;
		}
		var p = this._parent;
		while (p) {
			if (p._sysDefault && p._sysDefault._values[entry]) {
				return p._sysDefault;
			}
			p = p._parent;
		}
		return VisualStyles.Default;
	},
	changed: function (entry, fireEvent) {
		fireEvent = arguments.length > 1 ? fireEvent : true;
		if (this._updateLock == 0 && fireEvent) {
			if (this._owner && this._owner.stylesChanged) {
				this._owner.stylesChanged(entry);
			} else {
				this.fireEvent(VisualStyles.CHANGED, entry);
			}
		}
	},
	getFill: function (value) {
		return VisualStyles.getFill(value);
	},
	getStroke: function (value) {
		return VisualStyles.getStroke(value);
	}
}, {
	STYLE_ALL: -1,
	VISIBILITY: 0,
	BACKGROUND: 1,
	SELECTED_BACKGROUND: 2,
	INACTIVE_BACKGROUND: 3,
	FOREGROUND: 4,
	SELECTED_FOREGROUND: 5,
	INACTIVE_FOREGROUND: 6,
	BORDER: 10,
	BORDER_LEFT: 11,
	BORDER_RIGHT: 12,
	BORDER_TOP: 13,
	BORDER_BOTTOM: 14,
	LINE: 15,
	RENDERER: 16,
	TEXT_ALIGNMENT: 20,
	LINE_ALIGNMENT: 21,
	NUMBER_FORMAT: 22,
	DATETIME_FORMAT: 23,
	BOOLEAN_FORMAT: 24,
	PREFIX: 25,
	SUFFIX: 26,
	FONT: 30,
	FONT_FAMILY: 31,
	FONT_SIZE: 32,
	FONT_BOLD: 33,
	FONT_ITALIC: 34,
	FONT_UNDERLINE: 35,
	FONT_LINETHROUGH: 36,
	TEXT_WRAP: 37,
	PADDING_LEFT: 40,
	PADDING_RIGHT: 41,
	PADDING_TOP: 42,
	PADDING_BOTTOM: 43,
	ICON_INDEX: 44,
	ICON_LOCATION: 45,
	ICON_ALIGNMENT: 46,
	ICON_OFFSET: 47,
	ICON_PADDING: 48,
	CONTENT_FIT: 49,
	SELECTION_DISPLAY: 50,
	HOVERED_MASK_BACKGROUND: 51,
	HOVERED_MASK_BORDER: 52,
	HOVERED_BACKGROUND: 53,
	HOVERED_FOREGROUND: 54,
	FIGURE_BACKGROUND: 55,
	FIGURE_INACTIVE_BACKGROUND: 56,
	FIGURE_BORDER: 57,
	FIGURE_SIZE: 58,
	FIGURE_NAME: 59,
	FIGURE_STATE: 60,
	getFill: function (value) {
		if (typeof value === "string") {
			var s = value.trim().toLowerCase();
			if (s.indexOf("linear") == 0) {
				value = new LinearGradient(s);
			} else if (s.indexOf("radial") == 0) {
				value = new RadialGradient(s);
			} else if (s.indexOf("glass") == 0) {
				value = new GlassGradient(s);
			} else {
				value = new SolidBrush(s);
			}
		} 
		return value;
	},
    getFillText: function (fill) {
        return fill ? fill.toText() : null;
    },
	getStroke: function (value) {
		if (typeof value === "string") {
			var arr = value.trim().split(",");
			value = new SolidPen(arr[0], arr[1]);
		} 
		return value;
	},
    getStrokeText: function (stroke) {
        return stroke ? stroke.toText() : null;
    },
	getFont: function (value) {
		var font = [];
		var s = String(value);
		var arr, len;
		var sz = DEF_FONT_SIZE;
		if (s) {
			arr = s.toLowerCase().split($$_FONT_REG);
			len = arr.length;
			var family = null;
			var bold = false;
			var italic = false;
			if (len > 0 && arr[0]) {
				family = arr[0];
			}
			if (len > 1 && arr[1]) {
				sz = Number(arr[1]);
			}
			for (var i = 2; i < len; i++) {
				s = arr[i];
				if (s) {
					s = s.toLowerCase();
					switch (s) {
						case "bold":
							bold = true;
							break;
						case "italic":
							italic = true;
							break;
						default:
							break;
					}
				}
			}
			if (italic) {
				font.push("italic");
			}
			if (bold) {
				font.push("bold");
			}
			font.push(sz + "px");
			family && font.push(family);
		}
		s = font.join(" ");
		return { font: s, size: sz };
	},
	getDimension: function (value) {
		if (!(value instanceof Dimension)) {
			value = new Dimension(value);
		} 
		return value;
	},
    getDimensionText: function (dim) {
        return dim ? dim.toString() : null;
    }
}, function (f) {
	f.Default = new f(null, "defaultStyles");
	initStyles(f.Default);
	function initStyles(s) {
		s._background = SolidBrush.WHITE;
		s._selectedBackground = SolidBrush.DKGRAY;
		s._inactiveBackground = SolidBrush.LTGRAY;
		s._border = null;
		s._borderLeft = null;
		s._borderRight = null;
		s._borderTop = null;
		s._borderBottom = null;
		s._line = null;
		s._fontFamily = "Tahoma";
		s._fontSize = 12;
		s._fontBold = false;
		s._fontItalic = false;
		s._fontUnderline = false;
		s._fontLinethrough = false;
		s._textWrap = TextWrapMode.NONE;
		s._foreground = SolidBrush.BLACK;
		s._selectedForeground = SolidBrush.WHITE;
		s._inactiveForeground = SolidBrush.GRAY;
		s._textAlignment = Alignment.CENTER;
		s._lineAlignment = Alignment.CENTER;
		s._numberFormat = null;
		s._datetimeFormat = null;
		s._booleanFormat = null;
		s._prefix = null;
		s._suffix = null;
		s._paddingLeft = 0;
		s._paddingRight = 0;
		s._paddingTop = 0;
		s._paddingBottom = 0;
		s._iconIndex = 0;
		s._iconLocation = IconLocation.LEFT;
		s._iconAlignment = Alignment.CENTER;
		s._iconOffset = 0;
		s._iconPadding = 2;
		s._contentFit = ContentFit.AUTO;
		s._selectionDisplay = SelectionDisplay.MASK;
		s._hoveredMaskBackground = new SolidBrush(0x1F5292F7);
		s._hoveredMaskBorder = new SolidPen(0x335292F7);
		s._hoveredBackground = null;
		s._hoveredForeground = null;
		s._figureBackground = new SolidBrush(0xff008800);
		s._figureInactiveBackground = SolidBrush.LTGRAY;
		s._figureBorder = null;
		s._figureSize = null;
		s._figureName = null;
		s._figureState = null;
	}
	f.STYLE_NAMES = {
		background: f.BACKGROUND,
		selectedBackground: f.SELECTED_BACKGROUND,
		inactiveBackground: f.INACTIVE_BACKGROUND,
		border: f.BORDER,
		borderLeft: f.BORDER_LEFT,
		borderRight: f.BORDER_RIGHT,
		borderTop: f.BORDER_TOP,
		borderBottom: f.BORDER_BOTTOM,
		line: f.LINE,
		renderer: f.RENDERER,
		fontFamily: f.FONT_FAMILY,
		fontSize: f.FONT_SIZE,
		fontBold: f.FONT_BOLD,
		fontItalic: f.FONT_ITALIC,
		fontUnderline: f.FONT_UNDERLINE,
		fontLinethrough: f.FONT_LINETHROUGH,
		textWrap: f.TEXT_WRAP,
		foreground: f.FOREGROUND,
		selectedForeground: f.SELECTED_FOREGROUND,
		inactiveForeground: f.INACTIVE_FOREGROUND,
		textAlignment: f.TEXT_ALIGNMENT,
		lineAlignment: f.LINE_ALIGNMENT,
		numberFormat: f.NUMBER_FORMAT,
		datetimeFormat: f.DATETIME_FORMAT,
		booleanFormat: f.BOOLEAN_FORMAT,
		prefix: f.PREFIX,
		suffix: f.SUFFIX,
		paddingLeft: f.PADDING_LEFT,
		paddingRight: f.PADDING_RIGHT,
		paddingTop: f.PADDING_TOP,
		paddingBottom: f.PADDING_BOTTOM,
		iconIndex: f.ICON_INDEX,
		iconLocation: f.ICON_LOCATION,
		iconAlignment: f.ICON_ALIGNMENT,
		iconOffset: f.ICON_OFFSET,
		iconPadding: f.ICON_PADDING,
		contentFit: f.CONTENT_FIT,
		selectionDisplay: f.SELECTION_DISPLAY,
		hoveredMaskBackground: f.HOVERED_MASK_BACKGROUND,
		hoveredMaskBorder: f.HOVERED_MASK_BORDER,
		hoveredBackground: f.HOVERED_BACKGROUND,
		hoveredForeground: f.HOVERED_FOREGROUND,
		figureBackground: f.FIGURE_BACKGROUND,
		figureInactiveBackground: f.FIGURE_INACTIVE_BACKGROUND,
		figureBorder: f.FIGURE_BORDER,
		figureSize: f.FIGURE_SIZE,
		figureName: f.FIGURE_NAME,
		figureState: f.FIGURE_STATE
	};
});
VisualStyles.CHANGED = "onVisualStylesChanged";
var GridStyleSheet = defineClass("GridStyleSheet", null, {
	init : function() {
		this._super();
		this._grid = new VisualStyles(null, GridStyleSheet.DEFAULT, null, false);
		this._panel = new VisualStyles(null, GridStyleSheet.PANEL, null, false);
		this._body = new VisualStyles(null, GridStyleSheet.BODY, null, false);
		this._bodyEmpty = new VisualStyles(null, GridStyleSheet.BODY_EMPTY, null, false);
		this._bodyRowHover = new VisualStyles(null, GridStyleSheet.BODY_ROWHOVER, null, false);
		this._bodyRowFocus = new VisualStyles(null, GridStyleSheet.BODY_ROWFOCUS, null, false);
		this._fixed = new VisualStyles(null, GridStyleSheet.FIXED, null, false);
		this._fixedColBar = new VisualStyles(null, GridStyleSheet.FIXED_COLBAR, null, false);
		this._fixedRowBar = new VisualStyles(null, GridStyleSheet.FIXED_ROWBAR, null, false);
		this._header = new VisualStyles(null, GridStyleSheet.HEADER, null, false);
		this._headerGroup = new VisualStyles(null, GridStyleSheet.HEADER_GROUP, null, false);
        this._headerSub = new VisualStyles(null, GridStyleSheet.HEADER_SUB, null, false);
        this._headerSummary = new VisualStyles(null, GridStyleSheet.HEADER_SUMMARY, null, false);
		this._footer = new VisualStyles(null, GridStyleSheet.FOOTER, null, false);
		this._footerGroup = new VisualStyles(null, GridStyleSheet.FOOTER_GROUP, null, false);
		this._rowGroupHead = new VisualStyles(null, GridStyleSheet.ROWGROUP_HEAD, null, false);
		this._rowGroupFoot = new VisualStyles(null, GridStyleSheet.ROWGROUP_FOOT, null, false);
		this._rowGroupSummary = new VisualStyles(null, GridStyleSheet.ROWGROUP_SUMMARY, null, false);
		this._rowGroupHeader = new VisualStyles(null, GridStyleSheet.ROWGROUP_HEADER, null, false);
		this._rowGroupFooter = new VisualStyles(null, GridStyleSheet.ROWGROUP_FOOTER, null, false);
		this._rowGroupPanel = new VisualStyles(null, GridStyleSheet.ROWGROUP_PANEL, null, false);
		this._rowGroupBar = new VisualStyles(null, GridStyleSheet.ROWGROUP_BAR, null, false);
		this._rowGroupHeaderBar = new VisualStyles(null, GridStyleSheet.ROWGROUP_HEADER_BAR, null, false);
		this._rowGroupFooterBar = new VisualStyles(null, GridStyleSheet.ROWGROUP_FOOTER_BAR, null, false);
		this._indicator = new VisualStyles(null, GridStyleSheet.INDICATOR, null, false);
		this._indicatorHead = new VisualStyles(null, GridStyleSheet.INDICATOR_HEAD, null, false);
		this._indicatorFoot = new VisualStyles(null, GridStyleSheet.INDICATOR_FOOT, null, false);
        this._indicatorSum = new VisualStyles(null, GridStyleSheet.INDICATOR_SUM, null, false);
		this._checkBar = new VisualStyles(null, GridStyleSheet.CHECKBAR, null, false);
		this._checkBarHead = new VisualStyles(null, GridStyleSheet.CHECKBAR_HEAD, null, false);
		this._checkBarFoot = new VisualStyles(null, GridStyleSheet.CHECKBAR_FOOT, null, false);
        this._checkBarSum = new VisualStyles(null, GridStyleSheet.CHECKBAR_SUM, null, false);
		this._stateBar = new VisualStyles(null, GridStyleSheet.STATEBAR, null, false);
		this._stateBarHead = new VisualStyles(null, GridStyleSheet.STATEBAR_HEAD, null, false);
		this._stateBarFoot = new VisualStyles(null, GridStyleSheet.STATEBAR_FOOT, null, false);
        this._stateBarSum = new VisualStyles(null, GridStyleSheet.STATEBAR_SUM, null, false);
		this._selection = new VisualStyles(null, GridStyleSheet.SELECTION, null, false);
		this._treeExpander = new VisualStyles(null, GridStyleSheet.TREE_EXPANDER, null, false);
		this._fixedTreeExpander = new VisualStyles(null, GridStyleSheet.FIXED_TREE_EXPANDER, null, false);
		this._scrollBar = new VisualStyles(null, GridStyleSheet.SCROLLBAR, null, false);
		this._scrollThumb = new VisualStyles(null, GridStyleSheet.SCROLLTHUMB, null, false);
		this._scrollButton = new VisualStyles(null, GridStyleSheet.SCROLLBUTTON, null, false);
	},
	destroy: function() {
		return false;
	},
	getGrid: function () { return this._grid; },
	getPanel: function () { return this._panel; },
	getBody: function () { return this._body; },
	getBodyEmpty: function () { return this._bodyEmpty; },
	getBodyRowHover: function() { return this._bodyRowHover; },
	getBodyRowFocus: function() { return this._bodyRowFocus; },
	getFixed: function () { return this._fixed; },
	getFixedColBar: function () { return this._fixedColBar; },
	getFixedRowBar: function () { return this._fixedRowBar; },
	getHeader: function () { return this._header; },
	getHeaderGroup: function () { return this._headerGroup; },
    getHeaderSub: function () { return this._headerSub; },
    getHeaderSummary: function () { return this._headerSummary; },
	getFooter: function () { return this._footer; },
	getFooterGroup: function () { return this._footerGroup; },
	getRowGroupHead: function () { return this._rowGroupHead; },
	getRowGroupFoot: function () { return this._rowGroupFoot; },
	getRowGroupSummary: function () { return this._rowGroupSummary; },
	getRowGroupHeader: function () { return this._rowGroupHeader; },
	getRowGroupFooter: function () { return this._rowGroupFooter; },
	getRowGroupPanel: function () { return this._rowGroupPanel; },
	getRowGroupBar: function () { return this._rowGroupBar; },
	getRowGroupHeaderBar: function () { return this._rowGroupHeaderBar; },
	getRowGroupFooterBar: function () { return this._rowGroupFooterBar; },
	getIndicator: function () { return this._indicator; },
	getIndicatorHead: function () { return this._indicatorHead; },
	getIndicatorFoot: function () { return this._indicatorFoot; },
    getIndicatorSum: function () { return this._indicatorSum; },
	getCheckBar: function () { return this._checkBar; },
	getCheckBarHead: function () { return this._checkBarHead; },
	getCheckBarFoot: function () { return this._checkBarFoot; },
    getCheckBarSum: function () { return this._checkBarSum; },
	getStateBar: function () { return this._stateBar; },
	getStateBarHead: function () { return this._stateBarHead; },
	getStateBarFoot: function () { return this._stateBarFoot; },
    getStateBarSum: function () { return this._stateBarSum; },
	getSelection: function () { return this._selection; },
	getTreeExpander: function () { return this._treeExpander; },
	getFixedTreeExpander: function () { return this._fixedTreeExpander; },
	getScrollBar: function() {return this._scrollBar;},
	getScrollThumb: function() {return this._scrollThumb;},
	getScrollButton: function() {return this._scrollButton;},
	grid: function () { return this._grid; },
	panel: function () { return this._panel; },
	body: function () { return this._body; },
	bodyEmpty: function () { return this._bodyEmpty; },
	bodyRowHover: function() { return this._bodyRowHover},
	bodyRowFocus: function() { return this._bodyRowFocus},
	fixed: function () { return this._fixed; },
	fixedColBar: function () { return this._fixedColBar; },
	fixedRowBar: function () { return this._fixedRowBar; },
	header: function () { return this._header; },
	headerGroup: function () { return this._headerGroup; },
    headerSub: function () { return this._headerSub; },
    headerSummary: function () { return this._headerSummary; },
	footer: function () { return this._footer; },
	footerGroup: function () { return this._footerGroup; },
	rowGroupHead: function () { return this._rowGroupHead; },
	rowGroupFoot: function () { return this._rowGroupFoot; },
	rowGroupSummary: function () { return this._rowGroupSummary; },
	rowGroupHeader: function () { return this._rowGroupHeader; },
	rowGroupFooter: function () { return this._rowGroupFooter; },
	rowGroupPanel: function () { return this._rowGroupPanel; },
	rowGroupBar: function () { return this._rowGroupBar; },
	rowGroupHeaderBar: function () { return this._rowGroupHeaderBar; },
	rowGroupFooterBar: function () { return this._rowGroupFooterBar; },
	indicator: function () { return this._indicator; },
	indicatorHead: function () { return this._indicatorHead; },
	indicatorFoot: function () { return this._indicatorFoot; },
    indicatorSum: function () { return this._indicatorSum; },
	checkBar: function () { return this._checkBar; },
	checkBarHead: function () { return this._checkBarHead; },
	checkBarFoot: function () { return this._checkBarFoot; },
    checkBarSum: function () { return this._checkBarSum; },
	stateBar: function () { return this._stateBar; },
	stateBarHead: function () { return this._stateBarHead; },
	stateBarFoot: function () { return this._stateBarFoot; },
    stateBarSum: function () { return this._stateBarSum; },
	selection: function () { return this._selection; },
	treeExpander: function () { return this._treeExpander; },
	fixedTreeExpander: function () { return this._fixedTreeExpander; },
	scrollBar: function() {return this._scrollBar;},
	scrollThumb: function() {return this._scrollThumb;},
	scrollButton: function() {return this._scrollButton;}
}, {
	DEFAULT: "default",
    GRID: "grid",
	PANEL: "panel",
	BODY: "body",
	BODY_EMPTY: "body.empty",
	BODY_ROWHOVER: "body.rowHover",
	BODY_ROWFOCUS: "body.rowFocus",
	FIXED: "fixed",
	FIXED_COLBAR: "fixed.colBar",
	FIXED_ROWBAR: "fixed.rowBar",
	HEADER: "header",
	HEADER_GROUP: "header.group",
    HEADER_SUB: "header.sub",
    HEADER_SUMMARY: "header.summary",
	FOOTER: "footer",
	FOOTER_GROUP: "footer.group",
	ROWGROUP_HEADER: "rowGroup.header",
	ROWGROUP_FOOTER: "rowGroup.footer",
	ROWGROUP_HEAD: "rowGroup.head",
	ROWGROUP_FOOT: "rowGroup.foot",
	ROWGROUP_SUMMARY: "rowGroup.summary",
	ROWGROUP_BAR: "rowGroup.bar",
	ROWGROUP_HEADER_BAR: "rowGroup.headerBar",
	ROWGROUP_FOOTER_BAR: "rowGroup.footerBar",
	ROWGROUP_PANEL: "rowGroup.panel",
	ROWGROUP_LEVELS: "rowGroup.levels",
	INDICATOR: "indicator",
	INDICATOR_HEAD: "indicator.head",
	INDICATOR_FOOT: "indicator.foot",
    INDICATOR_SUMMARY: "indicator.summary",
	CHECKBAR: "checkBar",
	CHECKBAR_HEAD: "checkBar.head",
	CHECKBAR_FOOT: "checkBar.foot",
    CHECKBAR_SUMMARY: "checkBar.summary",
	STATEBAR: "stateBar",
	STATEBAR_HEAD: "stateBar.head",
	STATEBAR_FOOT: "stateBar.foot",
    STATEBAR_SUMMARY: "stateBar.summary",
	SELECTION: "selection",
	TREE_EXPANDER: "tree.expander",
	FIXED_TREE_EXPANDER: "fixed.tree.expander",
	SCROLLBAR: "scrollBar",
	SCROLLTHUMB: "scrollBar.thumb",
	SCROLLBUTTON:"scrollBar.button",
	clearStyles: function (grid) {
		grid.beginUpdate();
		try {
			grid.styles().clearValues();
			grid.panel().styles().clearValues();
			grid.body()().styles()().clearValues();
			grid.body().emptyStyles().clearValues();
			grid.body().rowHoverStyles().clearValues();
			grid.body().rowFocusStyles().clearValues();
			grid.fixedOptions().styles().clearValues();
			grid.fixedOptions().colBarStyles().clearValues();
			grid.fixedOptions().rowBarStyles().clearValues();
			grid.header().styles().clearValues();
			grid.header().groupStyles().clearValues();
            grid.header().subStyles().clearValues();
            grid.header().summary().styles().clearValues();
			grid.footer().styles().clearValues();
			grid.footer().groupStyles().clearValues();
			grid.rowGroup().headStyles().clearValues();
			grid.rowGroup().footStyles().clearValues();
			grid.rowGroup().summaryStyles().clearValues();
			grid.rowGroup().headerStyles().clearValues();
			grid.rowGroup().footerStyles().clearValues();
			grid.rowGroup().panelStyles().clearValues();
			grid.rowGroup().barStyles().clearValues();
			grid.rowGroup().headerBarStyles().clearValues();
			grid.rowGroup().footerBarStyles().clearValues();
			grid.indicator().styles().clearValues();
			grid.indicator().headStyles().clearValues();
			grid.indicator().footStyles().clearValues();
            grid.indicator().summaryStyles().clearValues();
			grid.checkBar().styles().clearValues();
			grid.checkBar().headStyles().clearValues();
			grid.checkBar().footStyles().clearValues();
            grid.checkBar().summaryStyles().clearValues();
			grid.stateBar().styles().clearValues();
			grid.stateBar().headStyles().clearValues();
			grid.stateBar().footStyles().clearValues();
            grid.stateBar().summaryStyles().clearValues();
			grid.selectOptions().maskStyles().clearValues();
			grid.displayOptions().scrollBarStyles().clearValues();
			grid.displayOptions().scrollThumbStyles().clearValues();
			grid.displayOptions().scrollButtonStyles().clearValues();
			if (grid instanceof TreeView) {
				grid.treeOptions().expanderStyles().clearValues();
			}
		} finally {
			grid.endUpdate();
		}
	}
});
GridStyleSheet.Default = (function () {
	var t = getTimer();
	var sheet = new GridStyleSheet();
	var s = sheet._grid;
	s.background(SolidBrush.WHITE);
	s.foreground(SolidBrush.BLACK);
	s.border(new SolidPen(0xffaaaaaa));
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(null);
	s.borderBottom(null);
	s.inactiveBackground(SolidBrush.LTGRAY);
	s.fontFamily("Tahoma");
	s.fontSize(12);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.textAlignment(Alignment.NEAR);
	s.lineAlignment(Alignment.CENTER);
	s.iconLocation(IconLocation.LEFT);
	s.iconAlignment(Alignment.CENTER);
	s.iconPadding(2);
	s.contentFit(ContentFit.AUTO);
	s.figureBackground(SolidBrush.BLACK);
	s = sheet._panel;
	s.background(new SolidBrush(0xffcccccc));
	s.foreground(SolidBrush.BLACK);
	s.borderRight(new SolidPen(0xff777777));
	// s.borderBottom(new SolidPen(0xff777777));
	s.paddingLeft(0);
	s.paddingTop(4);
	s.paddingBottom(5);
	s.paddingRight(2);
	s.textAlignment(Alignment.NEAR);
	s.lineAlignment(Alignment.CENTER);
	s = sheet._body;
	s.background(SolidBrush.WHITE);
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(new SolidPen(0xffcccccc));
	s.borderBottom(s.borderRight());
	s.line(SolidPen.DKGRAY); 
	s.paddingTop(2);
	s.paddingBottom(2);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.textAlignment(Alignment.NEAR);
	s.lineAlignment(Alignment.CENTER);
	s.iconLocation(IconLocation.LEFT);
	s.iconAlignment(Alignment.CENTER);
	s.iconPadding(2);
	s.contentFit(ContentFit.AUTO);
	s.figureInactiveBackground(SolidBrush.LTGRAY);
	s = sheet._bodyEmpty;
	s.background(new SolidBrush(0xfff8f8f8));
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(new SolidPen(0xff999999));
	s.borderBottom(s.borderRight());
	s.paddingTop(2);
	s.paddingBottom(2);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.fontSize(14);
	s.textAlignment(Alignment.NEAR);
	s.lineAlignment(Alignment.NEAR);
	s = sheet._bodyRowHover;
	s.background(new SolidBrush(0x2065686b));
	s.border(null);
	s = sheet._bodyRowFocus;
	s.background(new SolidBrush(0x30888888));
	s.border(null);
	s = sheet._fixed;
	s.background(SolidBrush.LTGRAY);
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(new SolidPen(0xff999999));
	s.borderBottom(s.borderRight());
	s.paddingTop(2);
	s.paddingBottom(2);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.textAlignment(Alignment.NEAR);
	s.lineAlignment(Alignment.CENTER);
	s.figureInactiveBackground(SolidBrush.LTGRAY);
	s = sheet._fixedColBar;
	s.background(SolidBrush.LTGRAY);
	s.borderRight(new SolidPen(0xff999999));
	s.borderBottom(s.borderRight());
	s = sheet._fixedRowBar;
	s.background(SolidBrush.LTGRAY);
	s.borderRight(new SolidPen(0xff999999));
	s.borderBottom(s.borderRight());
	s = sheet._header;
	s.background(new LinearGradient("linear #ffffff #cccccc 90"));
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(SolidPen.GRAY);
	s.borderBottom(SolidPen.GRAY);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.textAlignment(Alignment.CENTER);
	s.lineAlignment(Alignment.CENTER);
	s.textWrap(TextWrapMode.NORMAL);
	s.hoveredBackground(SolidBrush.LTGRAY);
	s = sheet._headerGroup;
	s.background(new LinearGradient("linear #ffffff #aaaaaa 90"));
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(SolidPen.GRAY);
	s.borderBottom(SolidPen.GRAY);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.textAlignment(Alignment.CENTER);
	s.lineAlignment(Alignment.CENTER);
	s.textWrap(TextWrapMode.NORMAL);
    s = sheet._headerSub;
    s.foreground(SolidBrush.BLACK);
    s.textAlignment(Alignment.CENTER);
    s.lineAlignment(Alignment.CENTER);
    s.textWrap(TextWrapMode.NORMAL);
    s = sheet._headerSummary;
    s.background(new SolidBrush(0xffeeeeee));
    s.foreground(SolidBrush.BLACK);
    s.borderLeft(null);
    s.borderTop(null);
    s.borderRight(SolidPen.GRAY);
    s.borderBottom(SolidPen.GRAY);
    s.paddingLeft(2);
    s.paddingRight(2);
    s.paddingTop(1);
    s.paddingBottom(2);
    s.textAlignment(Alignment.FAR);
    s.lineAlignment(Alignment.CENTER);
	s = sheet._footer;
	s.background(new SolidBrush(0xffeeeeee));
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderBottom(null);
	s.borderRight(SolidPen.GRAY);
	s.borderTop(SolidPen.GRAY);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.paddingTop(2);
	s.paddingBottom(1);
	s.textAlignment(Alignment.FAR);
	s.lineAlignment(Alignment.CENTER);
	s = sheet._footerGroup;
	s.background(new SolidBrush(0xffeeeeee));
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderBottom(null);
	s.borderRight(SolidPen.GRAY);
	s.borderTop(SolidPen.GRAY);
	s.paddingTop(2);
	s.paddingBottom(1);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.textAlignment(Alignment.FAR);
	s.lineAlignment(Alignment.CENTER);
	s = sheet._rowGroupHeader;
	s.background(SolidBrush.GRAY);
	s.foreground(SolidBrush.WHITE);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(SolidPen.DKGRAY);
	s.borderBottom(SolidPen.DKGRAY);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.textAlignment(Alignment.NEAR);
	s.lineAlignment(Alignment.CENTER);
	s.figureBackground(SolidBrush.WHITE);
	s = sheet._rowGroupFooter;
	s.background(new SolidBrush(0xffdddddd));
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(SolidPen.GRAY);
	s.borderBottom(SolidPen.GRAY);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.textAlignment(Alignment.FAR);
	s.lineAlignment(Alignment.CENTER);
	s.figureBackground(SolidBrush.GRAY);
	s = sheet._rowGroupPanel;
	s.background(new LinearGradient("linear #ffffff #cccccc 90"));
	s.foreground(SolidBrush.BLACK);
	s.border(SolidPen.DKGRAY);
	s.line(new SolidPen(0xff333333, 1));
	s.paddingLeft(1);
	s.paddingRight(1);
	s.paddingTop(1);
	s.paddingBottom(1);
	s.textAlignment(Alignment.CENTER);
	s.lineAlignment(Alignment.CENTER);
	s = sheet._rowGroupBar;
	s.borderLeft(null);
	s.borderRight(SolidPen.DKGRAY);
	s.borderTop(null);
	s.borderBottom(null);
	s = sheet._rowGroupHeaderBar;
	s.borderLeft(null);
	s.borderRight(null);
	s.borderTop(null);
	s.borderBottom(null);
	s = sheet._rowGroupFooterBar;
	s.borderLeft(null);
	s.borderRight(null);
	s.borderTop(null);
	s.borderBottom(SolidPen.GRAY);
	s = sheet._indicator;
	s.background(new LinearGradient("linear #e5e5e5 #ffffff 180"));
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(SolidPen.GRAY);
	s.borderBottom(SolidPen.GRAY);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.textAlignment(Alignment.CENTER);
	s.lineAlignment(Alignment.CENTER);
	s.hoveredBackground(SolidBrush.LTGRAY);
	s.selectedBackground(SolidBrush.LTGRAY);
	s.selectedForeground(SolidBrush.RED);
	s.figureBackground(SolidBrush.BLACK);
	s = sheet._checkBar;
	s.background(SolidBrush.WHITE);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(SolidPen.GRAY);
	s.borderBottom(SolidPen.GRAY);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.textAlignment(Alignment.CENTER);
	s.lineAlignment(Alignment.CENTER);
	s.figureBackground(new SolidBrush(0xff555555));
	s.figureInactiveBackground(new SolidBrush(0xffeeeeee))
	s.figureSize(new Dimension(12));
	s.line(new SolidPen("rgba(170, 170, 170, 0.7)"));
	s =sheet._checkBarHead;
	s.figureBackground(new SolidBrush(0xff555555));
	s.figureInactiveBackground(SolidBrush.LTGRAY);
	s.figureSize(new Dimension(12));
	s = sheet._stateBar;
	s.background(SolidBrush.WHITE);
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(SolidPen.GRAY);
	s.borderBottom(SolidPen.GRAY);
	s.paddingLeft(2);
	s.paddingRight(2);
	s.paddingTop(2);
	s.paddingBottom(2);
	s.textAlignment(Alignment.CENTER);
	s.lineAlignment(Alignment.CENTER);
	s = sheet._selection;
	s.background(new SolidBrush(0x2F1E90FF));
	s.border(new SolidPen(0x5F1E90FF, 2));
	s = sheet._treeExpander;
	s.foreground(SolidBrush.BLACK);
	s.borderLeft(null);
	s.borderTop(null);
	s.borderRight(null);
	s.borderBottom(new SolidPen(0xffcccccc));
	s.paddingTop(0);
	s.paddingBottom(0);
	s.paddingLeft(0);
	s.paddingRight(2);
	s.figureBackground(SolidBrush.GRAY);
	s.figureSize(new Dimension(9));
	s.line(SolidPen.GRAY);
	s = sheet._scrollBar;
	s.background(new SolidBrush("#fff0f0f0"));
	s = sheet._scrollThumb;
	s.background(new SolidBrush("#ffc0c0c0"));
	s.hoveredBackground(new SolidBrush("#ffa0a0a0"));
	s.selectedBackground(new SolidBrush("#ff808080"));
	s = sheet._scrollButton;
	s.background(new SolidBrush("#fff0f0f0"));
	s.hoveredBackground(new SolidBrush("#ffd0c0d0"));
	s.selectedBackground(new SolidBrush("#ff808080"));
	s.foreground(new SolidBrush("#ff333333"));
	s.hoveredForeground(new SolidBrush("#ff333333"));
	s.selectedForeground(new SolidBrush("#ffffffff"));
	t = getTimer() - t;
	// trace("init default style sheet: " + t + " msecs.");
	return sheet;
})();
var GRID_STYLES = "grid";
var PANEL_STYLES = "panel";
var BODY_STYLES = "body";
var FIXED_STYLES = "fixed";
var SORTING_STYLES = "sorting"
var HEADER_STYLES = "header";
var FOOTER_STYLES = "footer";
var ROW_GROUP_STYLES = "rowGroup";
var INDICATOR_STYLES = "indicator";
var ROW_HEADER_STYLES = "rowHeader";
var CHECKBAR_STYLES = "checkBar";
var STATUSBAR_STYLES = "statusBar";
var STATEBAR_STYLES = "stateBar";
var SELECTION_STYLES = "selection";
var MOBILE_SELECTION_STYLES = "mobileSelection";
var TREE_STYLES = "tree";
var COLUMNS_STYLES = "columns";
var SCROLLBAR_STYLES = "scrollBar";
var /* abstract */ StylesArchiver = defineClass("StylesArchiver", null, {
	init: function() {
		this._super();
	},
	loadGridStyles: function(source, grid) {
		this._loadGrid(source, grid);
	},
	loadGrid: function (source, grid) {
	},
	saveGrid: function (grid) {
	},
	loadStyles: function (source, styles) {
	},
	saveStyles: function (styles) {
	}
}, {
	applyStyles: function (source, styles, fireEvents) {
		fireEvents = arguments.length > 2 ? fireEvents : true;
		if (source && styles) {
			styles.extend(source, fireEvents);
		}
	},
	deserialize: function (source, grid) {
		function setStyles(styleName, styles) {
			if (styles && source && source.hasOwnProperty(styleName)) {
				var obj = source[styleName];
				if (obj) {
					styles.extend(obj);
					return true;
				}
			}
			return false;
		}
		function setChildStyles(parentStyle, styleName, styles) {
			var obj = source[parentStyle][styleName];
			if (obj) {
				styles.extend(obj);
				return true;
			}
			return false;
		}
		var owner;
		var styles;
		var s;
		var scase;
		var style;
		var obj;
		var i;
		setStyles(GRID_STYLES, grid.styles());
		setStyles(PANEL_STYLES, grid.panel().styles());
		var body = grid.body();
		if (setStyles(BODY_STYLES, body.styles())) {
			setChildStyles(BODY_STYLES, "empty", body.emptyStyles());
			setChildStyles(BODY_STYLES, "rowHover", body.rowHoverStyles());
			setChildStyles(BODY_STYLES, "rowFocus", body.rowFocusStyles());
			obj = source[BODY_STYLES].dynamicStyles;
			if (obj) {
				owner = grid.body().dynamicStyles().owner();
				styles = [];
				if (typeof obj === "function") {
					style = new DynamicStyleImpl(owner);
					style.setCriteria(obj);
					styles.push(style);
				} else {
					for (i = 0; i < obj.length; i++) {
						s = obj[i];
						if (_isArray(s.criteria)) {
							scase = new DynamicStyleCase(owner);
							scase.setCriteria(s.criteria);
							if (_isArray(s.styles)) {
								scase.setStyles(s.styles);
							} else {
								scase.setStyles([s.styles]);
							}
							styles.push(scase);
						} else {
							style = new DynamicStyleImpl(owner);
							style.setCriteria(s.criteria);
							style.setStyles(s.styles);
							styles.push(style);
						}
					}
				}
				body.setDynamicStyles(styles);
			} else {
				source[BODY_STYLES].hasOwnProperty("dynamicStyles") && body.setDynamicStyles(null);
			};
			obj = source[BODY_STYLES].cellDynamicStyles;
			if (obj) {
				owner = body.cellDynamicStyles().owner();
				styles = [];
				if (typeof obj === "function") {
					style = new DynamicStyleImpl(owner);
					style.setCriteria(obj);
					styles.push(style);
				} else {
					for (i = 0; i < obj.length; i++) {
						s = obj[i];
						if (_isArray(s.criteria)) {
							scase = new DynamicStyleCase(owner);
							scase.setCriteria(s.criteria);
							if (_isArray(s.styles)) {
								scase.setStyles(s.styles);
							} else {
								scase.setStyles([s.styles]);
							}
							styles.push(scase);
						} else {
							style = new DynamicStyleImpl(owner);
							style.setCriteria(s.criteria);
							style.setStyles(s.styles);
							styles.push(style);
						}
					}
				}
				body.setCellDynamicStyles(styles);
			} else {
				source[BODY_STYLES].hasOwnProperty("cellDynamicStyles") && body.setCellDynamicStyles(null);
			};
		}
		var fixedOptions = grid.fixedOptions();
		if (setStyles(FIXED_STYLES, fixedOptions.styles())) {
			setChildStyles(FIXED_STYLES, "colBar", fixedOptions.colBarStyles());
			setChildStyles(FIXED_STYLES, "rowBar", fixedOptions.rowBarStyles());
		}
		var sortingOptions = grid.sortingOptions();
		if (setStyles(SORTING_STYLES, sortingOptions.sortOrderStyles())) {
		}
		var header = grid.header();
		if (setStyles(HEADER_STYLES, header.styles())) {
			setChildStyles(HEADER_STYLES, "group", header.groupStyles());
            setChildStyles(HEADER_STYLES, "sub", header.subStyles());
            setChildStyles(HEADER_STYLES, "summary", header.summary().styles());
		}
		var footer = grid.footer();
		if (setStyles(FOOTER_STYLES, footer.styles())) {
			setChildStyles(FOOTER_STYLES, "group", footer.groupStyles());
		}
		if (source && source.hasOwnProperty(ROW_GROUP_STYLES)) {
			var rowGroup = grid.rowGroup();
			setChildStyles(ROW_GROUP_STYLES, "header", rowGroup.headerStyles());
			setChildStyles(ROW_GROUP_STYLES, "footer", rowGroup.footerStyles());
			setChildStyles(ROW_GROUP_STYLES, "head", rowGroup.headStyles());
			setChildStyles(ROW_GROUP_STYLES, "foot", rowGroup.footStyles());
			setChildStyles(ROW_GROUP_STYLES, "summary", rowGroup.summaryStyles());
			setChildStyles(ROW_GROUP_STYLES, "headerBar", rowGroup.headerBarStyles());
			setChildStyles(ROW_GROUP_STYLES, "footerBar", rowGroup.footerBarStyles());
			setChildStyles(ROW_GROUP_STYLES, "bar", rowGroup.barStyles());
			setChildStyles(ROW_GROUP_STYLES, "panel", rowGroup.panelStyles());
			var levels = source[ROW_GROUP_STYLES].rowGroupLevels;
			if (levels) {
				for (i = 0; i < Math.min(levels.length, rowGroup.levelCount); i++) {
					obj = levels[i];
					var glevel = rowGroup.getLevel(i);
					if (obj.header) {
						glevel.headerStyles().extend(obj.header);
					}
					if (obj.footer) {
						glevel.footerStyles().extend(obj.footer);
					}
					if (obj.headerBar) {
						glevel.headerBarStyles().extend(obj.headerBar);
					}
					if (obj.footerBar) {
						glevel.footerBarStyles().extend(obj.footerBar);
					}
					if (obj.bar) {
						glevel.barStyles().extend(obj.bar);
					}
				}
			}
		}
		var indicator = grid.indicator();
        if (setStyles(ROW_HEADER_STYLES, indicator.styles())) {
            setChildStyles(ROW_HEADER_STYLES, "head", indicator.headStyles());
            setChildStyles(ROW_HEADER_STYLES, "foot", indicator.footStyles());
            setChildStyles(ROW_HEADER_STYLES, "summary", indicator.summaryStyles());
        } else if (setStyles(INDICATOR_STYLES, indicator.styles())) {
			setChildStyles(INDICATOR_STYLES, "head", indicator.headStyles());
			setChildStyles(INDICATOR_STYLES, "foot", indicator.footStyles());
            setChildStyles(INDICATOR_STYLES, "summary", indicator.summaryStyles());
		}
		var checkBar = grid.checkBar();
		if (setStyles(CHECKBAR_STYLES, checkBar.styles())) {
			setChildStyles(CHECKBAR_STYLES, "head", checkBar.headStyles());
			setChildStyles(CHECKBAR_STYLES, "foot", checkBar.footStyles());
            setChildStyles(CHECKBAR_STYLES, "summary", checkBar.summaryStyles());
		}
		var stateBar = grid.stateBar();
		if (setStyles(STATUSBAR_STYLES, stateBar.styles())) {
			setChildStyles(STATUSBAR_STYLES, "head", stateBar.headStyles());
			setChildStyles(STATUSBAR_STYLES, "foot", stateBar.footStyles());
            setChildStyles(STATUSBAR_STYLES, "summary", stateBar.summaryStyles());
		}
		if (setStyles(STATEBAR_STYLES, stateBar.styles())) {
			setChildStyles(STATEBAR_STYLES, "head", stateBar.headStyles());
			setChildStyles(STATEBAR_STYLES, "foot", stateBar.footStyles());
            setChildStyles(STATEBAR_STYLES, "summary", stateBar.summaryStyles());
		}
		var displayOptions = grid.displayOptions();
		if (setStyles(SCROLLBAR_STYLES, displayOptions.scrollBarStyles())) {
			setChildStyles(SCROLLBAR_STYLES, "thumb", displayOptions.scrollThumbStyles());
			setChildStyles(SCROLLBAR_STYLES, "button", displayOptions.scrollButtonStyles());
		}
		if (_isMobile()) {
			setStyles(MOBILE_SELECTION_STYLES, grid.selectOptions().mobileStyles());
		} else {
			setStyles(SELECTION_STYLES, grid.selectOptions().maskStyles());
		}
        if (TreeView) {
            var tree = _cast(grid, TreeView);
            if (tree) {
                if (source && source.hasOwnProperty(TREE_STYLES)) {
                    setChildStyles(TREE_STYLES, "expander", tree.treeOptions().expanderStyles());
                }
            }
        }
	}
});
var DynamicStyleOwner = defineClass("DynamicStyleOwner", null, {
	init: function (config) {
		this._super();
		if (config) {
			if (config.hasOwnProperty("capitalIndexers")) {
				var indexers = config.capitalIndexers;
				if (indexers) {
					this._capitalIndexers = indexers.concat();
				}
			}
		}
	},
	capitalIndexers: function () {
		return this._capitalIndexers;
	},
	parseValue: function (prop, value) {
	}
});
var /* abstract */ DynamicStyle = defineClass("DynamicStyle", null, {
	init: function (owner) {
		this._super();
		_assert(owner != null, "owner is null");
		this._owner = owner; // capitalIndexers() 구현체.
		this._body = true;
		this._fixed = true;
	},
	owner: function () {
		return this._owner;
	},
	apply: function (runtime, target/* VisualStyles */) {
	},
	_setOwner: function (owner) {
		this._owner = owner;
	},
	_changed: function () {
	}
}); 
var $$_ds_edit_props = ["readOnly", "editable", "cursor", "editor"];
var DynamicStyleImpl = defineClass("DynamicStyleImpl", DynamicStyle, {
	init: function(owner, source) {
		this._super(owner);
		this._exprNode = null;
		this._styleMap = {};
		if (source) {
			if (source.hasOwnProperty("criteria")) {
				this.setCriteria(source.criteria);
			}
			if (source.hasOwnProperty("styles")) {
				this.setStyles(source.styles);
			}
		}
	},
	criteria: null,
	styles: null,
	setCriteria: function (value) {
		var s = value ? value.toString() : null;
		if (s != this._criteria) {
			this._criteria = s;
			if (typeof value === "function") {
				this._exprNode = new FunctionExpressionNode(value);
			} else {
				this.$_buildExpression();	
			}
			this._changed();
		}
	},
	setStyles: function (value) {
		if (value != this._styles) {
			this._styles = value;
			this.$_buildStyles();
			this._changed();
		}
	},
	check: function(runtime) {
		var ret = this._exprNode && this._exprNode.evaluate(runtime)
		if (ret && typeof ret === "object") {
			return Object.keys(ret).length > 0;
		} else {
			return ret;
		}
	},
	apply: function (runtime, target) {
		var rStyle;
		var editable;
		if (this._exprNode && (rStyle = this._exprNode.evaluate(runtime))) {
			var setter;
			rStyle = this._exprNode instanceof FunctionExpressionNode && (typeof rStyle != "boolean") ? rStyle : this._styleMap;
			for (var style in rStyle) {
				setter = target[style];
				if (setter) { 
					setter.call(target, rStyle[style]);
				} else if ($$_ds_edit_props.indexOf(style) >= 0) {
					editable = editable || {};
					editable[style] = rStyle[style];
				}
			}
			if (editable && runtime._cell) {
				var grid = runtime._grid;
				var index = runtime._cell._index;
				grid.setCellWritable(index, editable);
			}
		}
	},
	$_buildExpression: function () {
		if (this._criteria) {
			this._exprNode = ExpressionParser.Default.parse(this._criteria, this._owner ? this._owner.capitalIndexers() : null);
			if (this._exprNode == null) {
				this._exprNode = EmptyExpressionNode.Default;
			}
		} else {
			this._exprNode = EmptyExpressionNode.Default;
		}
	},
	$_buildStyles: function () {
		this._styleMap = {};
		if (typeof this._styles === "string") {
			var items = this._styles.split(";");
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var item = items[i];
				var arr = item.split("=");
				if (arr.length > 1) {
					this._styleMap[arr[0]] = arr[1];
				} else {
					this._styleMap[arr[0]] = UNDEFINED;
				}
			}
		} else if (this._styles) {
			for (var p in this._styles) {
				this._styleMap[p] = this._styles[p];
			}
		}
	}
});
var DynamicStyleCase = defineClass("DynamicStyleCase", DynamicStyle, {
	init : function(owner, config) {
		this._super(owner);
		this._exprNodes = [];
		this._stylesMap = [];
		if (config) {
			if (config.hasOwnProperty("criteria")) {
				this.setCriteria(config.criteria);
			}
			if (config.hasOwnProperty("styles")) {
				this.setStyles(config.styles);
			}
		}
	},
	criteria: null,
	styles: null,
	setCriteria: function (value) {
		if (value != this._criteria) {
			this._criteria = value;
			this.$_buildExpressions();
			this._changed();
		}
	},
	setStyles: function (value) {
		if (value != this._styles) {
			this._styles = value;
			this.$_buildStyles();
			this._changed();
		}
	},
	check: function(runtime) {
		for (var i = 0, len = this._exprNodes.length; i < len; i++) {
			var expr = this._exprNodes[i];
			if (expr && expr.evaluate(runtime)) {
				return true;
			}
		}		
		return false;
	},
	apply: function(runtime, target/* VisualStyles */) {
		for (var i = 0, len = this._exprNodes.length; i < len; i++) {
			var expr = this._exprNodes[i];
			var styleMap;
			var editable;
			if (expr && (styleMap = expr.evaluate(runtime))) {
				styleMap = expr instanceof FunctionExpressionNode && (typeof styleMap != "boolean") ? styleMap : this._stylesMap[i];
				for (var style in styleMap) {
					var setter = target[style];
					if (setter) { 
						setter.call(target, styleMap[style]);
					} else if ($$_ds_edit_props.indexOf(style) >= 0) {
						editable = editable || {};
						editable[style] = styleMap[style];
					}
				}
				if (editable && runtime._cell) {
					var grid = runtime._grid;
					var index = runtime._cell._index;
					grid.setCellWritable(index, editable);
				}
				break;
			}
		}
	},
	$_buildExpressions: function () {
		var cnt;
		var owner = this.owner();
		this._exprNodes = [];
		if (_isArray(this._criteria) && (cnt = this._criteria.length) > 0) {
			for (var i = 0; i < cnt; i++) {
				var c = this._criteria[i];
				if (c) {
					var expr = typeof c === "function" ? new FunctionExpressionNode(c) : ExpressionParser.Default.parse(c, owner ? owner.capitalIndexers() : null);
					if (expr == null) {
						expr = EmptyExpressionNode.Default;
					}
					this._exprNodes.push(expr);
				} else {
					this._exprNodes.push(EmptyExpressionNode.Default);
				}
			}
		}
	},
	$_buildStyles: function () {
		this._stylesMap = [];
		if (_isArray(this._styles)) {
			for (var i = 0, cnt = this._exprNodes.length; i < cnt; i++) {
				var styles = this._styles.length > i ? this._styles[i] : this._styles[cnt - 1];
				var map = {};
				this._stylesMap.push(map);
				if (typeof styles === "string") {
					var items = styles.split(";");
					for (var j = 0; j < items.length; j++) {
						var item = items[j];
						var arr = item.split(/\s*=/);
						if (arr.length > 1) {
							map[arr[0]] = arr[1];
						} else {
							map[arr[0]] = null;
						}
					}
				} else {
					for (var p in styles) {
						map[p] = styles[p];
					}
				}
			}
		}
	}
}); 
var DynamicStyleCollection = defineClass("DynamicStyleCollection", null, {
	init: function (owner) {
		this._super();
		this._owner = owner; // DynamicStyleOwner
		this._items = []; // of DynamicStyle
	},
	owner: function () {
		return this._owner;
	},
	count: function () {
		return this._items.length;
	},
	getItem: function (index) {
		return this._items[index];
	},
	clear: function () {
		this._items = [];
	},
	add: function (item) {
		var style = this.$_createStyle(item);
		if (style && this._items.indexOf(style) < 0) {
			this._items.push(style);
		}
	},
	setItems: function (items) {
		this._items = [];
		var style;
		if (items) {
			if (typeof items === "function") {
				style = this.$_createStyle(items);
				style && this._items.push(style);
			} else {
				if (items instanceof DynamicStyleCollection) {
					items = items.toArray();
				}
				if (!_isArray(items)) {
					return;
				}
				var i;
				var cnt = items.length;
				for (i = 0; i < cnt; i++) {
					style = this.$_createStyle(items[i]);
					style && this._items.push(style);
				}
			}
		}
	},
	prepare: function () {
	},
	checkStyle: function (runtime) {
        for (var i = 0, cnt = this._items.length; i < cnt; i++) {
            var style = this._items[i];
            if (style.check(runtime)) {
            	return true;
            }
        }		
        return false;
	},
	applyCheck: function (runtime, styles, targets) {
		if (runtime && styles && targets) {
			this.applyInternalNormal(runtime, styles, targets);
		}
	},
	applyInternalNormal: function (runtime, styles, targets) {
        for (var i = 0, cnt = this._items.length; i < cnt; i++) {
            var style = this._items[i];
            style.apply(runtime, styles);
        }
	},
    applyInternalUserMode: function (runtime, styles, targets) {
        try {
            for (var i = 0, cnt = this._items.length; i < cnt; i++) {
                var style = this._items[i];
                style.apply(runtime, styles);
            }
        } catch (err) {
        }
    },
	toArray: function () {
		return this._items.concat(); 
	},
	$_createStyle: function (source) {
		var s = null;
		var style;
		if (typeof source === "function") {
			style = new DynamicStyleImpl(this._owner);
			style.setCriteria(source);
			s = style;
		} else if (source instanceof DynamicStyle) {
			source._owner = this._owner;
			s = source;
		} else if (_isArray(source.criteria)) {
			var cstyle;
			source.styles = _isArray(source.styles) ? source.styles : source.styles ? [source.styles] : source.styles;
			cstyle = new DynamicStyleCase(this._owner);
			cstyle.setCriteria(source.criteria);
			cstyle.setStyles(source.styles);
			s = cstyle;
		} else if (source && source.criteria) {
			style = new DynamicStyleImpl(this._owner);
			style.setCriteria(source.criteria);
			style.setStyles(source.styles);
			s = style;
		}
		return s;
	},
	proxy: function() {
		if (!this._items || this._items.length <= 0) {
			return null;
		}
		var ret = [];
		for (var i = 0, len = this._items.length; i < len ; i++) {
			ret.push({
				"criteria":this._items[i].criteria(),
				"styles":this._items[i].styles()
			})
		}
		return ret;
	}
}); 
var $$_dc_empty_styles = new VisualStyles();
var $$_dc_edit_props = ["readOnly", "editable", "button", "popupMenu"];
var DataCellStyle = defineClass("DataCellStyle", null, {
	init: function (id, source) {
		this._super();
		this._id = id;
		this._styles = $$_dc_empty_styles;
		this._props = null;
		this.assign(source);
	},
	id: function () {
		return this._id;
	},
	isEditable: function (editable) {
		return this._props && typeof this._props.editable === "boolean" ? this._props.editable : editable;
	},
	isReadOnly: function (readOnly) {
		return this._props && typeof this._props.readOnly === "boolean" ? this._props.readOnly : readOnly;
	},
    isWritable: function () {
        if (this._props) {
            var v = this._props.editable;
            if (v !== undefined && !v) {
                return false;
            }
            v = this._props.readOnly;
            if (v) {
                return false;
            }
        }
        return true;
    },
    button: function () {
        return this._props && this._props.button;
    },
    popupMenu: function () {
        return this._props && this._props.popupMenu;
    },
	setStyles: function (value) {
		if (value != this._styles) {
			if (value) {
				if (this._styles === $$_dc_empty_styles) {
					this._styles = new VisualStyles(null, null, false);
				}
				this._styles.clearValues();
				this._styles.extend(value, false, false);
			} else {
				this._styles = $$_dc_empty_styles;
			}
		}
	},
	assignTo: function (styles) {
		styles && styles.extend(this._styles, false, false);
	},
    calcWritable: function (editable, readOnly) {
        var props = this._props;
        if (props) {
            if (props.editable !== undefined) {
                editable = props.editable;
                if (!editable) return false;
            }
            if (props.readOnly !== undefined) {
                readOnly = props.readOnly;
                if (readOnly) return false;
            }
        }
        return editable && !readOnly;
    },
    assign: function (source) {
        if (source) {
            this.setStyles(source instanceof DataCellStyle ? source._styles : source);
            this.$_assignProps(source, $$_dc_edit_props);
        }
    },
	$_assignProps: function (source, props) {
		for (var i = 0, cnt = props.length; i < cnt; i++) {
			var p = props[i];
			if (source[p] !== undefined) {
				this._props = this._props || {};
				this._props[p] = source[p];
			}
		}
	}
});
var DataCellStyleCollection = defineClass("DataCellStyleCollection", EventAware, {
	/**
	 * owner = {
	 * 		function dataCellStyleAdded(id, needUpdate);
	 * 		function dataCellStyleChanged(id, needUpdate);
	 * 		function dataCellStyleRemoved(id, style, needUpdate);
	 * 		function dataCellStylesCleared(needUpdate);
	 * }
	 */
	init: function (owner) {
		this._super();
		this._owner = owner;
		this._styles = {};
		this._dirtyLock = 0;
	},
	getStyle: function (id) {
		return this._styles[id];
	},
	get: function (id) {
		return this._styles[id];
	},
	clear: function () {
		this._styles = {};
		if (this._dirtyLock <= 0 && this._owner) {
			this._owner.dataCellStylesCleared();
		}
	},
	add: function (id, style) {
		if (id && style && !this._styles[id]) {
			this._styles[id] = new DataCellStyle(id, style);
			this._owner && this._owner.dataCellStyleAdded(id, this._dirtyLock <= 0);
		}
	},
	set: function (id, style) {
		if (id) {
			var oldStyle = this._styles[id];
			if (style) {
				if (oldStyle) {
					oldStyle.assign(style);
					this._owner && this._owner.dataCellStyleChanged(id, this._dirtyLock <= 0);
				} else {
					this._styles[id] = new DataCellStyle(id, style);
					this._owner && this._owner.dataCellStyleAdded(id, this._dirtyLock <= 0);
				}
			} else if (oldStyle) {
				delete this._styles[id];
				this._owner && this._owner.dataCellStyleRemoved(id, oldStyle, this._dirtyLock <= 0);
			}
		}
	},
	beginUpdate: function () {
		this._dirtyLock++;
	},
	endUpdate: function (updateOwner) {
		if (this._dirtyLock > 0) {
			this._dirtyLock = Math.max(this._dirtyLock - 1, 0);
			if (this._dirtyLock == 0 && updateOwner && this._owner) {
				this._owner.dataCellStyleChanged(null, true);
			}
		}
	},
	load: function (source) {
	}
});
var ColumnFilter = defineClass("ColumnFilter", EventAware, {
	init : function(criteria) {
		this._super();
		this.setCriteria(criteria);
	},
	destroy: function() {
		this._destroying = true;
		this._criteria = null;
		this._tag = null;
		return this._super();
	},
	name: null,
	criteria: null,
	text: null,
	description: null,
	active: false,
	visible: true,
	tag: null,
	setActive: function(value, execute) {
		this._active = value;
		execute !== false && this._changed();
	},
	setVisible: function(value) {
		if (value != this._visible) {
			this._visible = value;
		}
	},
	propertyChanged: function (prop, oldValue, newValue) {
		this._changed();
	},
	toString: function () {
		return this._text || this._name;
	},
	_changed: function () {
		this.fireEvent(ColumnFilter.CHANGED);
	}
});
ColumnFilter.CHANGED = "onColumnFilterChanged";
var ColumnFilterRun = defineClass("ColumnFilterRun", ColumnFilter, {
	init : function(refFilter) {
		this._super(refFilter.criteria());
		this._refFitler = refFilter;
		this._exprNode = null;
		this.$_parse();
	},
	destroy: function() {
		this._destroying = true;
		this._exprNode = null;
		this._criteria = null;
		this._refFitler = null;
		return this._super();
	},
	prepare: function (runtime, dataSource) {
		runtime.setDataSource(dataSource);
	},
	select: function (runtime, item, field) {
		if (this._exprNode) {
			runtime.setData(item, field);
			return this._exprNode.evaluate(runtime);
		} else
			return true;
	},
	setCriteria: function (value) {
		if (value != this._criteria) {
			this._criteria = value;
			this.$_parse();
		}
	},
	$_parse: function () {
		if (this._criteria) {
			this._exprNode = ExpressionParser.Default.parse(this._criteria, null);
			if (this._exprNode instanceof FunctionExpressionNode) {
				this._exprNode.evaluate = this._evaluate.bind(this);
			}
		} else {
			this._exprNode = null;
		}
	},
	_evaluate: function(runtime) {
		var func = this._criteria;
		var fieldName = runtime._dataSource.getOrgFieldName(runtime._field);
		var value = runtime._item.getData(runtime._field);
		return func(runtime._dataSource.getHandler(), runtime._item.dataRow(), fieldName, this._refFitler && this._refFitler.proxy(), value);
	}
});
var ColumnFilterCollection = defineClass("ColumnFilterCollection", EventAware, {
	init : function(column) {
		this._super();
		this._column = column;
		this._items = [];
		this._names = {};
		this._updating = false;
		this._nextId = 1;
	},
	destroy: function() {
		this._destroying = true;
		this.clear(false);
		for (var i = 0, cnt = this._items.length; i < cnt ; i++) {
			this._items[i] && !this._items[i]._destroying && this._items[i].destroy && this._items[i].destroy();
			this._items[i] = null;
		}
		this._items = null;
		this._super();
		this._names = null;
	},
	count: function () {
		return this._items.length;
	},
	activeCount: function () {
		var i, cnt = 0;
		for (i = this._items.length; i--;) {
			if (this._items[i].isActive()) {
				cnt++;
			}
		}
		return cnt;
	},
	items: function () {
		return this._items.slice();
	},
	isVisible: function () {
		for (var i = this._items.length; i--;) {
			if (this._items[i].isVisible()) {
				return true;
			}
		}
		return false;
	},
	getItemAt: function (index) {
		if (index < 0 || index >= this._items.length) {
			if ($_debug) debugger;
			throw new Error("Invalid index: " + index);
		}
		return this._items[index];
	},
	getItem: function (filterName) {
		return this._names[filterName] || null;
	},
	getItemIndex: function (filterName) {
		for (var i = this._items.length - 1; i >= 0; i--) {
			if (this._items[i]._name == filterName) {
				return i;
			}
		}
		return -1;
	},
	getActiveItems: function (active) {
		var items = [];
		for (var i = this._items.length - 1; i >= 0; i--) {
			if (this._items[i].isActive() == active) {
				items.push(this._items[i]);
			}
		}
		return items;
	},
	assign: function (source) {
		if (source === this) {
			return;
		}
		var cleared = this.clear(false);
		if (source) {
			var i;
			var cnt;
			var filter;
			var src = _asArray(source);
			if (!src) {
				src = [source];
			}
			cnt = src.length;
			for (i = 0; i < cnt; i++) {
				source = src[i];
				if (source && source.name) {
					this.$_checkName(source.name);
					filter = new ColumnFilter();
					filter.assign(source);
					this._items.push(filter);
					this._names[source.name] = filter;
					filter.addListener(this);
				}
			}
		}
		if (cleared || this.count() > 0) {
			this._changed(null);
		}
	},
	clear: function (fireEvent) {
		fireEvent = arguments.length > 0 ? fireEvent : true;
		var cnt = this._items.length;
		if (cnt > 0) {
			for (var i = 0; i < cnt; i++) {
				this._items[i].removeListener(this);
			}
			this._items.length = 0;
			this._names = {};
			fireEvent && this._changed(null);
			return true;
		}
		return false;
	},
	$_userFilterAdd: function(filter, apply) {
		var f = _cast(filter, ColumnFilter);
		if (!f) {
			this.$_checkName(filter.name);
			f = new ColumnFilter();
			f.assign(filter);
		};
		this.add(f, apply);
		return f;
	},
	add: function (filter, apply) {
		apply = apply == null ? true : apply;
		var f = _cast(filter, ColumnFilter);
		if (f) {
			if (this._items.indexOf(f) < 0 && f.name()) {
				this.$_checkName(f.name());
			}
		} else if (filter && filter.name) {
			this.$_checkName(filter.name);
			f = new ColumnFilter();
			f.assign(filter);
		}
		this._items.push(f);
		this._names[f.name()] = f;
		f.addListener(this);
		apply && this._changed(null);
	},
	addItems: function (filters, overwrite) {
		if (!_isArray(filters) && filters) {
			filters = [filters];
		}
		if (filters && filters.length > 0) {
			var i;
			var idx;
			var filter;
			var cnt = 0;
			var len = filters.length;
			for (i = 0; i < len; i++) {
				filter = _cast(filters[i], ColumnFilter);
				if (filter) {
					if (this._items.indexOf(filters[i]) < 0 && filter.name()) {
						if (!overwrite) {
							this.$_checkName(filter.name());
						}
					}
				} else if (filters[i] && filters[i].name) {
					if (!overwrite) {
						this.$_checkName(filters[i].name);
					}
					filter = new ColumnFilter();
					filter.assign(filters[i]);
				}
				idx = this.getItemIndex(filter.name());
				if (idx >= 0) {
					if (this._items[idx]) {
						this._items[idx].removeListener(this);
					}
					this._items[idx] = filter;
				} else {
					this._items.push(filter);
				}
				filter.addListener(this);
				this._names[filter.name()] = filter;
				cnt++;
			}
			if (cnt > 0) {
				this._changed(null);
			}
		}
	},
	remove: function (filterName) {
		if (!filterName) {
			return;
		}
		var i,
			filter;
		for (i = this._items.length - 1; i >= 0; i--) {
			filter = this._items[i];
			if (filter.name() == filterName) {
				this._items.splice(i, 1);
				delete this._names[filter.name()];
				filter.removeListener(this);
				this._changed(null);
				return true;
			}
		}
		return false;
	},
	removeItems: function (filterNames) {
		if (!_isArray(filterNames)) {
			return;
		}
		var i;
		var j;
		var filter;
		var cnt = 0;
		for (i = filterNames.length - 1; i >= 0; i--) {
			j = this.getItemIndex(filterNames[i]);
			if (j >= 0) {
				filter = this._items[j];
				this._items.splice(j, 1);
				delete this._names[filter.name()];
				filter.removeListener(this);
				cnt++;
			}				
		}
		if (cnt > 0) {
			this._changed(null);
		}
	},
	activateItems: function (filterNames, active) {
		if (!_isArray(filterNames)) {
			return;
		}
		var i;
		var filter;
		var cnt = 0;
		this._updating = true;
		try {
			for (i = filterNames.length - 1; i >= 0; i--) {
				filter = this._names[filterNames[i]];
				if (filter && filter.isActive() != active) {
					filter.setActive(active);
					cnt++;
				}				
			}
		} finally {
			this._updating = false;				
		}
		if (cnt > 0) {
			this._changed(null);
		}
	},
	activateAll: function (active) {
		this._updating = true;
		try {
			var i;
			var filter;
			var cnt = this._items.length;
			var dirty = false;
			for (i = 0; i < cnt; i++) {
				filter = this._items[i];
				if (filter.isActive() != active) {
					filter.setActive(active);
					dirty = true;
				}
			}
		} finally {
			this._updating = false;
		}
		if (dirty) {
			this._changed(null);
		}
	},
	hideFilters: function(filterNames, hide) {
		if (!filterNames) {
			return;
		};
		var i, filter, cnt = filterNames.length;
		for (i = 0; i < cnt ; i++) {
			filter = this._names[filterNames[i]];
			if (filter) {
				filter.setVisible(!hide);
			}
		}
	},
	hideAllFilters: function(hide) {
		var i, cnt = this._items.length, filter;
		for (i=0; i < cnt ; i++) {
			filter = this._items[i];
			filter && filter.setVisible(!hide);
		}
	},
	toggleItems: function (filterNames) {
		if (!filterNames) {
			return;
		}
		var i;
		var filter;
		var cnt = 0;
		this._updating = true;
		try {
			for (i = filterNames.length - 1; i >= 0; i--) {
				filter = this._names[filterNames[i]];
				if (filter) {
					filter.setActive(!filter.isActive());
					cnt++;
				}
			}
		} finally {
			this._updating = false;				
		}
		if (cnt > 0) {
			this._changed(null);
		}
	},
	toggleAll: function () {
		this._updating = true;
		try {
			var i;
			var filter;
			var cnt = this._items.length;
			var dirty = false;
			for (i = 0; i < cnt; i++) {
				filter = this._items[i];
				filter.setActive(!filter.isActive());
				dirty = true;
			}
		} finally {
			this._updating = false;
		}
		if (dirty) {
			this._changed(null);
		}
	},
	$_checkName: function (name) {
		if (this._names.hasOwnProperty(name)) {
			throw new Error("Column filter already existes: " + name);
		}
	},
	_changed: function (filter) {
		if (!this._updating) {
			this.fireEvent(ColumnFilter.CHANGED, filter);
		}
	},
	onColumnFilterChanged: function (filter) {
		this._changed(filter);
	},
	onColumnFilterSelectorChanged: function() {
		this._changed(null);
	},
	onColumnFilterUserAdd: function(selector, filter, apply) {
		if (!filter || !filter.criteria || !filter.text) {
			return;
		}
		filter.name = filter.name || "$userFilter_"+(this._nextId++);
		return this.$_userFilterAdd(filter, apply);
	}
});
var ColumnFilterSelector = defineClass("ColumnFilterSelector", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._eltActions = null;
		this._eltAll = null;
		this._eltItems = null;
		this._column = null;
		this._showing = false;
		this._x = 0;
		this._y = 0;
		this._acceptText = null;
		this._cancelText = null;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._element) {
					return;
				}
				p = p.parentNode;
			}
			this.hide();
		}.bind(this);
		this._acceptClickHandler = function(e) {
			this.$_activeFilters();
		}.bind(this);
		this._cancelClickHandler = function(e) {
			this.$_closeFilter();
		}.bind(this);
		this._acceptMouseoverHandler = function(e) {
			var label = e.currentTarget;
			label.style.background = "rgba(9, 211, 140, 0.5)";
		}.bind(this);
		this._acceptMouseoutHander = function(e) {
			var label = e.currentTarget;
			label.style.background = "";
		}.bind(this);
		this._cancelMouseoverHandler = function(e) {
			var label = e.currentTarget;
			label.style.background = "#888";
		}.bind(this);
		this._cancelMouseoutHandler = function(e) {
			var label = e.currentTarget;
			label.style.background = "";
		}.bind(this);
		this._searchTextInputHandler = function(e) {
			this.$_searchTextInputHandler(e);
		}.bind(this);
		this._searchTextKeydownHandler = function(e) {
			this.$_searchInputKeydown(e);
		}.bind(this);
	},
	closeWhenClick: false,
	showButtons: false,
	showSearchInput: false,
	userFilterAddCallback: null,
	viewGridInside: true,
	enterCallback: false,
	$_searchInputKeydown: function(e) {
		if ( (e.ctrlKey || this.isEnterCallback()) && e.keyCode == 13) {
			if (this._userFilterAddCallback) {
				var grid = this._column.grid();
				var handler = grid.getHandler();
				var column = $$_getColumnProxy(this._column);
				var text = e.currentTarget.value;
				var filter = this._userFilterAddCallback(handler, column, text);
				if (filter) {
					if(filter = this.fireObjectEvent(ColumnFilterSelector.USER_FILTER_ADD, filter, false)) {
						this.$_buildItem(filter, grid.filteringOptions().selector().isUseCssStyle());
						!this.isShowButtons() && this.fireEvent(ColumnFilterSelector.CHANGED);				
					};
				};
				e.preventDefault();
			}
		}
	},
	$_searchFilterItem: function(searchText) {
		function comparArr(filterArr, searchArr) {
			var match = true;
			for (var i = 0, cnt = filterArr.length; i < cnt; i++) {
				match = true;
				for (var j = 0, scnt = searchArr.length; j < scnt; j++) {
					match = match && searchArr[j].org ? (filterArr[i+j] && searchArr[j].org === filterArr[i+j].org) : (filterArr[i+j] && searchArr[j].cho === filterArr[i+j].cho);
					if (!match) break;
				}
				if (match || i+searchArr.length > filterArr.length) break;
			}
			return match;
		};
		var children = this._eltItems.children;
		for (var i = 0, cnt = children.length; i < cnt; i++) {
			var child = children[i];
			var ft = child.check.filter.toString();
			ft = ft ? ft.toLowerCase() : ft;
			if (!searchText) {
				child.style.display = "";
			} else {
				if (ft && ft.indexOf(searchText) >= 0) {
					child.style.display = "";
				} else {
					child.style.display = comparArr(hangulToChosungAll(ft), hangulToChosungAll(searchText)) ? "" : "none";
				}
			}
		};
		this.$_changeCheckAll();
	},
	$_searchTextInputHandler: function(e) {
		var input = e.currentTarget;
		var st = input.value ? input.value.toLowerCase() : "";
		this.$_searchFilterItem(st);
	},
	$_checkAll: function(checked, execute) {
		var elts = this._eltItems.children;
		for (var i = 0, cnt = elts.length; i < cnt ; i++) {
			if (!this._clearWhenSearchCheck && elts[i].style.display === "none") {
				continue;
			}
			elts[i].check.checked = elts[i].style.display === "none" ? false : checked !== null ? checked : elts[i].check.checked;
			// !this.isShowButtons() && execute && elts[i].check.filter.setActive(elts[i].check.checked, false);
			elts[i].check.filter.setActive(elts[i].check.checked, false);
		};
		!this.isShowButtons() && execute && this.fireEvent(ColumnFilterSelector.CHANGED);
	},
	$_changeCheckAll: function() {
		var elts = this._eltItems.children;
		var checked = true;
		var vCnt = 0;
		for (var i = 0, cnt = elts.length; i < cnt ; i++) {
			if (elts[i].style.display === "none") {continue};
			vCnt++;
			checked = elts[i].check.checked;
			if (!checked) {break};
		};
		this._eltAll.check.checked = checked && vCnt;
	},
	$_activeFilters: function() {
		var elts = this._eltItems.children;
		for (var i = 0, cnt = elts.length; i < cnt ; i++) {
			elts[i].check.filter.setActive(elts[i].check.checked && (!this._clearWhenSearchCheck || elts[i].style.display === ""), false);
		};
		this.fireEvent(ColumnFilterSelector.CHANGED);
		this.hide();
	},
	$_closeFilter: function() {
		this.hide();
	},
	destroy: function() {
		this._destroying = true;
		this._x = null;
		this._y = null;
		this._eltActions = null;
		this._eltAll = null;
		this._eltItems = null;
		this._eltSearchInput = null;
		this._eltButtons = null;
		this._column = null;
		this._globalMouseHandler = null;
		this._super();
	},
	column: function () {
		return this._column;
	},
	isOpened: function () {
		var container = this._element && this._element.parentElement;
		return this._element && container && container.contains(this._element);
	},
	show: function (columnView, options) {
		this.hide();
		if (!columnView) return;
		this._showing = true;
		try {
			options = options || columnView.grid().filteringOptions().selector();
			this._closeWhenClick = options.isCloseWhenClick();
			this._showButtons = options.isShowButtons();
			this._showSearchInput = options.isShowSearchInput();
			this._clearWhenSearchCheck = columnView.grid().filteringOptions().isClearWhenSearchCheck();
			this._acceptText = options.acceptText();
			this._cancelText = options.cancelText();
			this._userFilterAddCallback = options.userFilterAddCallback();
			this._enterCallback = options.isEnterCallback();
			this.$_show(columnView, options);
		} finally {
			this._showing = false;
		}
	},
	$_show: function (columnView, options) {
		var self = this;
		var grid = columnView.grid();
		var useCssStyle = options.isUseCssStyle();
		var viewGridInside = options.isViewGridInside();
		this._element = this._initControl(useCssStyle);
		var elt = this._element;
		if (!elt || elt.parentNode) {
			return;
		}
		var p, cr;
		var w = grid.width() - 10; // minus paddings + border
		var h = grid.height() - 10;
		elt.style.position = "absolute";
		elt.style.float = "none";
		elt.style.overflow = "hidden";
		elt.style.zIndex = 3000;
		if (!useCssStyle) {
			elt.style.background = "rgb(233, 233, 233)";
			elt.style.border = "1px solid rgb(200, 200, 200)";
			elt.style.boxShadow = "rgba(0, 0, 0, 0.8) 1px 2px 5px";
			elt.style.fontFamily = "Tahoma";
			elt.style.fontStyle = "normal";
			elt.style.fontVariant = "normal";
			elt.style.fontWeight = "normal";
			elt.style.fontSize = "10pt";
			elt.style.padding = "4px";
		};
		this._column = columnView.index().column();
		this._eltSearchInput.style.display = this.isShowSearchInput() ? "" : "none";
		this._eltButtons.style.display = this.isShowButtons() ? "" : "none";
		this.$_clearActions();
		var action = this.$_buildActions(this._column, useCssStyle);
		this.$_clearItems();
		var hasItems = this.$_buildItems(this._column, useCssStyle);
		this.$_changeCheckAll();
		this.$_buildButtons(this._column, useCssStyle);
		p = parseFloat(options.getMinWidth(w));
		if (!isNaN(p) && p > 0) {
			elt.style.minWidth = p + "px";
		}
		p = parseFloat(options.getMaxWidth(w));
		if (!isNaN(p) && p > 0) {
			elt.style.maxWidth = ( viewGridInside ? Math.min(p, w) : p ) + "px";
		} else {
            elt.style.maxWidth = w + "px";
        }
		p = parseFloat(options.getMinHeight(h));
		if (!isNaN(p) && p > 0) {
			elt.style.minHeight = p + "px";
		}
		p = parseFloat(options.getMaxHeight(h));
		if (!isNaN(p) && p > 0) {
			elt.style.maxHeight = ( viewGridInside ? Math.min(p, h) : p )+ "px";
		} else {
            elt.style.maxHeight = (viewGridInside ? h : Math.max(document.documentElement.clientHeight, h)) + "px";
        }
		this._eltAll.style.visibility = hasItems ? "" : "collapse";
		this._eltAll.style.height = hasItems ? "" : "0px";
		viewGridInside ? this._container.appendChild(elt) : _doc.body.appendChild(elt);
		cr = elt.getBoundingClientRect();
		// if ( !isNaN(p) && p > 0 && p > cr.height) {
		// 	// maxHeight가 지정되어있고 현재높이보다 크면 
		// } else {
			var itemsHeight = cr.height - 
				this._eltActions.offsetHeight -   	// action
				this._eltAll.offsetHeight -       	// 전체선택
				this._eltSearchInput.offsetHeight - // 검색input
				this._eltButtons.offsetHeight - 
				(this.isShowSearchInput() ? 4 : 0) -  // margin, padding은 높이계산이 잘 안된다.
				(this.isShowButtons() ? 4 : 0) -
				8; /* paddings */
			this._eltItems.offsetHeight - itemsHeight > 8 && (this._eltItems.style.height = Math.ceil(itemsHeight) + "px");
		// }

		if (this._eltItems.offsetWidth > this._eltItems.clientWidth) {
			elt.style.width = (cr.width + this._eltItems.offsetWidth - this._eltItems.clientWidth) + "px"; // for scroll bar
		}
		var r = viewGridInside ? columnView.boundsByContainer() : columnView.boundsByScreen();

		p = (r.right() - cr.width);
		elt.style.left = (this._x = Math.max(0, p))  + "px";
		var y = r.bottom();
		if (viewGridInside) {
			h += 10; // padding + border 추가
			if (y + cr.height >= h) {
				y = Math.max(0, h - cr.height - 3); // TODO 3을 빼주지 않으면 아래로 넘친다. Why?
			}
		} else {
			// 브라우저의 크기/
			if (cr.height + y > document.documentElement.clientHeight) {
				y = Math.max(0, document.documentElement.clientHeight - cr.height)
			}
		}
		elt.style.top = (this._y = y) + "px";
		if (action && !hasItems) {
			this.hide();
			action.click(r.x/*this._x*/, this._y);
		} else if (!this._column.hasFilterAction() && !hasItems) {
			this.hide();
		} else {
			setTimeout(function () {
				_win.addEventListener("mousedown", self._globalMouseHandler);
			}, 0);
		};
		this._column._filters && this.addListener(this._column._filters)
		this.isShowSearchInput() && setTimeout(function() {
				this._searchInput.focus();
			}.bind(this), 10);
	},
	hide: function () {
		var elt = this._element;
		if (!elt || !elt.parentNode) {
			return;
		}
		$_evl ? _win.removeEventListener("mousedown", this._globalMouseHandler) : _win.detachEvent("onmousedown", this._globalMouseHandler);
		this.removeListener(this._column._filters);
		elt.parentElement.removeChild(elt);
		// this._container.removeChild(elt);
	},
	_initControl: function (useCssStyle) {
		var container = _doc.createElement("div");
		if (useCssStyle) {
			container.className = "rg-filterselector";
		}
		container.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		var div = this._eltActions = _doc.createElement("div");
		if (useCssStyle) {
			div.className = "rg-filter-actions";
		}
		div.style.float = "none";
		div.style.overflow = "auto";
		container.appendChild(div);
/** search input **/		
		div = this._eltSearchInput = _doc.createElement("div");
		if (useCssStyle) {
			div.className = "rg-filter-search";
		};
		div.style.float = "none";
		if (!useCssStyle) {
			div.style.marginBottom = "4px";
		}
		var input = _doc.createElement("input");
		input.id = "$columnFilterSearch";
		if (useCssStyle) {
			input.className = "rg-filter-search-input";
		}
		if (!useCssStyle) {
			input.style.width = "100%";
		}
		input.tabIndex = -1;
		input.autocomplete = "off";
		input.oninput = this._searchTextInputHandler;
		input.onkeydown = this._searchTextKeydownHandler;
		this._searchInput = input;
		div.appendChild(input);
		container.appendChild(div);
/** all **/
		div = this._eltAll = _doc.createElement("div");
		if (useCssStyle) {
			div.className = "rg-filter-all";
		}
		div.style.float = "none";
		if (!useCssStyle) {
			div.style.backgroundColor = "#333";
			div.style.color = "#fff";
		}
/* all check */
		var check = _doc.createElement("input");
		if (useCssStyle) {
			check.className = "rg-filter-all-check";
		}
		check.id = "$columnFilter_all_" + ColumnFilterSelector.$_checkId++;
		check.type = "checkbox";

		check.tabIndex = -1;
		check.onclick = function (e) {
			this.$_checkAll(e.target.checked, true);
		}.bind(this);
		div.check = check;
		div.appendChild(check);
		var label = _doc.createElement("label");
		if (useCssStyle) {
			label.className = "rg-filter-all-label";
		}
		label.htmlFor = check.id;
		label.innerHTML = "All";
		div.appendChild(label);
		var hr = _doc.createElement("hr");
		if (useCssStyle) {
			hr.className = " ";
		}
		hr.style.height = "1px";
		hr.style.border = "0px";
		hr.style.margin = "2px";
		hr.style.color = "#777";
		hr.style.backgroundColor = "#777";
		div.appendChild(hr);
		container.appendChild(div);
		div = this._eltItems = _doc.createElement("div");
		if (useCssStyle) {
			div.className = "rg-filter-items";
		}
		div.style.float = "none";
		div.style.overflow = "auto";
		container.appendChild(div);

		div = this._eltButtons = _doc.createElement("div");
		if (useCssStyle) {
			div.className = "rg-filter-buttons";
		}
		!useCssStyle && Dom.setStyles(div, {
			textAlign:"center",
			paddingTop: "4px",
			marginLeft: "0px",
			marginRight: "0px",
		});		
		Dom.setStyles(div,{
			position: "relative",
			float: "none",
			clear: "both",
			boxSizing: "border-box"
		});
		container.appendChild(div);
		return container;
	},
	_disableSelection: function (element) {
		if (typeof element.onselectstart !== 'undefined') {
			element.onselectstart = function() { return false; };
		} else if (typeof element.style.MozUserSelect !== 'undefined') {
			element.style.MozUserSelect = 'none';
		} else {
			element.onmousedown = function() { return false; };
		}
	},
	$_clearActions: function () {
		var elt = this._eltActions;
		while (elt.lastChild) {
			elt.removeChild(elt.lastChild);
		}
	},
	$_buildActions: function (column, useCssStyle) {
		var actions = column.filterActions();
		var cnt = actions.length;
		var self = this;
		!useCssStyle && (this._eltActions.style.paddingBottom = cnt ? "4px" : "0px");
		for (var i = 0; i < cnt; i++) {
			var action = actions[i];
			var div = _doc.createElement("div");
			if (useCssStyle) {
				div.className = "rg-filter-action-item"
			}
			div.container = this;
			div.action = action;
			div.style.float = "none";
			div.style.whiteSpace = "nowrap";
			div.style.cursor = "pointer";
			this._disableSelection(div);
			this._eltActions.appendChild(div);
			div.onclick = function (e) {
				var div = this._currDiv = e.currentTarget;
				var action = div.action;
				div.container.hide();
				action && action.click(self._x, self._y);
				self._closeWhenClick && self.hide();
			};
			if (!useCssStyle) {
				div.onmouseover = function (e) {
					var div = this._currDiv = e.currentTarget;
					div.style.textDecoration = "underline";
				};
				div.onmouseout = function (e) {
					var div = this._currDiv = e.currentTarget;
					div.style.textDecoration = "none";
				};
			}
			var check = _doc.createElement("input");
			if (useCssStyle) {
				check.className = "rg-filter-action-check"
			}
			check.id = "$columnAction_item_" + ColumnFilterSelector.$_checkId++;
			check.type = "checkbox";
			check.tabIndex = -1;
			check.checked = false;
			check.action = action;
			check.style.visibility = "hidden";
			div.check = check;
			div.appendChild(check);
			var label = _doc.createElement("span");
			if (useCssStyle) {
				label.className = "rg-filter-action-label";
			}
			label.innerHTML = action.displayText();
			label.title = action.description();
			div.appendChild(label);
		}
		return cnt == 1 ? actions[0] : null;
	},
	$_clearItems: function () {
		var elt = this._eltItems;
		while (elt.lastChild) {
			elt.removeChild(elt.lastChild);
		}
	},
	$_buildItem:function(filter, useCssStyle) {
		var self = this;
		var div = _doc.createElement("div");
		if (useCssStyle) {
			div.className = "rg-filter-item"
		}
		div.style.float = "none";
		div.style.whiteSpace = "nowrap";
		this._disableSelection(div);
		this._eltItems.appendChild(div);
		if (!useCssStyle) {
			div.onmouseover = function (e) {
				var div = this._currDiv = e.currentTarget;
				div.style.textDecoration = "underline";
			};
			div.onmouseout = function (e) {
				var div = this._currDiv = e.currentTarget;
				div.style.textDecoration = "none";
			};
		}
		var check = _doc.createElement("input");
		if (useCssStyle) {
			check.className = "rg-filter-item-check";
		}
		check.id = "$columnFilter_item_" + ColumnFilterSelector.$_checkId++;
		check.type = "checkbox";
		check.tabIndex = -1;
		check.checked = filter.isActive();
		check.filter = filter;
		check.onclick = function (e) {
			var check = e.target;
			var filter = check.filter;
			self._clearWhenSearchCheck && self.$_checkAll(null, false); // clearWhenSearch search된것이외에는 모두 unCheck해야 한다.
			!self.isShowButtons() && filter.setActive(check.checked, !self.isShowButtons()); // 버튼이 있는 경우 accept를 클릭할때 까지 아무것도 안한다.
			self.$_changeCheckAll();	// 전체선택의 check를 변경
			!self.isShowButtons() && self._closeWhenClick && self.hide();
		};
		div.check = check;
		div.appendChild(check);
		var label = _doc.createElement("label");
		if (useCssStyle) {
			label.className = "rg-filter-item-label";
		}
		label.htmlFor = check.id;
		label.innerHTML = filter.toString();
		div.appendChild(label);
	},
	$_buildItems: function (column, useCssStyle) {
		var filters = column.filters();
		var visible = false;
		for (var i = 0, cnt = filters.length; i < cnt; i++) {
			var filter = filters[i];
			if (filter.isVisible()) {
				this.$_buildItem(filter, useCssStyle);
				visible = true;
			}
		}
		return visible;
	},
	$_buildButtons: function(column, useCssStyle) {
		if (!this._eltButtons) {
			return;
		}
		Dom.clearChildren(this._eltButtons);
		var button = document.createElement("label");
		button.innerHTML = this._acceptText || "accept";
		button.onclick = this._acceptClickHandler;
		button.onmouseover = !useCssStyle ? this._acceptMouseoverHandler : null;
		button.onmouseout = !useCssStyle ? this._acceptMouseoutHander : null;
		useCssStyle && (button.className = "rg-filter-accept");
		Dom.setStyles(button,{
			cursor: "pointer",
		});
		!useCssStyle && Dom.setStyles(button,{
			border: "1px solid #0a3c59",
			borderRadius: "3px",
			color: "#06426c",
			borderWidth: "1px", 
			padding: "0px 3px",
			marginLeft: "5px",
		});
		Dom.disableSelection(button);		
		this._eltButtons.appendChild(button);
		var button = document.createElement("label");
		button.innerHTML = this._cancelText || "cancel";
		button.onclick = this._cancelClickHandler;
		button.onmouseover = !useCssStyle ? this._cancelMouseoverHandler : null;
		button.onmouseout = !useCssStyle ? this._cancelMouseoutHandler : null;
		useCssStyle && (button.className = "rg-filter-cancel");
		Dom.setStyles(button,{
			cursor: "pointer",
		});
		!useCssStyle && Dom.setStyles(button,{
			border: "1px solid #0a3c59",
			borderRadius: "3px",
			color: "#06426c",
			borderWidth: "1px", 
			padding: "0px 3px",
			marginLeft: "5px",
		});
		Dom.disableSelection(button);		
		this._eltButtons.appendChild(button);
	},
	$_refreshItems: function () {
		var children = this._eltItems.children;
		for (var i = 0, cnt = children.length; i < cnt; i++) {
			var child = children[i];
			child.check.checked = child.check.filter.isActive();
		}
	},
	_changed: function () {
		this.fireEvent(ColumnFilter.CHANGED);
	}
}, {
	$_checkId: 0
});
ColumnFilterSelector.CHANGED = "onColumnFilterSelectorChanged";
ColumnFilterSelector.USER_FILTER_ADD = "onColumnFilterUserAdd";
var ColumnFilterAction = defineClass("ColumnFilterAction", EventAware, {
	init: function (column, name) {
		this._super();
		this._column = column;
		this._name = name;
	},
	name: null,
	text: null,
	description: null,
	column: function () {
		return this._column;
	},
	displayText: function () {
		return this._text || this._name;
	},
	click: function (x, y) {
		this._column && this._column.$_filterActionClick(this, x, y);
	}
});
var ToastOptions = defineClass("ToastOptions", null, {
	init : function (options) {
		this._super();
		options && this.assign(options);
	},
	message: null,
	visible: true,
	zIndex: null,
	styles: null,
	setStyles: function (value) {
		if (value) {
			if (!this._styles)
				this._styles = new VisualStyles();
			this._styles.extend(value);
		} else {
			this._styles = null;
		}
	},
	assign: function (source) {
		if (typeof source == "string") {
			this._message = source;
			if (this._message) {
				this._visible = true;
			}
		} else if (typeof source == "boolean") {
			this._visible = Boolean(source);
		} else {
			this._super(source);	
		}
	},
	proxy: function () {
		var proxy = this._super();
		if (this._styles)
			proxy["styles"] = this._styles.toProxy();
		return proxy;
	}
});
var ToastView = defineClass("ToastView", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._span = null;
		this._element = this._createElement();
		this._showing = false;
	},
	minWidth: 0,
	maxWidth: 0,
	dropDownCount: 8,
	show: function (options) {
		this._showing = true;
		try {
			this.$_show(options);
		} finally {
			this._showing = false;
		}
	},
	$_show: function (options) {
		var s = options.message();
		if (!s) {
			return;
		}
		var elt = this._element;
		if (!elt) {
			return;
		}
		var span = this._span;
		var displayOptions = this._container._gridView.displayOptions();
		span.innerHTML = s;
		elt.style.position = "absolute";
		elt.style.overflow = "hidden";
		elt.style.zIndex = options.zIndex && options.zIndex() != null ? options.zIndex() : ( displayOptions && displayOptions.toastZIndex && displayOptions.toastZIndex() != null ?  displayOptions.toastZIndex() : 3000);

		var styles = options.styles();
		var background;
		var foreground;
		var border
		var figureBackground;
		var fontFamily;
		var fontStyle;
		var fontWeight;
		var fontSize;
		var textDecoration;
		var paddingLeft;
		var paddingRight;
		var paddingTop;
		var paddingBottom;
		if (styles) {
			background = styles.background();
			foreground = styles.foreground();
			border = styles.border();
			figureBackground = styles.figureBackground();
			fontFamily = styles.fontFamily();
			fontStyle = styles.fontItalic() ? "italic" : "noramal";
			fontWidth = styles.fontBold() ? "bold" : "normal";
			textDecoration = styles.fontUnderline() ? "underline" : "";
			paddingLeft = styles.paddingLeft();
			paddingRight = styles.paddingRight();
			paddingTop = styles.paddingTop();
			paddingBottom = styles.paddingBottom();
		}
		
		if (background) {
			elt.style.background = background.css();
		} else if (_norgba) {
			new SolidBrush("rgba(33, 33, 33, 0.8)").applyToCss(elt.style);
		} else {
			elt.style.background = "rgba(33, 33, 33, 0.8)";
		}
		if (foreground) {
			elt.style.color = foreground.css();
		} else {
			elt.style.color = "rgb(255, 255, 255)";
		}

		if (border) {
			elt.style.border = border.css();
		} else {
			elt.style.border = "1px solid rgb(200, 200, 200)";
		}
		if (figureBackground) {
			elt.style.boxShadow = figureBackground.css() + " 1px 2px 5px";
		} else {
			elt.style.boxShadow = "rgb(0, 0, 0, 0.8) 1px 2px 5px";
		}

		elt.style.fontFamily = fontFamily ? fontFamily : "Tahoma";
		elt.style.fontStyle = fontStyle ? fontStyle : "normal";
		elt.style.fontWeight = fontWeight ? fontWeight : "normal";
		elt.style.fontSize = fontSize ? fontSize + "pt" : "16pt";
		elt.style.paddingTop = paddingTop ? paddingTop + "px" : "8px";
		elt.style.paddingBottom = paddingBottom ? paddingBottom + "px" : "8px";
		elt.style.paddingLeft = paddingLeft ? paddingLeft + "px" : "16px";
		elt.style.paddingRight = paddingRight ? paddingRight + "px" : "16px";
		if (textDecoration)
			elt.style.textDecoration = textDecoration;
		this._container._container.appendChild(elt);
		var cr = elt.getBoundingClientRect2();
		var w = cr.width + 10;
		var h = cr.height + 10;
		var r = new Rectangle();
		r.width = this._container.width();
		r.height = this._container.height();
		elt.style.left = ((r.width - w) / 2) + "px";
		elt.style.top =  ((r.height - h) / 2) + "px";
		/*
		_win.onmousedown = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._element)
					return;
				p = p.parentNode;
			}
			this.hide();
		}.bind(this);
		*/
	},
	hide: function () {
		var elt = this._element;
		if (!elt || !elt.parentNode) {
			return;
		}
		this._container._container.removeChild(elt);
	},
	_createElement: function () {
		var element = _doc.createElement("div");
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		this._disableSelection(element);
		this._span = _doc.createElement("span");
		element.appendChild(this._span);
		this._disableSelection(this._span);
		return element;
	},
	_disableSelection: function (element) {
        if (typeof element.onselectstart !== 'undefined') {
            element.onselectstart = function() { return false; };
        } else if (typeof element.style.MozUserSelect !== 'undefined') {
            element.style.MozUserSelect = 'none';
        } else {
            element.onmousedown = function() { return false; };
        }
    }
}, {
	$_labelId: 0
});
var ToastManager = defineClass("ToastManager", null, {
	init: function (grid) {
		this._super();
		this._container = grid.container();
		this._toast = null;
		this._active = false;
	},
	isVisible: function () {
		return this._active;
	},
	show: function (options, force, action) {
		if (!this._active || force) {
			this.close();
			options = options instanceof ToastOptions ? options : options ? new ToastOptions(options) : null;
			if (options && options.isVisible()) {
				if (!this._toast) {
					this._toast = new ToastView(this._container);
				}
				this._toast.show(options);
				this._active = true;
				if (action) {
					setTimeout(function () {
						try {
							action();
						} finally {
							this.close();
						}
					}.bind(this), 0);
				}
				return;
			}
		}
		action && action();
	},
	close: function () {
		if (this._active) {
			this._toast && this._toast.hide();
			this._active = false;
		}
	}
});
var ToolTipOptions = defineClass("ToolTipOptions", null, {
	init : function (options) {
		this._super();
		this._styles = new VisualStyles();
		options && this.assign(options);
	},
	message: null,
	visible: true,
	styles: null,
	setStyles: function (value) {
		if (value != this._styles) {
			this._styles.extend(value, false);
		}
	},
	assign: function (source) {
		if (typeof source == "string") {
			this._message = source;
			if (this._message) {
				this._visible = true;
			}
		} else if (typeof source == "boolean") {
			this._visible = Boolean(source);
		} else {
			this._super(source);	
		}
	}
});
var ToolTipView = defineClass("ToolTipView", EventAware, {
	init : function (container) {
		this._super();
		this._container = container;
		this._span = null;
		this._element = this._createElement();
		this._showing = false;
	},
	minWidth: 0,
	maxWidth: 0,
	dropDownCount: 8,
	show: function (options, x, y, cell) {
		this._showing = true;
		try {
			this.$_show(options, x, y, cell);
		} finally {
			this._showing = false;
		}
	},
	$_show: function (options, x, y, cell) {
		var grid = this._container.gridView();
		var s = options.message()+"";
		if (!s) {
			return;
		}
		var elt = this._element;
		if (!elt) {
			return;
		}
		var span = this._span;
		span.innerHTML = s.replace(/\n/g,"<br>");
		elt.style.position = "absolute";
		elt.style.left = x + "px";
		elt.style.top = y + "px";
		elt.style.overflow = "hidden";
		elt.style.zIndex = 3000;
		elt.style.background = options.styles().background().color().value();// "rgba(255, 255, 255, 0.9)";
		elt.style.color = "rgb(100, 100, 100)";
		elt.style.border = "1px solid rgb(100, 100, 100)";
		elt.style.borderRadius = "4px";
		elt.style.boxShadow = "5px 5px 5px rgba(100, 100, 100, 0.8)";
		elt.style.fontFamily = "Tahoma";
		elt.style.fontStyle = "normal";
		elt.style.fontVariant = "normal";
		elt.style.fontWeight = "normal";
		elt.style.fontSize = "10pt";
		elt.style.padding = "2px";
		elt.style.visibility = "hidden";
		elt.style.whiteSpace = "nowrap";
		this._container._container.appendChild(elt);
		var cr = elt.getBoundingClientRect();
		var pr = this._container._container.getBoundingClientRect();
		elt.style.left = cr.right > pr.right ? Math.max((pr.right - cr.width - pr.left -2),0)+"px": elt.style.left;
		if (cr.bottom > pr.bottom) {
			if (cell instanceof HeaderCellElement) {
				elt.style.top = Math.max(0, y - (cr.bottom - pr.bottom))+"px";
			} else {
				elt.style.top = Math.max(y - cr.height - grid._layoutManager.$_calcItemHeight(grid, grid.delegate(),0), 0)+"px";
			}
		}
		elt.style.visibility = "visible";
		/*
		var cr = elt.getBoundingClientRect();
		var w = cr.width + 10;
		var h = cr.height + 10;
		var r = new Rectangle();
		r.width = this._container.width();
		r.height = this._container.height();
		elt.style.left = x + "px";//((r.width - w) / 2) + "px";
		elt.style.top = y + "px";// ((r.height - h) / 2) + "px";
		*/
	},
	hide: function () {
		var elt = this._element;
		if (!elt || !elt.parentNode) {
			return;
		}
		this._container._container.removeChild(elt);
	},
	_createElement: function () {
		var element = _doc.createElement("div");
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		if (_isMobile()) {
			element.addEventListener("touchend", this._touchendHandler.bind(this), false);
		}
		this._disableSelection(element);
		this._span = _doc.createElement("span");
		element.appendChild(this._span);
		this._disableSelection(this._span);
		return element;
	},
	_touchendHandler: function (event) {
		event.preventDefault();
		this.hide();
	},
	_disableSelection: function (element) {
        if (typeof element.onselectstart !== 'undefined') {
            element.onselectstart = function() { return false; };
        } else if (typeof element.style.MozUserSelect !== 'undefined') {
            element.style.MozUserSelect = 'none';
        } else {
            element.onmousedown = function() { return false; };
        }
    }
}, {
	$_labelId: 0
});
var ToolTipManager = defineClass("ToolTipManager", null, {
	init: function (grid) {
		this._super();
		this._container = grid.container();
		this._tipView = null;
		this._active = false;
		this._hintDuration = grid.displayOptions && grid.displayOptions() ? grid.displayOptions()._hintDuration : 0;
		this._showTimer = null;
	},
	isVisible: function () {
		return this._active;
	},
	show: function (options, x, y, cell) {
		if (!this._active) {
			this.close();
			options = options instanceof ToolTipOptions ? options : options ? new ToolTipOptions(options) : null;
			if (options && options.isVisible()) {
				if (!this._tipView) {
					this._tipView = new ToolTipView(this._container);
				}
				this._tipView.show(options, x, y, cell);
				var grid = cell.grid();
				if (grid) {
					this._showPos = {x:grid.mouseX(), y:grid.mouseY()};
				}
				this._active = true;
			}
		}
	},
	close: function (x, y) {
		if (this._active && x && y) {
			var showPos = this._showPos;
			if ( showPos && Math.abs(showPos.x - x) < 4 && Math.abs(showPos.y - y) < 4) {
				return;
			}
		}
		this._showTimer && clearTimeout(this._showTimer);
		if (this._active) {
			this._tipView && this._tipView.hide();
			this._active = false;
		}
	}
});
ValidationLevel.$_levels = {
	error: 1,
	warning: 2,
	info: 3,
	ignore: 4
};
ValidationLevel.compare = function (level1, level2) {
	return ValidationLevel.$_levels[level1] - ValidationLevel.$_levels[level2];
};
var ValidationError = function (level, message, column, userMessage) {
	this.level = level;
	this.message = message;
	this.column = column;
	this.userMessage = userMessage;
	AbortError.call(this, message);
};
ValidationError.prototype = new AbortError();
ValidationError.prototype.toString = function () {
	return "Validation failed[" + this.level + "]: " + this.message;
};
var EditValidation = defineClass("EditValidation", null, {
	init: function (name) {
		this._super();
		this._name = name;
	},
	name: null,
	active: true,
	mode: ValidationMode.ALWAYS,
	level: ValidationLevel.ERROR,
	criteria: null,
	message: null,
	description: null,
	setCriteria: function (value) {
		if (value != this._criteria) {
			this._criteria = value;
			if (value) {
				this._exprNode = ExpressionParser.Default.parse(value, EditValidation.CAPITAL_INDEXERS);
			} else {
				this._exprNode = null;
			}
		}
	},
	validate: function (runtime) {
		if (this._exprNode && !this._exprNode.evaluate(runtime)) {
			var s = this._message || this._description || this._name || this._criteria;
			throw new ValidationError(this._level, s, null, this._message);
		}
	}
}, {
	CAPITAL_INDEXERS: ["value", "values"]
});
var EditValidationCollection = defineClass("EditValidationCollection", null, {
	init: function() {
		this._super();
		this._items = [];
	},
	count: function () {
		return this._items.length;
	},
	items_: function () {
		return this._items.slice();
	},
	setItems: function (value) {
		this.assign(value);
	},
	clear: function () {
		this._items = [];
	},
	addAll: function (items) {
		if (items && items.length > 0) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				this._items.push(items[i]);
			}
		}
	},
	assign: function (source) {
		if (source !== this) {
			this.clear();
			if (source) {
				if (!_isArray(source)) {
					source = [source];
				}
				for (var i = 0, cnt = source.length; i < cnt; i++) {
					var ev = new EditValidation();
					ev.assign(source[i]);
					this._items.push(ev);
				}
			}
		}
	},
	validate: function (mode, runtime, checkLevel, commitLevel) {
		for (var i = 0; i < this._items.length; i++) {
			var item = this._items[i];
			if (item.isActive() && (item.mode() == mode || item.mode() == ValidationMode.ALWAYS)) {
				try {
					item.validate(runtime);
				} catch (err) {
					if (!checkLevel || (ValidationLevel.compare(item.level(), commitLevel) < 0)) {
						if (err instanceof ValidationError) {
							err.level = item.level();
							throw err;
						} else {
							throw new ValidationError(item.level(), err);
						}
					}
				}
			}
		}
	}
});
var DataRowValidationRuntime = defineClass("DataRowValidationRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
		this._item = null;
		this._dataSource = null;
		this._fieldCount = null;
	},
	item: null,
	setItem: function (value) {
		this._item = value;
		this._dataSource = this._item.dataSource();
		this._fieldCount = this._dataSource ? this._dataSource.fieldCount() : 0;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataRowValidationRuntime.IDENTS.hasOwnProperty(token)) {
			var v = DataRowValidationRuntime.IDENTS[token];
			return v;
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case DataRowValidationRuntime.ID_ROW:
				return this._item.index();
			case DataRowValidationRuntime.ID_DATA_ROW:
				return this._item.dataRow();
			case DataRowValidationRuntime.ID_CHECKED:
				return this._item.isChecked();
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (index < 0 || index >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
		}
		switch (idKey) {
		case DataRowValidationRuntime.ID_VALUE:
		case DataRowValidationRuntime.ID_VALUES:
			return this._item.getData(index);
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
		if (idx < 0 || idx >= this._fieldCount) {
			throw new ExpressionEvaluationError("Data field is not exists:" + index);
		}
		switch (idKey) {
			case DataRowValidationRuntime.ID_VALUE:
			case DataRowValidationRuntime.ID_VALUES:
				return this._item.getData(idx);
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_ROW: 0,
	ID_DATA_ROW: 1,
	ID_CHECKED: 2,
	ID_VALUE: 3,
	ID_VALUES: 4
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		checekd: f.ID_CHECKED,
		value: f.ID_VALUE,
		values: f.ID_VALUES
	};
});
var DataCellValidationRuntime = defineClass("DataCellValidationRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
		this._index = null;
		this._value = null;
	},
	setIndex: function (value) {
		this._index = value;
		this._value = this._index.item().getData(this._index.column().dataIndex());
		this._dataSource = this._index.item().dataSource();
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataCellValidationRuntime.IDENTS.hasOwnProperty(token)) {
			var v = DataCellValidationRuntime.IDENTS[token];
			return v;
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		switch (idKey) {
			case DataCellValidationRuntime.ID_VALUE:
				return this._value;
			case DataCellValidationRuntime.ID_ROW:
				return this._index.I();
			case DataCellValidationRuntime.ID_DATA_ROW:
				return this._index.item().dataRow();
			case DataCellValidationRuntime.ID_INDEX:
				return this._index.column().index();
			case DataCellValidationRuntime.ID_FIELD:
				return this._index.column().dataIndex();
			case DataCellValidationRuntime.ID_CHECKED:
				var item = this._index.item();
				return item ? item.isChecked() : false;
			case DataCellValidationRuntime.ID_TAG:
				return this._index.column().tag();
			case DataCellValidationRuntime.ID_BASE:
				var idx = this._index.dataColumn().baseIndex();
				return idx >= 0 ? this._index.item().getData(idx) : UNDEFINED;
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		var fldCnt = this._dataSource.fieldCount();
		if (index < 0 || index >= fldCnt) {
			throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
		}
		switch (idKey) {
			case DataCellValidationRuntime.ID_VALUE:
			case DataCellValidationRuntime.ID_VALUES:
				return this._index.item().getData(index);
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
		var fldCnt = this._dataSource.fieldCount();
		if (idx < 0 || idx >= fldCnt) {
			throw new ExpressionEvaluationError("Data field is not exists:" + index);
		}
		switch (idKey) {
			case DataCellValidationRuntime.ID_VALUE:
			case DataCellValidationRuntime.ID_VALUES:
				return this._index.item().getData(idx);
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_VALUE: 0,
	ID_ROW: 1,
	ID_DATA_ROW: 2,
	ID_INDEX: 3,
	ID_FIELD: 4,
	ID_CHECKED: 5,
	ID_TAG: 6,
	ID_BASE: 7,
	ID_VALUES: 8
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		index: f.ID_INDEX,
		field: f.ID_FIELD,
		checked: f.ID_CHECKED,
		tag: f.ID_TAG,
		base: f.ID_BASE,
		values: f.ID_VALUES
	};
});
var ValidationManager = defineClass("ValidationManager", null, {
	init: function(owner) {
		this._super();
		this._owner = owner;
		this._userValidations = false;
		this._validateCellList = {};		
	},
	owner: function () {
		return this._owner;
	},
	hasRowValidation: function () {
		return this._owner.validations() && this._owner.validations().count() > 0;
	},
	validateCell: function (index/*CellIndex*/, inserting) {
		this.$_validateCell(index, inserting, true, this._owner.editOptions().commitLevel());
	},
	validateRow: function (item/*GridItem*/, inserting, rowOnly) {
		var level/*ValidationLevel*/ = this._owner.editOptions().commitLevel();
		if (!rowOnly) {
			var columns/*[DataColumn]*/ = this._owner.getDataColumns();
			for (var i = 0, cnt = columns.length; i < cnt; i++) {
				var column = columns[i];
				var index = CellIndex.temp(this._owner, item.index(), column);
				this.$_validateCell(index, inserting, true, level);
			}
		}
		var validations/*EditValidationCollection*/ = this._owner.validations();
		if (validations && validations.count() > 0) {
			var runtime/*DataRowValidationRuntime*/ = this._owner.rowValidationRuntime();
			runtime.setItem(item);
			validations.validate(inserting ? ValidationMode.INSERT : ValidationMode.UPDATE, runtime, false, level);
		}
	},
	$_validateCell: function (index, inserting, levelCheck, level) {
		var column = _cast(index.dataColumn(), DataColumn);
		if (column) {
			var value = index.item().getData(column.dataIndex());
			if (column.isRequired()) {
				var grid = column.grid();
				var fld = grid && grid.dataSource() && grid.dataSource().getField(column.dataIndex());
				if (fld && fld.isEmpty(value)) {
					var level = column.requiredLevel() || ValidationLevel.ERROR;
					var msg = column.requiredMessage() || "Value is required: " + column.fieldName();
					throw new ValidationError(level, msg, column, column.requiredMessage());
				}
			}
			var validations = column.validations();
			if (validations && validations.count() > 0) {
				var runtime/*DataCellValidationRuntime*/ = this._owner.columnValidationRuntime();
				runtime.setIndex(index);
				try {
					validations.validate(inserting ? ValidationMode.INSERT : ValidationMode.UPDATE, runtime, levelCheck, level);
					this.$_clearInvalidateCell(index);
				} catch (err) {
					if (err instanceof ValidationError) {
						err.column = column;
					}
					throw err;
				}
			}
		}
	},
	$_addInvalidateCell: function(index, err) {
		var dataId = index.dataId && index.dataId();
		var dataIndex = index.dataColumn && index.dataColumn().dataIndex();
		if (dataId == undefined || dataIndex <= -1) {
			return;
		};
		var validateList = this._validateCellList;
		var row = validateList[dataId] ? validateList[dataId] : (validateList[dataId] = {});
		row[dataIndex] = {dataRow:index.dataRow(), message:err.message, userMessage:err.userMessage, level:err.level, column:index.dataColumn().name()}
	},
	$_clearInvalidateCell: function(index) {
		var dataId = index.dataId();
		var dataIndex = index.dataColumn().dataIndex();
		var row = this._validateCellList[dataId];
		if (row && row[dataIndex]) {
			delete row[dataIndex];
		}
	},
	$_clearInvalidateList: function() {
		this._validateCellList = {};
		this._userValidations = false;
		var grid = this._owner;
		grid.refreshView();
	},
	clearInvalidCellList: function() {
		this.$_clearInvalidateList();
	},
	addInvalidateCell: function(index, err) {
		this.$_addInvalidateCell(index, err)
	},
	getInvalidCellList: function () {
		var ret = [];
		var invalidList = this._validateCellList;
		for (var r in invalidList) {
			var row = invalidList[r];
			for (var c in row) {
				var cell = row[c];
				ret.push(
					{column: cell.column, dataRow: cell.dataRow, message:cell.message, level:cell.level}
				)
			}
		}
		return ret.length > 0 ? ret : null;
	},
	checkValidateCells: function (itemIndices, visibleOnly) {
		var grid = this._owner;
		var columns = grid.getDataColumns();
		var items = [];
		var i, j, cnt, rCnt, item;
		if (itemIndices != null) {
			itemIndices = _makeArray(itemIndices);
			for (i = 0, cnt = itemIndices.length; i < cnt ; i++) {
				item = grid.getItem(itemIndices[i]);
				if (item && item.dataId && item.dataId() > -1) {
					delete this._validateCellList[item.dataId()];
					items.push(item);
				}
			}
		} else {
			if (visibleOnly) {
				for (i = 0, cnt = grid.itemCount(); i < cnt ; i++) {
					item = grid.getItem(i);
					if (item && item.dataId && item.dataId() > -1) {
						delete this._validateCellList[item.dataId()];
						items.push(item);
					}
				}
			} else {
				items = grid.getAllItems();
			}
			this._validateCellList = {};
		}
		for (i = 0, rCnt = items.length;  i < rCnt; i++) {
			item = items[i];
			if (!item.dataId || (item.dataId() < 0)) { continue };
			for (j = 0, cnt = columns.length; j < cnt; j++) {
				try {
					var column = columns[j];
					var dataIndex = column.dataIndex();
					var index = CellIndex.temp(grid, item.index(), column);
					index._item = item;
					this.$_validateCell(index, false, false, "ignore");
					grid._fireValidateCell(index, false, index.item().getData(dataIndex));
				} catch (err) {
					this.$_addInvalidateCell(index, err);
					this._userValidations = true;
				}
			}
		};
		grid.refreshView();
		return this.getInvalidCellList();
	},
	clearInvalidateList: function() {
		this.$_clearInvalidateList();
	}
});

var /* abstract */ LookupSource = defineClass("LookupSource", EventAware, {
	init: function (id) {
		this._super();
		this._id = id;
	},
	id: function () {
		return this._id;
	},
	clear: function () {
	},
	load: function (options) {
	},
	exists: function (/*keys*/) {
		return false;
	},
	fill: function (keys, values) {
	},
	fillRows: function (rows) {
	},
	add: function (keys, value) {
	},
	addRow: function (row) {
	},
	lookup: function () {
		return undefined;
	},
	getDomain: function (/*keys*/) {
		return null;
	},
	getTextDomain: function (/*keys*/) {
		return null;
	},
	_changed: function () {
		this.fireEvent(LookupSource.CHANGED);
	}
});
LookupSource.CHANGED = "onLookupSourceChanged";
var /* abstract */ LookupSourceProvider = defineClass("LookupSourceProvider", EventAware, {
	init: function (id) {
		this._super();
		this._id = id;
	},
	getSource: function (id) {
		return null;
	},
	_changed: function () {
		this.fireEvent(LookupSourceProvider.CHANGED);
	}
});
LookupSourceProvider.CHANGED = "onLookupSourceProviderChanged";
var LocalLookupSourceProvider = defineClass("LocalLookupSourceProvider", LookupSourceProvider, {
	init: function (config) {
		this._super();
		this._sources = {};
		config && this.load(config);
	},
	/**
	 * [{
	 * 		id: "id",
	 * 		type: "table" | "tree",
	 * 		levels: 2 // for tree
	 * }, {
	 * }]
	 */
	load: function (config) {
		if (config !== this) {
			this._sources = {};
			if (_isArray(config)) {
				for (var i = 0, cnt = config.length; i < cnt; i++) {
					this.$_add(config[i]);
				}
			} else if (config) {
				this.$_add(config);
			}
			this._changed();
		}
	},
	add: function (config) {
		var source = this.$_add(config);
		source && this._changed();
		return source;
	},
	remove: function (id) {
		if (this.$_remove(id)) {
			this._changed();
		}
	},
	getSource: function (id) {
		return this._sources[id];
	},
	$_createSource: function (src) {
		var source = null;
		if (src) {
			var type = src.type;
			type = type ? type.toLowerCase() : null;
				var tree = new LookupTree(src.id, src.levels, src.ordered);
				tree.fill(src.keys, src.values);
				source = tree;
		}
		return source;
	},
	$_add: function (config) {
		if (config && config.id) {
			if (this._sources[config.id] !== config) {
				var source = this.$_createSource(config);
				if (source) {
					this.$_remove(config.id);
					this._sources[config.id] = source;
					source.addListener(this);
					return source;
				}
			}
		}
		return null;
	},
	$_remove: function (id) {
		if (id) {
			var source = this._sources[id];
			if (source) {
				source.removeListener(this);
				delete this._sources[id];
				return true;
			}
		}
		return false;
	},
	onLookupSourceChanged: function (source) {
		this._changed();
	}
});
var LookupTree = defineClass("LookupTree", LookupSource, {
	init: function (id, levels, ordered) {
		id = arguments.length > 0 ? id : null;
		levels = arguments.length > 1 ? levels : -1;
		ordered = arguments.length > 2 ? ordered : false;
		this._super(id);
		if (levels < 1 ) {
			throw "LookupTable levels must be equals or greater than 1";
		}
		this._levels = levels;
		this._tree = {};
		this._listMap = ordered ? {} : null;
	},
	clear: function () {
		this._tree = {};
		this._changed();
	},
	load: function (options) {
	},
	exists: function (keys) {
		var len;
		if (keys && (len = keys.length) > 0 && len <= this._levels) {
			len = Math.min(len, this._levels) - 1;
			if (len > 0) {
				var key;
				var map = this._tree;
				for (var i = 0; i < len; i++) {
					key = keys[i];
					map = map[key];
					if (!map) {
						break;
					}
				}
				return map != null && map.hasOwnProperty(keys[len]);
			} else {
				return this._tree.hasOwnProperty(keys[0]);
			}
		}
		return false;
	},
	fill: function (keys, values) {
		if (keys && keys.length > 0 && values && values.length > 0) {
			var cnt = Math.min(keys.length, values.length);
			for (var i = 0; i < cnt; i++) {
				var k = keys[i];
				if (!_isArray(k)) {
					k = [k];
				}
				this.$_add(k, values[i]);
			}
			this._changed();
		}
	},
	fillRows: function (rows) {
		var cnt;
		if (rows && (cnt = rows.length) > 0) {
			for (var i = 0; i < cnt; i++) {
				this.$_addRow(rows[i]);
			}
			this._changed();
		}
	},
	add: function (keys, value) {
		if (keys) {
			this.$_add(keys, value);
			this._changed();
		}
	},
	addRow: function (row) {
		if (row) {
			this.$_addRow(row);
			this._changed();
		}
	},
	lookup: function (keys, valueSeparator) {
		if (this._levels > 1) {
			var i, key;
			var map = this._tree;
			var len = this._levels - 1;
			for (i = 0; i < len; i++) {
				key = keys[i];
				map = map[key];
				if (!map) {
					break;
				}
			}
		} else {
			map = this._tree;
		}
		key = keys[keys.length-1];
		if (map && key && valueSeparator) {
			var values = key.split(valueSeparator);
			var ret = [];
			for (var i = 0, cnt = values.length; i < cnt ; i++) {
				ret.push(map[values[i]] ? map[values[i]] : values[i]);
			}
			return ret.join(valueSeparator);
		} else {
			return map ? map[key] : undefined;
		}
	},
	getDomain: function (keys) {
		if (!keys || keys.length != this._levels - 1) {
			throw "Keys length must be " + (this._levels - 1);
		}
		var i, cnt, k;
		var domain = [];
		var values = [];
		var key;
		var dic = this._tree;
		if (this._levels > 1) {
			cnt = keys.length;
			for (i = 0; i < cnt; i++) {
				key = keys[i];
				dic = dic[keys[i]];
				if (!dic) {
					return {
						keys: domain,
						values: values
					};
				}
			}
		}
		if (this._listMap) {
			var list = this._listMap[keys.slice(0,keys.length).join("~!~")];
			cnt = list ? list.length : 0;
			for (i = 0; i < cnt; i++) {
				domain.push(list[i]);
				values.push(dic[list[i]]);
			}
		} else {
			for (k in dic) {
				domain.push(k);
				values.push(dic[k]);
			}
		}
		return {
			keys: domain,
			values: values
		}
	},
	getTextDomain: function (keys) {
		var i, cnt;
		var domain = this.getDomain(keys);
		var keys = domain.keys;
		var vals = domain.values;
		for (i = 0, cnt = keys.length; i < cnt; i++) {
			keys[i] = keys[i] ? String(keys[i]) : null;
			vals[i] = vals[i] ? String(vals[i]) : null;
		}
		return domain;
	},
	$_add: function (keys, value) {
		if (!keys) {
			return;
		}
		var k;
		var levels = this._levels;
		var len = _isArray(keys) ? keys.length : 1;
		if (len < levels) {
			throw Error("Keys length must be equals or greater than " + levels);
		}
		if (levels > 1) {
			var i, key, node;
			var map = this._tree;
			for (i = 0, len = levels - 1; i < len; i++) {
				key = keys[i];
				node = map[key];
				if (!node) {
					node = {};
					map[key] = node;
				}
				map = node;
			}
			map[k = keys[len]] = value;
		} else {
			this._tree[k = keys] = value;
		}
		if (this._listMap) {
			var keyStr = keys.slice(0,keys.length-1).join("~!~");
			var list = this._listMap[keyStr];
			if (!_isArray(list)) {
				list = [];
				this._listMap[keyStr] = list;
			}
			list.push(k);
		}
	},
	$_addRow: function (row) {
		if (row) {
			var len = row.length;
			if (len - 1 < this._levels ) {
				throw Error("Keys length must be equals or greater than " + this._levels);
			}
			var v = row[this._levels];
			row = row.slice(0, this._levels);
			this.$_add(row, v);
		}
	}
});
var GridObject = defineClass("GridObject", EventAware, {
	init: function (grid) {
		this._super();
		this._grid = grid;
		this._dirty = false;
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		for (var attr in this) {
			if (this[attr] instanceof VisualStyles || this[attr] instanceof DynamicStyleCollection) {
				this[attr] = null;
				// delete this[attr];
			}
		}
		this._super();
	},
	owner: function () {
		return this._grid;
	},
	isDirty: function () {
		return this._dirty;
	},
	/*
	assign: function (source) {
		this._super(source);
		this.$_assignProperties(source);
		if (source instanceof GridObject) {
			if (source._styles) {
				this._styles.extend(source._styles);
			}
		} else if (source) {
			if (source.styles) {
				this._styles.extend(source.styles);
			}
		}
	},
	$_assignProperties: function (source) {
		var prop = null, 
			name;
		if (source instanceof GridObject) {
			for (prop in source) {
				if (prop.indexOf("get") == 0) {
					name = "set" + prop.substring(3);
					if (this[name]) {
						this[name].call(this, source[prop].call(source));
					} else {
						trace("Unknown setter: " + name);
					}
				}
			}
		} else if (source) {
			for (prop in source) {
				if (source.hasOwnProperty(prop)) {
					name = "set" + _capitalize(prop);
					if (this[name]) {
						this[name].call(this, source[prop]);
					} else {
						trace("Unknown setter: " + name);
					}
				}
			}
		}
	},
	*/
	clean: function () {
		if (this._dirty) {
			this._dirty = false;
		}
	},
	invalidate: function () {
		this._grid && this._grid.invalidate();
	},
	refreshOwner: function () {
		this._grid && this._grid.refreshView();
	},
	propertyChanged: function (prop, newValue) {
		if (prop == "visible") {
			this._visibleChanged();
		}
		this._changed();
	},
	_changed: function() {
		if (!this._dirty) {
			this._dirty = true;
			this._doChanged();
			this.refreshOwner();
		}
	},
	_visibleChanged: function () {
		this._grid && this._grid._objectVisualChanged(this);
	},
	_doChanged: function () {
	}
});
var GridObject$ = GridObject.prototype;
var VisualObject = defineClass("VisualObject", GridObject, {
	init: function (grid, styleName) {
		this._super(grid);
		this._styles = new VisualStyles(this, styleName);
	},
	destroy: function() {
		this._destroying = true;
		this._styles = null;
		this._realHeight = null;
		this._super();
	},
	stylesChanged: function (/*stypeProp*/) {
		this._changed();
	},
	visible: true,
	styles: null,
	setStyles: function (value) {
		if (value !== this._styles) {
			this._styles.extend(value);
		}
	},
	_doChanged: function () {
		if (this._grid) {
			this._grid._visualObjectChanged(this);
		}
	}
});
var VisualObject$ = VisualObject.prototype;
var GridPanel = defineClass("GridPanel", VisualObject, {
	init: function (grid/* GridBase */) {
		this._super(grid, "panelStyles");
		this.setVisible(true);
	},
	minHeight: 20,
	height: 0,
	realHeight: 0,
	proxy: function () {
		var obj = this._super();
		obj.height = this._realHeight;
		delete(obj.realHeight);
		return obj;
	}
});
var SummaryObject = defineClass("SummaryObject", VisualObject, {
	init: function (grid, styleName) {
		this._super(grid, styleName);
		this._cell = this.$_createSummaryCell();
		this._groupStyles = new VisualStyles(this);
        this._runtime = new FooterExpressionRuntime();
        this._runStyles = new VisualStyles(this, "runFooterStyles", null, false);
		this._eachStyles =null;
	},
	styles : null,
    groupStyles: null,
	minHeight: IntProp(23),
	height: IntProp_0,
	realHeight: IntProp_0,
	resizable: false,
	mergeCells: null,
	count: 1,
	$_createSummaryCell: function() {
		return null;
	},
	setGroupStyles: function (value) {
		if (value !== this._groupStyles) {
			this._groupStyles.extend(value);
		}
	},
	setStyles: function (value) {
		if (!value) {
			this._eachStyles = null;
			this._styles.clearValues();
		} else {
			if (isArray(value)) {
				var es = this._eachStyles = [];
				var i, cnt, styles;
				for (i = 0, cnt = value.length; i < cnt ; i++) {
					styles = new VisualStyles(this, "footerStyles");
					es.push(styles);
					styles.setSysDefault(this.$_getSysdefaultStyles());
					styles.extend(value[i]);
				}
			} else {
				this._eachStyles = null;
				this._styles.extend(value);
			}
		}
	},
	setMergeCells: function (value) {
		this._mergeCells = [];
		if (value instanceof Array) {
			if (value[0] instanceof Array) {
				for (var i = 0, len = value.length; i < len; i++) {
					this._mergeCells[i] = value[i].slice(0);
				}
			} else {
				this._mergeCells[0] = value.slice(0);
			}
		} else {
			this._mergeCells = null;
		}
		this._summaryMergeDirty = true;
		this._changed();
	},
    getCell: function (index, summaryIndex) {
		var cell = this._cell;
		var column = index.column();
		cell.setIndex(index);
		if (summaryIndex === undefined) {
			cell.setSummaryIndex(0);
		} else {
			cell.setSummaryIndex(summaryIndex);
		}
		cell.calculate();
		if (column instanceof ColumnGroup) {
			cell.setStyles(this._groupStyles);
		} else {
			var summary = this.$_getSummaryObject(column);
        	var sStyles = summary.getStyles(summaryIndex);
        	if (summaryIndex != null && this._eachStyles && this._eachStyles[summaryIndex]) {
        		sStyles.setParent(this._eachStyles[summaryIndex], false);
        	} else {
        		sStyles.setParent(this.styles(), false);
        	}

            var d = summary.getDynamicStyles(summaryIndex);
            if (d && d.count() > 0) {
                var r = this._runStyles;
                r.clearValues();
                r.setParent(sStyles);
                this._runtime.setCell(cell);
                d.applyInternal(this._runtime, r);
                cell.setStyles(r);
            } else {
                cell.setStyles(sStyles)
            }
		}
		return cell;
	},
	assign: function(value) {
		this._super(value);
		if (this._dirty) {
			this._doChanged();
			this.refreshOwner();
		}
	},
	_changed: function() {
		if (!this._dirty) {
			this._dirty = true;
			this._doChanged();
			this.refreshOwner();
		}
	},
	proxy: function () {
		var obj = this._super();
		obj.height = this._realHeight;
		delete(obj.realHeight);
		return obj;
	}
});

var Footer = defineClass("Footer", SummaryObject, {
	init: function (grid) {
		this._super(grid, "footerStyles");
		this.setVisible(true);
	},
	$_createSummaryCell: function() {
		return new FooterCell();
	},
	$_getSummaryObject: function(column) {
		return column.footer();
	},
	$_getSysdefaultStyles: function() {
		GridStyleSheet.Default.footer();
	}
});


var HeaderSummary = defineClass("HeaderSummary", SummaryObject, {
	init: function (header) {
		this._super(header._grid, "headerSummaryStyles");
		this._header = header;
		this._headStyles = new VisualStyles(this);
        this._headCell = new StyledCell(this);
        this.setVisible(false);
	},
	destroy: function () {
		this._destroying = true;
		this._header = null;
		this._headStyles = null;
        this._headCell = null;
		this._super();
	},
    headStyles: null,
	$_createSummaryCell: function() {
		return new HeaderSummaryCell();
	},
	$_getSummaryObject: function(column) {
		return column.header().summary();
	},
    setHeadStyles: function (value) {
        if (value !== this._headStyles) {
            this._headStyles.extend(value);
        }
    },
	header: function () {
		return this._header;
	},
    getHeadCell: function () {
        var cell = this._headCell;
        cell.setStyles(this._headStyles);
        return cell;
    },
	proxy: function () {
		var obj = this._super();
		obj.height = this._realHeight;
		delete(obj.realHeight);
		return obj;
	},
	$_getSysdefaultStyles: function() {
		GridStyleSheet.Default.headerSummary();
	}
});
var Header = defineClass("Header", VisualObject, {
	init: function (grid) {
		this._super(grid, "headerStyles");
        this._summary = new HeaderSummary(this);
		this._groupStyles = new VisualStyles(this, "headerGroupStyles");
        this._subStyles = new VisualStyles(this, "headerSubSytles");
		this._cell = new HeaderCell();
		this.setVisible(true);
	},
	destroy: function() {
		this._destroying = true;
        this._summary = null;
		this._groupStyles = null;
        this._subStyles = null;
		this._cell = null;
		this._super();
	},
    summary: null,
    groupStyles: null,
    subStyles: null,
	minHeight: IntProp(23),
	height: IntProp_0,
	realHeight: IntProp_0,
	resizable: false,
	sortable: true,
	filterable: true,
    subTextLocation: SubTextLocation.LOWER,
	subTextGap: 1,
	itemOffset: 2,
	itemGap: 2,
	imageList: null,
	showTooltip:false,
	tooltipEllipseTextOnly: false,
	heightFill: HeaderHeightFill.DEFAULT,
    setSummary: function (value) {
        if (value !== this._summary) {
            this._summary.assign(value);
        }
    },
	setGroupStyles: function (value) {
		if (value !== this._groupStyles) {
			this._groupStyles.extend(value);
		}
	},
    setSubStyles: function (value) {
        if (value !== this._subStyles) {
            this._subStyles.extend(value);
        }
    },
    setSubTextLocation: function (value) {
        if (!value) {
            value = SubTextLocation.LOWER;
        }
        if (value != this._subTextLocation) {
            this._subTextLocation = value;
            this._changed();
        }
    },
	getCell: function (index) {
		var cell = this._cell;
        var column = index.column();
        var header = column.header();
        var v;
		cell.setIndex(index);
		cell.setStyles(header.styles());
        cell.setSubStyles(header.subStyles());
        cell.setText(header.displayText());
        cell.setSubText(header.subText());
		cell.setSubLocation(!(v = header.subTextLocation()) ? this._subTextLocation : v);
        cell.setSubTextGap((v = header.subTextGap()) === undefined ? this._subTextGap : v);
		cell.setItemOffset((v = header.itemOffset()) === undefined ? this._itemOffset : v);
		cell.setItemGap((v = header.itemGap()) === undefined ? this._itemGap : v);
		cell.setImageList(this._imageList);
		cell.setImageIndex(header.imageIndex());
		cell.setImageUrl(header.imageUrl());
		cell.setCheckLocation(header.checkLocation());
		cell.setImageLocation(header.imageLocation());
		cell.setChecked(column.isChecked());
		cell.setShowTooltip(header.isShowTooltip());
		cell.setTooltip(header.tooltip());
		return cell;
	},
	getGroupingCell: function (column) {
		var cell = this._cell;
        var header = column.header();
        var v;
		cell.setIndex(this._grid.getIndex(-1, column));
		cell.setStyles(this._grid.rowGroup().panelStyles());
        cell.setSubStyles(header.subStyles());
        cell.setText(header.displayText());
        cell.setSubText(header.subText());
        cell.setSubLocation(!(v = header.subTextLocation()) ? this._subTextLocation : v);
        cell.setSubTextGap((v = header.subTextGap()) === undefined ? this._subTextGap : v);
        cell.setItemOffset((v = header.itemOffset()) === undefined ? this._itemOffset : v);
        cell.setItemGap((v = header.itemGap()) === undefined ? this._itemGap : v);
        cell.setImageList(this._imageList);
        cell.setImageIndex(header.imageIndex());
        cell.setImageUrl(header.imageUrl());
        cell.setCheckLocation(header.checkLocation());
        cell.setImageLocation(header.imageLocation());
        cell.setChecked(column.isChecked());
		cell.setShowTooltip(header.isShowTooltip());
		cell.setTooltip(header.tooltip());
		return cell;
	},
    clean: function () {
        this._super();
        this._summary.clean();
    },
	proxy: function () {
		var obj = this._super();
		obj.height = this._realHeight;
		delete(obj.realHeight);
		return obj;
	}
});
var /* @internal */ EditBar = defineClass("EditBar", VisualObject, {
	init: function (grid) {
		this._super(grid, "editBarStyles");
		this._cell = new EditBarCell();
		this.setVisible(false);
	},
	minHeight: 23,
	height: 0,
	getCell: function (index) {
		var cell = this._cell;
		cell.setStyles(this._styles);
		return cell;
	}
});

var /* @internal */ SectionObject = defineClass("SectionObject", VisualObject, {
	init: function (grid, stylename) {
		this._super(grid, stylename);
		this._headStyles = new VisualStyles(this);
		this._footStyles = new VisualStyles(this);
        this._summaryStyles = new VisualStyles(this);
		this._headCell = new StyledCell(this);
		this._footCell = new StyledCell(this);
        this._sumCell = new StyledCell(this);
		this.setVisible(true);
	},
	headStyles: null,
	footStyles: null,
    summaryStyles: null,
	headText: null,
	footText: null,
	summaryText: null,
	headImageUrl: null,
	footImageUrl: null,
	summaryImageUrl: null,
	setHeadStyles: function (value) {
		if (value !== this._headStyles) {
			this._headStyles.extend(value);
		}
	},
	setFootStyles: function (value) {
		if (value !== this._footStyles) {
			this._footStyles.extend(value);
		}
	},
    setSummaryStyles: function (value) {
        if (value !== this._summaryStyles) {
            this._summaryStyles.extend(value);
        }
    },
	getCell: function (index) {
		throwAbstractError();
	},
	getHeadCell: function () {
		var cell = this._headCell;
		cell.setStyles(this._headStyles);
		return cell;
	},
	getFootCell: function () {
		var cell = this._footCell;
		cell.setStyles(this._footStyles);
		return cell;
	},
    getSumCell: function () {
        var cell = this._sumCell;
        cell.setStyles(this._summaryStyles);
        return cell;
    },
    setHeadImageUrl: function (value) {
    	if (value != this._headImageUrl) {
    		this._headImageUrl = value;
    		this._headImage = value ? this._grid.getImage(value) : null;
    		this._changed();
    	}
    },
    setFootImageUrl: function (value) {
    	if (value != this._footImageUrl) {
    		this._footImageUrl = value;
    		this._footImage = value ? this._grid.getImage(value) : null;
    		this._changed();
    	}    	
    },
    setSummaryImageUrl: function (value) {
    	if (value != this._summaryImageUrl) {
    		this._summaryImageUrl = value;
    		this._summaryImage = value ? this._grid.getImage(value) : null;
    		this._changed();
    	}
    },
    headImage: function () {
    	if (this._headImage) {
    		return this._headImage;
    	} else {
    		return this._headImage = this._headImageUrl ? this._grid.getImage(this._headImageUrl) : null;
    	}
    },
    footImage: function () {
    	if (this._footImage) {
    		return this._footImage;
    	} else {
    		return this._footImage = this._footImageUrl ? this._grid.getImage(this._footImageUrl) : null;
    	}    	
    },
    summaryImage: function () {
    	if (this._summaryImage) {
    		return this._summaryImage;
    	} else {
    		return this._summaryImage = this._summaryImageUrl ? this._grid.getImage(this._summaryImageUrl) : null;
    	}
    }
});

var Indicator = defineClass("Indicator", SectionObject, {
	init: function (grid) {
		this._super(grid, "indicatorStyles");
		this._cell = new IndicatorCell(this);
		this._stateImages = {};
		this._mark = StateMark.DEFAULT;
	},
	destroy: function() {
		this._destroying = true;
		this._realWidth = null;
		this._super();
	},
	displayValue: IndicatorValue.INDEX,
	zeroBase: false,
	indexOffset: IntProp_0,
	rowOffset: IntProp_0,
	minWidth: IntProp(40),
	maxWidth: IntProp_0,
	width: IntProp_0,
	realWidth: IntProp_0,
	selectable: true,
	stateImages: null,
	mark: null,
	getCell: function (index) {
		var cell = this._cell;
		cell.setIndex(index);
		cell.setStyles(this.styles());
		var item = index.item();
		if (item) {
			var state = index.item().itemState();
			if (state == ItemState.NORMAL && this._grid.focusedIndex().I() == index.I()) {
				state = ItemState.FOCUSED;
			}
			cell.setItemState(state);
		}
		return cell;
	},
    setStateImages: function (value) {
		if (typeof value == "object") {
			for (var state in value) {
				this._stateImages[state] = value[state];
			}
			this._changed();
		}
    },
	proxy: function () {
		var obj = this._super();
		obj.width = this._realWidth;
		delete(obj.realWidth);
		return obj;
	}
});
var StateBar = defineClass("StateBar", SectionObject, {
	init: function (grid) {
		this._super(grid, "stateBarStyles");
		this._cell = new StateBarCell();
		this._stateTexts = {
			"created": "C",
			"updated": "U",
			"deleted": "D",
			"createAndDeleted": "X"
		};
		this._stateStyles = {
			"created": null,
			"updated": null,
			"deleted": null,
			"createAndDeleted": null	
		};
		this._stateImages = {};
	},
	destroy: function() {
		this._destroying = true;
		this._stateTexts = null;
		this._stateStyles = null;
		this._super();
	},
	width: IntProp(20),
	mark: StateMark.DEFAULT,
    stateTexts: {},
    stateStyles: {},
    stateImages: {},
    setStateTexts: function (value) {
		if (typeof value == "object") {
			for (var state in value) {
				if (this._stateTexts.hasOwnProperty(state)) {
					this._stateTexts[state] = value[state];
				}
			}
			this._changed();
		}
    },
    setStateImages: function (value) {
		if (typeof value == "object") {
			for (var state in value) {
				this._stateImages[state] = value[state];
			}
			this._changed();
		}
    },
    setStateStyles: function (value) {
    	if (typeof value == "object") {
    		for (var state in value) {
    			if (this._stateStyles.hasOwnProperty(state)) {
    				if (value[state] == null) {
    					this._stateStyles[state] = null;
    				} else {
    					var st = this._stateStyles[state];
    					st = st ? st : new VisualStyles(this);
    					st.copy(this._styles);
    					st.extend(value[state],false);
    					this._stateStyles[state] = st;
    				}
    			}
    		}
    		this._changed();
    	}
    },
	getCell: function (index) {
		var cell = this._cell;
		cell.setIndex(index);
		cell.setStyles(this.styles());
		return cell;
	}	
});
var CheckBar = defineClass("CheckBar", SectionObject, {
	init: function (grid) {
		this._super(grid, "checkBarStyles");
		this._cell = new CheckBarCell();
        this._runtime = new CheckBarExpressionRuntime();
        this._runStyles = new VisualStyles(this, "runCheckBarStyles", null, false);
        this._dynamicStyles = new DynamicStyleCollection(this);
		this._allChecked = false;
	},
	width: IntProp(20),
	exclusive: false,
	showAll: true,
	showGroup: true,
	visibleOnly: false,
	checkableOnly: true,
	checkableExpression: null,
	dynamicStyles:null,
	headCheckImageUrl: null,
	headUnCheckImageUrl : null,
	checkImageUrl: null,
	unCheckImageUrl: null,
	disableCheckImageUrl: null,
	disableUnCheckImageUrl: null,
	drawCheckBox: true,
	radioImageUrl: null,
	syncHeadCheck: false,
	setCheckImageUrl: function(value) {
		if (value != this._checkImageUrl) {
			this._checkImageUrl = value;
			value && this._grid.getImage(value);
		}
	},
	setUnCheckImageUrl : function(value) {
		if (value != this._unCheckImageUrl) {
			this._unCheckImageUrl = value;
			value && this._grid.getImage(value);
		}
	},
	setDisableCheckImageUrl: function(value) {
		if (value != this._disableCheckImageUrl) {
			this._disableCheckImageUrl = value;
			value && this._grid.getImage(value);
		}
	},
	setDisableUnCheckImageUrl: function(value) {
		if (value != this._disableUnCheckImageUrl) {
			this._disableUnCheckImageUrl = value;
			value && this._grid.getImage(value);
		}
	},
	getCheckImage: function (checked, checkable) {
		var img;
		if (checkable) {
			img = checked ? this._checkImageUrl : this._unCheckImageUrl;
		} else {
			img = checked ? (this._disableCheckImageUrl || this._checkImageUrl) : (this._disableUnCheckImageUrl || this._unCheckImageUrl);
		}
		return img ? this._grid.getImage(img) : null;
	},
	setHeadCheckImageUrl: function(value) {
		if (value != this._headCheckImageUrl) {
			this._headCheckImageUrl = value;
			value && this._grid.getImage(value);
		}
	},
	setHeadUnCheckImageUrl : function(value) {
		if (value != this._headUnCheckImageUrl) {
			this._headUnCheckImageUrl = value;
			value && this._grid.getImage(value);
		}
	},
	setRadioImageUrl: function(value) {
		if (value != this._radioImageUrl) {
			this._radioImageUrl = value;
			value && this._grid.getImage(value);
		}
	},
	getCell: function (index) {
		var cell = this._cell;
		cell.setIndex(index);
		var d = this.dynamicStyles();
		if (d && d.count() > 0) {
			var r = this._runStyles;
			r.clearValues();
			r.setParent(this.styles());
			this._runtime.setCell(cell);
			d.applyInternal(this._runtime, r);
			cell.setStyles(r);
		} else {
			cell.setStyles(this.styles())
		}
		return cell;
	},
	setCheckableExpression: function(value) {
		this._checkableExpression = value;
		this._grid._items && this._grid._items.setCheckableExpression && this._grid._items.setCheckableExpression(this.checkableExpression());
		if (!this._dirty) {
			this._dirty = true;
			this.refreshOwner();
		}
	},
	setDynamicStyles: function(value) {
		this._dynamicStyles.setItems(value);
		this.refreshOwner();
	},
	capitalIndexers: function () {
		return ["value", "values"];
	},
	propertyChanged: function (prop, newValue) {
		if (prop == "exclusive") {
			this._grid && this._grid._objectVisualChanged(this);			
		}
		this._super(prop, newValue);
	}
});
var GridBody = defineClass("GridBody", VisualObject, {
	init: function (grid) {
		this._super(grid, "gridBodyStyles");
		this._cellStyles = new VisualStyles(this, "", null, false);
		this._runtimeStyles = new VisualStyles(this, "", null, false);
		this._runtimeStyles2 = new VisualStyles(null, "", null, false);
		this._items = null;
		this._fixedStyles = null;
		this._bodyStyles = null;
		this._hasCellStyles = false;
		this._emptyStyles = new VisualStyles(this, "emptyStyles", null, false);
		this._rowHoverStyles = new VisualStyles(this, "rowHoverStyles", {border:null}, false);
		this._rowFocusStyles = new VisualStyles(this, "rowFocusStyles", {border:null}, false);
		this._dynamicStyles = new DynamicStyleCollection(this);
		this._cellDynamicStyles = new DynamicStyleCollection(this);
		this._rowStylesFirst = false;
		this._fixedIgnoreDynamic = false;
		this._fixedIgnoreColumn = false;
        this._groupCell = new GroupCell();
		this._dataCell = new DataCell();
		this._literalCell = new LiteralCell();
		this._seriesCell = new SeriesCell();
		this._mergedCell = new MergedDataCell();
		this._dataSource = null;
		this._rowRuntime = new DataRowExpressionRuntime();
		this._cellRuntime = new DataCellExpressionRuntime();
		this._rowStylesOwner = new DynamicStyleOwner({
			capitalIndexers: ["value", "values"]
		});
		this._cellStylesOwner = new DynamicStyleOwner({
			capitalIndexers: ["value", "values"]
		});
		this._styleTargets = { body: true, fixed: false };
		this._runBodyStyles = new VisualStyles(this, "runBodyStyles", null, false);
	},
	destroy: function() {
		this._destroying = true;
		this._styleTargets = null;;
		for( var attr in this) {
			if (this[attr] instanceof VisualStyles) {
				this[attr] = null;
				delete this[attr];
			}
		}
		this._rowStylesOwner = null;
		this._cellStylesOwner = null;
		this._super();
	},
	capitalIndexers: function () { return $$_gridbody_capital_indexers; },
    emptyStyles: null,
    rowHoverStyles: null,
    rowFocusStyles: null,
    dynamicStyles: null,
    cellDynamicStyles: null,
	rowStylesFirst: false,
	setEmptyStyles: function (value) {
		if (value !== this._emptyStyles) {
			this._emptyStyles.extend(value);
			this._grid && this._grid.refreshView();
		}
	},
	setRowHoverStyles: function (value) {
		if (value != this._rowHoverStyles) {
			this._rowHoverStyles.extend(value);
			this._grid && this._grid.refreshView();
		}
	},
	setRowFocusStyles: function(value) {
		if (value != this._rowFocusStyles) {
			this._rowFocusStyles.extend(value);
			this._grid && this._grid.refreshView();
		}
	},
	setDynamicStyles: function (value) {
		this._dynamicStyles.setItems(value);
		this._grid && this._grid.refreshView();
	},
	setCellDynamicStyles: function (value) {
		this._cellDynamicStyles.setItems(value);
		this._grid && this._grid.refreshView();
	},
	setRowStylesFirst: function (value) {
		if (value != this._rowStylesFirst) {
			this._rowStylesFirst = value;
			this._grid && this._grid.refreshView();
		}
	},
	rowRuntime: function () {
		return this._rowRuntime;
	},
	cellRunTime: function () {
		return this._cellRuntime;
	},
	checkDynamicStyle: function (index, item) {
		if (index.isFixed() && this._fixedIgnoreDynamic) {
			return false;
		}
		if (index._itemIndex < 0 && !item) {
			return false;
		}
		item = item ? item : index.item();
		// var item = index.item();
        this._rowRuntime.setItem(item, this._grid);
        if (this._dynamicStyles.checkStyle(this._rowRuntime)) {
        	return true;
        }
		var column = index.column();
		var dataColumn = index.dataColumn();
		if (dataColumn && !column._ignoreDefaultDynamicStyles) {
			var cell = column instanceof SeriesColumn ? this._seriesCell : column instanceof LiteralCell ? this._literalCell : column instanceof ColumnGroup ? this._groupCell : this._dataCell;
			cell.setIndex(index);
			this._cellRuntime.setCell(cell, item);
			if (this.cellDynamicStyles().checkStyle(this._cellRuntime)) {
				return true;
			}
			if (dataColumn.dynamicStyles().checkStyle(this._cellRuntime)) {
				return true;
			}
			if (this._hasCellStyles && this._items.checkCellStyle(item.dataRow(), dataColumn.dataIndex())) {
                return true;
            }
		}
	    return false;
	},
	getCell: function (index, merged, item) {
		var runStyles;
		var column = index.column();
		var dataColumn = index.dataColumn();
		var fixed = index.isFixed();
		var cell;
		if (merged) {
			cell = this._mergedCell;
		} else if (column instanceof DataColumn) {
			cell = this._dataCell;
		} else if (column instanceof SeriesColumn) {
			cell = this._seriesCell;
		} else if (column instanceof LiteralCell) {
			cell = this._literalCell;
		} else if (column instanceof ColumnGroup) {
			cell = this._groupCell;
		} else {
			cell = this._dataCell;
		}

		// var cell = merged ? this._mergedCell : column instanceof SeriesColumn ? this._seriesCell : column instanceof LiteralCell ? this._literalCell : column instanceof ColumnGroup ? this._groupCell : this._dataCell;
		var runBodyStyles = this._rowStylesFirst ? this._runBodyStyles : null;
		var colStyles = this._cellStyles;
		cell.setIndex(index);
		
		runStyles = this._runtimeStyles2;
    	runStyles.clearValues(); 
		if (!this._fixedIgnoreColumn || !fixed) {
        	runStyles.assign(column._styles);
        }
		if (runBodyStyles) {
			runStyles.setParent(runBodyStyles, false);
		} else {
			runStyles.setParent(fixed ? this._fixedStyles : this._bodyStyles, false);
		}
		colStyles.clearValues();
		colStyles.setParent(runStyles, false);
        if (this._dataSource && cell !== this._groupCell) {
            item = item ? item : index.item();
            var dynRow, dynCell, dynCol, dynRowCount, dynCellCount, dynColCount;
            if (fixed && this._fixedIgnoreDynamic) {
                dynRowCount = dynCellCount = dynColCount = 0;
            } else {
                dynRow = this._dynamicStyles;
                dynCell = this._cellDynamicStyles;
                dynRowCount = dynRow.count();
                if (dataColumn) {
                    dynCellCount = dataColumn._ignoreDefaultDynamicStyles ? 0 : dynCell.count();
                    dynCol = dataColumn.dynamicStyles();
                    dynColCount = dynCol.count();
                } else {
                    dynCellCount = column._ignoreDefaultDynamicStyles ? 0 : dynCell.count();
                    dynColCount = 0;
                }
            }
            if (runBodyStyles) {
                this._styleTargets.body = !fixed;
                this._styleTargets.fixed = fixed;
                runBodyStyles.clearValues();
                runBodyStyles.setParent(fixed ? this._fixedStyles : this._bodyStyles, false);
                if (dynRowCount > 0) {
                    this._rowRuntime.setItem(item, this._grid);
                    dynRow.applyInternal(this._rowRuntime, runBodyStyles, this._styleTargets);
                }
                if (dynCellCount > 0 || dynColCount > 0) {
                    runStyles = this._runtimeStyles;
                    runStyles.clearValues();
                    runStyles.setParent(colStyles, false);
                    if (dynCellCount > 0) {
                        this._cellRuntime.setCell(cell, item);
                        dynCell.applyInternal(this._cellRuntime, runStyles, this._styleTargets);
                    }
                    if (dynColCount > 0) {
                        this._cellRuntime.setCell(cell, item);
                        dynCol.applyInternal(this._cellRuntime, runStyles, this._styleTargets);
                    }
                    cell.setStyles(runStyles);
                } else {
                    cell.setStyles(colStyles);
                }
            } else if ( item.dataRow && item.dataRow() >= -1 && (dynRowCount > 0 || dynCellCount > 0 || dynColCount > 0) ) {  // item.dataRow check
            // } else if (dynRowCount > 0 || dynCellCount > 0 || dynColCount > 0) { 
                runStyles = this._runtimeStyles;
                runStyles.clearValues();
                runStyles._parent = colStyles;
                if (dynRowCount > 0) {
                    this._rowRuntime.setItem(item, this._grid);
                    dynRow.applyInternal(this._rowRuntime, runStyles);
                }
                if (dynCellCount > 0) {
                    this._cellRuntime.setCell(cell, item);
                    dynCell.applyInternal(this._cellRuntime, runStyles);
                }
                if (dynColCount > 0) {
                    this._cellRuntime.setCell(cell, item);
                    dynCol.applyInternal(this._cellRuntime, runStyles);
                }
                cell.setStyles(runStyles);
            } else {
                cell.setStyles(colStyles);
            }
            if (dataColumn && this._hasCellStyles) {
                var cs = this._items.getCellStyle(item.dataRow(), dataColumn.dataIndex());
                cell.setCellStyles(cs);
            } else {
                cell.setCellStyles(null);
            }
        } else {
            cell.setStyles(colStyles);
        }
        if (dataColumn) {
            if (this._grid.isItemEditing(item)) {
                cell.setError(dataColumn.error());
                cell.setErrorLevel(dataColumn.errorLevel());
            } else {
            	var validateCellList = this._grid._validationManager._validateCellList;
            	var validCell = validateCellList[index.dataId()] && validateCellList[index.dataId()][dataColumn.dataIndex()];
            	if (validCell) {
        			cell.setError(validCell.message);
        			cell.setErrorLevel(validCell.level);
            	} else {
	                cell.setError(null);
	                cell.setErrorLevel(ValidationLevel.IGNORE);
	            }            	
            }
        }
		cell._styles._sysDefault = fixed ? this._fixedStyles._sysDefault : this._bodyStyles._sysDefault;
		return cell;
	},
    getCellSimple: function (index, merged) {
        var col = index._column;
        var cell = merged ? this._mergedCell : col instanceof SeriesColumn ? this._seriesCell : col instanceof LiteralCell ? this._literalCell : col instanceof ColumnGroup ? this._groupCell : this._dataCell;
        cell.setIndex(index);
        return cell;
    },
	addDynamicStyle: function (criteria, styles) {
	},
	_prepareUpdate: function () {
		var grid = this._grid = this.owner();
		this._items = grid.itemSource();
		this._fixedStyles = grid.fixedOptions().styles();
		this._fixedIgnoreDynamic = grid.fixedOptions().isIgnoreDynamicStyles();
		this._fixedIgnoreColumn = grid.fixedOptions().isIgnoreColumnStyles();
		this._bodyStyles = this.styles();
		this._hasCellStyles = this._items.hasCellStyle();
		this._dataSource = grid.dataSource();
		this._rowRuntime.setDataSource(this._dataSource);
		this._cellRuntime.setDataSource(this._dataSource);
        var proto = DynamicStyleCollection.prototype;
        proto.applyInternal = this._grid._userMode ? proto.applyInternalUserMode : proto.applyInternalNormal;
	}
});
var $$_gridbody_capital_indexers = ["value", "values"];
var RowGroupLevel = defineClass("RowGroupLevel", null, {
	init : function(config) {
		this._super();
        /*
		this._level = -1;
		this._column = null;
		this._minHeight = 0;
		*/
		this._headerStyles = new VisualStyles(this, "rowGroupLevelHeaderStyles");
		this._footerStyles = new VisualStyles(this, "rowGroupLevelFooterStyles");
		this._barStyles = new VisualStyles(this, "rowGroupLevelBarStyles");
		this._headerBarStyles = new VisualStyles(this, "rowGroupLevelHeaderBarStyles");
		this._footerBarStyles = new VisualStyles(this, "rowGroupLevelFooterBarStyles");
        if (config) {
            if (config.footerStyles) {
                this._footerStyles.extend(config.footerStyles);
            }
			if (config.headerStyles) {
				this._headerStyles.extend(config.headerStyles);
			}
			if (config.barStyles) {
				this._barStyles.extend(config.barStyles);
			}
			if (config.headerBarStyles) {
				this._headerBarStyles.extend(config.headerBarStyles);
			}
			if (config.footerBarStyles) {
				this._footerBarStyles.extend(config.footerBarStyles);
			}
		}
	},
    /*
    minHeight: 0,
    setMinHeight: function (value) {
        if (value != this._minHeight) {
            this._minHeight = value;
        }
    },
	level: function () {
		return this._level;
	},
	column: function () {
		return this._column;
	},
	*/
	headerStyles: function () {
		return this._headerStyles;
	},
	footerStyles: function () {
		return this._footerStyles;
	},
	barStyles: function () {
		return this._barStyles;
	},
	headerBarStyles: function () {
		return this._headerBarStyles;
	},
	footerBarStyles: function () {
		return this._footerBarStyles;
	}
});
var RowGroup = defineClass("RowGroup", GridObject, {
	init : function(grid) {
		this._super(grid);
		this._levels = [];	// RowGroupLevel
		this._headStyles = new VisualStyles(this, "rowGroupHead");
		this._footStyles = new VisualStyles(this, "rowGroupFoot");
		this._summaryStyles = new VisualStyles(this, "rowGroupSummary");
		this._headerStyles = new VisualStyles(this, "rowGroupHeader");
		this._footerStyles = new VisualStyles(this, "rowGroupFooter");
		this._panelStyles = new VisualStyles(this, "rowGroupPanel");
		this._barStyles = new VisualStyles(this, "rowGroupBar");
		this._headerBarStyles = new VisualStyles(this, "rowGroupHeaderBar");
		this._footerBarStyles = new VisualStyles(this, "rowGroupFooterBar");
		this._headerCell = new RowGroupHeaderCell(this);
		this._footerCell = new RowGroupFooterCell(this);
		this._barCell = new RowGroupBarCell();
		this._itemBarCell = new RowGroupItemBarCell();
		this._headCell = new RowGroupHeadCell();
		this._footCell = new RowGroupFootCell();
		this._summaryCell = new RowGroupSummaryCell();
        this._footerRuntime = new FooterExpressionRuntime();
		this._runStyles = new VisualStyles(this, "rowGroupRuntimeStyles", null, false);
		this._headerExprStatement = new ExpressionStatement(this._headerStatement);
		this._statementRuntime = new RowGroupStatementRuntime();
	},
	destroy: function() {
		this._destroying = true;
		this._headerExprStatement = null;
		this._statementRuntime = null;
		for (var attr in this) {
			if (this[attr] instanceof VisualStyles) {
				this[attr] = null;
			}
		}
		this._super();
	},
	levels: null,
	headerStyles : null,
	footerStyles : null,
	panelStyles : null,
	barStyles : null,
	headerBarStyles : null,
	footerBarStyles : null,
	headStyles : null,
	footStyles : null,
	summaryStyles : null,
	headerStatement : "${groupField}: ${groupValue} - ${rowCount} rows",
	levelIndent : 20,
	headerOffset : -1,
	footerOffset : 0,
	mergeMode : false,
	mergeExpander: true,
	expandedAdornments : RowGroupAdornments.BOTH,
	collapsedAdornments : RowGroupAdornments.HEADER,
	cellDisplay : RowGroupCellDisplay.MERGE,
	footerVisibility : RowGroupFooterVisibility.MULTI_ROWS_ONLY,
	inheritsLevel : true,
	imageLists : null,
	summaryMode : SummaryMode.AGGREGATE,
	footerCellMerge: false,
	footerStatement: null,
	sorting: true,
	headerCallback: null,
	createFooterCallback: null,
	levelCount: function () {
		return this._levels.length;
	},
	levels_: function () {
		return this._levels.concat();
	},
	setLevels: function (value) {
        this._levels = [];
        if (value) {
            for (var i = 0; i < value.length; i++) {
                var v = value[i];
                if (v instanceof RowGroupLevel) {
                    this._levels.push(v);
                } else {
                    v = new RowGroupLevel(v);
                    this._levels.push(v);
                }
		    }
        }
        this._changed();
	},
	setFooterStyles: function (value) {
		if (value != this._footerStyles) {
			this._footerStyles.extend(value);
		}
	},
	setHeaderStatement: function (value) {
		if (value != this._headerStatement) {
			this._headerStatement = value;
			this._headerExprStatement.setSource(value);
			this._changed();
		}
	},
	setFooterStatement: function (value) {
		if (value != this._footerStatement) {
			this._footerStatement = value;
			if (value) {
				if (this._footerExprStatement) {
					this._footerExprStatement.setSource(value);
				} else {
					this._footerExprStatement = new ExpressionStatement(value);
				}
			} else {
				this._footerExprStatement = null;
			}
			this._changed();
		}
	},
	setMergeMode: function (value) {
		if (value != this._mergeMode) {
			this._mergeMode = value;
			if (this.owner()) {
				this.owner().$_rowGroupFooterMergeChanged();
				this.owner().$_rowGroupMergeModeChanged();
			}
		}
	},
	setFooterCellMerge: function (value) {
		if (value != this._footerCellMerge) {
			this._footerCellMerge = value;
			if (this.owner()) {
				this.owner().$_rowGroupFooterMergeChanged();
			}
			this._changed();		
		}
	},
	setExpandedAdornments: function (value) {
		if (value != this._expandedAdornments) {
			this._expandedAdornments = value;
			if (this.owner()) {
				this.owner().$_rowGroupAdornmentsChanged();
			}
		}
	},
	setCollapsedAdornments: function (value) {
		if (value != this._collapsedAdornments) {
			this._collapsedAdornments = value;
			if (this.owner()) {
				this.owner().$_rowGroupAdornmentsChanged();
			}
		}
	},
	setCreateFooterCallback: function(value) {
		if (value != this._createFooterCallback) {
			this._createFooterCallback = typeof value === "function" ? value : null;
			if (this.owner()) {
				this.owner().$_rowGroupAdornmentsChanged();
			}
		}
	},
	setSummaryMode: function (value) {
		if (value != this._summaryMode) {
			this._summaryMode = value;
			if (this.owner()) {
				this.owner().$_groupSummaryModeChanged();
			}
		}
	},
	setSorting: function (value) {
		if (value != this._sorting) {
			this._sorting = value;
			if (this.owner()) {
				this.owner().$_groupSortingChanged();
			}
		}
	},
	getLevel: function (level)/* RowGroupLevel */ {
		var cnt = this._levels.length;
		if (cnt > level) {
			return this._levels[level];
		} else if (cnt > 0 && this._inheritsLevel) {
			return this._levels[cnt - 1];
		}
		return null;
	},
	getHeaderCell: function (index) {
		var item = this.owner().getItem(index);
		var level = this.getLevel(item.level() - 1);
		this._runStyles.clearValues();
		if (level) {
			this._runStyles.setParent(level.headerStyles(), false);
		} else {
			this._runStyles.setParent(this._headerStyles, false);
		}
		this._headerCell.setStyles(this._runStyles);
		this._headerCell.setIndex(CellIndex.temp(this.owner(), index));
		return this._headerCell;
	},
	getFooterCell: function (index, item) {
		var item/*GroupFooter*/ = this.owner().getItem(index.I()) || item;
		var group = item.parent();
		var level/*RowGroupLevel*/ = this.getLevel(group.level() - 1);
		var column = _cast(index.column(), ValueColumn);
		if (column) {
			this._runStyles.clearValues();
			this._runStyles.extend(column.footer().styles());
			this._runStyles.extend(column.footer().groupStyles());
		}
		if (level) {
			this._runStyles.setParent(level.footerStyles(), false);
		} else {
			this._runStyles.setParent(this._footerStyles, false);
		}
        this._footerCell.setIndex(index);
        this._footerCell.calculate(item);
        if (column) {
            var d = column.footer().groupDynamicStyles();
            if (d && d.count() > 0) {
                this._footerRuntime.setCell(this._footerCell, item);
                d.applyInternal(this._footerRuntime, this._runStyles);
            }
        }
		this._footerCell.setStyles(this._runStyles);
		return this._footerCell;
	},
	getBarCell: function (level) {
		this._barCell.setLevel(level);
		var glevel = this.getLevel(level - 1);
		if (glevel) {
			this._barCell.setStyles(glevel.barStyles());
		} else {
			this._barCell.setStyles(this._barStyles);
		}
		return this._barCell;
	},
	getHeaderBarCell: function (index) {
		this._itemBarCell.setIndex(index);
		var level = this.getLevel(index.item().level() - 1);
		if (level) {
			this._itemBarCell.setStyles(level.headerBarStyles());
		} else {
			this._itemBarCell.setStyles(this._headerBarStyles);
		}
		return this._itemBarCell;
	},
	getFooterBarCell: function (index) {
		this._itemBarCell.setIndex(index);
		var group = index.item().parent();
		var level = this.getLevel(group.level() - 1);
		if (level) {
			this._itemBarCell.setStyles(level.footerBarStyles());
		} else {
			this._itemBarCell.setStyles(this._footerBarStyles);
		}
		return this._itemBarCell;
	},
	getHeadCell: function (level) {
		this._headCell.setStyles(this._headStyles);
		return this._headCell;
	},
	getFootCell: function (level) {
		this._footCell.setStyles(this._footStyles);
		return this._footCell;
	},
	getSummaryCell: function (level) {
		this._summaryCell.setStyles(this._summaryStyles);
		return this._summaryCell;
	},
	getHeaderText: function (group) {
		if (!this._headerStatement && this._headerCallback && typeof this._headerCallback === "function") {
			return this._headerCallback($$_getItemProxy(group, true), this._grid && this._grid.getHandler());
		}
		this._statementRuntime.setGrid(this.owner());
		this._statementRuntime.setGroup(group);
		return this._headerExprStatement.evaluate(this._statementRuntime);
	},
	getFooterText: function (group) {
		if (this._footerExprStatement) {
			this._statementRuntime.setGrid(this.owner());
			this._statementRuntime.setGroup(group);
			return this._footerExprStatement.evaluate(this._statementRuntime)
		} else {
			return null;
		}
	}
});

var /* @abstract */ GridCell = defineClass("GridCell", null, {
	init: function (name) {
		this._super();
		this._name = name;
		this._index = new CellIndex();
	},
	styles: null,
    index: null,
	name: function () {
		return this._name;
	},
	setIndex: function (value) {
		this._index.assign(value);
	},
	getItem: function () {
		return this._index.item();
	},
	item: function () {
		return this._index.item();
	},
	error: function () {
		return null;
	},
	errorLevel: function () {
		return ValidationLevel.IGNORE;
	}
}, {
	ERROR: "<<ERROR>>"
});
var /* @abstract */ StyledCell = defineClass("StyledCell", GridCell, {
	init: function (model) {
		this._super(null);
		this._model = model;
	},
	model: null,
	displayText: function () {
		return null;
	},
	value: function () {
		return null;
	}
});
var HeaderCell = defineClass("HeaderCell", GridCell, {
	init: function () {
		this._super("headerCell");
	},
    subStyles: null,
    text: null,
    subText: null,
    subTextGap: 1,
    subLocation: SubTextLocation.LOWER,
	itemOffset: 2,
	itemGap: 2,
	imageList: null,
	imageIndex: -1,
	imageUrl: null,
	checkLocation: ColumnHeaderItemLocation.NONE,
	imageLocation: ColumnHeaderItemLocation.NONE,
	checked: false,
	showTooltip: true,
	tooltip: null
});

var SummaryCell = defineClass("SummaryCell", GridCell, {
	init: function (name) {
		this._super(name);
		this._value = NaN;
		this._error = null;
		this._errorDetail = null;
	},
	summaryIndex: 0,
	displayText: function () {
		if (this._error) {
			return GridCell.ERROR;
		} else {
			var column;
			var index = this._summaryIndex;
			var s = isNaN(this._value) ? null : String(this._value);
			if (!s && (column = this.index().valueColumn())) {
				var summaryObject = this.$_getSummaryObject(column);
				s = summaryObject.text();
				if (s instanceof Array) {
					if (index >= 0 && s[index]) {
						s = s[index];
					} else {
						s = null;
					}
				}
			}
			return s;
		}
	},
	value: function () {
		return this._value;
	},
    level: function () {
        return 0;
    },
	calculate: function () {
		var column = this.index().dataColumn();
		var grid = column ? column.grid() : null;
		this._value = NaN;
		this._error = null;
		if (grid && column.dataIndex() >= 0) {
			var summaryObject = this.$_getSummaryObject(column);
			if (grid.summaryMode() != SummaryMode.NONE && summaryObject.expression() && grid.rowCount() > 0) {
				try {
					var runtime = grid.columnSummaryRuntime();
					runtime.setColumn(column, grid.getSummarizer());
					this._value = summaryObject.evaluate(runtime, this._summaryIndex);
				} catch (err) {
					this._error = err;
					this._errorDetail = err;
					throwDebugError(err);
				}
			} else if (summaryObject._callback) {
				this._value = summaryObject._callback(column.proxy(), this._summaryIndex, grid.getHandler());
			}
		}
	},
	error: function () {
		return this._error;
	},
	errorDetail: function () {
		return this._errorDetail;
	}
});

var FooterCell = defineClass("FooterCell", SummaryCell, {
	init: function () {
		this._super("footerCell");
	},
	$_getSummaryObject: function(column) {
		return column.footer();
	},
	$_execCallback: function(callback, column, summaryIndex) {
		var grid = column.grid()
		return callback(column.proxy(), summaryIndex, grid.getHandler());
	}
});

var HeaderSummaryCell = defineClass("HeaderSummaryCell", SummaryCell, {
	init: function () {
		this._super("headerSummaryCell");
	},
	$_getSummaryObject: function(column) {
		return column.header().summary();
	},
	$_execCallback: function(callback, column, summaryIndex) {
		var grid = column.grid();
		return callback(column.proxy(), grid.getHandler(), summaryIndex)
	}
});

var /* @internal */ EditBarCell = defineClass("EditBarCell", GridCell, {
	init: function () {
		this._super("editBarCell");
	},
	displayText: function () {
		return null;
	},
	value: function () {
		return null;
	}
});
var IndicatorCell = defineClass("IndicatorCell", GridCell, {
	init: function (indicator) {
		this._super("indicatorCell");
		this._indicator = indicator;
	},
	indicator: null,
	itemState: ItemState.NORMAL,
	displayText: function () {
		var r;
		var indicator = this._indicator;
		var index = this.index();
		var item = index.item();
		var s = "";
		if (index.item()) {
			switch (indicator.displayValue()) {
			case IndicatorValue.INDEX:
				r = indicator._grid.getIndicatorIndex(item);
				if (r >= 0) {
					r += indicator.indexOffset();
					if (!indicator.isZeroBase()) {
						r++;
					}
					s = String(r);
				}
				break;
			case IndicatorValue.ROW:
				r = index.dataRow();
				if (r >= 0) {
					r += indicator.rowOffset();
					if (!indicator.isZeroBase()) {
						r++;
					}
					s = String(r);
				}
				break;
			}
		}
		return s;
	},
	value: function () {
		return null;
	}
});
var StateBarCell = defineClass("StateBarCell", GridCell, {
	init: function () {
		this._super("stateBarCell");
	},
	displayText: function () {
		switch (this.item().rowState()) {
		case RowState.CREATED:
			return "C";
		case RowState.UPDATED:
			return "U";
		case RowState.DELETED:
			return "D";
		case RowState.CREATE_AND_DELETED:
			return "CD";
		default:
			return "";	
		}
	},
	value: function () {
		return null;
	}
});
var CheckBarCell = defineClass("CheckBarCell", GridCell, {
	init: function () {
		this._super("checkBarCell");
	},
	displayText: function () {
		return this._index.dataRow();
	},
	value: function () {
		return this.item().isChecked();
	}
});
var GroupCell = defineClass("GroupCell", GridCell, {
    init: function (name) {
        this._super(name);
    },
    setCellStyles: function (value) {
    }
});
var /* @abstract */ ValueCell = defineClass("ValueCell", GridCell, {
	init: function (name) {
		this._super(name);
	},
    cellStyles: null,
	displayText: function () {
		return this.value();
	},
	value: function () {
		return UNDEFINED;
	},
	blankState: function () {
		return BlankState.NONE;
	},
    setCellStyles: function (value) {
            this._cellStyles = value;
            value && value.assignTo(this._styles);
    }
});
var DataCell = defineClass("DataCell", ValueCell, {
	init : function(name) {
		this._super(name || "dataCell");
	},
	error: null,
	errorLevel: ValidationLevel.IGNORE,
	error_: function () {
		return this._error;
	},
	errorLevel_: function () {
		return this._errorLevel;
	},
    displayText: function() {
        var v;
        var index = this.index();
        var col = index.dataColumn();
        var item = index.item();
        return DataCell._displayText(item, col);
        /*
        if (col.isLookupDisplay()) {
            var lookup = col.lookupSource();
            if (lookup) {
                var i,
                    flds = col.lookupKeyFieldIds(),
                    cnt = flds.length,
                    keys = [];
                for (i = 0; i < cnt; i++) {
                    keys.push(item.getData(flds[i]));
                }
                v = lookup.lookup(keys, col.valueSeparator());
                v = (v !== undefined) ? v : this.value();
            } else {
                var fld = col.labelFieldIndex();
                v = (fld >= 0) ? item.getData(fld) : col.getLookupLabel(this.value());
            }
        } else {
            v = this.value();
            var exp, rep;
            if (col.valueType && col.valueType() == ValueType.NUMBER && isNaN(v)) {
            	v = col.nanText();
            } else if (v != null && (typeof v === "string" || typeof v === "number") && (v = v.toString()) && (exp = col.getDisplayRegExp()) && (rep = col.displayReplace())) {
            	v = v.replace(exp, rep);
            } else if (v != null && typeof v === "object") {
            	v = JSON.stringify(v);
            }
        }
        return  (v === undefined || v === null) ? "" : String(v);
        */
    },
    value: function() {
        var idx = this.index();
        var col = idx.dataColumn();
        var fld = col.dataIndex();
        if (fld >= 0) {
            return idx.item().getData(fld);
        }
        return undefined;
    },
    blankState: function() {
        var state = BlankState.NONE,
            idx = this.index(),
            col = idx.dataColumn(),
            item = idx.item(),
            expr = col._equalBlankNode,
            runtime = expr && DataCell.equalBlankRuntime();
        if (col && (col.isEqualBlank() || expr) && col.isDataRoot() && item.dataRow() >= 0 ) {
            var grid = idx.grid(),
                cnt = grid.itemCount();
            expr && runtime && runtime.setDataArguments(this._index.item().dataSource(), this, item);
            if (cnt > 1) {
                var i = idx.I(),
                    fld = col.dataIndex(),
                    v = expr ? (runtime.setItem(item), expr.evaluate(runtime)) : item.getData(fld);
                if (i > 0) {
                    var prev, next, nextItem,
                        prevItem = grid.getItem(i - 1);
                    if (i < cnt - 1) {
                        nextItem = grid.getItem(i + 1);
                        if (prevItem instanceof GridRow) {
                            prev = expr ? (runtime.setItem(prevItem), expr.evaluate(runtime)) : prevItem.getData(fld);
                            if ( v instanceof Date && prev instanceof Date ? +v == +prev : v == prev) {
                                if (nextItem instanceof GridRow) {
                                    next = expr ? (runtime.setItem(nextItem), expr.evaluate(runtime)) : nextItem.getData(fld);
                                    state = ( next instanceof Date && v instanceof Date ? +next == +v : next == v) ? BlankState.BODY : BlankState.TAIL;
                                } else {
                                    state = BlankState.TAIL;
                                }
                            } else if (nextItem instanceof GridRow) {
                                next = expr ? (runtime.setItem(nextItem), expr.evaluate(runtime)) : nextItem.getData(fld);
                                if (next instanceof Date && v instanceof Date ? +next == +v : next == v) {
                                    state = BlankState.HEAD;
                                }
                            }
                        } else if (nextItem instanceof GridRow) {
                            next = expr ? (runtime.setItem(nextItem), expr.evaluate(runtime)) : nextItem.getData(fld);
                            if (next instanceof Date && v instanceof Date ? +next == +v : next == v) {
                                state = BlankState.HEAD;
                            }
                        }
                    } else if (prevItem instanceof GridRow) {
                        prev = expr ? (runtime.setItem(prevItem), expr.evaluate(runtime)) : prevItem.getData(fld);
                        if (prev instanceof Date && v instanceof Date ? +prev == +v : prev == v) {
                            state = BlankState.TAIL;
                        }
                    }
                } else {
                    nextItem = grid.getItem(i + 1);
                    if (nextItem instanceof GridRow) {
                        next = expr ? (runtime.setItem(nextItem), expr.evaluate(runtime)) : nextItem.getData(fld);
                        if (next instanceof Date && v instanceof Date ? +next == +v : next == v) {
                            state = BlankState.HEAD;
                        }
                    }
                }
            }
        }
        return state;
    },
    getTextFromItem : function(item) {
        var col = this.index().dataColumn();
        return DataCell._displayText(item, col);
        /*
        var fldVal = item.getData(col.dataIndex());
        var v;
        if (col.isLookupDisplay()) {
            var lookup = col.lookupSource();
            if (lookup) {
                var i,
                    flds = col.lookupKeyFieldIds(),
                    cnt = flds.length,
                    keys = [];
                for (i = 0; i < cnt; i++) {
                    keys.push(item.getData(flds[i]));
                }
                v = lookup.lookup(keys, col.valueSeparator());
                v = (v !== undefined) ? v : this.value();
            } else {
                var fld = col.labelFieldIndex();
                v = (fld >= 0) ? item.getData(fld) : col.getLookupLabel(fldVal);
            }
        } else {
            v = fldVal;
        }
        return  (v === undefined || v === null) ? "" : String(v);
        */
    }
},{
	_displayText:function(item, column) {
        var v, displayCallback;
        var col = column;
        var value = col.dataIndex() >= 0 ? item.getData(col.dataIndex()) : undefined;
        if (col.isLookupDisplay()) {
            var lookup = col.lookupSource();
            if (lookup) {
                var i,
                    flds = col.lookupKeyFieldIds(),
                    cnt = flds.length,
                    keys = [];
                for (i = 0; i < cnt; i++) {
                    keys.push(item.getData(flds[i]));
                }
                v = lookup.lookup(keys, col.valueSeparator());
                v = (v !== undefined) ? v : col.textOfInvalid() != null ? col.textOfInvalid() : value;
            } else {
                var fld = col.labelFieldIndex();
                v = (fld >= 0) ? item.getData(fld) : col.getLookupLabel(value);
            }
        } else {
            v = value;
            var exp, rep;
            if (col.valueType && col.valueType() == ValueType.NUMBER && col.nanText() != null && isNaN(v)) {
            	v = col.nanText();
            } else if (v != null && (typeof v === "string" || typeof v === "number") && (v.toString()) && (exp = col.getDisplayRegExp()) && (rep = col.displayReplace())) {
            	v = v.toString().replace(exp, rep);
            } else if (displayCallback = col.displayCallback && col.displayCallback()) {
            	var handler = col.grid().getHandler();
            	var idx = CellIndex.temp(col.grid(), item.index(), column);
            	v = displayCallback(handler, idx.proxy(), v);
            } else if (v != null && typeof v === "object") {
            	v = JSON.stringify(v);
            } 
        }
        return  (v === undefined || v === null) ? "" : String(v);
	},
	equalBlankRuntime: function() {
		if (!this._equalBlankRuntime) {
			this._equalBlankRuntime = new EqualBlankRuntime();
		};
		return this._equalBlankRuntime;
	}
});
var LiteralCell = defineClass("LiteralCell", ValueCell, {
	init : function(name) {
		this._super(name || "literalCell");
	},
	displayText : function() {
		return this._index.column().value();
	},
	value : function() {
		return this._index.column().getValue();
	}
});
var SeriesCell = defineClass("SeriesCell", ValueCell, {
	init : function(name) {
		this._super(name || "seriesCell");
	},
	displayText : function() {
		return null;
	},
	value : function() {
		var column = this.index().column();
		if (column instanceof SeriesColumn) {
			var cnt,
				fields = column.fields();
			if (fields && (cnt = fields.length) > 0) {
				var i,
					item = this.item();
					vals = new Array(cnt);
				for (i = 0; i < cnt; i++) {
					if (fields[i] >= 0) {
						vals[i] = item.getData(fields[i]);
					}
				}
				return vals;
			}
		}
		return [];
	}
}, {
	getText: function (value, separator) {
		return value ? value.join(separator != null ? separator : ",") : "";
	}
});
var RowGroupHeaderCell = defineClass("RowGroupHeaderCell", GridCell, {
	init: function(rowGroup) {
		this._super("rowGroupHeaderCell");
		this._rowGroup = rowGroup;
	},
	displayText: function () {
		var group = _cast(this.item(), GroupItem);
		if (group) {
			return this._rowGroup.getHeaderText(group);
		} else {
			return "";
		}
	},
	value: function () {
		return null;
	}
});
var RowGroupFooterCell = defineClass("RowGroupFooterCell", GridCell, {
	init: function(rowGroup) {
		this._super("rowGroupFooterCell");
		this._value = NaN;
		this._error = null;
		this._errorDetail = null;
		this._rowGroup = rowGroup;
	},
	calculate: function (item) {
		this._value = NaN;
		this._error = null;
		try {
			this._value = RowGroupFooterCell.$_getValue(this.item()||item, this.index().dataColumn());
		} catch (err) {
			this._error = err;
			this._errorDetail = err;
			throwDebugError(err);
		}
	},
	displayText: function() {
		if (this._error) {
			return GridCell.ERROR;
		} else {
			return RowGroupFooterCell.$_displayText(this.item(), this.index().valueColumn(), this._value);
		}
	},
	value: function() {
		return this._value;
	},
    level: function () {
        return this.index().item().level();
    }
}, {
	$_getValue: function (item, column) {
		if (column && column.dataIndex() >= 0) {
			var footer = column.footer();
			var group = item.parent();
			if (footer.groupExpression()) {
				var runtime/*RowGroupSummaryRuntime*/ = column.grid().rowGroupSummaryRuntime();
				runtime.setColumn(column, column.grid().getSummarizer());
				runtime.setItem(group);
				var v = footer.evaluateGroup(runtime);
				return v;
			} else if (footer._groupCallback) {
				var grid = column.grid();
				return footer._groupCallback(item._index, column.proxy(), grid && grid.getHandler(), $$_getItemProxy(group,true));
			} else if (group && column && column.grid().isGroupedColumn(column)) {
				var s = column.grid()._rowGroup.getFooterText(group);;
				return s == null ? undefined : s;
			} else {
				return undefined;
			}
		} else {
			return undefined;
		}
	},
	getValue: function (item, column) {
		try {
			return RowGroupFooterCell.$_getValue(item, column);
		} catch (err) {
			return GridCell.ERROR;
		}
	},
	$_displayText: function (item, column, value) {
		var s = isNaN(value) ? null : String(value);
		if (!s) {
			var group = _cast(item.parent(), GroupItem);
			var rowGroup = column.grid().rowGroup();
			var groupText;
			if (group && column && column.grid().isGroupedColumn(column) && (groupText = rowGroup.getFooterText(group))) {
				s = groupText;
			} else if (column) {
				s = column.footer().groupText();
			}
		}
		return s;
	}
});
var RowGroupBarCell = defineClass("RowGroupBarCell", GridCell, {
	init: function(rowGroup) {
		this._super("rowGroupBarCell");
	},
    level: 0,
	displayText: function() {
		return null;
	},
	value: function() {
		return null;
	}
});
var RowGroupItemBarCell = defineClass("RowGroupItemBarCell", GridCell, {
	init: function(rowGroup) {
		this._super("rowGroupItemBarCell");
	},
	displayText: function() {
		return null;
	},
	value: function() {
		return null;
	}
});
var RowGroupHeadCell = defineClass("RowGroupHeadCell", GridCell, {
	init: function(rowGroup) {
		this._super("rowGroupHeadCell");
	},
	index: function () {
		return CellIndex.NULL;
	},
	displayText: function() {
		return null;
	},
	value: function() {
		return null;
	}
});
var RowGroupFootCell = defineClass("RowGroupFootCell", GridCell, {
	init: function(rowGroup) {
		this._super("rowGroupFootCell");
	},
	displayText: function() {
		return null;
	},
	value: function() {
		return null;
	}
});
var RowGroupSummaryCell = defineClass("RowGroupSummaryCell", GridCell, {
	init: function(rowGroup) {
		this._super("rowGroupSummaryCell");
	},
	displayText: function() {
		return null;
	},
	value: function() {
		return null;
	}
});
var GridElement = defineClass("GridElement", VisualElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._drawRect = new Rectangle();
		this._recycling = false;
	},
	destroy: function() {
		this._destroying = true;
		this._drawRect = null;
		this._super();
	},
	grid: function () {
		var p = this._parent;
		while (p) {
			if (p instanceof GridBase) {
				return p;
			}
			p = p._parent;
		}
		return null;
	},
	measure: function (grid, hintWidth, hintHeight) {
		return this._doMeasure(grid, hintWidth, hintHeight);
	},
	measureHeight: function(grid, hintWidth, hintHeight) {
		return this._doMeasureHeight(grid, hintWidth, hintHeight);
	},
	layoutContent: function (lm) {
		return this._doLayoutContent(lm);
	},
	refresh: function () {
		this._doRefresh();
	},
	clip: function (g) {
		this.getClientRect(this._drawRect);
		g.clipRect(this._drawRect);
	},
	_doDraw: function(g, needOpaque) {
		needOpaque && g.drawRectI(SolidBrush.WHITE, null, this._drawRect);
		this._doRender(g, this._drawRect);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doMeasureHeight: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doLayoutContent: function (lm) {
	},
	_doRefresh: function () {
	},
	_doRender: function (g, r) {
	},
	_drawStyledBorders: function (g, r, styles) {
		var wLeft = styles.borderLeftWidth();
		var wTop = styles.borderTopWidth();
		var wRight = styles.borderRightWidth();
		var wBottom = styles.borderBottomWidth();
		if (wLeft) {
			wLeft = wLeft / 2;
			g.drawLineI(styles.borderLeft(), r.x + wLeft, r.y, r.x + wLeft, r.bottom());
		}
		if (wTop) {
			wTop = wTop / 2;
			g.drawLineI(styles.borderTop(), r.x, r.y + wTop, r.right(), r.y + wTop);
		}
		if (wRight) {
			wRight = (wRight + 1) / 2;
			g.drawLineI(styles.borderRight(), r.right() - wRight, r.y, r.right() - wRight, r.bottom());
		}
		if (wBottom) {
			wBottom = (wBottom + 1) / 2;
			g.drawLineI(styles.borderBottom(), r.x, r.bottom() - wBottom, r.right(), r.bottom() - wBottom);
		}
	}
});
var GridElement$ = GridElement.prototype;
var /* abstract */ VisualObjectElement = defineClass("VisualObjectElement", GridElement, {
	init : function(dom, name, model) {
		this._super(dom, name);
		this._model = model;
		this._clipBounds = null;
		if (this._dom) {
			this._dom.style.pointerEvents = "none";
		}
	},
	destroy: function() {
		this._destroying = true;
		this._clipBounds = null;
		this._model = null;
		this._super();
	},
	model: null,
	setClipBounds: function (x, y, w, h) {
		var r = null;
		var bounds = _cast(x, Rectangle);
		if (bounds) {
			r = this._clipBounds || new Rectangle();
			r.x = Math.max(bounds.x, this._x);
			r.setRight(Math.min(bounds.right(), this.right()));
			r.y = Math.max(bounds.y, this._y);
			r.setBottom(Math.min(bounds.bottom(), this.bottom()));
			r.x -= this._x;
			r.y -= this._y;
		} else if (!isNaN(x)) {
			r = this._clipBounds || new Rectangle();
			r.x = Math.max(x, this._x);
			r.setRight(Math.min(x + w, this.right()));
			r.y = Math.max(y, this._y);
			r.setBottom(Math.min(y + h, this.bottom()));
			r.x -= this._x;
			r.y -= this._y;
		}
		this._clipBounds = r;
	},
	clip: function (g) {
		this.getClientRect(this._drawRect);
		g.clipRect(this._clipBounds || this._drawRect);
	}
});
var VisualObjectElement$ = VisualObjectElement.prototype;
var EmptyGridElement = defineClass("EmptyGridElement", GridElement, {
	init: function (dom, name) {
		this._super(dom, name);
	},
	_doRender: function(g, r) {
		var grid = this.grid();
		var s = grid.displayOptions().emptyMessage();
        var s2 = grid._productName;
		var fill = grid.body().emptyStyles().background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		if (s || s2) {
			r.inflate(-10, -10);
			s && g.drawTextRect(null, SolidBrush.BLACK, s, r, TextAlign.LEFT, TextLayout.TOP);
			s2 && g.drawTextRect(null, SolidBrush.BLACK, s2, r, TextAlign.LEFT, TextLayout.BOTTOM);
		}
	}
});
var PanelElement = defineClass("PanelElement", VisualObjectElement, {
	init : function(dom, panel) {
		this._super(dom, "panelView", panel);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return Size.create(hintWidth, this.model().minHeight());
	},
	_doRender : function(g, r) {
		var panel = this.model();
		var styles = panel.styles();
		var fill = styles.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawStyledBorders(g, r, styles);
	}
});
var HeaderElement = defineClass("HeaderElement", VisualObjectElement, {
	init : function(dom, header, fixed, rightFixed) {
		this._super(dom, "headerView", header);
		this._fixed = fixed;
		this._rightFixed = rightFixed;
		this._cells = {};
		this._focusedColumn = null;
	},
	destroy: function() {
		this._destroying = true;
		for (var cell in this._cells) {
			this._cells[cell] = null;
		}
		this._cells = null;
		this._focusedColumn = null;
		this._super();
	},
	isFixed: function () { return this._fixed; },
	isRightFixed: function () { return this._rightFixed; },
	$_getChildAt: function (p, x, y, deep) {
		for (var i = 0, cnt = p.childCount(); i < cnt; i++) {
			var cell = p.getChild(i);
			if (cell.isVisible()) {
				if (deep && cell instanceof GroupCellElement) {
					var child = this.$_getChildAt(cell, x - cell.x(), y - cell.y(), true);
					if (child) {
						return child;
					}
				}
				if (cell.containsInBounds(x, y)) {
					return cell;
				}
			}
		}
		return null;
	},
	getCellAt: function (x, y, deep) {
		return this.$_getChildAt(this, x, y, deep);
	},
	findCell: function (column, force) {
		if (column) {
			var root = column.root();
			var view = this._cells[root.$_hash];
			if (view && (view.isVisible() || force) ) {
				if (root != column) {
					view = view.findCell(column, force);
				}
				return view;
			}
		}
		return null;
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return Size.create(hintWidth, this.model().minHeight());
	},
	_doRender : function(g, r) {
		g.drawRectI(SolidBrush.WHITE, null, r);
		var options = this.grid().fixedOptions();
		var wbar = options.colBarWidth();
		if (wbar > 0 && this.isFixed()) {
			var styles = options.colBarStyles();
			var fill = styles.background();
			var stroke = styles.borderRight();
			var lstroke = styles.borderLeft();
			if (this.isRightFixed()) {
				r.setRight(wbar);
			} else {
				r.setLeft(r.right() - wbar);
			}

			if (fill) {
				g.drawRectI(fill, null, r);
			}
			if (stroke) {
				g.drawVertLineI(stroke, r.y, r.bottom(), r.right() - 1);
			}
			if (lstroke && this._rightFixed) {
				g.drawVertLineI(lstroke, r.y, r.bottom(), r.x);
			}
		}
	},
	_doLayoutContent: function (lm) {
		this._prepareCells(lm);
		this._layoutCells(lm);
	},
	$_checkCell: function (view) {
		var cell = _cast(view, HeaderCellElement);
		if (cell) {
			cell.setFocused(this._focusedColumn == cell.index().column());
		}
		if (view instanceof HeaderGroupCellElement) {
			this.$_refreshCells(view);
		}
	},
	$_refreshCells: function (group) {
		for (var i = 0, cnt = group.childCount(); i < cnt; i++) {
			this.$_checkCell(group.getChild(i));
		}
	},
	_doRefresh: function () {
		this._focusedColumn = this.grid().focusedIndex().column();
		for (var key in this._cells) {
			this.$_checkCell(this._cells[key]);
		}
	},
	_prepareCells: function (lm) {
		var grid = this.grid();
        var header = grid.header();
		if (grid.isColumnLayoutChanged()) {
		}
		this.hideAll();
		var start = lm.firstCol(this._fixed, this._rightFixed);
		var end   = lm.lastCol(this._fixed, this._rightFixed);
		for (var i = start; i <= end; i++) {
			var column = lm.getColumn(i);
			var view = this._cells[column.$_hash];
			if (!view) {
				if (column instanceof ColumnGroup) {
					view = new HeaderGroupCellElement(this._dom);
				} else {
					view = new HeaderCellElement(grid, this._dom);
				}
				this._cells[column.$_hash] = view;
				this.addElement(view);
			}
			view.setVisible(true);
			var index = CellIndex.temp(grid, -1, column);
			var model = header.getCell(index);
			view.updateCell(model);
		}
	},
	_layoutCells: function (lm) {
		var start = lm.firstCol(this._fixed, this._rightFixed);
		var end   = lm.lastCol(this._fixed, this._rightFixed);
		for (var i = start; i <= end; i++) {
			var view = this._cells[lm.getColumn(i).$_hash];
			var r = lm.getColumnBounds(i);
			r.height = this.height();
			view.setRect(r);
			view.layoutContent(lm);
		}
	}
});

var SummaryElement = defineClass("SummaryElement", VisualObjectElement, {
	init: function (dom, name, summary, fixed, rightFixed) {
		this._super(dom, name, summary);
		this._fixed = fixed;
		this._rightFixed = rightFixed;
		this._cells = [];
		this._mergeCells = {};
	},
	destroy: function() {
		this._destroying = true;
		this._cells = null;
		this._mergeCells = null;
		this._super();
	},
	isFixed: function () { return this._fixed; },
	isRightFixed: function () { return this._rightFixed; },
    findCell: function (index, column) {
        if (column) {
            var root = column.root();
            var view = this._cells[index] && this._cells[index][root.$_hash];
            if (view && view.isVisible()) {
                if (root != column) {
                    view = view.findCell(column);
                }
                return view;
            }
        }
        return null;
    },
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return Size.create(hintWidth, this.model().minHeight());
	},
	_doRender : function(g, r) {
		g.drawRectI(SolidBrush.WHITE, null, r);
		var options = this.grid().fixedOptions();
		var wbar = options.colBarWidth();
		if (this.isFixed() && wbar > 0) {
			var styles = options.colBarStyles();
			var fill = styles.background();
			var stroke = styles.borderRight();
			var lstroke = styles.borderLeft();
			if (this.isRightFixed()) {
				r.setRight(wbar);
			} else {
				r.setLeft(r.right() - wbar);
			}
			if (fill) {
				g.drawRectI(fill, null, r);
			}
			if (stroke) {
				g.drawVertLine(stroke, r.y, r.bottom(), r.right() - 1);
			}
			if (lstroke && this._rightFixed) {
				g.drawVertLineI(lstroke, r.y, r.bottom(), r.x);
			}

		}
	},
	_doLayoutContent : function(lm) {
		this._prepareCells(lm);
		this._layoutCells(lm);
	},
	_doRefresh : function() {
	},
	_prepareCells: function (lm) {
		var grid = this.grid();
		if (grid.isColumnLayoutChanged()) {
		}
		this.hideAll();

		var mergeCount;
		var	start = lm.firstCol(this._fixed, this._rightFixed);
		var	end   = lm.lastCol(this._fixed, this._rightFixed);
		var mergeManager = this.$_getMergeManager();// grid.footerMergeManager();
		var merged = mergeManager.count() > 0;
		var r, i;
		var count = this.model().count();

		for (i = start; i <= end; i++) {
			var room = merged && mergeManager.findRoomBy(lm.getColumn(i));
			for (r = 0; r < count; r++) {
				this._prepareCell(lm, r, i, merged, room);
			}
		}
		if (merged) {
			var rooms = mergeManager.getRoomNames();
			for (var i = 0; i < rooms.length; i++) {
				var room = merged && mergeManager.getRoom(rooms[i]);
				if (room && ((start > room.base() && start <= room.last()) ||
					         (end   < room.base() && end   >= room.start()))) {
					for (r = 0; r < count; r++) {
						this._prepareCell(lm, r, room.base(), true, room);
					}
				}
			}
		}
	},
	_prepareCell: function (lm, row, col, merged, room) {
		var grid = this.grid();
		var summary = this.model();
		var column = lm.getColumn(col);
		var rowView = this._cells[row];
		if (!rowView) {
			rowView = {};
			this._cells.push(rowView);
		}
		var view = rowView[column.$_hash];
		if (!view) {
			if (column instanceof ColumnGroup) {
				view = this.$_createGroupCellElement();
			} else {
				view = this.$_createCellElement();
			}
			rowView[column.$_hash] = view;
			this.addElement(view);
		}

		view.setVisible(!merged || !room || room.base() == col);
		var index = CellIndex.temp(grid, -1, column);
		var model = summary.getCell(index, row);
		view.updateCell(model);
	},
	_layoutCells: function (lm) {
		var i, row, view, r, column, room;
		var	start = lm.firstCol(this._fixed, this._rightFixed);
		var	end   = lm.lastCol(this._fixed, this._rightFixed);
		var grid = this.grid();
		var mergeManager = this.$_getMergeManager();
		var merged = mergeManager.count() > 0;
		var count = this.model().count();
		var rowHeight = _int(this.height() / count);
		for (i = start; i <= end; i++) {
			column = lm.getColumn(i);
			for (row = 0; row < count; row++) {
				view = this._cells[row][column.$_hash];
				r = lm.getColumnBounds(i);
				if (merged && (room = mergeManager.findRoomBy(column))) {
					var sr = lm.getColumnBounds(room.start());
					var er = lm.getColumnBounds(room.last());

					r.x = sr.x;
					r.width = er.right() - r.x;
				}
				r.y = rowHeight * row; 
				if (row < count -1) {
					r.height = rowHeight;
				} else {
					r.height = this.height() - rowHeight * row;
				}
				view.setRect(r);
				view.layoutContent(lm, row);
			}
		}
		if (merged) {
			var rooms = mergeManager.getRoomNames();
			for (var i = 0; i < rooms.length; i++) {
				var room = mergeManager.getRoom(rooms[i]);
				if (room && ((start > room.base() && start <= room.last()) ||
				             (end   < room.base() && end   >= room.start()))) {
					for (row = 0; row < count; row++) {
						r = lm.columnBounds(room.start());
						r.height = this.height();
						er = lm.columnBounds(room.last());
						r.width = er.right() - r.x;
						r.y = rowHeight * row; 
						if (row < count -1) {
							r.height = rowHeight;
						} else {
							r.height = this.height() - rowHeight * row;
						}
						view = this._cells[row][lm.getColumn(room.base()).$_hash];
						view.setRect(r);
						view.layoutContent(lm);
					}			
				}
			}
		}
	}
});

var FooterElement = defineClass("FooterElement", SummaryElement, {
	init : function(dom, footer, fixed, rightFixed) {
		this._super(dom, "footerView", footer, fixed, rightFixed);
	},
	$_getMergeManager: function() {
		return this.grid().footerMergeManager();
	},
	$_createGroupCellElement: function() {
		return new FooterGroupCellElement(this._dom);
	},
	$_createCellElement: function() {
		return new FooterCellElement(this._dom);
	}
});

var HeaderSummaryElement = defineClass("HeaderSummaryElement", SummaryElement, {
	init : function(dom, summary, fixed, rightFixed) {
		this._super(dom, "headerSummaryView", summary, fixed, rightFixed);
	},
	destroy: function() {
		this._super();
	},
	$_getMergeManager: function() {
		return this.grid().headerSummaryMergeManager();
	},
	$_createGroupCellElement: function() {
		return new HeaderSummaryGroupCellElement(this._dom);
	},
	$_createCellElement: function() {
		return new HeaderSummaryCellElement(this._dom);
	}
});
var IndicatorElement = defineClass("IndicatorElement", VisualObjectElement, {
	init : function(dom, indicator) {
		this._super(dom, "IndicatorView", indicator);
		this._cells = [];
		this._fixedCount = 0;
	},
	refreshSelection: function (selections) {
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		function calcWidth(grid, indicator) {
			var cnt = grid.itemCount();
			if (cnt <= 0) {
				return 0;
			}
			var s = new Array(String(cnt).length + 1).join('8');
			var st = indicator.styles()
			cnt = grid.container().measureText(st.font(), s);
			return cnt;
		}
		var grid = this.grid();
		var indicator = this.model();
		var w = indicator.width();
		if (w <= 0) {
			w = calcWidth(grid, indicator);
			var w2 = indicator.maxWidth();
			if (w2 > 0 && w > w2) {
				w = w2
			}
			w = Math.max(indicator.minWidth(), w);
		}
		return Size.create(w, hintHeight);
	},
	_doRender : function(g, r) {
		var indicator = this.model();
		var styles = indicator.styles();
		var fill = styles.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawStyledBorders(g, r, styles);
	},
	_doLayoutContent : function(lm) {
		var view, item, i, cnt, row, index, cell, r,
			grid = this.grid(),
			indicator = this.model(),
			width = this.width(),
			topIndex = lm.topIndex(),
			fixedItemCount = lm.fixedItemCount(),
			itemCount = lm.itemCount();
		// if (fixedItemCount == this._fixedCount && itemCount == this.childCount() - this._fixedCount && this.childCount() > this._fixedCount + 1) {
		// 	view = this.getChild(this._fixedCount);
		// 	if (view && (item = view.item()) != null) {
		// 		if (item.index() == this._fixedCount + topIndex - 1) {
		// 			// view = this.removeElementAt(this._fixedCount);
		// 			// this.addElement(view);
		// 		} else if (item.index() == this._fixedCount + topIndex + 1) {
		// 			view = this.removeElementAt(this.childCount() - 1);
		// 			this.insertElement(this._fixedCount, view);
		// 		}
		// 	}
		// }
		this._fixedCount = fixedItemCount;
		while (this.childCount() < fixedItemCount + itemCount) {
			if (this._cells.length > 0) {
				view = this._cells.pop();
			} else {
				view = this._createCell();
			}
			this.addElement(view);
		}
		while (this.childCount() > fixedItemCount + itemCount) {
			view = this.removeElementAt(this.childCount() - 1);
			view.validate(true);
			this._cells.push(view);
		}
		cnt = this.childCount();
		for (i = 0; i < cnt; i++) {
			view = this.getChild(i);
			row = (i < fixedItemCount) ? i : i + topIndex;
			index = CellIndex.temp(grid, row);
			cell = indicator.getCell(index);
			view.updateCell(cell);
			r = lm.getItemBounds(i);
			r.x = 0;
			r.width = width;
			view.setRect(r);
		}
	},
	_doRefresh: function() {
		var grid = this.grid();
		var indicator = grid.indicator();
		var lm = grid.layoutManager();
		var fixed = lm.fixedItemCount();
		var cnt = this.childCount();
		for (var i = 0; i < cnt; i++) {
			var row = (i < fixed) ? i : i + lm.topIndex();
			var index = CellIndex.temp(grid, row);
			var model = indicator.getCell(index);
			var view = this.getChild(i);
			view.updateCell(model);
		}
	},
	_createCell: function () {
		return new IndicatorCellElement(this._dom);
	}
});
var StateBarElement = defineClass("StateBarElement", VisualObjectElement, {
	init : function(dom, stateBar) {
		this._super(dom, "stateBarView", stateBar);
		this._cells = [];
		this._fixedCount = 0;
	},
	refreshSelection: function (selections) {
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return Size.create(this.model().width(), hintHeight);
	},
	_doRender: function(g, r) {
		var stateBar = this.model();
		var styles = stateBar.styles();
		var fill = styles.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawStyledBorders(g, r, styles);
	},
	_doLayoutContent : function(lm) {
		var view, item, i, cnt, row, index, cell, r,
			grid = this.grid(),
			stateBar = this.model(),
			width = this.width(),
			topIndex = lm.topIndex(),
			fixedItemCount = lm.fixedItemCount(),
			itemCount = lm.itemCount();
		// if (fixedItemCount == this._fixedCount && itemCount == this.childCount() - this._fixedCount && this.childCount() > this._fixedCount + 1) {
		// 	view = this.getChild(this._fixedCount);
		// 	if (view && (item = view.getItem()) != null) {
		// 		if (item.index() == this._fixedCount + topIndex - 1) {
		// 			view = this.removeElementAt(this._fixedCount);
		// 			this.addElement(view);
		// 		} else if (item.index() == this._fixedCount + topIndex + 1) {
		// 			view = this.removeElementAt(this.childCount() - 1);
		// 			this.insertElement(this._fixedCount, view);
		// 		}
		// 	}
		// }
		this._fixedCount = fixedItemCount;
		while (this.childCount() < fixedItemCount + itemCount) {
			if (this._cells.length > 0) {
				view = this._cells.pop();
			} else {
				view = this._createCell();
			}
			this.addElement(view);
		}
		while (this.childCount() > fixedItemCount + itemCount) {
			view = this.removeElementAt(this.childCount() - 1);
			view.validate(true);
			this._cells.push(view);
		}
		cnt = this.childCount();
		for (i = 0; i < cnt; i++) {
			view = this.getChild(i);
			row = (i < fixedItemCount) ? i : i + topIndex;
			index = CellIndex.temp(grid, row);
			cell = stateBar.getCell(index);
			view.updateCell(cell);
			r = lm.getItemBounds(i);
			r.x = 0;
			r.width = width;
			view.setRect(r);
		}
	},
	_doRefresh: function() {
	},
	_createCell: function () {
		return new StateBarCellElement(this._dom);
	}
});
var CheckBarElement = defineClass("CheckBarElement", VisualObjectElement, {
	init : function(dom, checkBar) {
		this._super(dom, "checkBarView", checkBar);
		this._cells = [];
		this._fixedCount = 0;
	},
	refreshSelection: function (selections) {
	},
	_doMeasure : function(grid, hintWidth, hintHeight) {
		return Size.create(this.model().width(), hintHeight);
	},
	_doRender : function(g, r) {
		var checkBar = this.model();
		var styles = checkBar.styles();
		var fill = styles.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawStyledBorders(g, r, styles);
	},
	_doLayoutContent : function(lm) {
		var view, item, i, cnt, row, index, cell, r;
		var grid = this.grid();
		var width = this.width();
		var checkBar = this.model();
		var exclusive = checkBar.isExclusive();
		var showGroup = checkBar.isShowGroup();
		var checkImageUrl = checkBar.checkImageUrl();
		var unCheckImageUrl = checkBar.unCheckImageUrl();
		var drawCheckBox = checkBar.isDrawCheckBox();
		var radioImageUrl = checkBar.radioImageUrl();
		var topIndex = lm.topIndex();
		var fixedItemCount = lm.fixedItemCount();
		var itemCount = lm.itemCount();
		// if (fixedItemCount == this._fixedCount && itemCount == this.childCount() - this._fixedCount && this.childCount() > this._fixedCount + 1) {
		// 	view = this.getChild(this._fixedCount);
		// 	if (view && (item = view.getItem()) != null) {
		// 		if (item.index() == this._fixedCount + topIndex - 1) {
		// 			view = this.removeElementAt(this._fixedCount);
		// 			this.addElement(view);
		// 		} else if (item.index() == this._fixedCount + topIndex + 1) {
		// 			view = this.removeElementAt(this.childCount() - 1);
		// 			this.insertElement(this._fixedCount, view);
		// 		}
		// 	}
		// }
		this._fixedCount = fixedItemCount;
		while (this.childCount() < fixedItemCount + itemCount) {
			if (this._cells.length > 0) {
				view = this._cells.pop();
			} else {
				view = this._createCell();
			}
			this.addElement(view);
		}
		while (this.childCount() > fixedItemCount + itemCount) {
			view = this.removeElementAt(this.childCount() - 1);
			view.validate(true);
			this._cells.push(view);
		}
		cnt = this.childCount();
		for (i = 0; i < cnt; i++) {
			row = (i < fixedItemCount) ? i : i + topIndex;
			index = CellIndex.temp(grid, row);
			cell = checkBar.getCell(index);
			view = this.getChild(i);
			view.setMarkVisible(showGroup || index.dataRow() >= 0);
			view.setExclusive(exclusive);
			view.setDrawCheckBox(drawCheckBox);
			view.setRadioImageUrl(radioImageUrl);
			view.updateCell(cell);
			r = lm.getItemBounds(i);
			r.x = 0;
			r.width = width;
			view.setRect(r);
		}
	},
	_doRefresh: function() {
	},
	_createCell: function () {
		return new CheckBarCellElement(this._dom);
	}
});
var GridBodyElement = defineClass("GridBodyElement", VisualObjectElement, {
	init : function (dom, body, fixed, rightFixed) {
		this._super(dom, "gridBodyView", body);
		this._fixed = fixed;
		this._rightFixed = rightFixed;
		this._lineScrolled = false;
		this._horzScrolling = false;
		this._fixedCount = 0;
		this._items = [];
		this._rowViews = [];
		this._fill = new SolidBrush(0xffffff);
	},
	destroy: function() {
		this._destroying = true;
		this._items = null;
		this._rowViews = null;
		this._fill = null;
		this._super();
	},
	empty: false,
	isFixed: function () { return this._fixed; },
	isRightFixed: function () { return this._rightFixed; },
	isLineScrolled: function () { return this._lineScrolled; },
	checkResourceColumn: function (column, list) {
	},
	checkResourceUse: function (url, list) {
	},
	clearItems: function () {
		this._items = [];
	},
	addItem: function (item) {
		if (this._items.indexOf(item) < 0) {
			this._items.push(item);
		}
	},
	findRowView: function (itemIndex) {
		var childs = this.getChildren() || [];
		var i, cnt, rowView;
		for (i = 0, cnt = childs.length; i < cnt ; i++) {
			rowView = childs[i];
			if (rowView instanceof RowElement && rowView._item._index == itemIndex) {
				return rowView;
			}
		}
  //       for (var i = 0, cnt = this.childCount(); i < cnt; i++) {
		// 	var rowView = this.getChild(i);
		// 	if (rowView instanceof RowElement && rowView.item().index() == itemIndex) {
		// 		return rowView;
		// 	}
		// }
		return null;
	},
    findFirstRow: function () {
        var cnt = this.childCount();
        if (cnt > 0) {
            var first = null;
            for (var i = 1; i < cnt; i++) {
                var rowView = this.getChild(i);
                if (rowView instanceof RowElement) {
                    if (!first && rowView.itemIndex() < first.itemIndex()) {
                        first = rowView;
                    }
                }
            }
            return first;
        }
        return null;
    },
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return {
			width : hintWidth,
			height : hintHeight
		};
	},
	_doLayoutContent : function(lm) {
		this._lineScrolled = false;
		this._super(lm);
		var i, j, item, view, styles, idx, r, topIndex;
		var fixed = this._fixed;
		var rfixed = this._rightFixed;
		var grid = this.grid();
		var cnt = this.childCount();
		var items = this._items;
		var itemCount = items.length;
		for (i = 0; i < cnt; i++) {
			this.getChild(i)._recycling = false;
		};
		/*
		this._horzScrolling = grid.isHorzScrolling();
		if (this._horzScrolling) {
		} else if (grid.isScrolling() && lm.getFixedItemCount() == fixedCount && 
				this.childCount() > fixedCount + 2 && itemCount > fixedCount + 2) {
			i = fixedCount;
			var v1 = this.getChild(i);
			var v2 = this.getChild(i + 1);
			if (v1.getItem() === items[i]) {
				v1._recycling = true;
				cnt = this.childCount();
				while (++i < cnt && i < itemCount) {
					v2 = this.getChild(i);
					if (v2.getItem() != items[i]) {
						break;
					}
					v2._recycling = true;
				}
				for (j = cnt - 1; j >= i; j--) {
					this.$_removeView(j);
				}
			} else if (v2.getItem() === items[i]) {
				this._lineScrolled = 1;
				this.$_removeView(i);
				cnt = this.childCount();
				while (i < cnt && i < itemCount) {
					v2 = this.getChildAt(i);
					if (v2.getItem() === items[i]) {
						break;
					}
					v2._recycling = true;
					i++;
				}
				for (j = cnt; j >= i; j--) {
					this.$_removeView(j);
				}
			} else if (v1.getItem() === items[i + 1]) {
				this._lineScrolled = -1;
				v2 = this.$_borrowView(items[i]);
				this.insertElement(1, v2);
				cnt = this.childCount();
				while (++i < cnt && i < itemCount) {
					v2 = this.getChild(i);
					if (v2.getItem() !== items[i]) {
						break;
					}
					v2._recycling = true;
				}
				for (j = cnt - 1; j >= i; j--) {
					this.$_removeView(j);
				}
			}
		}
		*/
		while ((j = this.childCount()) < itemCount) {
			item = items[j];
			view = this.$_borrowView(item);
			this.addElement(view);
		}
		while ((j = this.childCount()) > itemCount) {
			this.$_removeView(j - 1);
		}
		this._fixedCount = lm.fixedItemCount();
		styles = grid.body().styles();
		topIndex = grid.topIndex();
		j = 0;
		for (i = 0; i < itemCount; i++) {
			item = items[i];
			view = this.getChild(i);
			view.updateElement(item, styles);
			idx = item.index();
			idx = (idx < this._fixedCount) ? idx : idx - topIndex;
			r = lm.itemBounds(idx, fixed, rfixed);
			view.setRect(r);
			if (!view._recycling) {
				view._layoutIndex = j++
				view.layoutContent(lm);
			} else if (lm.isColumnMerged && this._lineScrolled && (i <= 1 || i >= itemCount - 2)) {
				view._layoutIndex = j++
				view.layoutContent(lm);
			}
		}
	},
	_doRender: function(g, r) {
		if (this.isEmpty()) {
			return;
		};
		var grid = this.grid();
		var options = grid.fixedOptions();
		var wbar = options.colBarWidth();
		g.drawRect(SolidBrush.WHITE, null, r);  // grid.empty영역을 따로 분리하지 않고 모두 칠하면서 전체 색상이 변경되는 문제가 발생. body영역은 흰색으로 칠해준다.
		if (this.isFixed() && wbar > 0) {
			if (this.isRightFixed()) {
				r.setRight(wbar);
			} else {
				r.setLeft(r.right() - wbar);
			}
			r.height = grid.layoutManager().fixedBounds().height;
			var styles = options.colBarStyles();
			var stroke = styles.borderRight();
			var lstroke = styles.borderLeft();
			var fill = styles.background();
			if (fill) {
				g.drawRect(fill, null, r);
			}
			if (stroke) {
				g.drawVertLineI(stroke, r.y, r.bottom(), r.right() - 1);
			}
			if (lstroke && this._rightFixed) {
				g.drawVertLineI(lstroke, r.y, r.bottom(), r.x);
			}

		}
	},
	_doRefresh: function() {
	},
	$_removeView: function (row) {
		var view = this.removeElementAt(row);
		view.validate(true);
		this._rowViews.push(view);
	},
	$_borrowView: function (item) {
		var view = this._rowViews.pop();
		if (!view) {
			view = this.grid().delegate().borrowItemView(item, this._fixed, this._rightFixed);
		}
		assert(view != null, "view is null");
		view._recycling = false;
		return view;
	}
});
var GridLinesElement = defineClass("GridLinesElement", LayerElement, {
	init: function(dom, grid) {
		this._super(dom, "gridLinesView");
		this._grid = grid;
	},
	_doDraw: function (g) {
		var grid = this._grid;
		var lm = grid.layoutManager();
		var r = lm.bodyBounds();
		r.setRight(r.right()+lm.rfixedWidth());
		var fy = lm.footerBounds().y;
		var x2 = Math.min(r.right(), lm.gridBounds().right());
		var x, y, fill, stroke;
		var options = grid.fixedOptions();
		if (lm.fixedHeight() > 0 && options.rowBarHeight() > 0) {
			x = Math.min(lm.gridBounds().right(), r.right());
			y  = r.y + lm.fixedHeight();
			if (y < fy) {
				fill = options.rowBarStyles().background();
				stroke = options.rowBarStyles().borderBottom();
				if (fill) {
					var h = Math.min(options.rowBarHeight(), fy - y);
					g.drawBoundsI(fill, null, 0, y, x, h);
				}
				y += options.rowBarHeight() - 1;
				if (y < fy && stroke && stroke.width() > 0) {
					g.drawLineI(stroke, 0, y, x, y);
				}
			}
		}
		stroke = grid.body().styles().line();
		if (stroke && stroke.width() > 0) {
			x = r.right();
			y = r.bottom();
			if (x <= x2 && lm.columnCount() + lm.fixedColCount() > 0) {
				g.drawLineI(stroke, x - 1, 0, x - 1, y);
			}
			if (grid.itemCount() > 0 && lm.itemCount() == lm.fullItemCount() && y < fy) {
				g.drawLineI(stroke, 0, y - 1, x2, y - 1);
			}
		}
	}
});

var GridDebugElement = defineClass("GridDebugElement", LayerElement, {
	init: function (dom, grid) {
		this._super(dom, "gridDebugView");
		this._grid = grid;
		this._drawRect = new Rectangle();
		this._strokes = {
			"grid": SolidPen.RED,
			"body": SolidPen.BLUE,
			"fixed": SolidPen.RED,
			"nonfixed": SolidPen.GREEN
		}
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		this._super();
	},
	gridBounds: false,
	bodyBounds: false,
	fixedBounds: false,
	nonfixedBounds: false,
	_doDraw: function(g, needOpaque) {
		this.getClientRect(this._drawRect);
		this._doRender(g, this._drawRect);
	},
	_doRender: function (g, bounds) {
		var r;
		var lm = this._grid.layoutManager();
		if (this._gridBounds) {
			r = lm.gridBounds();
			g.drawRect(null, this._strokes["grid"], r);
		}
		if (this._bodyBounds) {
			r = lm.bodyBounds();
			trace("### B O D Y: " + r.x + ", " + r.width);
			g.drawRect(null, this._strokes["body"], r);
		}
		if (this._fixedBounds) {
			r = lm.fixedBounds();
			g.drawRect(null, this._strokes["fixed"], r);
		}
		if (this._nonfixedBounds) {
			r = lm.nonfixedBounds();
			g.drawRect(null, this._strokes["nonfixed"], r);
		}
	}
});
var /* @abstract */ HandleElement = defineClass("HandleElement", VisualElement, {
	init: function (dom, owner, name) {
		this._super(dom, name);
		this._owner = owner;
	},
	clickable: false,
	owner: function () { return this._owner; },
	propertyChanged: function (prop, value) {
		this.invalidate();
	},
	hoverChanged: function (lm) {
		this.invalidate();
	}
});
var /* @abstract */ CellHandle = defineClass("CellHandle", HandleElement, {
	init: function (dom, cellView, name) {
		this._super(dom, cellView, name);
	},
	cellView: function () {
		return this._owner;
	}
});

var /* @abstract */ HeaderCellHandle = defineClass("HeaderCellHandle", CellHandle, {
	init: function (dom, cellView, name) {
		this._super(dom, cellView, name);
	},
	destroy: function() {
		this._destroying = true;
		this._options = null;
		this._super();
	},
});

var SORT_ICON_WIDTH = 8;
var SORT_ORDER_WIDTH = 12;
var SORT_ICON_HEIGHT = 9;
var HeaderSortHandle = defineClass("HeaderSortHandle", HeaderCellHandle, {
	init: function(grid, dom, cellView) {
		this._super(dom, cellView, "sortHandle");
		this.setMouseEnabled(false);
		this.setClickable(false);
		this._grid = grid;

		this._options = grid.sortingOptions();
		if (this._options._handleFill)
			this._fill = this._options._handleFill;
		if (this._options._handleNoneFill)
			this._noneFill = this._options._handleNoneFill;
		if (this._options._hoveredHandleFill)
			this._hoveredFill = this._options._hoveredHandleFill;
		if (this._options._hoveredHandleNoneFill)
			this._hoveredNoneFill = this._options._hoveredHandleNoneFill;
		if (this._options._handleBorderPen)
			this._border = this._options._handleBorderPen;
	},
	sortOrder: -1,
	sortDir: SortDirection.ASCENDING,
	fill: SolidBrush.GRAY,
	noneFill: SolidBrush.EMPTY,
	hoveredFill: SolidBrush.GRAY,
	hoveredNoneFill: SolidBrush.EMPTY,
	border: SolidPen.GRAY,
	_doDraw: function (g) {
		var options = this._options;
		if (options.visibility == HandleVisibility.HOVERED && !this._owner.isHovered()) {
			return;
		}
		var r = this.getClientRect();
        var sortOrder = this.sortOrder();
        if (options.isImageHandle())
        	this.$_drawHandleImage(g, r, sortOrder);
        else 
        	this.$_drawHandle(g, r, sortOrder);

		if (options.isShowSortOrder() && sortOrder >= 0) {
			var st = options._sortOrderStyles;
			r.setLeft(SORT_ORDER_WIDTH);
			r.y = (r.height - (SORT_ICON_HEIGHT + 6)) / 2;
			r.height = SORT_ICON_HEIGHT + 4;
			var font = (st && st.font()) || this._owner.font();
			var foreground = (st && st.foreground()) || this._owner.foreground();
			var align = st.textAlignment();
			var line = st.lineAlignment();
			align = !align ? "left" : align == Alignment.FAR ? "right" : align == Alignment.NEAR ? "left" : "center";
			line = !line ? "top" : line == Alignment.FAR ? "bottom" : line == Alignment.NEAR ? "top" : "middle";
			g.drawTextRect(font, foreground, (sortOrder+1).toString(), r, align, line);	
		}     
	},
	$_drawHandle: function (g, r, sortOrder) {
		var orderWidth = this._options._showSortOrder ? SORT_ORDER_WIDTH : 0;
        var	x = (r.width - orderWidth) / 2;
        var	y = (r.height - SORT_ICON_HEIGHT) / 2;
        var	pts, fill;
		if (sortOrder < 0 || this.sortDir() == SortDirection.ASCENDING) {
			pts = [
				x, y,
				x - SORT_ICON_WIDTH / 2, y + SORT_ICON_HEIGHT - 1,
				x + SORT_ICON_WIDTH/ 2, y + SORT_ICON_HEIGHT - 1,
				x, y
			];
		} else{
			pts = [
				x - SORT_ICON_WIDTH / 2, y,
				x + SORT_ICON_WIDTH / 2, y,
				x, y + SORT_ICON_HEIGHT - 1,
				x - SORT_ICON_WIDTH / 2, y
			];
		}
		if (this.isHovered()) {
			fill = sortOrder < 0 ? this._hoveredNoneFill : this._hoveredFill;
		} else {
			fill = sortOrder < 0 ? this._noneFill : this._fill;
		}
		g.drawPolygonArray(fill, this._border, pts);
	},
	$_drawHandleImage: function (g, r, sortOrder) {
		var sortDir = this.sortDir();
		var hovered = this.isHovered();
		var images = this._options.handleImages();
		var url;
		var orderWidth = this._options._showSortOrder ? SORT_ORDER_WIDTH : 0;
		if (sortOrder < 0) {
			url = hovered ? images._hoveredNone : images._none;
		} else if ( sortDir == SortDirection.ASCENDING) {
			url = hovered ? images._hoveredAscending : images._ascending;
		} else {
			url = hovered ? images._hoveredDescending : images._descending;
		}
		if (url) {
			var img = this._grid.getImage(url);

        	var w = Math.min(img.width, r.width-orderWidth);
        	var h = Math.min(img.height, r.height)
            g.drawImage(img, (r.width-orderWidth-w)/2 + orderWidth, (r.height-h)/2, w, h);	
	    }
	},
	isHovered: function () {
		return this._super() || (this._owner && this._owner.isHovered());
	}
});
var FILTER_ICON_WIDTH = 10;
var FILTER_ICON_HEIGHT = 12;
var FILTER_ICON_BAR = 4;
var HeaderFilterHandle = defineClass("HeaderFilterHandle", HeaderCellHandle, {
	init: function(grid, dom, cellView) {
		this._super(dom, cellView, "filterHandle");
		this.setClickable(true);
		this._grid = grid;
		this._options = grid.filteringOptions();
		if (this._options._handleFill)
			this._fill = this._options._handleFill;
		if (this._options._handleNoneFill)
			this._noneFill = this._options._handleNoneFill;
		if (this._options._hoveredHandleFill)
			this._hoveredFill = this._options._hoveredHandleFill;
		if (this._options._hoveredHandleNoneFill)
			this._hoveredNoneFill = this._options._hoveredHandleNoneFill;
		if (this._options._handleBorderPen)
			this._border = this._options._handleBorderPen;
	},
	fill: SolidBrush.GRAY,
	noneFill: SolidBrush.EMPTY,
	hoveredFill: SolidBrush.GRAY,
	hoveredNoneFill: SolidBrush.EMPTY,
	border: SolidPen.GRAY,
	isClickable: function () {
		return true;
	},
	_doDraw: function(g) {
		var cellView = this.cellView();
		if (!cellView) {
			return;
		}
		var column = cellView.index().dataColumn();
		if (!column) {
			return;
		}
		if (this._options.isImageHandle()) {
			this.$_drawHandleImage(g, this.clientRect(), column);
		}
		else {
			this.$_drawHandle2(g, this.clientRect(), column);
		}
	},
	$_drawHandle2: function (g, r, column) {
		var x = r.width / 2;
		var y = (r.height - FILTER_ICON_HEIGHT) / 2;
		var pts = [
			x - FILTER_ICON_WIDTH / 2, y,
			x + FILTER_ICON_WIDTH / 2, y,
			x, y + FILTER_ICON_HEIGHT - FILTER_ICON_BAR + 2,
			x - FILTER_ICON_WIDTH / 2, y
		];
		var fill;
		var filtered = column.isFiltered();
		if (this.isHovered()) {
			fill = filtered ? this._hoveredFill : this._hoveredNoneFill;
		} else {
			fill = filtered ? this._fill : this._noneFill;
		}
		g.drawPolygonArray(fill, this._border, pts);
		g.drawLineI(this._border, x - 1, y + FILTER_ICON_HEIGHT - FILTER_ICON_BAR - 1, x - 1, y + FILTER_ICON_HEIGHT + 1);
		g.drawLineI(this._border, x, y + FILTER_ICON_HEIGHT - FILTER_ICON_BAR - 1, x, y + FILTER_ICON_HEIGHT + 1);
	},
	$_drawHandleImage: function (g, r, column) {
		var filtered = column.isFiltered();
		var hovered = this.isHovered();
		var images = this._options.handleImages();
		var url;
		if (filtered) {
			url = hovered ? images._hoveredFill : images._fill;
		} else {
			url = hovered ? images._hoveredNone : images._none;
		}

		var img = this._grid.getImage(url);
		if (img) {
        	var w = Math.min(img.width, r.width);
        	var h = Math.min(img.height, r.height)
            g.drawImage(img, (r.width-w)/2, (r.height-h)/2, w, h);	
        }	
	}, 
	setHovered: function (value) {
		this._super(value);
		this._owner.invalidate(true,true);
		//if (value && this._owner)
		//	this._owner.setHovered(value);
	}
});
var HEADER_CHECKBOX_SIZE = 12;
var HeaderCheckHandle = defineClass("HeaderCheckHandle", HeaderCellHandle, {
    init: function(grid, dom, cellView) {
        this._super(dom, cellView, "checkHandle");
        this.setClickable(true);
		this._grid = grid;

		this._options = grid.columnHeaderOptions();
		if (this._options._checkFill)
			this._fill = this._options._checkFill;
		if (this._options._checkNoneFill)
			this._noneFill = this._options._checkNoneFill;
		if (this._options._hoveredCheckFill)
			this._hoveredFill = this._options._hoveredCheckFill;
		if (this._options._hoveredCheckNoneFill)
			this._hoveredNoneFill = this._options._hoveredCheckNoneFill;
		if (this._options._checkBorderPen)
			this._border = this._options._checkBorderPen;
    },
    checked: false,
	fill: SolidBrush.DKGRAY,
	noneFill: SolidBrush.EMPTY,
	hoveredFill: SolidBrush.DKGRAY,
	hoveredNoneFill: SolidBrush.EMPTY,
	border: SolidPen.GRAY,
    _doDraw: function (g) {
        var r = this.getClientRect();

        if (this._options.isImageCheckHandle())
        	this.$_drawImageCheck(g, r);
        else 
        	this.$_drawCheck(g, r);
    },
    $_drawCheck: function (g, r) {
        var fill = SolidBrush.WHITE;
        if (fill) {
            g.drawRectI(fill, this._border, r);
        }
        var sz = HEADER_CHECKBOX_SIZE;
        g.drawBoundsI(null, this._border, r.x, r.y, sz, sz);

        r.y+=2;

        var fill;
        if (this.isHovered()) {
        	fill = this.isChecked() ? this._hoveredFill : this._hoveredNoneFill;
        } else {
        	fill = this.isChecked() ? this._fill : this._noneFill;
        }

        $$_drawCheckMark(g, fill, r, sz - 1);
    },
    $_drawImageCheck: function(g, r) {
		var checked = this.isChecked();
		var hovered = this.isHovered();
		var images = this._options.checkImages();
		var url;

		if (checked) {
			url = hovered ? images._hoveredFill : images._fill;
		} else {
			url = hovered ? images._hoveredNone : images._none;
		}
		var img = this._grid.getImage(url);
		if (img) {
         	var w = Math.min(img.width, r.width);
        	var h = Math.min(img.height, r.height)
            g.drawImage(img, (r.width-w)/2, (r.height-h)/2, w, h);	
		}
    },
	setHovered: function (value) {
		this._super(value);
		//if (value && this._owner)
			//this._owner.setHovered(value);
	}
});
var HeaderImageHandle = defineClass("HeaderImageHandle", HeaderCellHandle, {
    init: function(dom, cellView) {
        this._super(dom, cellView, "imageHandle");
        this.setMouseEnabled(true);
        this.setClickable(true);
    },
    image: null,
    _doDraw: function (g) {
        var img = this._image;
        if (img && img.width > 0 && img.height > 0) {
            g.drawImage(img, 0, 0, img.width, img.height);
        }
    }
});
var GroupRemoveButtonHandle = defineClass("GroupRemoveButtonHandle", HeaderCellHandle, {
	init: function(grid, dom, cellView) {
		this._super(dom, cellView, "removeButtonHandle");
		this._grid = grid;
		this.setMouseEnabled(true);
		this.setClickable(true);
		this._options = grid.groupingOptions() && grid.groupingOptions().removeButton();
		this._options._fill && (this._fill = this._options._fill);
		this._options._hoveredFill && (this._hoveredFill = this._options._hoveredFill);
		this._size = this._options._size || HEADER_CHECKBOX_SIZE;
		this._buttonGap = this._options.buttonGap();
	},
	fill: SolidBrush.DKGRAY,
	hoveredFill: SolidBrush.DKGRAY,
	size: 0,
	buttonGap: 4,
	isClickable: function () {
		return true;
	},
	_doDraw: function(g) {
		var r = this.getClientRect();
		this.$_drawCloseMark(g, r);
	},
    $_drawCloseMark: function (g, r) {
        var sz = this._size;
        var fill = this.isHovered() ? this._hoveredFill : this._fill;
        $$_drawCloseMark(g, fill, r, sz);
    },	
	setHovered: function (value) {
		this._super(value);
	}
});
var POPUP_WIDTH = 7;
var HeaderPopupHandle = defineClass("HeaderPopupHandle", HeaderCellHandle, {
	init: function(grid, dom, cellView) {
		this._super(dom, cellView, "popupHandle");
		this.setClickable(true);
		this._grid = grid;
		this._options = grid.columnHeaderOptions();
	},
	pen: SolidPen.GRAY,
	hoveredPen: SolidPen.DKGRAY,
	border: SolidPen.GRAY,
	isClickable: function () {
		return true;
	},
	_doDraw: function(g) {
		var cellView = this.cellView();
		if (!cellView) {
			return;
		}
		var column = cellView.index().column();
		if (!column) {
			return;
		}
		if (this._options._popupMenuPen)
			this._pen = this._options._popupMenuPen;
		if (this._options._hoveredPopupMenuPen)
			this._hoveredPen = this._options._hoveredPopupMenuPen;
		var width;
		width = (isNaN(width = parseInt(this._options.popupMenuWidth())) ? POPUP_WIDTH : width);
		var r = this.getClientRect();
        var x = r.x + (r.width - width)/ 2;
        var y = r.y + (r.height - 13 + 3) / 2;
        width += x;
		var hovered = this.isHovered();
        var pen = hovered ? this._hoveredPen : this._pen;
        g.drawHLine(pen, y, x, width);
        y += 3 + 2;
        g.drawHLine(pen, y, x, width);
        y += 3 + 2;
        g.drawHLine(pen, y, x, width);
	},
	setHovered: function (value) {
		this._super(value);
		this._owner.invalidate(true,true);
	}
});
var DataCellExpandHandle = defineClass("DataCellExpandHandle", CellHandle, {
	init: function(dom, cellView) {
		this._super(dom, cellView, "dataCellExpandHandle");
	},
	expanded: false,
	background: null,
	group: function () {
		var view = _cast(this.cellView(), MergedDataCellElement);
		return view ? view.mergeRoom().group() : null;
	},
	isClickable: function() {
		return true;
	},
	_doDraw: function (g) {
		var r = this.clientRect();
		var fill = this._background || SolidBrush.DKGRAY;
		if (this.isExpanded()) {
			$$_drawMinusBox(g, r, 9, fill, SolidBrush.WHITE);
		} else {
			$$_drawPlusBox(g, r, 9, fill, SolidBrush.WHITE);
		}
	}
});
var /* @abtract */ CellElement = defineClass("CellElement", GridElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._grid = null;
		this._fixed = false;
		this._recycling = false;
		this._index = new CellIndex();
		this._renderRect = new Rectangle();
		this._textAlign = "near";
		this._lineAlign = "middle";
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		this._font = null;
		this._index = null;
		this._renderREct = null;
		this._super();
	},
	background: SolidBrush.WHITE,
	foreground: SolidBrush.BLACK,
	font: null,
	border: null,
	borderLeft: null,
	borderTop: null,
	borderRight: null,
	borderBottom: null,
	paddingLeft: 0,
	paddingTop: 0,
	paddingRight: 0,
	paddingBottom: 0,
	line: null,
	figureBackground: SolidBrush.DKGRAY,
	figureInactiveBackground: SolidBrush.LTGRAY,
	figureBorder: null,
	figureSize: null,
	figureName: null,
	figureState: null,
	textAlignment: Alignment.NEAR,
	lineAlignment: Alignment.CENTER,
	textWrap: TextWrapMode.NONE,
	pushed: false,
	mouseEntered: false,
    pressed: false,
	clickable: false,
	index: null,
	isFixed: function () { return this._fixed; },
	setIndex: function (value) { 
		if (!CellIndex.areEquals(this._index, value)) {
			this._index.assign(value); 
			this.invalidate();
		}
	},
	getItem: function () { return this._index.item(); },
	item: function () { return this._index.item(); },
	setTextAlignment: function (value) {
		if (value != this._textAlignment) {
			this._textAlignment = value;
			switch (value) {
			case Alignment.FAR:
				this._textAlign = "right";
				break;
			case Alignment.NEAR:
				this._textAlign = "left";
				break;
			default:
				this._textAlign = "center";
				break;
			}
			this.invalidate();
		}
	},
	setLineAlignment: function (value) {
		if (value != this._lineAlignment) {
			this._lineAlignment = value;
			switch (value) {
				case Alignment.FAR:
					this._lineAlign = "bottom";
					break;
				case Alignment.NEAR:
					this._lineAlign = "top";
					break;
				default:
					this._lineAlign = "middle";
					break;
			}
			this.invalidate();
		}
	},
	setFont: function (value) {
		var f = this._font;
		if (value == f) return;
		if (!value || !f || value.font != f.font || value.size != f.size || value.underline != f.underline || value.linethrough != f.linethrough) {
			this._font = value;
			this.invalidate();
		}
	},
	borderWidth: function () {
		return this._border ? this._border.width() : 0;
	},
	borderLeftWidth: function () {
		return this._borderLeft ? this._borderLeft.width() : 0;
	},
	borderRightWidth: function () {
		return this._borderRight ? this._borderRight.width() : 0;
	},
	borderHorzWidth: function () {
		return (this._borderLeft ? this._borderLeft.width() : 0) + (this._borderRight ? this._borderRight.width() : 0);
	},
	borderTopWidth: function () {
		return this._borderTop ? this._borderTop.width() : 0;
	},
	borderBottomWidth: function () {
		return this._borderBottom ? this._borderBottom.width() : 0;
	},
	borderVertWidth: function () {
		return (this._borderTop ? this._borderTop.width() : 0) + (this._borderBottom ? this._borderBottom.width() : 0);
	},
	paddingHorz: function () {
		return this._paddingLeft + this._paddingRight;
	},
	paddingVert: function () {
		return this._paddingTop + this._paddingBottom;
	},
	textAlign: function () {
		return this._textAlign;
	},
	lineAlign: function () {
		return this._lineAlign;
	},
	canHovering: function (hovered) {
		return true;
	},
	setMouseEntered: function (value) {
		if (value != this._mouseEntered) {
			this._mouseEntered = value;
			if (this.canHovering(value)) {
				this._doLayoutHandles();
				this.invalidate(false, true);
			}
		}
	},
    setPressed: function (value) {
        if (value != this._pressed) {
            this._pressed = value;
            this.invalidate(false, true);
        }
    },
	updateCell: function (model) {
		this._grid = this.grid();
		this.setIndex(model.index());
		this._doPrepareValue(model);
		this._doPrepareElement(model.styles());
		this._doUpdateContent(model);
	},
	inflatePadding: function (r) {
		r.x += this._paddingLeft;
		r.width -= this._paddingLeft + this._paddingRight;
		r.y += this._paddingTop;
		r.height -= this._paddingTop + this._paddingBottom;
		return r;
	},
	deflatePadding: function (r) {
		r.x -= this._paddingLeft;
		r.width += this._paddingLeft + this._paddingRight;
		r.y -= this._paddingTop;
		r.height += this._paddingTop + this._paddingBottom;
		return r;
	},
	deflatePadding2: function (r) {
		r.x += this._paddingLeft;
		r.width -= this._paddingLeft + this._paddingRight;
		r.y += this._paddingTop;
		r.height -= this._paddingTop + this._paddingBottom;
		return r;
	},
	inflatePadding2: function (r) {
		r.x -= this._paddingLeft;
		r.width += this._paddingLeft + this._paddingRight;
		r.y -= this._paddingTop;
		r.height += this._paddingTop + this._paddingBottom;
		return r;
	},
    getButtonWidth: function () {
        return 0;
    },
	propertyChanged: function (prop, value) {
		this.invalidate();
	},
	_doLayoutContent: function (lm) {
		this._doLayoutHandles();
	},
	_doRender: function (g, r) {
		g.drawTextRect(null, SolidBrush.BLACK, "Cell:" + this._index.toString(), r, TextAlign.CENTER);
	},
	_doPrepareValue: function (model) {
	},
	_doPrepareElement: function (styles) {
        this.setBackground(styles.background());
        this.setForeground(styles.foreground());
        this.setFont(styles.font());
        this.setBorder(styles.border());
        this.setBorderLeft(styles.borderLeft());
        this.setBorderTop(styles.borderTop());
        this.setBorderRight(styles.borderRight());
        this.setBorderBottom(styles.borderBottom());
        this.setPaddingLeft(styles.paddingLeft());
        this.setPaddingTop(styles.paddingTop());
        this.setPaddingRight(styles.paddingRight());
        this.setPaddingBottom(styles.paddingBottom());
        this.setLine(styles.line());
        this.setFigureBackground(styles.figureBackground());
        this.setFigureInactiveBackground(styles.figureInactiveBackground());
        this.setFigureBorder(styles.figureBorder());
        this.setFigureSize(styles.figureSize());
        this.setFigureName(styles.figureName());
        this.setFigureState(styles.figureState());
        this.setTextAlignment(styles.textAlignment());
        this.setLineAlignment(styles.lineAlignment());
        this.setTextWrap(styles.textWrap());
	},
	_doUpdateContent: function (model) {
	}, 
	_doLayoutHandles: function () {
	},
	_drawBorders: function (g, r) {
		var wLeft = this._borderLeft ? this._borderLeft.width() : 0;
		var wTop = this._borderTop ? this._borderTop.width() : 0;
		var wRight = this._borderRight ? this._borderRight.width() : 0;
		var wBottom = this._borderBottom ? this._borderBottom.width() : 0;
		if (wLeft) {
			wLeft = _floor(wLeft / 2);
			g.drawVertLineI(this._borderLeft, r.y, r.bottom(), r.x + wLeft);
		}
		if (wTop) {
			wTop = _floor(wTop / 2);
			g.drawHorzLineI(this._borderTop, r.x, r.right(), r.y + wTop);
		}
		if (wRight) {
			wRight = _floor((wRight + 1) / 2);
			g.drawVertLineI(this._borderRight, r.y, r.bottom(), r.right() - wRight);
		}
		if (wBottom) {
			wBottom = _floor((wBottom + 1) / 2);
			g.drawHorzLineI(this._borderBottom, r.x, r.right(), r.bottom() - wBottom);
		}
	},
	_drawBordersWithBlank: function (g, r, blankState) {
		var wLeft = this._borderLeft ? this._borderLeft.width() : 0;
		var wTop = (this._borderTop && (blankState == BlankState.NONE || blankState == BlankState.HEAD)) ? this._borderTop.width() : 0;
		var wRight = this._borderRight ? this._borderRight.width() : 0;
		var wBottom = (this._borderBottom && (blankState == BlankState.NONE || blankState == BlankState.TAIL)) ? this._borderBottom.width() : 0;
		if (wLeft) {
			wLeft = _floor(wLeft / 2);
			g.drawVertLineI(this._borderLeft, r.y, r.bottom(), r.x + wLeft);
		}
		if (wTop) {
			wTop = _floor(wTop / 2);
			g.drawHorzLineI(this._borderTop, r.x, r.right(), r.y + wTop);
		}
		if (wRight) {
			wRight = _floor((wRight + 1) / 2);
			g.drawVertLineI(this._borderRight, r.y, r.bottom(), r.right() - wRight);
		}
		if (wBottom) {
			wBottom = _floor((wBottom + 1) / 2);
			g.drawHorzLineI(this._borderBottom, r.x, r.right(), r.bottom() - wBottom);
		}
	},
	_getRenderRect: function (source) {
		var r = this._renderRect;
		var wLeft = this._borderLeft ? _int((this._borderLeft.width() + 1) / 2) : 0;
		var wTop = this._borderTop ? _int((this._borderTop.width() + 1) / 2) : 0;
		if (source) {
			r.set(source.x + wLeft, source.y + wTop, 
				source.width - wLeft - (this._borderRight ? _int((this._borderRight.width() + 1) / 2) : 0), 
				source.height - wTop - (this._borderBottom ? _int((this._borderBottom.width() + 1) / 2) : 0));
		} else {
			r.set(wLeft, wTop, 
				this.width() - wLeft - (this._borderRight ? _int((this._borderRight.width() + 1) / 2) : 0), 
				this.height() - wTop - (this._borderBottom ? _int((this._borderBottom.width() + 1) / 2) : 0));
		}
		return r;
	}
});
var CellElement$ = CellElement.prototype;
var /* @abstract */ GroupCellElement = defineClass("GroupCellElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
		this._cells = {};
		this._fill = new SolidBrush(0xfff0f0f0);
	},
	destroy: function() {
		this._destroying = true;
		for (var cell in this._cells) {
			this._cells[cell] = null;
		}
		this._cells = null;
		this._fill = null;
		this._super();
	},
	focused: false,
	group: function() {
		return _cast(this._index._column, ColumnGroup);
	},
	findCell: function (column) {
		var i;
		var view;
		var cnt = this.childCount();
		for (i = 0; i < cnt; i++) {
			view = this.getChild(i);
			if (view.isVisible()) {
				if (view.index().column() === column) {
					return view;
				}
				if (view instanceof GroupCellElement) {
					view = view.findCell(column);
					if (view) {
						return view;
					}
				}
			}
		}
		return null;
	},
	getCellBounds: function (cellView, bounds) {
		if (!bounds) {
			bounds = cellView.bounds();
		} else {
			bounds.copy(cellView.bounds());
		}
		var column = this.index().column();
		var group = cellView.index().column().group();
		var view = cellView;
		while (group && group != column) {
			view = view.parent(); 
			bounds.x += view.x();
			bounds.y += view.y();
			group = group.group();
		}
		return bounds;
	},
	$_getChild: function (p, x, y, recursive) {
		var i;
		var cell;
		var child;
		var cnt = p.childCount();
		for (i = 0; i < cnt; i++) {
			cell = p.getChild(i);
			if (recursive && cell instanceof GroupCellElement) {
				child = this.$_getChild(cell, x - cell.x(), y - cell.y(), recursive);
				if (child) {
					return child;
				}
			}
			if (cell.containsInBounds(x, y)) {
				return cell;
			}
		}
		return null;
	},
	getCellAt: function (x, y, recursive) {
		return this.$_getChild(this, x, y, recursive);
	},
	_updateCell: function (model) {
		this._super(model);
		this._doUpdateGroup(model.index().column());
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, grid.header().minHeight());	
	},
	_doRender: function (g, r) {
		if (this.childCount() <= 0) {
			g.drawRect(this._fill, null, r);
			this._drawBorders(g, r);
		}
	},
	_doLayoutContent: function (lm) {
		this._prepareCells(lm);
		this._layoutCells(lm);
	},
	_doUpdateGroup: function (group) {
	},
	_getCell: function (column) {
		return this._cells[column.$_hash];
	},
	$_setCell: function (column, view) {
		this._cells[column.$_hash] = view;
	},
	_prepareCells: function (lm) {
	},
	_layoutCells: function (lm) {
	}
}, {
	getRootOf: function (cell) {
		var group = _cast(cell.parent(), GroupCellElement);
		if (!group) {
			return null;
		}
		while (group) {
			var p = _cast(group.parent(), GroupCellElement);
			if (!p) {
				return group;
			}
			group = p;
		}
		return null;
	}
});
var /* @abstract */ ValueCellElement = defineClass("ValueCellElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
		this._numberFormatter = null;
		this._datetimeWriter = null;
		this._booleanFormatter = null;
	},
	focused: false,
	text: null,
	prefix: null,
	suffix: null,
	numberFormat: null,
	datetimeFormat: null,
	booleanFormat: null,
	setFocused: function (value) {
		if (value != this._focused) {
			this._focused = value;
			this.invalidate();
		}
	},
	setNumberFormat: function (value) {
		if (value != this._numberFormat) {
			this._numberFormat = value;
			if (value) {
				this._numberFormatter = new DecimalFormatter(value);
			} else {
				this._numberFormatter = null;
			}
			this.invalidate();
		}
	},
	setDatetimeFormat: function (value) {
		if (value != this._datetimeFormat) {
			this._datetimeFormat = value;
			if (value) {
				this._datetimeWriter = new DateTimeWriter(value);
			} else {
				this._datetimeWriter = null;
			}
			this.invalidate();
		}
	},
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			if (value) {
				this._boolFormatter = new BooleanFormatter(value);
			} else {
				this._boolFormatter = null;
			}
			this.invalidate();
		}
	},
	numberFormatter: function () {
		return this._numberFormatter;
	},
	/*
	datetimeFormatter: function () {
		return this._datetimeFormatter;
	},
	*/
	booleanFormatter: function () {
		return this._boolFormatter;
	},
	datetimeWriter: function () {
		return this._datetimeWriter || DateTimeWriter.Default;
	},
	setBorderRight: function(value) {
		var column = this._index && this._index._column;
		var drawRight = this.grid().displayOptions().isDrawLastColumnRight();
		this._super(!drawRight && column && column._isLastColumn ? null : value);
	},
	_doPrepareValue: function(model) {
		this._super(model);
		var styles = model.styles();
		this.setNumberFormat(styles.numberFormat());
		this.setDatetimeFormat(styles.datetimeFormat());
		this.setBooleanFormat(styles.booleanFormat());
		this.setPrefix(styles.prefix());
		this.setSuffix(styles.suffix());
	}
});
var SelectableCellElement = defineClass("SelectableCellElement", CellElement, {
	init: function (dom, name) {
		this._super(dom, name);
	},
	hoveredBackground: SolidBrush.WHITE,
	hoveredForeground: SolidBrush.BLACK,
	selectedBackground: SolidBrush.WHITE,
	selectedForeground: SolidBrush.BLACK,
	selected: false,
	_doPrepareElement: function (styles) {
		this._super(styles);
		this.setHoveredBackground(styles.hoveredBackground());
		this.setHoveredForeground(styles.hoveredForeground());
		this.setSelectedBackground(styles.selectedBackground());
		this.setSelectedForeground(styles.selectedForeground());
	}
},{
	drawImageUrl: function(grid, g, r, imageUrl) {
		var img = grid.getImage(imageUrl);
		if (img) {
			var w, h;
			if (img && (w = img.width) > 0 && (h = img.height) > 0) {
				var x = _floor(r.x + (r.width - w) / 2);
				var y = _floor(r.y + (r.height - h) / 2);
				g.drawImage(img, x, y, w, h);
			}
		}

	}
});
var $$_HCE_RECT = new Rectangle();
var HeaderCellElement = defineClass("HeaderCellElement", SelectableCellElement, {
	init: function(grid, dom) {
		this._super(dom, "headerCellView");
		this._sortHandle = new HeaderSortHandle(grid, dom, this);
		this._sortHandle.setVisible(false);
		this.addElement(this._sortHandle);
		this._filterHandle = new HeaderFilterHandle(grid, dom, this);
		this._filterHandle.setVisible(false);
		this.addElement(this._filterHandle);
		this._popupHandle = new HeaderPopupHandle(grid, dom, this);
		this._popupHandle.setVisible(false);
		this.addElement(this._popupHandle);
        this._checkHandle = new HeaderCheckHandle(grid, dom, this);
		this._checkHandle.setVisible(false);
		this.addElement(this._checkHandle);
        this._imageHandle = null;
        this._column = null;
        this._handleWidth = 0;
	},
    subFont: null,
    subForeground: null,
    subHoveredForeground: null,
    subSelectedForeground: null,
    subTextWrap: null,
    subTextAlignment: null,
    subLineAlignment: null,
	focused: false,
	text: null,
    subText: null,
    subTextGap: 1,
	showHandles: true,
    checkLocation: ColumnHeaderItemLocation.NONE,
    imageLocation: ColumnHeaderItemLocation.NONE,
    subLocation: SubTextLocation.LOWER,
	imageList: null,
	imageIndex: -1,
    imageUrl: null,
    itemOffset: 2,
    itemGap: 2,
	checked: false,
	showTooltip:true,
	tooltip:null,
    setSubFont: function (value) {
        var f = this._subFont;
        if (value == f) return;
        if (!value || !f || value.font != f.font || value.size != f.size || value.underline != f.underline || value.linethrough != f.linethrough) {
            this._subFont = value;
            this.invalidate();
        }
    },
    setSubTextAlignment: function (value) {
        if (value != this._subTextAlignment) {
            this._subTextAlignment = value;
            switch (value) {
                case Alignment.FAR:
                    this._subTextAlign = "right";
                    break;
                case Alignment.NEAR:
                    this._subTextAlign = "left";
                    break;
                default:
                    this._subTextAlign = "center";
                    break;
            }
            this.invalidate();
        }
    },
    setSubLineAlignment: function (value) {
        if (value != this._subLineAlignment) {
            this._subLineAlignment = value;
            switch (value) {
                case Alignment.FAR:
                    this._subLineAlign = "bottom";
                    break;
                case Alignment.NEAR:
                    this._subLineAlign = "top";
                    break;
                default:
                    this._subLineAlign = "middle";
                    break;
            }
            this.invalidate();
        }
    },
    column: function () {
        return this.index().C();
    },
    setFocused: function (value) {
        if (value != this._focused) {
            this._focused = value;
            this._doLayoutHandles();
            this.invalidate();
        }
    },
	isHovered: function () {
		return this._super() || this._filterHandle.isHovered() || this._checkHandle.isHovered() || this._popupHandle.isHovered() || (this._imageHandle && this._imageHandle.isHovered());
	},
	setHovered: function (value) {
		this._super(value);
		//if (this._sortHandle.isVisible())
		//	this._sortHandle.setHovered(value);
	}, 
	isClickable: function () {
		return true;
	},
	_doPrepareValue: function (model) {
		this._super(model);
		this._column = this.index().column();
		if (!this._column) { if ($_debug) debugger; }
		this.setText(model.text());
		var substyles = model.subStyles();
		this.setSubFont(substyles.font());
		this.setSubForeground(substyles.foreground());
        this.setSubHoveredForeground(substyles.hoveredForeground());
        this.setSubSelectedForeground(substyles.selectedForeground());
        this.setSubTextAlignment(substyles.textAlignment());
        this.setSubLineAlignment(substyles.lineAlignment());
        this.setSubTextWrap(substyles.textWrap());
        this.setSubText(model.subText());
        this.setSubTextGap(model.subTextGap());
        this.setSubLocation(model.subLocation());
		this.setItemOffset(model.itemOffset());
		this.setItemGap(model.itemGap());
		this.setImageList(model.imageList());
		this.setImageIndex(model.imageIndex());
		this.setImageUrl(model.imageUrl());
		this.setCheckLocation(model.checkLocation());
		this.setImageLocation(model.imageLocation());
		this.setChecked(model.isChecked());
		this.setShowTooltip(model.isShowTooltip());
		this.setTooltip(model.tooltip());
	},
	setBorderRight: function(value) {
		var column = this._index && this._index._column;
		var drawRight = this.grid().displayOptions().isDrawLastColumnRight();
		this._super(!drawRight && column && column._isLastColumn ? null : value);
	},
	tooltipWidth: function (grid, hintWidth, hintHeight) {
		var s = this.tooltip() || this.text();
		if (this._textWrap && (this._textWrap == TextWrapMode.NORMAL || this._textWrap == TextWrapMode.EXPLICIT)) {
			var r = new Rectangle(0, 0, 0, 0);
			grid.measureTextRect(this.font(),s, 0, 0, hintWidth, hintHeight, this._textAlign, this._lineAlign, this._textWrap,r)
			return _tempSize(r.width+this.paddingHorz(), hintHeight);
		} else {
			return _tempSize(grid.measureText(this.font(), s) + this.paddingHorz(), hintHeight);		
		}
	},	
	_doPrepareElement: function(styles) {
		this._super(styles);
	},
	_doLayoutHandles: function () {
		var grid = this.grid();
		var column = this._column;
		var r = this._getRenderRect(null);
		var x = r.right() - 4;
		var y = r.y;
		var h = r.height;
		this._handleWidth = 0;

		var columnHeaderOptions = grid.columnHeaderOptions();
		var popupWidth = columnHeaderOptions.popupMenuWidth();
		popupWidth = isNaN(popupWidth = parseInt(popupWidth)) ? POPUP_WIDTH : popupWidth;
		popupWidth += 4;

		if (this.$_canPopupHandleVisible(grid, column)) {
			this._popupHandle.setVisible(true);
			this._popupHandle.setMouseEnabled(true);
			this._popupHandle.setBounds(x - popupWidth, y, popupWidth, h);
			this._popupHandle.invalidate();
			x -= popupWidth;
			this._handleWidth += popupWidth;
		} else {
			this._popupHandle.setVisible(false);
		}

		if (grid && column instanceof DataColumn) {
			if (this.$_canFilterHandleVisible(grid, column)) {
				this._filterHandle.setVisible(true);
				this._filterHandle.setMouseEnabled(true);
				this._filterHandle.setBounds(x - 12, y, 12, h);
				this._filterHandle.invalidate();
				x -= 12;
				this._handleWidth += 12;
			} else {
				this._filterHandle.setVisible(false);
			}
			var options = grid.sortingOptions();
			if (this.$_canSortHandleVisible(options, column)) {
				var width = 11 + (options._showSortOrder ? SORT_ORDER_WIDTH : 0);
				this._sortHandle.setSortOrder(column.sortOrder());
				this._sortHandle.setSortDir(column.sortDirection());
				this._sortHandle.setVisible(true);
				this._sortHandle.setBounds(x - width, y, width, h);
				this._sortHandle.invalidate();
				this._handleWidth += width;
				x -= width;
			} else {
				this._sortHandle.setVisible(false);
			}
			this._handleWidth += this._handleWidth > 0 ? 4 : 0;
			this._checkHandle.setMouseEnabled(true);
		}
	},
    $_renderEdgedItems: function (g, tr) {
        var checkLoc = this._checkLocation;
        var imageLoc = this._imageLocation;
        var checkHandle = this._checkHandle;
        var imageHandle = this._imageHandle;
        var checked = 0;
        var sz = HEADER_CHECKBOX_SIZE;
        switch (checkLoc) {
            case ColumnHeaderItemLocation.LEFT_EDGE:
                checked = 1;
                break;
            case ColumnHeaderItemLocation.RIGHT_EDGE:
                checked = 2;
                break;
            case ColumnHeaderItemLocation.TOP_EDGE:
                checked = 3;
                break;
            case ColumnHeaderItemLocation.BOTTOM_EDGE:
                checked = 4;
                break;
        }
        if (checked) {
            switch (checked) {
                case 1: // left
                    tr.leftBy(this._itemOffset);
                    checkHandle.setBounds(tr.x, tr.y + (tr.height - sz) / 2, sz, sz);
                    tr.leftBy(sz);
                    break;
                case 2: // right
                    tr.rightBy(-this._itemOffset);
                    checkHandle.setBoundsI(tr.right() - sz, tr.y + (tr.height - sz) / 2, sz, sz);
                    tr.rightBy(-sz);
                    break;
                case 3: // top
                    tr.topBy(this._itemOffset);
                    checkHandle.setBoundsI(tr.x + (tr.width - sz) / 2, tr.y, sz, sz);
                    tr.topBy(sz);
                    break;
                case 4: // bottom
                    tr.bottomBy(-this._itemOffset);
                    checkHandle.setBoundsI(tr.x + (tr.width - sz) / 2, tr.bottom() - sz, sz, sz);
                    tr.bottomBy(-sz);
                    break;
            }
            checkHandle.setChecked(this._checked);
            checkHandle.setVisible(true);
        }
        var img, w, h;
        if (imageLoc != ColumnHeaderItemLocation.NONE) {
            if (!imageHandle) {
                imageHandle = this._imageHandle = new HeaderImageHandle(this.$_dom, this);
                this.addElement(imageHandle);
            }
            img = this._imageUrl && this.grid().getImage(this._imageUrl);
            if (img && (w = img.width) > 0 && (h = img.height) > 0) {
                var imaged = false;
                switch (imageLoc) {
                    case ColumnHeaderItemLocation.LEFT_EDGE:
                        if (checked == 1) {
                            tr.leftBy(this._itemGap);
                        } else {
                            tr.leftBy(this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.x, tr.y + (tr.height - h) / 2, w, h);
                        tr.leftBy(w);
                        imaged = true;
                        break;
                    case ColumnHeaderItemLocation.RIGHT_EDGE:
                        if (checkLoc == 2) {
                            tr.rightBy(-this._itemGap);
                        } else {
                            tr.rightBy(-this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.right() - w, tr.y + (tr.height - h) / 2, w, h);
                        tr.rightBy(-w);
                        imaged = true;
                        break;
                    case ColumnHeaderItemLocation.TOP_EDGE:
                        if (checkLoc == 3) {
                            tr.topBy(this._itemGap);
                        } else {
                            tr.topBy(this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.x + (tr.width - w) / 2, tr.y, w, h);
                        tr.topBy(h);
                        imaged = true;
                        break;
                    case ColumnHeaderItemLocation.BOTTOM_EDGE:
                        if (checkLoc == 4) {
                            tr.bottomBy(-this._itemGap);
                        } else {
                            tr.bottomBy(-this._itemOffset);
                        }
                        imageHandle.setBoundsI(tr.x + (tr.width - w) / 2, tr.bottom() - h, w, h);
                        tr.bottomBy(-h);
                        imaged = true;
                        break;
                }
                imageHandle.setImage(img);
                imageHandle.setVisible(imaged);
            } else {
                img = null;
            }
        }
        return img;
    },
    $_renderCenteredItems: function (g, tr, img) {
        var checkLoc = this._checkLocation;
        var imageLoc = this._imageLocation;
        var checkHandle = this._checkHandle;
        var imageHandle = this._imageHandle;
        var sz = HEADER_CHECKBOX_SIZE;
        var x, y, w, h, r;
        if (img) {
            w = img.width;
            h = img.height;
        } else {
            imageLoc = ColumnHeaderItemLocation.NONE
        }
        if (checkLoc == ColumnHeaderItemLocation.CENTER) {
            if (imageLoc == ColumnHeaderItemLocation.NONE || imageHandle.isVisible()) {
                tr.x += (tr.width - sz) / 2;
                tr.y += (tr.height - sz) / 2;
            } else {
                if (!imageHandle) {
                    imageHandle = this._imageHandle = new HeaderImageHandle(this.$_dom, this);
                    this.addElement(imageHandle);
                }
                r = tr.clone();
                switch (imageLoc) {
                    case ColumnHeaderItemLocation.RIGHT:
                    case ColumnHeaderItemLocation.CENTER:
                        tr.x += (tr.width - sz - w - this._itemGap) / 2;
                        tr.y += (tr.height - sz) / 2;
                        x = tr.x + sz + this._itemGap;
                        y = r.y + (r.height - h) / 2;
                        break;
                    case ColumnHeaderItemLocation.LEFT:
                        tr.x += (tr.width - sz - w - this._itemGap) / 2 + w + this._itemGap;
                        tr.y += (tr.height - sz) / 2;
                        x = tr.x - this._itemGap - w;
                        y = r.y + (r.height - h) / 2;
                        break;
                    case ColumnHeaderItemLocation.TOP:
                        tr.x += (tr.width - sz) / 2;
                        tr.y += (tr.height - sz - h - this._itemGap) / 2 + h + this._itemGap;
                        x = r.x + (r.width - w) / 2;
                        y = tr.y - this._itemGap - h;
                        break;
                    case ColumnHeaderItemLocation.BOTTOM:
                        tr.x += (tr.width - sz) / 2;
                        tr.y += (tr.height - sz - h - this._itemGap) / 2;
                        x = r.x + (r.width - w) / 2;
                        y = tr.y + sz + this._itemGap;
                        break;
                }
                imageHandle.setBoundsI(x, y, w, h);
                imageHandle.setVisible(true);
            }
            checkHandle.setChecked(this._checked);
            checkHandle.setVisible(true);
            checkHandle.setBoundsI(tr.x, tr.y, sz, sz);
            return true;
        } else if (imageLoc == ColumnHeaderItemLocation.CENTER) {
            if (checkLoc == ColumnHeaderItemLocation.NONE || (checkHandle && checkHandle.isVisible())) {
                tr.x += (tr.width - w) / 2;
                tr.y += (tr.height - h) / 2;
            } else {
                r = tr.clone();
                switch (checkLoc) {
                    case ColumnHeaderItemLocation.LEFT:
                    case ColumnHeaderItemLocation.CENTER:
                        tr.x += (tr.width - w - sz - this._itemGap) / 2 + w + this._itemGap;
                        tr.y += (tr.height - h) / 2;
                        x = tr.x - this._itemGap - sz;
                        y = r.y + (r.height - sz) / 2;
                        break;
                    case ColumnHeaderItemLocation.RIGHT:
                        tr.x += (tr.width - w - sz - this._itemGap) / 2;
                        tr.y += (tr.height - h) / 2;
                        x = tr.x + w + this._itemGap;
                        y = r.y + (r.height - sz) / 2;
                        break;
                    case ColumnHeaderItemLocation.TOP:
                        tr.x += (tr.width - w) / 2;
                        tr.y += (tr.height - h - sz - this._itemGap) / 2 + sz + this._itemGap;
                        x = r.x + (r.width - sz) / 2;
                        y = tr.y - this._itemGap - sz;
                        break;
                    case ColumnHeaderItemLocation.BOTTOM:
                        tr.x += (tr.width - w) / 2;
                        tr.y += (tr.height - h - sz - this._itemGap) / 2;
                        x = r.x + (r.width - sz) / 2;
                        y = tr.y + sz + this._itemGap;
                        break;
                    case ColumnHeaderItemLocation.NONE:
                    default:
                        tr.x += (tr.width - w) / 2;
                        tr.y += (tr.height - h) / 2;
                        break;
                }
                checkHandle.setChecked(this._checked);
                checkHandle.setVisible(true);
                checkHandle.setBoundsI(x, y, sz, sz);
            }
            imageHandle.setBoundsI(tr.x, tr.y, w, h);
            imageHandle.setVisible(true);
            return true;
        }
        return false;
    },
    $_calcTextRect: function (g, r, info, checkWidth) {
    	if (checkWidth && info.wrap == TextWrapMode.NORMAL) {
    		return g.getExplicitTextRect(info.font, info.text, r.x, r.y, r.width, r.height, info.align, info.valign);
    	}
        switch (info.wrap) {
            case TextWrapMode.EXPLICIT:
                return g.getExplicitTextRect(info.font, info.text, r.x, r.y, r.width, r.height, info.align, info.valign);
            case TextWrapMode.NORMAL:
                return g.getWrapTextRect(info.font, info.text, r.x, r.y, r.width, r.height, info.align, info.valign);
            default:
                return g.getTextRect(info.font, info.text, r.x, r.y, r.width, r.height, info.align, info.valign);
        }
    },
    $_renderText: function (g, r, info) {
        switch (info.wrap) {
            case TextWrapMode.EXPLICIT:
                g.drawTextBoundsExplicit(info.font, info.fill, info.text, r.x, r.y, r.width, r.height, info.align, info.valign);
                break;
            case TextWrapMode.NORMAL:
                g.drawTextBoundsWrap(info.font, info.fill, info.text, r.x, r.y, r.width, r.height, info.align, info.valign);
                break;
			case TextWrapMode.ELLIPSE:
				g.drawTextBoundsEllipse(info.font, info.fill, info.text, r.x, r.y ,r.width, r.height, info.align, info.valign);
				break;
            default:
                g.drawTextBounds(info.font, info.fill, info.text, r.x, r.y, r.width, r.height, info.align, info.valign);
                break;
        }
    },
    $_renderTexts: function (g, r, img, hovered, selected) {
        var checkHandle = this._checkHandle;
        var imageHandle = this._imageHandle;
        var checkLoc = (!checkHandle || !checkHandle.isVisible()) ? this._checkLocation : ColumnHeaderItemLocation.NONE;
        var imageLoc = (img && !imageHandle.isVisible()) ? this._imageLocation : ColumnHeaderItemLocation.NONE;
        var text = this._text;
        var stext = this._subText;
        var textInfo, subInfo, fill;
        if (text) {
            hovered && (fill = this._hoveredForeground);
            (!fill && selected) && (fill = this._selectedForeground);
            !fill && (fill = this._foreground);
            textInfo = {
                text: text,
                font: this._font,
                fill: fill,
                wrap: this._textWrap,
                align: this._textAlign,
                valign: this._lineAlign
            };
        }
        if (stext) {
            fill = null;
            hovered && (fill = this._subHoveredForeground);
            (!fill && selected) && (fill = this._subSelectedForeground);
            !fill && (fill = this._subForeground);
            subInfo = {
                text: stext,
                font: this._subFont,
                fill: fill,
                wrap: this._subTextWrap,
                align: this._textAlign, // this._subTextAlign,
                valign: this._lineAlign // this._subLineAlign
            };
        }
        var itemGap = this._itemGap;
        var gap = this._subTextGap;
        var wimg = img ? img.width : 0;
        var himg = img ? img.height : 0;
        var sz = HEADER_CHECKBOX_SIZE;
		var cleft = 0;
		var cright = 0;
		var ctop = 0;
		var cbottom = 0;
		var ileft = 0;
		var iright = 0;
		var itop = 0;
		var ibottom = 0;
		switch (checkLoc) {
			case ColumnHeaderItemLocation.LEFT:
				cleft = sz + itemGap;
				break;
			case ColumnHeaderItemLocation.RIGHT:
				cright = sz + itemGap;
				break;
			case ColumnHeaderItemLocation.TOP:
				ctop = sz + itemGap;
				break;
			case ColumnHeaderItemLocation.BOTTOM:
				cbottom = sz + itemGap;
				break;
		}
		switch (imageLoc) {
			case ColumnHeaderItemLocation.LEFT:
				ileft = img.width + itemGap;
				break;
			case ColumnHeaderItemLocation.RIGHT:
				iright = img.width + itemGap;
				break;
			case ColumnHeaderItemLocation.TOP:
				itop = img.height + itemGap;
				break;
			case ColumnHeaderItemLocation.BOTTOM:
				ibottom = img.height + itemGap;
				break;
		}
		var tr, sr, x, y, r2, w, h, tr2, sr2;
        var cx, cy, ix, iy;
        if (text || stext) {
            r.leftBy(cleft + ileft);
            r.rightBy(-cright - iright);
            r.topBy(ctop + itop);
            r.bottomBy(-cbottom - ibottom);
            tr = text && this.$_calcTextRect(g, r, textInfo);
            tr2 = text && this.$_calcTextRect(g, r, textInfo, true);
            if (tr && tr.width > r.width && textInfo.align == "center" && textInfo.wrap == "none") {
            	textInfo.align = "near";
            	tr = this.$_calcTextRect(g, r, textInfo);
            }
            sr = stext && this.$_calcTextRect(g, r, subInfo);
            sr2 = stext && this.$_calcTextRect(g, r, subInfo, true);
            if (sr && sr.width > r.width && subInfo.align == "center" && subInfo.wrap == "none") {
            	subInfo.align = "near";
            	sr = this.$_calcTextRect(g, r, subInfo);
            }
        }
        if (text && stext) {
			switch (this._subLocation) {
				case SubTextLocation.LOWER:
					if ((y = tr.height + gap + sr.height) <= r.height) {
                        switch (textInfo.valign) {
                            case "middle":
                                y = r.y + (r.height - y) / 2;
                                break;
                            case "bottom":
                                y = r.bottom() - sr.height - gap - tr.height;
                                break;
                            default:
                                y = r.y;
                                break;
                        }
						tr.y = y;
						this.$_renderText(g, tr, textInfo);
						sr.y = tr.bottom() + gap;
						this.$_renderText(g, sr, subInfo);
                        r2 = tr;
                        h = tr.height + sr.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
					} else if (tr.height <= r.height) {
						tr.y = r.y;
						this.$_renderText(g, tr, textInfo);
						sr.y = tr.bottom() + gap;
						this.$_renderText(g, sr, subInfo);
                        r2 = r;
                        h = r.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
                    } else {
						this.$_renderText(g, r, textInfo);
                        sr = null;
                        r2 = r;
                        h = r.height;
                        x = tr.x;
                        w = tr.width;
					}
                    (cleft || cright) && (cy = r2.y + (h - sz) / 2);
                    (ileft || iright) && (iy = r2.y + (h - himg) / 2);
                    (ctop || cbottom) && (cx = x + (w - sz) / 2);
                    (itop || ibottom) && (ix = x + (w - wimg) / 2);
					break;
				case SubTextLocation.UPPER:
					if ((y = tr.height + gap + sr.height) <= r.height) {
                        switch (textInfo.valign) {
                            case "middle":
                                y = r.y + (r.height - y) / 2;
                                break;
                            case "bottom":
                                y = r.bottom() - sr.height - gap - tr.height;
                                break;
                            default:
                                y = r.y;
                                break;
                        }
						sr.y = y;
						this.$_renderText(g, sr, subInfo);
						tr.y = sr.bottom() + gap;
						this.$_renderText(g, tr, textInfo);
                        r2 = sr;
                        h = tr.height + sr.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
                    } else if (tr.height <= r.height) {
						tr.y = r.bottom() - tr.height;
						this.$_renderText(g, tr, textInfo);
						sr.y = tr.y - gap - sr.height;
						this.$_renderText(g, sr, subInfo);
                        r2 = r;
                        h = r.height;
                        x = Math.min(tr.x, sr.x);
                        w = Math.max(tr.right(), sr.right()) - x;
					} else {
						this.$_renderText(g, tr, textInfo);
                        sr = null;
                        r2 = r;
                        h = r.height;
                        x = tr.x;
                        w = tr.width;
					}
                    (cleft || cright) && (cy = r2.y + (h - sz) / 2);
                    (ileft || iright) && (iy = r2.y + (h - himg) / 2);
                    (ctop || cbottom) && (cx = x + (w - sz) / 2);
                    (itop || ibottom) && (ix = x + (w - wimg) / 2);
					break;
				case SubTextLocation.RIGHT:
					if ((x = tr.width + gap + sr.width) <= r.width) {
						switch (textInfo.align) {
							case "center":
								x = r.x + (r.width - x) / 2;
								break;
							case "right":
								x = r.right() - sr.width - gap - tr.width;
								break;
							default:
								x = r.x;
						}
						tr.x = x;
						this.$_renderText(g, tr, textInfo);
						sr.x = tr.right() + gap;
						this.$_renderText(g, sr, subInfo);
                        r2 =  tr;
                        w = tr.width + sr.width;
						y = Math.min(tr.y, sr.y);
						h = Math.max(tr.bottom(), sr.bottom()) - y;
                    } else if (tr.width <= r.width) {
						tr.x = r.x;
						this.$_renderText(g, tr, textInfo);
						sr.x = tr.right() + gap;
						this.$_renderText(g, sr, subInfo);
                        r2 = r;
						w = r.width;
                        y = Math.min(tr.y, sr.y);
                        h = Math.max(tr.bottom(), sr.bottom()) - y;
					} else {
						this.$_renderText(g, r, textInfo);
                        r2 = r;
						w = r.width;
                        y = tr.y;
                        h = tr.height;
                        sr = null;
					}
                    (cleft || cright) && (cy = y + (h - sz) / 2);
                    (ileft || iright) && (iy = y + (h - himg) / 2);
					(ctop || cbottom) && (cx = r2.x + (w - sz) / 2);
					(itop || ibottom) && (ix = r2.x + (w - wimg) / 2);
					break;
				case SubTextLocation.LEFT:
					if ((x = tr.width + gap + sr.width) <= r.width) {
						switch (textInfo.align) {
							case "center":
								x = r.x + (r.width - x) / 2;
								break;
							case "right":
								x = r.right() - sr.width - gap - tr.width;
								break;
							default:
								x = r.x;
						}
						sr.x = x;
						this.$_renderText(g, sr, subInfo);
						tr.x = sr.right() + gap;
						this.$_renderText(g, tr, textInfo);
                        r2 =  r;
						y = Math.min(tr.y, sr.y);
						h = Math.max(tr.bottom(), sr.bottom()) - y;
						w = tr.width + sr.width;
                    } else if (tr.width <= r.width) {
						tr.x = r.right() - tr.width;
						this.$_renderText(g, tr, textInfo);
						sr.x = tr.x - gap - sr.width;
						this.$_renderText(g, sr, subInfo);
                        r2 =  r;
						w = r.width;
                        y = Math.min(tr.y, sr.y);
                        h = Math.max(tr.bottom(), sr.bottom()) - y;
					} else {
						this.$_renderText(g, tr, textInfo);
                        r2 = r;
						w = r.width;
                        y = tr.y;
                        h = tr.height;
                        sr = null;
					}
					(cleft || cright) && (cy = y + (h - sz) / 2);
					(ileft || iright) && (iy = y + (h - himg) / 2);
					(ctop || cbottom) && (cx = r2.x + (w - sz) / 2);
					(itop || ibottom) && (ix = r2.x + (w - wimg) / 2);
					break;
				default:
					this.$_renderText(g, r, textInfo);
					break;
			}
		} else if (text || stext) {
            if (text) {
                this.$_renderText(g, r, textInfo);
                r = tr;
            } else {
                this.$_renderText(g, r, subInfo);
                r = sr;
            }
            (cleft || cright) && (cy = r.y + (r.height - sz) / 2);
            (ileft || iright) && (iy = r.y + (r.height - himg) / 2);
            (ctop || cbottom) && (cx = r.x + (r.width - sz) / 2);
            (itop || ibottom) && (ix = r.x + (r.width - wimg) / 2);
		}
        if (cleft || ileft) {
            x = tr && sr ? Math.min(tr.x, sr.x) : tr ? tr.x : sr ? sr.x : r.x;
            if (cleft && ileft) {
                ix = x - itemGap - wimg;
                cx = ix - itemGap - sz;
            } else if (cleft) {
                cx = x - itemGap - sz;
            } else if (ileft) {
                ix = x - itemGap - wimg;
            }
        }
        if (cright + iright) {
            x = tr && sr ? Math.max(tr.right(), sr.right()) : tr ? tr.right() : sr ? sr.right() : r.right();
            if (cright && iright) {
                cx = x + itemGap;
                ix = cx + sz + itemGap;
            } else if (cright) {
                cx = x + itemGap;
            } else if (iright) {
                ix = x + itemGap;
            }
        }
        if (ctop || itop) {
            y = tr && sr ? Math.min(tr.y, sr.y) : tr ? tr.y : sr ? sr.y : r.y;
            if (ctop && itop) {
                iy = y - itemGap - himg;
                cy = iy - itemGap - sz;
            } else if (ctop) {
                cy = y - itemGap - sz;
            } else if (itop) {
                iy = y - itemGap - himg;
            }
        }
        if (cbottom || ibottom) {
            y = tr && sr ? Math.max(tr.bottom(), sr.bottom()) : tr ? tr.bottom() : sr ? sr.bottom() : r.bottom();
            if (cbottom && ibottom) {
                cy = y + itemGap;
                iy = cy + sz + itemGap;
            } else if (cbottom) {
                cy = y + itemGap;
            } else if (ibottom) {
                iy = y + itemGap;
            }
        }
        if (cleft + cright + ctop + cbottom > 0) {
            checkHandle.setChecked(this._checked);
            checkHandle.setVisible(true);
            checkHandle.setBoundsI(cx, cy, sz, sz);
        }
        if (ileft + iright + itop + ibottom > 0) {
            imageHandle.setImage(img);
            imageHandle.setVisible(true);
            imageHandle.setBoundsI(ix, iy, wimg, himg);
        }
        // header.text || header.subText가 없는 경우는 ??
        // 마지막에 text+subText+check+image+sort+filter를 계산해서 넓이를 구해둔다.
        this._calcWidth = _included(this._subLocation, SubTextLocation.RIGHT, SubTextLocation.LEFT) && text && stext ? tr2.width + gap + sr2.width : 0;
       	this._calcWidth = (text || stext) && Math.max(tr2 && tr2.width , sr2 && sr2.width, w || 0, this._calcWidth) || r.width;
      	this._calcWidth = Math.max(w || 0, this._calcWidth)
      						+ (checkLoc == ColumnHeaderItemLocation.LEFT || checkLoc == ColumnHeaderItemLocation.RIGHT ? (sz+itemGap) : 0)
      	                    + (imageLoc == ColumnHeaderItemLocation.LEFT || imageLoc == ColumnHeaderItemLocation.RIGHT ? (wimg+itemGap) : 0)
      	                    + this._handleWidth 
      	                    + this.paddingHorz();
    },
    _doRender: function (g, r) {
		var fill = null;
		var textFill = null;
		var itemCount = this.grid().itemCount();
		var hovered = this.isHovered();
        var selected;
		if (hovered) {
			fill = this.hoveredBackground();
		} 
		if (!fill && (selected = itemCount > 0 && (this.isFocused() || this.isSelected()))) {
			fill = this.selectedBackground();
		}
		if (!fill) {
			fill = this.background();
		}
		if (fill) {
			g.drawRect(fill, null, r);
		}
		var s = this.text();
		var s2 = this.subText();
        var checkLoc = this._checkLocation;
        var imageLoc = this._imageLocation;
		var checkHandle = this._checkHandle;
		var imageHandle = this._imageHandle;
		checkHandle && checkHandle.setVisible(false);
		imageHandle && imageHandle.setVisible(false);
		r.width -= this._handleWidth;
		this.deflatePadding2(r);
		if (r.width > 0) {
			var tr = r.clone();
            var img = this.$_renderEdgedItems(g, tr);
            if (!this.$_renderCenteredItems(g, tr, img)) {
                this.$_renderTexts(g, tr, img, hovered, selected);
            }
		}
		this.inflatePadding2(r);
		r.width += this._handleWidth;
		this._drawBorders(g, r);
		return;
        if (s || s2) {
            this.inflatePadding(r);
            switch (this._textWrap) {
                case TextWrapMode.EXPLICIT:
                    s = s.split(g.LINES_REG);
                    tr = g.getExplicitTextRect(this._font, s, r.x, r.y, r.width, r.height, this._textAlign, this._lineAlign, $$_HCE_RECT);
                    break;
                case TextWrapMode.NORMAL:
                    s = s.split(g.LINES_REG);
                    tr = g.getWrapTextRect(this._font, s, r.x, r.y, r.width, r.height, this._textAlign, this._lineAlign, $$_HCE_RECT);
                    break;
                default:
                    tr = g.getTextRect(this._font, s, r.x, r.y, r.width, r.height, this._textAlign, $$_HCE_RECT);
                    break;
            }
            this.deflatePadding(r);
        }
		if (s) {
			if (hovered) {
				textFill = this.hoveredForeground();
			}
			if (!textFill) {
				if (selected === undefined) {
					selected = itemCount > 0 && (this.isFocused() || this.isSelected());
				}
				if (selected) {
					textFill = this.selectedForeground();
				}
			}
			if (!textFill) {
				textFill = this.foreground();
			}
            r.width -= this._handleWidth;
            if (r.width > 0) {
                this.inflatePadding(r);
                if (checkLoc == ColumnHeaderItemLocation.NONE && imageLoc == ColumnHeaderItemLocation.NONE) {
                    switch (this._textWrap) {
                        case TextWrapMode.EXPLICIT:
                            g.drawTextBoundsExplicit(this._font, textFill, s, r.x, r.y, r.width, r.height, this._textAlign, this._lineAlign);
                            break;
                        case TextWrapMode.NORMAL:
                            g.drawTextBoundsWrap(this._font, textFill, s, r.x, r.y, r.width, r.height, this._textAlign, this._lineAlign);
                            break;
                        default:
                            g.drawTextBounds(this._font, textFill, s, r.x, r.y, r.width, r.height, this._textAlign);
                            break;
                    }
                    g.drawRect(null, SolidPen.RED, tr);
                } else {
                    var tr = r.clone();
                    /*var checkLayouted = */this.$_layoutCheckBox(checkLoc, imageLoc, tr, s, this._font);
                    /*var imageLayouted = */this.$_layoutImage(imageLoc, checkLoc, tr);
                    if (checkLoc != ColumnHeaderItemLocation.CENTER && imageLoc != ColumnHeaderItemLocation.CENTER) {
                        switch (this._textWrap) {
                            case TextWrapMode.EXPLICIT:
                                g.drawTextBoundsExplicit(this._font, textFill, s, tr.x, tr.y, tr.width, tr.height, this._textAlign, this._lineAlign);
                                break;
                            case TextWrapMode.NORMAL:
                                g.drawTextBoundsWrap(this._font, textFill, s, tr.x, tr.y, tr.width, tr.height, this._textAlign, this._lineAlign);
                                break;
                            default:
                                g.drawTextBounds(this._font, textFill, s, tr.x, tr.y, tr.width, tr.height, this._textAlign);
                                break;
                        }
                    }
                }
                this.deflatePadding(r);
            }
            r.width += this._handleWidth;
		} else {
        }
		this._drawBorders(g, r);
	},
	$_canPopupHandleVisible: function(grid, column) {
		return !!column._header._popupMenuName;
	},
	$_canFilterHandleVisible: function (grid, column) {
		var visible = this.isShowHandles() && column && column.hasFilters() && (!column.isFilterIconVisible || column.isFilterIconVisible());
		if (visible) {
			switch (grid.filteringOptions().handleVisibility()) {
				case HandleVisibility.HIDDEN:
					visible = false;
					break;
				case HandleVisibility.HOVERED:
					visible = this.isHovered() || grid.isFilterSelecting(column);
					break;
			}
		}
		return visible;
	},
	$_canSortHandleVisible: function (options, column) {
		var visible = this.isShowHandles() && column;
		if (visible) {
			switch (options.handleVisibility()) {
				case HandleVisibility.VISIBLE:
					visible = column.sortOrder() >= 0;
					break;
				case HandleVisibility.HOVERED:
					visible = this.isHovered() && column.sortOrder() >= 0;
					break;
				case HandleVisibility.HIDDEN:
					visible = false;
					break;
			}
		}
		return visible;
	},
	$_canCheckHandleVisible: function (options, column) {
		var visible = this.isShowHandles() && column;
		if (visible) {
			switch (options.handleVisibility()) {
				case HandleVisibility.VISIBLE:
					visible = column.sortOrder() >= 0;
					break;
				case HandleVisibility.HOVERED:
					visible = this.isHovered();
					break;
				case HandleVisibility.HIDDEN:
					visible = false;
					break;
			}
		}
		return visible;
	}
});
var HeaderGroupCellElement = defineClass("HeaderGroupCellElement", GroupCellElement, {
	init: function(dom) {
		this._super(dom, "headerGroupCellView");
	},
	focused: false,
	_prepareCells: function (lm) {
		var group = this.group();
		this.$_createCells(group);
		this._fillUnit = _int(this.height() / Math.max(1, group.headerLevel()));
		var notFixed = true;
		if (this._grid.header().heightFill() == HeaderHeightFill.FIXED) {
			var fill = {levels: 0, fixHeight: 0};
			this.$_calculateFillLevel(group, fill);
			this._fillLevels = fill.levels;
			if (!group.parent().header()._notHeightFixed && fill.fixHeight <= this.height() - this._fillLevels*3 && (fill.levels != 0 || fill.fixHeight == this.height())) {
				notFixed = false;
				if (fill.levels > 0) {
					this._fillUnit = _int((this.height() - fill.fixHeight) / fill.levels);
				}
			}
			this.$_prepareHeight(group, notFixed);
		}
		group.header()._notHeightFixed = notFixed;
	},
	_layoutCells: function (lm) {
		var view;
		var y;
		var h;
		var i;
		var column;
		var dy;
		var x;
		var w;
		var r = new Rectangle();
		var group = this.group();
		var width = this.width();
		var height = this.height();
		var cnt = group.visibleCount();
		var header = group.header();
		if (header.isVisible()) {
			view = this._cells[group.$_hash];//this._getCell(group);
			if (view) {
				r.set(0, 0, width, height);
				r.height = header.fixedHeight() > 0 && !header._notHeightFixed ? header.fixedHeight() : this._fillUnit;
				view.setRect(r);
				view.layoutContent(lm);	
			}
		}
		if (!group.isHideChildHeaders()) {
			y = r.bottom();
			if (group.isVertical()) {
				h = this._fillUnit;
				for (i = 0; i < cnt; i++) {
					column = group.getVisibleItem(i);
					var colHeader = column.header();
					view = this._cells[column.$_hash];//this._getCell(column);
					if (view) {
						dy = 0;
						if (i == cnt - 1) {
							dy = height - y;
						} else if (view instanceof HeaderGroupCellElement) {
							dy = colHeader._fillHeight > 0 && !header._notHeightFixed ? colHeader._fillHeight : h * view.group().headerLevel();
						} else {
							dy += colHeader.fixedHeight() > 0 && !header._notHeightFixed ? colHeader.fixedHeight() : h;
						}
						view.setBounds(0, y, width, dy);
						view.layoutContent(lm);
						y += dy;
						if (view instanceof HeaderGroupCellElement) {
							view._layoutCells(lm);
						}
					}
				}
			} else {
				x = 0;
				for (i = 0; i < cnt; i++) {
					column = group.getVisibleItem(i);
					view = this._cells[column.$_hash];//this._getCell(column);		
					if (view) {
						if (i == cnt - 1) {
							w = width - x;
						} else {
							w = column.displayWidth();
						}
						view.setBounds(x, y, w, height - y);
						view.layoutContent(lm);
						x += w;
						if (view instanceof HeaderGroupCellElement) {
							view._layoutCells(lm);
						}
					}
				}
			}
		}
	},
	// header.fixedHeight 값이 있는 컬럼들의 최대 level, fixed 높이의 합을 계산  
	$_calculateFillLevel: function (group, fill) {
		var header = group.header();
		if (header.isVisible()) {
			if (header.fixedHeight() > 0) {
				fill.fixHeight += header.fixedHeight();
			} else {
				fill.levels++;	
			}
		}
		if (!group._hideChildHeaders) {
			var i,
			    f,
				col,
				cols = group.visibleCount(),
				cnt = 0,
				fixHeight = 0;
			if (cols > 0) {
				if (group.isHorizontal()) {
					for (i = 0; i < cols; i++) {
						col = group.getVisibleItem(i);
						if (col instanceof ColumnGroup) {
							var colfill = {levels:0, fixHeight:0};
							this.$_calculateFillLevel(col, colfill);
							if (colfill.levels > cnt) {
								cnt = colfill.levels;
								fixHeight = colfill.fixHeight;
							} 
						} else {
							f = col.header().fixedHeight();
							if (f > 0) {
								cnt = 0;
								fixHeight = Math.max(fixHeight, f);
							}
						}
					}
					if (fixHeight == 0) {
						cnt = 1;
					}
					fill.levels += cnt;
					fill.fixHeight += fixHeight
				} else {
					for (i = 0; i < cols; i++) {
						col = group.getVisibleItem(i);
						if (col instanceof ColumnGroup) {
							var colfill = {levels:0, fixHeight:0};
							this.$_calculateFillLevel(col, colfill);
							fill.levels += colfill.levels;
							fill.fixHeight += colfill.fixHeight;
						} else { 
							header = col.header();
							f = col.header().fixedHeight();
							if (f > 0) {
								fill.fixHeight += f;
							} else {
								fill.levels ++;
							}
						}
					}
				}
			}
		}
	},
	// 각각의 group._fillHeight를 설정
	$_prepareHeight: function (group, notFixed) {
		var header,
			i,
			col,
			cols = group.visibleCount(),
			height = 0;
		if (!group._hideChildHeaders) {
			if (cols > 0) {
				if (group.isHorizontal()) {
					var fixedMax = 0;
					for (i = 0; i < cols; i++) {
						col = group.getVisibleItem(i);
						if (col instanceof ColumnGroup) {
							height = Math.max(height, this.$_prepareHeight(col,notFixed));
						} else {
							var fixedHeight = col.header().fixedHeight();
							if ((fixedHeight > 0 && !notFixed) || fixedMax > 0) {
								fixedMax = Math.max(fixedMax, fixedHeight);
								height = Math.max(height, fixedMax);
							} else {
								height = Math.max(height, this._fillUnit);
							}
								
						}
					}
				} else {
					for (i = 0; i < cols; i++) {
						col = group.getVisibleItem(i);
						if (col instanceof ColumnGroup) {
							height += this.$_prepareHeight(col,notFixed);
						} else { 
							header = col.header();
							height += header.fixedHeight() > 0 && !notFixed ? header.fixedHeight() : this._fillUnit;
						}
					}
				}
			}
		}
		header = group.header();
		if (header.isVisible()) {
			height += header.fixedHeight() > 0 && !notFixed ? header.fixedHeight() : this._fillUnit;
		}
		return header._fillHeight = height;
	},
	$_createCells: function (group) {
		this.hideAll();
		var i;
		var cnt;
		var column;
		var view;
		var model;
		var cols;
		var grid = this.grid();
		var header = grid.header();
		var colheader = group.header();
		if (colheader.isVisible()) {
			view = this._cells[group.$_hash];
			if (!view) {
				this.$_setCell(group, view = new HeaderCellElement(grid, this._dom));
				this.addElement(view);
			}
			view.setVisible(true);
			model = header.getCell(CellIndex.temp(grid, -1, group));
			view.updateCell(model);
		}
		if (!group.isHideChildHeaders()) {
			for (i = 0, cols = group.visibleCount(); i < cols; i++) {
				column = group.getVisibleItem(i);
				view = this._cells[column.$_hash];//this._getCell(column);
				if (!view) {
					if (column instanceof ColumnGroup) {
						view = new HeaderGroupCellElement(this._dom);
					} else { 
						view = new HeaderCellElement(grid, this._dom);
					}
					this.$_setCell(column, view);
					this.addElement(view);
				}
				view.setVisible(true);					
				model = header.getCell(CellIndex.temp(grid, -1, column));
				view.updateCell(model);
				if (view instanceof HeaderCellElement) {
				} else {
				}
				if (column instanceof ColumnGroup) {
					view.$_createCells(column);
				}
			}
		}
	}
});

var SummaryCellElement = defineClass("SummaryCellElement", ValueCellElement, {
	init: function (dom , name) {
		this._super(dom, name);
		this._value = NaN;
		this._error = null;
		this._errorDetail = null;
	},
	text: null,
    column: function () {
        return this.index().C();
    },
	value: function () {
		return this._value;
	},
	error: function () { 
		return this._error;
	},
	errorDetail: function () {
		return this._errorDetail;
	},
	_doPrepareValue: function(model) {
		this._super(model);
		this._value = model.value();
		var fmt;
		var s = null;
		var f = null;
		if (this._value !== UNDEFINED) {
			if (model.index().column() instanceof DataColumn && model.index().column().valueType() == ValueType.DATETIME) {
				if (this._value instanceof Date && (fmt = this.datetimeWriter())) {
					s = fmt.getText(this._value)
				} else if (this._value) {
					s = this._value;
				} else {
					s = model.displayText();
				}
			} else {
				var v = Number(this._value);
				if (!isNaN(v) && (fmt = this.numberFormatter())) {
					s = fmt.format(v);
				} else if (this._value) {
					s = this._value;
				} else {
					s = model.displayText();
				}
			}
		} else {
			s = model.displayText();
		}
		if (s != null) {
			if (f = this.prefix()) {
				s = f + s;
			}
			if (f = this.suffix()) {
				s = s + f;
			}
		}
		this.setText(s);
		this._error = model.error();
	},
	_doPrepareElement: function(styles) {
		this._super(styles);
	},
	_doLayoutHandles: function() {
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		var s = this.text();
		if (s) {
			this.inflatePadding(r);
			if (typeof s == "string") {
				g.drawTextBoundsExplicit(this._font, this._foreground, s, r.x, r.y, r.width, r.height, this._textAlign); 
			} else {
				g.drawTextRect(this._font, this._foreground, s, r, this._textAlign);			
			}
			this.deflatePadding(r);
		}
		this._drawBorders(g, r);
	},
	canHovering: function () {
		return false;
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		var s = this.text();
		var g = grid._container._defContext._graphics;
		var r;
		if (s) {
			if (typeof s == "string") {
				r = g.getExplicitTextRect(this._font, s, 0,0,hintWidth, hintHeight, this._textAlign); 
			} else {
				r = g.getTextRect(this._font, s, 0,0,hintWidth, hintHeight, this._textAlign);			
			}
		}
		if (r) {
			r.width += this.paddingLeft() + this.paddingRight();
		}
		return r;	
	}
});

var FooterCellElement = defineClass("FooterCellElement", SummaryCellElement, {
	init: function(dom) {
		this._super(dom, "footerCellView");
	}
});


var HeaderSummaryCellElement = defineClass("HeaderSummaryCellElement", SummaryCellElement, {
	init: function(dom) {
		this._super(dom, "summaryCellView");
	}
});

var SummaryGroupCellElement = defineClass("SummaryGroupCellElement", GroupCellElement, {
	init: function(dom, name) {
		this._super(dom, name);
	},
	layoutContent: function (lm, fIndex) {
		return this._doLayoutContent(lm, fIndex);
	},	
	_doLayoutContent: function (lm, fIndex) {
		this._prepareCells(lm, fIndex);
		this._layoutCells(lm, fIndex);
	},
	_prepareCells: function(lm, fIndex) {
		this.$_createCells(this.group(), fIndex);
	},
	_layoutCells: function(lm, fIndex) {
		var i;
		var dy;
		var x;
		var y;
		var h;
		var w;
		var column;
		var view;
		var group = this.group();
		var r = new Rectangle();
		var width = this.width();
		var height = this.height();
		var cnt = group.visibleCount();
		if (group.isVertical()) {
			y = r.bottom();
			h = _int(height / group.dataLevel());
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				view = this._getCell(column);
				if (view) {
					dy = 0;
					if (i == cnt - 1) {
						dy = height - y;
					} else if (view instanceof SummaryGroupCellElement) {
						dy = h * view.group().dataLevel();
					} else {
						dy += h;
					}
					view.setBounds(0, y, width, dy);
					view.layoutContent(lm, fIndex);
					y += dy;
					if (view instanceof SummaryGroupCellElement) {
						view._layoutCells(lm, fIndex);
					}
				}
			}
		} else {
			var grid = this.grid();
			var mergeManager = this.$_getMergeManager();
			var merged = mergeManager.count() > 0;
			var room;
			x = 0;
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				view = this._getCell(column);
				if (view) {
					if (i == cnt - 1) {
						w = width - x;
					} else {
						w = column.displayWidth();
					}
					view.setBounds(x, 0, w, height);
					view.layoutContent(lm, fIndex);
					x += w;
					if (view instanceof SummaryGroupCellElement) { 
						view._layoutCells(lm, fIndex);
					}							
				}
			}
			if (merged) {
				for (i =0; i < cnt ; i++) {
					column = group.getVisibleItem(i);
					room = mergeManager.findRoomBy(column);
					if (room) {
						view = this._getCell(column);
						var baseView = this._getCell(room.baseColumn());
						var startView = this._getCell(room.startColumn());
						var lastView = this._getCell(room.lastColumn());
						var r = startView.getBounds();
						var br = baseView.getBounds();
						var er = lastView.getBounds();
						br.x = r.x;
						br.width = er.right() - r.x;
						baseView.setRect(br);
					}
				}
			}
		}
	},
	canHovering: function () {
		return false;
	},
	$_createCells: function (group, fIndex) {
		this.hideAll();
		var i;
		var cnt;
		var column;
		var view;
		var model;
		var grid = this.grid();
		var summary = this.$_getSummaryModel();
		var mergeManager = this.$_getMergeManager();
		var merged = mergeManager.count() > 0;
		var room;
		for (i = 0, cnt = group.visibleCount(); i < cnt; i++) {
			column = group.getVisibleItem(i);
			room = mergeManager.findRoomBy(column);
			view = this._getCell(column);
			if (!view) {
				if (column instanceof ColumnGroup) {
					view = this.$_createGroupCellElement();
				} else { 
					view = this.$_createCellElement();
				}
				this.$_setCell(column, view);
				this.addElement(view);
			}
			view.setVisible(!merged || !room || room.baseColumn() == column);					
			model = summary.getCell(CellIndex.temp(grid, -1, column), fIndex);
			view.updateCell(model);
			if (column instanceof ColumnGroup) {
				view.$_createCells(column);
			}
		}
	}
})

var FooterGroupCellElement = defineClass("FooterGroupCellElement", SummaryGroupCellElement, {
	init: function(dom) {
		this._super(dom, "fooerGroupCellView");
	},
	$_getSummaryModel: function() {
		return this.grid().footer();
	},
	$_getMergeManager: function () {
		return this.grid()._footerMergeManager;
	},
	$_createCellElement: function () {
		return new FooterCellElement(this._dom);		
	},
	$_createGroupCellElement: function () {
		return new FooterGroupCellElement(this._dom);
	}
});

var HeaderSummaryGroupCellElement = defineClass("HeaderSummaryGroupCellElement", SummaryGroupCellElement, {
	init: function(dom) {
		this._super(dom, "headerSummaryGroupCellView");
	},
	$_getSummaryModel: function() {
		return this.grid().header().summary();
	},
	$_getMergeManager: function () {
		return this.grid().headerSummaryMergeManager();
	},
	$_createCellElement: function () {
		return new HeaderSummaryCellElement(this._dom);		
	},
	$_createGroupCellElement: function () {
		return new HeaderSummaryGroupCellElement(this._dom);
	}
});

// rowGroup에 해당.
var GroupFooterCellElement = defineClass("GroupFooterCellElement", ValueCellElement, {
	init: function(dom) {
		this._super(dom, "groupFooterCellElement");
		this._value = UNDEFINED;
		this._error = null;
	},
	text: null,
	textVisible: true,
	value: function () {
		return this._value;
	},
	error: function () { 
		return this._error;
	},
	_doPrepareValue: function(model) {
		this._super(model);
		this._value = model.value();
		var fmt;
		var s = null;
		var f = null;
		if (this._value !== UNDEFINED) {
			if (model.index().column() instanceof DataColumn && model.index().column().valueType() == ValueType.DATETIME) {
				if (this._value instanceof Date && (fmt = this.datetimeWriter())) {
					s = fmt.getText(this._value)
				} else {
					s = model.displayText();
				}
			} else {
				var v = Number(this._value);
				if (!isNaN(v) && (fmt = this.numberFormatter())) {
					s = fmt.format(v);
				} else if (this._value) {
					s = this._value;
				} else {
					s = model.displayText();
				}
			}
		} else {
			s = model.displayText();
		}
		if (s != null) {
			if (f = this.prefix()) {
				s = f + s;
			} 
			if (f = this.suffix()) {
				s = s + f;
			}
		}
		this.setText(s);
		this._error = model.error();
	},
	_doPrepareElement: function(styles) {
		this._super(styles);
	},
	_doLayoutHandles: function() {
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		var s = this.text();
		if (s && this._textVisible) {
			this.inflatePadding(r);
			if (typeof s == "string") {
				g.drawTextBoundsExplicit(this._font, this._foreground, s, r.x, r.y, r.width, r.height, this._textAlign); 
			} else {
				g.drawTextRect(this._font, this._foreground, s, r, this._textAlign);			
			}
			this.deflatePadding(r);
		}
		this._drawBorders(g, r);
	},
	clip: function (g) {
		this.getClientRect(this._drawRect);
		var dr = this._drawRect.clone();
		var grid = this.grid();
		var lm = grid.layoutManager();
		var lfr = lm._nonfixedBounds;
		var cr = this.boundsBy();
		if (cr.x < lfr.x && !this._index._column.isFixed()) {
			var sx = lfr.x - cr.x + grid._x;
			// sx = this._shiftLeft ? sx - this._shiftLeft : sx;
			dr.leftBy(sx);
		};
		this._shiftLeft ? dr.leftBy(-this._shiftLeft) : null;
		if (cr.right() > lm._rfixedBounds.x && !this._index._column.isRightFixed()) {
			dr.rightBy(lm._rfixedBounds.x - cr.right() + 1);
		}
		g.clipRect(dr);
	}
});
var GroupFooterGroupCellElement = defineClass("GroupFooterGroupCellElement", GroupCellElement, {
	init: function (dom) {
		this._super(dom, "groupFooterGroupCellView");
	},
	_prepareCells: function (lm) {
		this.$_createCells(this.group());
	},
	_layoutCells: function (lm) {
		var i;
		var dy;
		var x;
		var y;
		var h;
		var w;
		var column;
		var view;
		var group = this.group();
		var r = new Rectangle();
		var width = this.width();
		var height = this.height();
		var cnt = group.visibleCount();
		if (group.isVertical()) {
			y = r.bottom();
			h = _int(height / group.dataLevel());
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				view = this._getCell(column);
				if (view) {
					dy = 0;
					if (i == cnt - 1) {
						dy = height - y;
					} else if (view instanceof GroupFooterGroupCellElement) {
						dy = h * view.group().dataLevel();
					} else {
						dy += h;
					}
					view.setBounds(0, y, width, dy);
					y += dy;
				}
				if (view instanceof GroupFooterGroupCellElement) {
					view._layoutCells(lm);
				}
			}
		} else {
			x = 0;
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				view = this._getCell(column);
				if (view) {
					if (i == cnt - 1) {
						w = width - x;
					} else {
						w = column.displayWidth();
					}
					view.setBounds(x, 0, w, height);
					x += w;
				}
				if (view instanceof GroupFooterGroupCellElement) {
					view._layoutCells(lm);
				}
			}
		}
	},
	$_createCells: function (group) {
		this.hideAll();
		var i;
		var cnt;
		var column;
		var view;
		var model;
		var grid = this.grid();
		var rowGroup = grid.rowGroup();
		for (i = 0, cnt = group.visibleCount(); i < cnt; i++) {
			column = group.getVisibleItem(i);
			view = this._getCell(column);
			if (!view) {
				if (column instanceof ValueColumn) {
					view = new GroupFooterCellElement(this._dom);
				} else  if (column instanceof ColumnGroup) {
					view = new GroupFooterGroupCellElement(this._dom);
				}
				this.$_setCell(column, view);
				if (view) {
					this.addElement(view);
				}
			}
			if (view) {
				view.setVisible(true);
				model = rowGroup.getFooterCell(CellIndex.temp(grid, this.index().I(), column));
				view.updateCell(model);
				if (column instanceof DataColumn) {
				} else if (column instanceof ColumnGroup) {
				}
			}
			if (column instanceof ColumnGroup) {
				view.$_createCells(column);
			}
		}
	}
});
var SectionHeadFootElement = defineClass("SectionHeadFootElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
	},
	text: null,
	image: null,
	_renderCell: function (g, r) {
		if (this._image) {
        	var w = Math.min(this._image.width, r.width);
        	var h = Math.min(this._image.height, r.height)
			g.drawImage(this._image, (r.width-w)/2, (r.height-h)/2, w, h);
		} else if (this._text) {
			stroke = this.foreground();
			if (stroke) {
				this.inflatePadding(r);
				g.drawTextBoundsExplicit(this._font, stroke, this._text, r.x, r.y, r.width, r.height, this._textAlign, this._lineAlign);
				this.deflatePadding(r);
			}
		}		
	}
});

var IndicatorHeadElement = defineClass("IndicatorHeadElement", SectionHeadFootElement, {
	init: function(dom) {
		this._super(dom, "indicatorHeadView");
	},
	_doUpdateContent: function(model) {
		this._super(model);
		var grid = this.grid();
		var indicator = grid.indicator();
		this._text = indicator.headText();
		this._image = indicator.headImage();
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		this._renderCell(g, r);
		this._drawBorders(g, r);
	}
});
var IndicatorFootElement = defineClass("IndicatorFootElement", SectionHeadFootElement, {
	init: function(dom, name) {
		this._super(dom, name || "indicatorFootView");
	},
	renderer: null,
	_doUpdateContent: function(model) {
		this._super(model);
		var grid = this.grid();
		var indicator = grid.indicator();
		this._text = indicator.footText();
		this._image = indicator.footImage();
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
	},
	_doRender: function(g, r) {
		if (this._renderer && !this._text && !this._image) {
			this._renderer.render(this, g, r);
		} else {
			var fill = this.background();
			if (fill) {
				g.drawRect(fill, null, r);
			}
			this._renderCell(g, r);
		}
		this._drawBorders(g, r);
	}
});
var FooterHeadRenderer = defineClass("FooterHeadRenderer", null, {
	init: function () {
		this._super();
	},
	render: function (view, g, r) {
		var fill = view.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		this.$_drawSigma(view, g, r);
	},
	$_drawSigma: function (view, g, r) {
		var fill = view.figureBackground();
		if (fill) {
			var w = 11;
			var h = 11;
			var x = r.x + (r.width - w) / 2;
			var y = r.y + (r.height - h) / 2;
			var points = [
				x + 2, y + 1,
				x + 2, y + 2.5,
				x + 4, y + 5,
				x + 1, y + 8.5,
				x + 1, y + 10,
				x + 9, y + 10,
				x + 9, y + 6.5,
				x + 8, y + 8.5,
				x + 2, y + 8.5,
				x + 5, y + 5,
				x + 3, y + 2.5,
				x + 9, y + 2.5,
				x + 10, y + 4.5,
				x + 10, y + 1
			];
			g.drawPolygonArray(fill, null, points);
		}
	}
});

var IndicatorSummaryElement = defineClass("IndicatorSummaryElement", IndicatorFootElement, {
    init: function (dom) {
        this._super(dom, "indicatorSummaryView");
    },
   	_doUpdateContent: function(model) {
   		this._super(model);
		var grid = this.grid();
		var indicator = grid.indicator();
		this._text = indicator.summaryText() || indicator.footText();
		this._image =indicator.summaryImage() || indicator.footImage();
   	}

});
var StateBarHeadElement = defineClass("StateBarHeadElement", SectionHeadFootElement, {
	init: function(dom) {
		this._super(dom, "stateBarHeadView");
	},
	_doUpdateContent: function(model) {
		this._super(model);
		var grid = this.grid();
		var stateBar = grid.stateBar();
		this._text = stateBar.headText();
		this._image = stateBar.headImage();
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		this._renderCell(g, r);
		this._drawBorders(g, r);
	}
});
var StateBarFootElement = defineClass("StateBarFootElement", SectionHeadFootElement, {
	init: function(dom, name) {
		this._super(dom, name || "stateBarFootView");
	},
	_doUpdateContent: function(model) {
		this._super(model);
		var grid = this.grid();
		var stateBar = grid.stateBar();
		this._text = stateBar.footText();
		this._image = stateBar.footImage();
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		this._renderCell(g, r);
		this._drawBorders(g, r);
	}
});
var StateBarSummaryElement = defineClass("StateBarSummaryElement", StateBarFootElement, {
    init: function (dom) {
        this._super(dom, "stateBarSummaryView");
    },
   	_doUpdateContent: function(model) {
   		this._super(model);
		var grid = this.grid();
		var stateBar = grid.stateBar();
		this._text = stateBar.summaryText() || stateBar.footText();
		this._image =stateBar.summaryImage() || stateBar.footImage();
   	}
});
var CheckBarHeadElement = defineClass("CheckBarHeadElement", SectionHeadFootElement, {
	init: function(dom) {
		this._super(dom, "checkBarHeadView");
	},
	showCheck: true,
	checked: false,
	_doUpdateContent: function(model) {
		this._super(model);
		var grid = this.grid();
		var checkBar = grid.checkBar();
		this.setShowCheck(checkBar.isShowAll() && !checkBar.isExclusive() && grid.itemCount() > 0);
		this._text = checkBar.headText();
		this._image = checkBar.headImage();
		if (grid.itemCount() <= 0) {
			this.setChecked(false);
		}
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		if (this.isShowCheck()) {
			this.$_drawCheck(g, r);
		} else {
			this._renderCell(g, r);
		}
		this._drawBorders(g, r);
	},
	$_drawCheck: function (g, r) {
		r = this._getRenderRect(r);
		var grid = this.grid();
		var checkBar = grid.checkBar();
		var w, h;
		var img = this.isChecked() ? checkBar.headCheckImageUrl() : checkBar.headUnCheckImageUrl();
		img && (img = grid.getImage(img));
		if (img && (w = img.width) > 0 && (h = img.height) > 0) {
			var x = _floor(r.x + (r.width - w) / 2);
			var y = _floor(r.y + (r.height - h) / 2);
			g.drawImage(img, x, y, w, h);
		} else {
			var fill = this.isChecked() ? this.figureBackground() : this.figureInactiveBackground();
			if (fill) {
				var fs = this.figureSize();
				var sz = fs ? fs.getDimension(r.height) : 12;
				$$_drawCheckMark(g, fill, r, sz);
			}
		}
	}
});
var CheckBarFootElement = defineClass("CheckBarFootElement", SectionHeadFootElement, {
	init: function(dom, name) {
		this._super(dom, name || "checkBarFootView");
	},
	_doUpdateContent: function(model) {
		this._super(model);
		var grid = this.grid();
		var checkBar = grid.checkBar();
		this._text = checkBar.footText();
		this._image = checkBar.footImage();
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		this._renderCell(g, r);
		this._drawBorders(g, r);
	}
});
var CheckBarSummaryElement = defineClass("CheckBarSummaryElement", CheckBarFootElement, {
    init: function (dom) {
        this._super(dom, "checkBarSummaryView");
    },
   	_doUpdateContent: function(model) {
   		this._super(model);
		var grid = this.grid();
		var checkBar = grid.checkBar();
		this._text = checkBar.summaryText() || checkBar.footText();
		this._image =checkBar.summaryImage() || checkBar.footImage();
   	}
});
var IndicatorCellElement = defineClass("IndicatorCellElement", SelectableCellElement, {
	init: function(dom) {
		this._super(dom, "indicatorCellView");
	},
	text: null,
	itemState: ItemState.NORMAL,
	setItemState: function (value) {
		if (value != this._itemState) {
			this._itemState = value;
			this.invalidate();
		}
	},
	_doPrepareElement: function(styles) {
		this._super(styles);
	},
	_doUpdateContent: function(model) {
		this._super(model);
		this.setItemState(model.itemState());
		this.setText(model.displayText());
	},
	_doRender: function(g, r) {
		var itemState = this.itemState();
		var fill = null;
		var options = this.grid().indicator();
		var mark = options.mark();
		var stateImages = options.stateImages();
		if (this.isHovered()) {
			fill = this.hoveredBackground();
		}
		if (!fill && (this.isSelected() || itemState != ItemState.NORMAL)) {
			fill = this.selectedBackground();
		}
		if (!fill) {
			fill = this.background();
		}
		if (fill) {
			g.drawRect(fill, null, r);
		}
		fill = this.figureBackground();
		if (mark === StateMark.IMAGE && stateImages && itemState != ItemState.NORMAL && stateImages[itemState]) {
			SelectableCellElement.drawImageUrl(this.grid(), g, r, stateImages[itemState])
		} else if ((!mark || mark === StateMark.DEFAULT) && fill && itemState != ItemState.NORMAL) {
			if (itemState == ItemState.INSERTING || itemState == ItemState.APPENDING) {
				this.$_drawInsert(g, fill, r);
			} else if (itemState == ItemState.UPDATING) {
				this.$_drawEdit(g, fill, r);
			}
			 else if (itemState == ItemState.FOCUSED) {
				this.$_drawArrow(g, fill, r);
			}
		} else if (mark != StateMark.NONE) {
			var s = this.text();
			if (s) {
				fill = null;
				if (this.isSelected()) {
					fill = this.selectedForeground();
				}
				if (!fill && this.isHovered()) {
					fill = this.hoveredForeground();
				}
				if (!fill) {
					fill = this.foreground();
				}
				if (fill) {
					this.inflatePadding(r);
					g.drawTextRect(this._font, fill, s, r, this._textAlign);
					this.deflatePadding(r);
				}
			}
		}
		this._drawBorders(g, r);
	},
	_hoveredChanged: function () {
		this.invalidate();
	},
	$_drawArrow: function (g, fill, r) {
		var W = 11;
		var H = 11;
		var x = r.x + (r.width - W) / 2;
		var y = r.y + (r.height - H) / 2;
		g.drawPolygonArray(fill, null, [
			x + 4, y + 2,
			x + 7.5, y + 5.5,
			x + 4, y + 9,
			x + 5, y + 10,
			x + 9.5, y + 5.5,
			x + 5, y + 1
		]);
	},
	$_drawEdit: function (g, fill, r) {
		var W = 11;
		var H = 11;
		var x = r.x + (r.width - W) / 2;
		var y = r.y + (r.height - H) / 2;
		g.drawPolygonArray(fill, null, [
			x + 9, y + 0,
			x + 3, y + 6,
			x + 3, y + 8,
			x + 5, y + 8,
			x + 11, y + 2
		]);
		g.drawPolygonArray(fill, null, [
			x + 0, y + 9,
			x + 0, y + 11,
			x + 11, y + 11,
			x + 11, y + 9,
		]);
	},
	$_drawInsert: function (g, fill, r) {
		var W = 11;
		var H = 11;
		var x = r.x + (r.width - W) / 2;
		var y = r.y + (r.height - H) / 2;
		g.drawPolygonArray(fill, null, [
			x + 0, y + 0,
			x + 0, y + 11,
			x + 5, y + 11,
			x + 5, y + 9,
			x + 2, y + 9,
			x + 2, y + 2,
			x + 9, y + 2,
			x + 9, y + 5,
			x + 11, y + 5,
			x + 11, y + 0
		]);
		g.drawPolygonArray(fill, null, [
			x + 7, y + 5,
			x + 7, y + 7,
			x + 5, y + 7,
			x + 5, y + 9,
			x + 7, y + 9,
			x + 7, y + 11,
			x + 9, y + 11,
			x + 9, y + 9,
			x + 11, y + 9,
			x + 11, y + 7,
			x + 9, y + 7,
			x + 9, y + 5,
		]);
	}});
var $_SBC_CW = 14;
var $_SBC_CH = 10;
var StateBarCellElement = defineClass("StateBarCellElement", SelectableCellElement, {
	init: function(dom) {
		this._super(dom, "stateBarCellView");
	},
	rowState: RowState.NONE,
	mark: StateMark.DEFAULT,
	stateTexts: null,
	stateImages: null,
	_doPrepareElement: function(styles) {
		this._super(styles);
	},
	_doUpdateContent: function(model) {
		this._super(model);
		this.setRowState(model.index().item().rowState());
		var grid = this.grid();
		var stateBar = grid.stateBar();
		this._mark = stateBar.mark();
		var texts = null;
		if (texts = stateBar.stateTexts()) {
			this.setStateTexts(texts);
		}
	},
	_doRender: function(g, r) {
		var rowState = this.rowState();
		var fill = null;
		var font = null;
		var grid = this.grid();
		var st = grid && grid._stateBar && grid._stateBar._stateStyles[rowState];
		if (this.isHovered()) {
			fill = this.hoveredBackground();
		}
		if (!fill) {
			fill = st && st.background() || this.background();
		}
		if (fill) {
			g.drawRect(fill, null, r);
		}
		if (rowState != RowState.NONE) {
			if (this._mark == StateMark.NONE) {
			}
			else if (this._mark == StateMark.TEXT) {
				var text = this._stateTexts[rowState];
				font = st && st.font() || this.font();
				fill = this.isHovered() ? this.hoveredForeground() : null;
				if (!fill)
					fill = st && st.foreground() || this.foreground();
				if (fill) {
					this.inflatePadding(r);
					g.drawTextRect(font, fill, text, r, this._textAlign);
					this.deflatePadding(r);
				}
			} else {
				var stateImages = this.grid().stateBar().stateImages();
				if (this._mark === StateMark.IMAGE && stateImages[rowState]) {
					SelectableCellElement.drawImageUrl(this.grid(), g, r, stateImages[rowState]);
				} else {
					fill = st && st.figureBackground() || this.figureBackground();
					if (fill) {
						var rc = this._getRenderRect(r);
						var figureSize = this.figureSize();
						var w = figureSize ? figureSize.getDimension(rc.width) : $_SBC_CW;
						var h = figureSize ? figureSize.getDimension(rc.width) : $_SBC_CH;
						var x = (rc.width - w) / 2;
						var y = (rc.height - h) / 2;
						rc.set(_int(x), _int(y), w, h);
						switch(rowState) {
						case RowState.CREATED:
							this.$_drawCreated(g, fill, rc);
							break;
						case RowState.DELETED:
							this.$_drawDeleted(g, fill, rc);
							break;
						case RowState.UPDATED:
							this.$_drawUpdated(g, fill, rc);
							break;
						case RowState.CREATE_AND_DELETED:
							this.$_drawCreateAndDeleted(g, fill, rc);
							break;
						}
					}
				}
			}
		};
		this._drawBorders(g, r);
	},
	$_drawCreated: function (g, fill, r) {
		var x = r.x;
		var y = r.y;
		var w = r.width;
		var h = r.height;
		var pts = [
			x + 6 * w / $_SBC_CW, y + 0 * h / $_SBC_CH,
			x + 6 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 4 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 4 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 6 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 6 * w / $_SBC_CW, y + 6 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 6 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 0 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 1 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 1 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 13 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 13 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
	},
	$_drawUpdated: function (g, fill, r) {
		var x = r.x;
		var y = r.y;
		var w = r.width;
		var h = r.height;
		var pts = [
			x + 2 * w / $_SBC_CW, y + 1 * h / $_SBC_CH,
			x + 2 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 3 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 3 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 9 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 9 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 7 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 7 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 6 * h / $_SBC_CH,
			x + 9 * w / $_SBC_CW, y + 6 * h / $_SBC_CH,
			x + 9 * w / $_SBC_CW, y + 7 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 7 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 6 * h / $_SBC_CH,
			x + 11 * w / $_SBC_CW, y + 6 * h / $_SBC_CH,
			x + 11 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 12 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 12 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 1 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 1 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 1 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 13 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 13 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
	},
	$_drawDeleted: function (g, fill, r) {
		var x = r.x;
		var y = r.y;
		var w = r.width;
		var h = r.height;
		var pts = [
			x + 4 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 4 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 10 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 0 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 0 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 2 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 2 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 3 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 3 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 5 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 5 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 6 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 6 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 9 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 9 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 11 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 11 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 12 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 12 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 14 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 14 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
	},
	$_drawCreateAndDeleted: function (g, fill, r) {
		var x = r.x;
		var y = r.y;
		var w = r.width;
		var h = r.height;
		var pts = [
			x + 3 * w / $_SBC_CW, y + 0 * h / $_SBC_CH,
			x + 3 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 1 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 1 * w / $_SBC_CW, y + 3 * h / $_SBC_CH,
			x + 3 * w / $_SBC_CW, y + 3 * h / $_SBC_CH,
			x + 3 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 4 * w / $_SBC_CW, y + 5 * h / $_SBC_CH,
			x + 4 * w / $_SBC_CW, y + 3 * h / $_SBC_CH,
			x + 6 * w / $_SBC_CW, y + 3 * h / $_SBC_CH,
			x + 6 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 4 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 4 * w / $_SBC_CW, y + 0 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 7 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
			x + 7 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 13 * w / $_SBC_CW, y + 4 * h / $_SBC_CH,
			x + 13 * w / $_SBC_CW, y + 2 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 0 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 0 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 2 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 2 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 3 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 3 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 5 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 5 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 6 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 6 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 8 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 9 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 9 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 11 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 11 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
		pts = [
			x + 12 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
			x + 12 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 14 * w / $_SBC_CW, y + 10 * h / $_SBC_CH,
			x + 14 * w / $_SBC_CW, y + 9 * h / $_SBC_CH,
		];
		g.drawPolygonArray(fill, null, pts);
	}
});
var CHECK_CELL_BORDER = new SolidPen("rgba(170, 170, 170, 0.7)");
var CHECK_CELL_FOCUS_BORDER = new SolidPen(0xff000000, 2, [1,1]);
var CHECK_CELL_GRAY_FILL = new SolidBrush(0xffeeeeee);
var CHECK_CELL_GRAY_BORDER = new SolidPen("rgba(170, 170, 170, 0.35)");
var CheckBarCellElement = defineClass("CheckBarCellElement", SelectableCellElement, {
	init: function(dom) {
		this._super(dom, "checkBarCellView");
	},
	markVisible: true,
	exclusive: false,
	checked: false,
	checkable: true,
	drawCheckBox: true,
	radioImageUrl: null,
	_doPrepareElement: function(styles) {
		this._super(styles);
	},
	_doUpdateContent: function(model) {
		this._super(model);
		var item = model.index().item();
		this.setCheckable(item.isCheckable());
		this.setChecked(item.isChecked());
	},
	_doRender: function(g, r) {
		var fill = null;
		if (this.isHovered()) {
			fill = this.hoveredBackground();
		}
		if (!fill) {
			fill = this.background();
		}
		if (fill) {
			g.drawRect(fill, null, r);
		}
		if (this._markVisible) {
			this._exclusive ? this.$_drawRadio(g, r) : this.$_drawCheck(g, r);
		}
		this._drawBorders(g, r);
	},
	$_drawCheck: function (g, r) {
		r = this._getRenderRect(r);
		var cf;
		var fill;
		var	checkSize = this.figureSize() ? this.figureSize().getDimension(r.height) : 12;
		var	sz = _floor(checkSize - 2);
		var	x = _floor(r.x + (r.width - sz) / 2);
		var	y = _floor(r.y + (r.height - sz) / 2);
		var line = this.line();
		var grayFill = this.figureInactiveBackground();
		var img = this.grid().checkBar().getCheckImage(this.isChecked(), this.isCheckable());
		if (this.isCheckable()) {
			if ((cf = this.grid()._focusedCheckIndex) && (cf.itemIndex() == this._index.itemIndex())) {
				g.drawBounds(null, CHECK_CELL_FOCUS_BORDER, x, y, sz, sz);
			} else {
				this.isDrawCheckBox() && g.drawBoundsI(null, line || CHECK_CELL_BORDER, x, y, sz, sz);
			}
		} else {
			(this.isDrawCheckBox() || !img) && g.drawBoundsI(grayFill || CHECK_CELL_GRAY_FILL, line || CHECK_CELL_GRAY_BORDER, x, y, sz, sz);
		}
		if (img) {
			var w, h;
			if (img && (w = img.width) > 0 && (h = img.height) > 0) {
				var x = _floor(r.x + (r.width - w) / 2);
				var y = _floor(r.y + (r.height - h) / 2);
				g.drawImage(img, x, y, w, h);
			}
		} else if (this.isChecked()) {
			fill = this.figureBackground();
			$$_drawCheckMark(g, fill, r, checkSize);
		}
	},
	$_drawRadio: function (g, r) {
		r = this._getRenderRect(r);
		var cf;
		var fill,
			checkSize = this.figureSize() ? this.figureSize().getDimension(r.height) : 12,
			rd = (checkSize - 2) / 2,
			cx = _floor(r.x + r.width  / 2),
			cy = _floor(r.y + r.height / 2);
		var line = this.line();
		var grayFill = this.figureInactiveBackground();
		if (this.isCheckable()) {
			if ((cf = this.grid()._focusedCheckIndex) && (cf.itemIndex() == this._index.itemIndex())) {
				g.drawCircle(null, CHECK_CELL_FOCUS_BORDER, cx, cy, rd);
			} else {
				g.drawCircle(null, line || CHECK_CELL_BORDER, cx, cy, rd);
			}
		} else {
			g.drawCircle(CHECK_CELL_GRAY_FILL, line || CHECK_CELL_GRAY_BORDER, cx, cy, rd);
		}
		if (this.isChecked()) {
			if (this._radioImageUrl) {
				var img = this.grid().getImage(this._radioImageUrl);
				var w, h;
				if (img && (w = img.width) > 0 && (h = img.height) > 0) {
					var x = _floor(r.x + (r.width - w) / 2);
					var y = _floor(r.y + (r.height - h) / 2);
					g.drawImage(img, x, y, w, h);
				}
			} else {
				rd -= 2;
				fill = this.figureBackground();
				g.drawCircle(fill, null, cx, cy, rd);
			}
		}
	}
});
var DataCellElement = defineClass("DataCellElement", ValueCellElement, {
	init: function(dom, name) {
		this._super(dom, name || "dataCellView");
		this._dataColumn = null;
        this._cellStyles = null;
		this._error = null;
		this._errorLevel = ValidationLevel.IGNORE;
		this._leftButtonsWidth = 0;
		this._buttonWidth = 0;
		this._imageButtonWidth = 0;
		this._editWidth = 0;
		this._errorWidth = 0;
		this._buttonHovered = false;
		this._buttonPressed = false;
		this._buttonIndex = undefined;
		this._editButtonHovered = false;
		this._editButtonPressed = false;
		this._expandHandle = null;
	},
	contentFit: ContentFit.NONE,
	iconIndex: 0,
	iconLocation: IconLocation.NONE,
	iconAlignment: Alignment.NEAR,
	iconOffset: 0,
	iconPadding: 0,
    writable: true,
	renderer: null,
	text: null,
	value: UNDEFINED,
	blankState: BlankState.NONE,
	button: CellButton.NONE,
	buttonVisibility: ButtonVisibility.DEFAULT,
    editButtonVisibility: ButtonVisibility.DEFAULT,
    expanderVisible: false,
	innerIndex: -1,
	setInnerIndex: function (value) {
		if (value != this._innerIndex) {
			this._innerIndex = value;
			this.$_resetButtonVisible();
			this.invalidate();
		}
	},
	mergeRoom: function () {
		return null;
	},
	expanderVisible_: function () {
		return this._expandHandle != null;
	},
	setExpanderVisible: function (value) {
		if (value != this.isExpanderVisible()) {
			if (this._expandHandle) {
				if (this.contains(this._expandHandle)) {
					this.removeChild(this._expandHandle);
				}
				this._expandHandle = null;
			} else {
				this._expandHandle = new DataCellExpandHandle(this._dom, this);
			}
			this.invalidate();
		}
	},
	group: function () {
		var room = this.mergeRoom();
		return room ? room.group() : this.index().item().parent();
	},
	layoutTreeContent: function (lm) {
		this._doLayoutHandles();
	},
	// clickable Renderer를 가지는 셀을 클릭했을때 셀영역인가를 체크.
	ptInCell: function (x, y) {
		return (x > this._leftButtonsWidth) && (x < this.width() - this._imageButtonWidth - this._buttonWidth - this._editWidth - this._errorWidth);
	},
	// 순서가 중요..!!
	ptInButton: function (x, y) {  // column.button이 popup, action, image인경우.
		var w = this._buttonWidth;
		var bx = this.width() - w - this._imageButtonWidth;
		if (w > 0 && x >= bx && x < this.width() - this._imageButtonWidth && y >= 0 && y <= this.height()) {
			return this.grid().delegate().getCellButtonRenderer(this.index()).hitTest(w, this.height(), x - bx, y);
		}
		return false;
	},
	getPtInButtonIndex: function (x, y) {
		var w = this._buttonWidth;
		var bx = this.width() - w - this._imageButtonWidth;
		return this.grid().delegate().getCellButtonRenderer(this.index()).getButtonIndex(w, this.height(), x - bx, y);
	},
	// column.editor 가 dropdown, datecell등 버튼을 가지면.
	ptInEditButton: function (x, y) {
		var w = this._editWidth;
		var bx = this.width() - w - this._buttonWidth - (this._isLeftImageButton ? 0 : this._imageButtonWidth);
		if (w > 0 && x >= bx && x < (bx+w) && y >= 0 && y <= this.height()) {
			return this.grid().delegate().getCellEditButtonRenderer(this.index()).hitTest(w, this.height(), x - bx, y);
		}
		return false;
	},
	// renderer가 버튼을 가지면. 
    ptInDataButton: function (x, y) {
        var renderer = this._renderer;
        if (renderer && renderer.isButton()) {
            return renderer.ptInButton(this, x, y);
        }
        return false;
    },
    getPtInDataButtonIndex: function(x, y) {
		var renderer = this._renderer;
		if (renderer && renderer.isButton()) {
			return renderer.ptInButtonIndex(this, x, y);
		}
    },
	setButtonState: function (hovered, pressed, buttonIndex) {
		if (this._buttonHovered != hovered || this._buttonPressed != pressed || buttonIndex != this._buttonIndex) {
			this._buttonHovered = (this._buttonPressed && !pressed && this._buttonHovered) ? true : hovered;
			this._buttonPressed = pressed;
			this._buttonIndex = buttonIndex;
			this.invalidate();
		}
	},
	setEditButtonState: function (hovered, pressed) {
		if (this._editButtonHovered != hovered || this._editButtonPressed != pressed) {
			this._editButtonHovered = hovered;
			this._editButtonPressed = pressed;
			this.invalidate();
		}
	},
	/** grid.getEditBounds()에서 호출된다. -1을 해준다. */
	getButtonsWidth: function () {
		return (this.$_imageButtonWidth() || this.$_buttonWidth()) + this.$_editButtonWidth() + this.$_errorWidth() - 1;
	},
	/** grid.getEditBounds()에서 호출된다.*/
	getLeftButtonsWidth: function() {
		return this._isLeftImageButton ? this.$_imageButtonWidth() : 0;
	},
	getValueOf: function (fieldName) {
		var idx = this.index();
		var item = idx.item();
		var ds = item.dataSource();
		var fld = ds.getFieldIndex(fieldName);
		if (fld >= 0) {
			return item.getData(fld);
		}
		return undefined;
	},
	canHovering: function (hovered) {
		if (hovered) {
			if (this.button() != CellButton.NONE || this.$_editButtonWidth() > 0 || this._expandHandle || this._error || this.$_imageButtonWidth() > 0) {
				return true;
			}
		} else {
			if (this._leftButtonsWidth + this._buttonWidth + this._editWidth + this._errorWidth + this._imageButtonWidth != 0) {
				return true;
			}
		}
		return false;
	},
	_hoveredChanged: function () {
		var renderer = this.renderer();
		if (renderer && renderer.isHoveredUnderline) {
			if (this._hovered && renderer.isHoveredUnderline(this.index())) {
				this._fontUnderline = this._font.underline;
				this._font.underline = true;
			} else {
				this._font.underline = this._fontUnderline == undefined ? this._font.underline : this._fontUnderline;
			}
            this.invalidate(false, true);
		}
	},
	_doLayoutHandles: function () {
		this._super();
		if (this._expandHandle) {
			var sz = DataCellElement.EXPANDER_SIZE;
			this._expandHandle.setBounds(2, 2, sz, sz);
			this._expandHandle.setExpanded(this.group && this.group() && this.group().isExpanded());
			if (!this.contains(this._expandHandle)) {
				this.addElement(this._expandHandle);
				this._expandHandle.invalidate();
			}
		}
	},
	_doPrepareValue: function (model) {
		this._super(model);
		this._dataColumn = this._index.dataColumn();
		this.setValue(model.value());
		this._error = model.error();
		this._errorLevel = model.errorLevel();
		var s = null;
		var col = this._dataColumn;
		this._numberFormatter && (col._displayMinusZero != null ? this._numberFormatter.setDisplayMinusZero(!!col._displayMinusZero) : this._numberFormatter.setDisplayMinusZero(true));
		if (col) {
			switch (col.valueType()) {
			case ValueType.TEXT:
				s = model.displayText();
				break;
			case ValueType.NUMBER:
				var v = Number(this._value);
				if (isNaN(v)) {
					s = col.nanText();
				} else if (v == 0 && col.zeroText() != null) {
					s = col.zeroText();
				} else if (this._numberFormatter) {
					s = this._numberFormatter.format(v);
				} else {
					s = model.displayText();
				}
				break;
			case ValueType.DATETIME:
				/*if (this._value instanceof Date && this._datetimeFormatter) {
					s = this._datetimeFormatter.format(this._value);
				} else*/ if (this._value instanceof Date && this.datetimeWriter()) {
					s = this.datetimeWriter().getText(this._value);
				} else {
					s = model.displayText();
				}
				break;
			case ValueType.BOOLEAN:
				if (this._boolFormatter) {
					s = this._boolFormatter.formatValue(this._value);
				} else {
					s = model.displayText();
				}
				break;
			case ValueType.OBJECT:
				var field = col.getField();
				var dataRow = this._index.dataRow();
				var key = col._objectKey;
				var fn = col._objectCallback;
				var v = this._value;
				var f;
				if (v) {
					s = v = fn && typeof fn === "function" ? fn(field.orgFieldName(), dataRow, v) : key && v.hasOwnProperty(key) ? v[key]  : model.displayText();
					switch (typeof v) {
						case "stirng":
							break;
						case "number":
							s = (f = this._numberFormatter) ? f.format(v) : v;
							break;
						case "boolean":
							s = (f = this._boolFormatter) ? f.formatValue(v) : v;
							break;
						default:
							s = v instanceof Date && (f = this.datetimeWriter()) ? f.getText(v) : v;
							break;
					}
				}
				break;
			default:
				s = model.displayText();
				break;
			}
		}
		this.setText(s);
	},
	_doPrepareElement: function (styles) {
		this._super(styles);
		this.setContentFit(styles.contentFit());
		this.setIconIndex(styles.iconIndex());
		this.setIconLocation(styles.iconLocation());
		this.setIconAlignment(styles.iconAlignment());
		this.setIconOffset(styles.iconOffset());
		this.setIconPadding(styles.iconPadding());
		var renderer = null;
		var rendererId = styles.renderer();
		if (rendererId) {
			renderer = this.grid().dataCellRenderers().getRenderer(rendererId);
		}
		if (!renderer) {
			renderer = this._index.column().rendererObj();
		}
		this.setRenderer(renderer);
	},
	_doUpdateContent: function (model) {
		this._super(model);
        var col = this._dataColumn;
        this._cellStyles = model._cellStyles;
		this.setInnerIndex(-1);
		this.setBlankState(model.blankState());
		if (col) {
            var w = this._grid.$_editOptionsWritable;
            if (w) {
                if (this._cellStyles) {
                    w = this._cellStyles.calcWritable(col.isEditable(), col.isReadOnly());
                } else {
                    w = col.isWritable() &&
                    (this._grid.$_fixedRowCount < 1 || this._grid.$_fixedRowEditable || this._index.itemIndex() >= this._grid.$_fixedRowCount);
                }
            }
            w = w && this._renderer && this._renderer.canEditable();
            this.setWritable(w);
			this.setButton(col.button());
			this.setButtonVisibility(col.buttonVisibility());
			this.setEditButtonVisibility(col.editButtonVisibility());
		} else {
            this.setWritable(false);
        }
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		var sz = this.renderer().measure(grid, this, hintWidth, hintHeight);
		sz.width += this._borderLeft ? this._borderLeft.width() : 0;
		sz.width += this._borderRight ? this._borderRight.width() : 0;
		return sz;
	},
	_doMeasureHeight: function (grid, hintWidth, maxHeight) {
		var sz = this.renderer().measureHeight(grid, this, hintWidth, maxHeight);
        sz.height += this._borderTop ? this._borderTop.width() : 0;
        sz.height += this._borderBottom ? this._borderBottom.width() : 0;
        return sz;
    },
	_doRender: function (g, rc) {
		var fill = this._background;
		if (fill) {
			g.drawRectI(fill, null, rc);
		} else {
			g.drawRectI(SolidBrush.WHITE, null, rc);
		}
		var r = this._getRenderRect(rc);

		// leftButton : Expander 또는 imageButtonsCellRenderer의 alignment가 near인경우 
		// 순서. expander, leftImageButton, Text&&editButton ||CenterImageButton, rightImageButton || cellButton, errorButton 순서로 배치한다. 이 순서는 바꿀수 없다.
		// edit영역은 leftButtonsWidth - 다른 버튼 영역이다.
		// expander의 경우 expanderHandler가 그린다. 여기서는 영역만 체크한다.
		// 왼쪽인 경우. 
		// 오른쪽인 경우  // 그냥 그리면 된다.
		// 가운데인 경우  // 모두 안그리면 된다. (error의 경우는 예외적)
		this._imageButtonWidth = this.$_imageButtonWidth();
		this._leftButtonsWidth = this.$_leftButtonsWidth(r);
		this._isLeftImageButton = this._renderer && this._renderer instanceof ImageButtonsCellRenderer && this._renderer.alignment() === Alignment.NEAR;
		this._buttonWidth = this._imageButtonWidth > 0 ? 0 : this.$_buttonWidth();
		this._editWidth = this.$_editButtonWidth();
		this._errorWidth = this.$_errorWidth();

		var hasButton = this._buttonWidth > 0 || this._editWidth > 0 || this._errorWidth > 0 || this._imageButtonWidth > 0;
		if (this._renderer && (this._blankState == BlankState.NONE || this._blankState == BlankState.HEAD || this._index.itemIndex() === this._grid._topIndex)) {
			if ( (hasButton || this._leftButtonsWidth > 0 ) /*&& !this._imageButtonWidth*/) { //
				r.leftBy(this._leftButtonsWidth + (this._isLeftImageButton ? this._imageButtonWidth : 0));
				r.rightBy(-this._buttonWidth - this._editWidth - this._errorWidth - (this._isLeftImageButton ? 0 : this._imageButtonWidth));
				g.save();
				g.clipRect(r);
				this._renderer.applyDynamicStyles(this);
				this._renderer.render(this, g, r);
				g.restore();
				r.rightBy(this._buttonWidth + this._editWidth + this._errorWidth + (this._isLeftImageButton ? 0 : this._imageButtonWidth));
				r.leftBy(-this._leftButtonsWidth - (this._isLeftImageButton ? this._imageButtonWidth : 0));
			} else {
				this._renderer.applyDynamicStyles(this);
				this._renderer.render(this, g, r);
			}
		}
		if (hasButton) {
			var br = r.clone();
			var buttonVisibility = this._dataColumn && this._dataColumn._editButtonVisibility;
			if ((this._innerIndex >= 0 || buttonVisibility == ButtonVisibility.ROWFOCUSED) && this._mergeRoom) {
				var grid = this.grid();
				var cr;
				if ( buttonVisibility === ButtonVisibility.ROWFOCUSED && grid._focusedIndex) {
					cr = grid.layoutManager().getItemRect(grid._focusedIndex.itemIndex() - grid.topIndex());
				} else if (this._innerIndex >= 0){
					cr = grid.layoutManager().getItemRect(this._mergeRoom.headItem() + this._innerIndex - grid.topIndex());
				}
				if (cr) {
					br.y = cr.y - this.topBy(grid, 0);
					br.height = cr.height;
				}
			}
			if (this._buttonWidth > 0 && this._imageButtonWidth <= 0) { // imageButtonsCellRenderer인경우 그리지 않는다.
				br.setLeft(br.right() - this._buttonWidth);
				// br.rightBy(-this._imageButtonWidth);
				this.$_drawButton(g, br);
			};
			if (this._imageButtonWidth > 0) {
				this._renderer && this._renderer.doDrawButton && this._renderer.doDrawButton(this, g, br);
			};
			if (this._editWidth > 0) {  // dropdown, date 등.
				br.set(r.x, br.y, r.width, br.height);
				br.rightBy(-this._buttonWidth - (this._isLeftImageButton ? 0 : this._imageButtonWidth));
				br.setLeft(br.right() - this._editWidth);
				this.$_drawEditorButton(g, br);
			}
			if (this._errorWidth > 0) {
				br.set(r.x, br.y, r.width, br.height);
				br.rightBy(-this._buttonWidth - this._editWidth - (this._isLeftImageButton ? 0 : this._imageButtonWidth));
				br.setLeft(br.right() - this._errorWidth);
				this.$_drawError(g, br);
			}
		}
		this._drawBordersWithBlank(g, rc, this._blankState);
	},
	$_leftButtonsWidth: function (r, editing) {  // Edit상태를 보고 editing중이면 expandHandler의 width는 제외한다.
		var w = this._expandHandle ? ( r.height > DataCellElement.EXPANDER_SIZE * 3 ?  0 : 16 ) : 0;
		return w;
		// var iw = this.renderer && this._renderer instanceof ImageButtonsCellRenderer && this._renderer.alignment() === Alignment.NEAR ? this._imageButtonWidth : 0;
		// return w+iw;
		// return this._expandHandle ? 16 : 0;
	},
    _getButtonVisible: function (visibility) {
        var vis;
        if (typeof visibility === "function") {
        	var handler = this._grid.getHandler();
        	vis = visibility(handler, this.index().proxy(), this._focused, this._mouseEntered);
        } else {
	        switch (visibility) {
	            case ButtonVisibility.ALWAYS:
	                vis = true;
	                break;
	            case ButtonVisibility.HIDDEN:
	                vis = false;
	                break;
	            case ButtonVisibility.VISIBLE:
	                vis = this._focused;
	                break;
	            case ButtonVisibility.ROWFOCUSED:
	           		vis = (this._grid && this._grid.focusedIndex() && this._grid.focusedIndex()._itemIndex == this._index._itemIndex) || this._mouseEntered;
	            	break;
	            case ButtonVisibility.DEFAULT:
	            default:
	                vis = this._focused || this._mouseEntered;
	                break;
	        }
	    }
        return vis;
    },
	$_resetButtonVisible: function () {
		var col = this._dataColumn;
		if (col) {
			this.setButton(col.button());
			this.setButtonVisibility(col.buttonVisibility());
			this.setEditButtonVisibility(col.editButtonVisibility());
		}
	},
	$_editButtonWidth: function () {
		var w = 0;
        if (this._writable) {
        	var grid = this.grid();
            var column = this._dataColumn;
            if (column) {
            	if (this._renderer && !this._renderer.canEditable()) {

            	} else {
	                if (grid._delegate.hasEditorButton(this._index)) {
	                	var editorListing = false;
	                	if (CellIndex.areEquals(grid.focusedIndex(), this._index)) {
		                	var editor = grid.delegate().getCellEditor(this._index);
		                	editorListing = editor ? editor.isListing() : false;
	                	}
	                    if (editorListing || this._getButtonVisible(this._editButtonVisibility)) {
	                        var renderer = grid._delegate.getCellEditButtonRenderer(this._index);
	                        if (renderer) {
	                            w = renderer.measure(this._index, 0, this.height()).width;
	                        }
	                    }
	                }
	            }
            }
        }
		return w;
	},
	$_imageButtonWidth: function () {
		var renderer = this._renderer;
		if (renderer instanceof ImageButtonsCellRenderer && this._getButtonVisible(this._buttonVisibility)) {
			return this._renderer.measure(this._grid, this, 0, this.height()).width;
		}
		return 0;
	},
	$_buttonWidth: function () {
        var w = 0;
		var focused;
		var index;
		var renderer;
		var grid = this.grid();
		if (this.button() != CellButton.NONE) {
			focused = this.isFocused();
			index = this.index();
			var focusIndex = grid.focusedIndex();
			if (this._innerIndex > 0) {
				focusIndex = focusIndex.clone();
				focusIndex.incRow(-this._innerIndex);
			}
			var equals = CellIndex.areEquals(focusIndex, index);
			if (focused) {
				if (!equals)
					this._focused = false;
			} else if (equals) {
				this._focused = true;
			}
            if (this._getButtonVisible(this._buttonVisibility)) {
				renderer = grid.delegate().getCellButtonRenderer(index);
				if (renderer) {
					w = renderer.measure(index, 0, this.height()).width;
				}
			}
		}
		return w;
	},
	getButtonWidth: function () {
		if (this._renderer instanceof ImageButtonsCellRenderer) {
			var w = this._renderer.measure(this._grid, this, 0, this.height()).width;
			return w;
		} else if (this.button() != CellButton.NONE) {
			var index = this.index();
			var renderer = this.grid().delegate().getCellButtonRenderer(index);
			if (renderer) {
				return renderer.measure(index, 0, this.height()).width;
			}
		}
		return 0;
	},
	$_errorWidth: function () {
		if (this._error) {
			var icon = DataCellElement.getErrorIcon(this.grid(), this._errorLevel);
			return icon ? icon.width + 4 : 0;
		}
		return 0;
	},
	$_drawEditorButton: function (g, r) {
		var renderer = this._grid._delegate.getCellEditButtonRenderer(this._index);
		renderer.render(this._index, g, r, this._editButtonHovered, this._editButtonPressed, this._focused);
	},
	$_drawButton: function (g, r) {
		var renderer = this.grid().delegate().getCellButtonRenderer(this.index());
		renderer.render(this.index(), g, r, this._buttonHovered, this._buttonPressed, this._focused, this._buttonIndex);
		this._buttonIndex = undefined;
	},
	$_drawError: function (g, r) {
		var w, h;
		var img = DataCellElement.getErrorIcon(this.grid(), this._errorLevel);
		if (img && (w = img.width) > 0 && (h = img.height) > 0) {
			var x = _int(r.x + (r.width - w) / 2);
			var y = _int(r.y + (r.height - h) / 2);
			g.drawImage(img, x, y, w, h);
		}
	},
	cursor:function(x, y) {
		var idx;
		var cursor;
		if (this.ptInButton(x, y)) {
			idx = this.getPtInButtonIndex(x, y);
			cursor = this._dataColumn.buttonCursor();
			if (this._button === CellButton.IMAGE && this._dataColumn._imageButtonsRenderer) {
				cursor = this._dataColumn._imageButtonsRenderer.getCursor(idx) || cursor;
			}
		} else if (this.ptInDataButton(x,y)) {
			idx = this.getPtInDataButtonIndex(x,y);
			cursor = this._renderer && this._renderer.getCursor && this._renderer.getCursor(idx);
		} else if (this._renderer && this._renderer.getCursor) {
			cursor = this._renderer.getCursor(this.index());
		};
		if (!cursor) {
			var grid = this.grid();
			var callback = grid.displayOptions().cursorCallback();
			if (callback) {
				var handler = grid.getHandler();
				cursor = callback(handler, this.index().proxy(), this._focused, this._mouseEntered);
			}
		}
		return cursor ? cursor : (this._dataColumn && this._dataColumn.cursor());
	}
}, {
}, function (f) {
	var icons = {};
	f.getErrorIcon = function (grid, level) {
		var icon = icons[level];
		if (!icon) {
			icon = grid.getImage($$_rootContext + $$_assets + "error_" + level + ".png");
			if (icon) {
				icons[level] = icon;
			}
		}
		return icon;
	};
});
DataCellElement.EXPANDER_SIZE = 12;

var DataGroupCellElement = defineClass("DataGroupCellElement", GroupCellElement, {
	init: function(dom) {
		this._super(dom, "dataGroupCellView");
	},
	layoutTreeContent: function (lm) {
		this._layoutTreeCells(lm);
	},
	_layoutColumnRects: function(lm) {
		var grid = this.grid(),
			group = this.group(),
			cnt = group.visibleCount(),
			width = group._layoutRect.width,
			height = this._height;

		var i, x, y, w, h, column, view;
		if (group.isVertical()) {
			y = 0;
			for (i = 0; i < cnt ;i++) {
				column = group.getVisibleItem(i);
				view = this._cells[column.$_hash];//this._getCell(column);
				h = grid.getDataLevel() == 1 ? height : column.measuredHeight();
				column._layoutRect.set(0, y, width, h);
				y += h;
				if (view instanceof DataGroupCellElement) {
					view._layoutColumnRects(lm);
				}
			}
		} else {
			x = 0;
			h = height;
			for (i = 0; i < cnt ; i++) {
				column = group.getVisibleItem(i);
				view = this._cells[column.$_hash];//this._getCell(column);
				w = i == cnt - 1 ? width - x : column.displayWidth();
				column._layoutRect.set(x, 0, w, h);
				x += w;
				if (view instanceof DataGroupCellElement) {
					view._layoutColumnRects(lm);
				}
			}
		}
	},
	_prepareCells: function (lm) {
		this.$_createCells(this.group());
	},
	_layoutCells: function (lm) {
		var width = this._width;
		var height = this._height;
		var group = this.group();
		var cnt = group.visibleCount();
		var i, w, h, column, view, x, y;
		if (group.isVertical()) {
			y = 0;
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				view = this._cells[column.$_hash];//this._getCell(column);
				h = this.grid().getDataLevel() == 1 ? height : column.measuredHeight(); // int 이어야 한다.
				// column._layoutRect.set(0, y, width, h);
				view && view.setBounds(0, y, width, h);
				y += h;
				if (view instanceof DataGroupCellElement) { 
					view._layoutCells(lm);
				}
			}
		}  else {
			x = 0;
			h = height;
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				view = this._cells[column.$_hash];//this._getCell(column);
				if (i == cnt - 1) {
					w = width - x;
				} else {
					w = column.displayWidth(); // int 이어야 한다.
				}
				// column._layoutRect.set(x, 0, w, h);

				view && view.setBounds(x, 0, w, h);
				x += w;
				if (view instanceof DataGroupCellElement) {
					view._layoutCells(lm);
				}
			}
		}
	},
	_layoutTreeCells: function (lm) {
		var width = this._width;
		var height = this._height;
		var group = this.group();
		var cnt = group.visibleCount();
		var i, w, h, column, view, x, y;
		if (group.isVertical()) {
			y = 0;
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				view = this._cells[column.$_hash];//this._getCell(column);
				h = column.measuredHeight();
				column._layoutRect.set(0, y, width, h);
				view.setBounds(0, y, width, h);
				y += h;
				if (view instanceof DataGroupCellElement) {
					view._layoutTreeCells(lm);
				}
			}
		}  else {
			x = 0;
			h = height;
			for (i = cnt - 1; i >= 0; i--) {
				column = group.getVisibleItem(i);
				view = this._getCell(column);
				if (i == 0) {
					w = Math.max(0, width - x);
				} else {
					w = Math.min(width, column.displayWidth());
				}
				x += w;
				column._layoutRect.set(width - x, 0, w, h);
				view.setBounds(width - x, 0, w, h);
				if (view instanceof DataGroupCellElement) {
					view._layoutTreeCells(lm);
				}
			}
		}
	},
	$_createCells: function (group) {
		this.hideAll();
		var i;
		var cnt;
		var column;
		var view;
		var model;
		var r;
		var br;
		var index;
		var grid = this.grid();
		var body = grid.body();
		var idx = this.index().I();
		var lm = grid._layoutManager;
		var leftPos = lm.leftPos();
		for (i = 0, cnt = group.visibleCount(); i < cnt; i++) {
			column = group.getVisibleItem(i);
			if (this._edgeColumn) {
				// r = column._layoutRect;
				// br = this.bounds();
				// // 왼쪽에 있으면 continue
				// if (br.x+r.right() < leftPos) {
				// 	continue;
				// }
				// // 오른쪽에 있으면 break;
				// if (this.x()+column._layoutRect.x > grid._layoutManager._nonfixedBounds.width+leftPos) {
				// 	break;
				// }
			}
			view = this._cells[column.$_hash];// this._getCell(column);
			if (!view) {
				if (column instanceof DataColumn) {
					view = new DataCellElement(this._dom);
				} else if (column instanceof SeriesColumn) {
					view = new SeriesCellElement(this._dom);
				} else { //if (column is ColumnGroup) 
					view = new DataGroupCellElement(this._dom);
				}
				this.$_setCell(column, view);
				this.addElement(view);
			}
			index = CellIndex.temp(grid, idx, column);
			if (column instanceof ValueColumn && column.canMerge() && lm.getMergedCell(index)) {
				view.setVisible(false);
			} else {
				view.setVisible(true)	
			}
			model = body.getCell(index);
			view.updateCell(model);
			view.setMouseEntered(false);
			if (view instanceof DataCellElement) {
				view.setFocused(false);
			}
			if (column instanceof ValueColumn) {
			} else if (column instanceof ColumnGroup) {
				view._edgeColumn = this._edgeColumn;
				view.$_createCells(column);
			}
		}
	}
    /*
	$_checkResourceColumn: function (column, list) {
		var i;
		var view;
		var cnt = this.childCount();
		for (i = 0; i < cnt; i++) {
			view = this.getChild(i);
			if (view instanceof DataCellElement) {
				if (view.index().column() === column) {
					list.push(view);
				}
			} else if (view instanceof DataGroupCellElement) {
				view.$_checkResourceColumn(column, list);
			}
		}
	},
	$_checkResourceUse: function (url, list) {
		var i;
		var view;
		var cnt = this.childCount();
		for (i = 0; i < cnt; i++) {
			view = this.getChild(i);
			if (view instanceof DataCellElement) {
				var renderer = view.renderer();
				if (renderer.useResource(view, url)) {
					list.push(view);
				}
			} else if (view instanceof DataGroupCellElement) {
				view.$_checkResourceUse(url, list);
			} 
		}
	}
	*/
});
var SeriesCellElement = defineClass("SeriesCellElement", DataCellElement, {
	init : function(dom, name) {
		this._super(dom, name || "seriesCellView");
		this._values = null;
	},
	_doPrepareValue: function (model) {
		this._super(model);
	},
	value: function () {
		return this._values;
	},
	setValue: function (v) {
		if (!equalArrays(v, this._values)) {
			this._values = v;
			this.invalidate();
		}
	}
});

var /* abstract */ ItemElement = defineClass("ItemElement", GridElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._item = null;
	},
	item: function () { return this._item; },
	index: function () { return this._item.index(); },
    itemIndex: function () { return this._item.index(); },
	updateElement: function (item, styles) {
		this._item = item;
		this._doUpdateElement(styles);
	},
	propertyChanged: function (prop, value) {
		this.invalidate();
	},
	_doLayoutContent: function (lm) {
		this._doLayoutHandles();
	},
	_doRender: function (g, r) {
	},
	_doUpdateElement: function (styles) {
	}
}, {
});
var RowElement = defineClass("RowElement", ItemElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._cells = {};
	},
	fixed: false,
	rightFixed: false,
	findCell: function (column) {
		if (column) {
			var root = column.root();
			var view = this._cells[root.$_hash];
			if (view && view.isVisible()) {
				if (root != column) {
					view = view.findCell(column);
				}
				return view;
			}
		}
		return null;
	},
	checkMerged: function (lm) {
		var	start = lm.firstCol(this._fixed, this.rightFixed);
		var	end   = lm.lastCol(this._fixed, this.rightFixed);
		for (var i = start; i <= end; i++) {
			var cellView = this._cells[lm.getColumn(i).$_hash];
			if (cellView) {
				if (lm.getMergedCell(cellView.index())) {
                    cellView.setVisible(false);
				} else {
                    cellView.setVisible(true);
				}
			}
		}
	},
	_doUpdateElement: function (styles) {
		this._super(styles);
	},
	_doMesasure: function (grid, hintWidth, hintHeight) {
		return { width: hintWidth, height: hintHeight };
	},
	_doLayoutContent: function (lm) {
		this._prepareCells(lm);
		this._layoutIndex == 0  && this._layoutColumnRects(lm);
		this._layoutCells(lm);
	},
	_doRender: function (g, r) {
	},
	_getCellView: function (column) {
		return this._cells[column.$_hash];
	},
	_getFirstCell: function (lm) {
		var start = lm.firstCol(this._fixed, this._rightFixed);
		return this._cells[lm.getColumn(start).$_hash];
	},
	_clearChildren: function () {
		this.clear();
		this._cells = {};
	},
	_prepareCells: function (lm) {
		var i, cnt, column, index, cellView, room, start, end, cell, expander, group;
		var grid = this.grid();
		var body = grid.body();
		var rowGroup = grid.rowGroup();
		var fixedCols = lm.fixedColCount();
		var horzScrolling = grid.isHorzScrolling();
		var merged = lm.isColumnMerged();
		var mergeExpander = rowGroup.isMergeExpander();
		var adorned = rowGroup.expandedAdornments() == RowGroupAdornments.BOTH;
		var itemDataId = this.item().dataId();
		var itemEditing = ItemState.isEditing(this.item().itemState());
		if (grid.isColumnLayoutChanged()) {
			this._clearChildren();
			this._cells = {};
		}
		for (var c in  this._cells) {
			this._cells[c]._recycling = false;
		}
		if (horzScrolling) {
			start = lm.prevFirst(this._fixed, this._rightFixed); //lm.getPrevFirst();
			end = lm.prevLast(this._fixed, this._rightFixed); //lm.getPrevLast();
			for (i = start; i < end; i++) {
				column = lm.getColumn(i);
				cellView = this._cells[column.$_hash];
				if (cellView) {
					if (cellView instanceof DataGroupCellElement && (cellView.x() <= lm._leftPos || cellView.right() >= lm._leftPos+lm._nonfixedBounds.width)) {
						cellView._recycling = false;	
					} else if ((cellView.index().dataId() !== itemDataId) || (grid._updateRows && grid._updateRows.indexOf(itemDataId) >= 0)) {
						cellView._recycling = false;
					} else {
						cellView._recycling = true;	
					}
				}
			}
		}
		this.hideAll();
		start = lm.firstCol(this._fixed, this._rightFixed);
		end = lm.lastCol(this._fixed, this._rightFixed);
		for (i = start; i <= end; i++) {
			column = lm.getColumn(i);
			index = CellIndex.temp(grid, this._item.index(), column);
			room = column instanceof ValueColumn && lm.getMergedCell(index);
			if (room) {
				cellView = grid.getCellView(grid._mergeView, index);
				cellView && cellView.setFocused(false);
				continue;
			}
			cell = body.getCell(index);
			cellView = this._cells[column.$_hash];
			if (!cellView) {
				if (column instanceof ColumnGroup) {
					cellView = new DataGroupCellElement(this._dom);
				} else if (column instanceof SeriesColumn) {
					cellView = new SeriesCellElement(this._dom);
				} else {
					cellView = new DataCellElement(this._dom);
				}
				this._cells[column.$_hash] = cellView;
				this.addElement(cellView);
			}
			cellView.setVisible(true);
			if (cellView instanceof DataCellElement) {
				expander = false;
				if (merged && mergeExpander) {
					if (column instanceof DataColumn && column.isMergeGrouped()) {
						group = this._item.parent();
						cnt = group.count() - (adorned ? 0 : 1);
						expander = cnt > 1 && group.firstItem() == this._item;
					}
				}
				cellView.setExpanderVisible(expander);
			}
			if (this.grid()._dataChanged || itemEditing || !horzScrolling || !cellView._recycling || cellView instanceof SeriesCellElement) {
				cellView.updateCell(cell);
			}
			cellView.setMouseEntered(false);
			if (cellView instanceof DataCellElement) {
				cellView.setFocused(false);
			} else {
			}
		}
	},
	_layoutColumnRects: function(lm) {
        var i, view, r, 
        	grid = this.grid(), 
        	isHorzScrolling = grid.isHorzScrolling(), 
        	startCol = lm.firstCol(this._fixed, this._rightFixed), 
        	endCol = lm.lastCol(this._fixed, this._rightFixed);
        for (i = startCol; i <= endCol; i++) {
            view = this._cells[lm.getColumn(i).$_hash];
            if (view && view.isVisible()) {
                r = lm.getColumnBounds(i);
                r.height = this.height();
                view.index().column()._layoutRect.copy(r);
                if (view instanceof DataGroupCellElement && (!isHorzScrolling || !view._recycling)) {
                    view._layoutColumnRects(lm);
                }
            }
        }
	},
	_layoutCells: function (lm) {
		var i, cellView, r;
		var horzScrolling = this.grid().isHorzScrolling();
		// var fixedCols = lm.fixedColCount();
		var start = lm.firstCol(this._fixed, this._rightFixed);
		var end = lm.lastCol(this._fixed, this._rightFixed);
		var col = start;
		var leftPos = lm.leftPos();

		while(col <= end) {
			cellView = this._cells[lm.getColumn(col).$_hash];
			if (cellView && cellView.isVisible()) {
				cellView._fixed = this._fixed;
				r = lm.getColumnBounds(col);
				r.height = this.height();
				// cellView.index().column()._layoutRect.copy(r);
				cellView.setRect(r);
				if (cellView instanceof DataGroupCellElement) {
					if (!cellView._fixed && (col == start || col == end)) {
						cellView._edgeColumn = true;
					} else {
						cellView._edgeColumn = false;
					}
				}
				if (!horzScrolling || !cellView._recycling) {
					cellView.layoutContent(lm);
				}
			}
			col++;
		}
		// for (i = start; i <= end; i++) {
		// 	cellView = this._cells[lm.getColumn(i).$_hash];
		// 	if (cellView && cellView.isVisible()) {
		// 		cellView._fixed = this._fixed;
		// 		r = lm.getColumnBounds(i);
		// 		r.height = this.height();
		// 		// cellView.index().column()._layoutRect.copy(r);
		// 		cellView.setRect(r);
		// 		if (cellView instanceof DataGroupCellElement) {
		// 			if (!cellView._fixed && (i == start || i == end)) {
		// 				cellView._edgeColumn = true;
		// 			} else {
		// 				cellView._edgeColumn = false;
		// 			}
		// 		}
		// 		if (!horzScrolling || !cellView._recycling) {
		// 			cellView.layoutContent(lm);
		// 		}
		// 	}
		// }
	}
}, {
});
var RowGroupBarCellElement = defineClass("RowGroupBarCellElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
	},
	level:0,
	_doRender: function (g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawBorders(g, r);
	}
});
var RowGroupBarElement = defineClass("RowGroupBarElement", LayerElement, {
	init: function(dom) {
		this._super(dom, "rowGroupBarView");
		this._level = 0;
		this._cells = [];
	},
    setLevel: function(value) {
        this._level = value;
    },
	$_checkCapacity: function (count) {
		while (this._cells.length < count) {
			this._cells.push(new RowGroupBarCellElement(this._dom, "rowGroupBarCell"));
		}
	},
	$_addCell: function (grid, idx, y, w, h) {
		this.$_checkCapacity(idx + 1);
		var cell = this._cells[idx];
		cell.setBounds(0, y, w, h);
		cell.setLevel(this._level);
		this.addElement(cell);
		var model = grid.rowGroup().getBarCell(this._level);
		cell.updateCell(model);
		cell.invalidate();
	},
	$_isBarItem: function (item) {
		return item instanceof GroupItemImpl ||	(item instanceof GroupFooter && item.isExpandable());
	},
	/* @internal */ layoutCells: function (items, lm) {
		this.clear();
		var grid = this.container().gridView();
		var c = 0;
		var yTop = 0;
		var w = this.width();
		var h = this.height();
		if (lm.fixedItemCount() > 0) {
			yTop = lm.itemBounds(lm.fixedItemCount() - 1).bottom();
			this.$_addCell(grid, c, 0, w, yTop);
			c++;
		}
		if (h <= yTop) {
			return;
		}
		var top = grid.topIndex();
		var cnt = items.length;
		if (cnt < 1) {
			this.$_addCell(grid, c, yTop, w, h - yTop);
		} else {
			var i;
			var y1;
			var r;
			var item2;
			var y2;
			var item = items[0];
			if (item.level() <= this._level || item.displayLevel() <= this._level) {
				y1 = item.index();
				r = lm.itemBounds(y1 - top);
				if (y1 > grid.topItem()) {
					this.$_addCell(grid, c, yTop, w, r.y - yTop);
					c++;
				}
			}
			for (i = 0; i < cnt - 1; i++) {
				item = items[i];
				if (this.$_isBarItem(item) && (item.level() == this._level || item.displayLevel() == this._level)) {
					item2 = items[i + 1];
					y2 = item2.index();
					y1 = item.index();
					r = lm.itemBounds(y1 - top);
					y1 = r.bottom();
					r = lm.itemBounds(y2 - top);
					y2 = r.y;
					this.$_addCell(grid, c, y1, w, y2 - y1);
					c++;
				}
			}
			i = cnt - 1;
			item = items[i];
			if (this.$_isBarItem(item) && (item.level() <= this._level || item.displayLevel() <= this._level)) {
				y1 = item.index();
				r = lm.itemBounds(y1 - top);
				if (r.bottom() < this.y() + h) {
					this.$_addCell(grid, c, r.bottom(), w, this.y() + h - r.bottom());
				}
			}
		}
	}
});
var RowGroupExpandHandle = defineClass("RowGroupExpandHandle", CellHandle, {
	init: function(dom, cellView) {
		this._super(dom, cellView, "rowGroupExpandHandle");
	},
	expanded: false,
	background: null,
	isClickable: function () {
		return true;
	},
	_doDraw: function (g) {
		var r = this.clientRect();
		if (this.isExpanded()) {
			$$_drawDownArrow(g, r, 9, this.background());
		} else {
			$$_drawRightArrow(g, r, 9, this.background());
		}
	}
});
var RowGroupExpanderElement = defineClass("RowGroupExpanderElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
		this._handle = new RowGroupExpandHandle(dom, this);
		this.addElement(this._handle);
	},
	setHandleVisible: function(visible) {
		this._handle.setVisible(visible);
	},
	_doUpdateContent: function (cell) {
		this._super(cell);
		var styles = cell.styles();
		this._handle.setBackground(styles.figureBackground());
		var expanded = cell.index().item() instanceof GroupItem ? cell.index().item().isExpanded() : cell.index().item() instanceof GroupFooter ? cell.index().item().parent().isExpanded() : false;
		this._handle.setExpanded(expanded);
	},
	_doLayoutContent: function (lm) {
		this._handle.setRect(this.clientRect());
	},
	_doRender: function (g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawBorders(g, r);
	}
});
var RowGroupItemBarElement = defineClass("RowGroupItemBarElement", GridElement, {
	init: function(dom, name) {
		this._super(dom, name);
		this._index = 0;
		this._expander = new RowGroupExpanderElement(dom, "RowGroup expander");
		this.addElement(this._expander);
	},
	setExpanderVisible: function (visible) {
		this._expander.setHandleVisible(visible);
	},
	setIndex: function (index) {
		this._index = index;
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doLayoutContent: function (lm) {
		var grid = this.grid();
		var item = grid.getItem(this._index);
		var model = (item instanceof GroupItem) ? grid.rowGroup().getHeaderBarCell(CellIndex.temp(grid, this._index))
			: grid.rowGroup().getFooterBarCell(CellIndex.temp(grid, this._index));
		var expander = this._expander;
			expander.updateCell(model);
			expander.setRect(this.clientRect());
			expander.layoutContent(lm);
	},
	_doRender: function(g, r) {
		g.drawRectI(SolidBrush.WHITE, null, r);
	}
});
var RowGroupHeadCellElement = defineClass("RowGroupHeadCellElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
	},
	_doUpdateContent: function(cell) {
		this._super(cell);
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, grid.header().minHeight());
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawBorders(g, r);
	}
});
var RowGroupFootCellElement = defineClass("RowGroupFootCellElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
	},
	_doUpdateContent: function(cell) {
		this._super(cell);
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, grid.footer().minHeight());
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawBorders(g, r);
	}
});
var RowGroupSummaryCellElement = defineClass("RowGroupSummaryCellElement", CellElement, {
	init: function(dom, name) {
		this._super(dom, name);
	},
	_doUpdateContent: function(cell) {
		this._super(cell);
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, grid.header().summary().minHeight());
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		this._drawBorders(g, r);
	}
});
var RowGroupItemElement = defineClass("RowGroupItemElement", ItemElement, {
	init: function(dom, name) {
		this._super(dom, name);
	}
});
var RowGroupHeaderCellElement = defineClass("RowGroupHeaderCellElement", CellElement, {
	init: function(dom) {
		this._super(dom, "rowGroupHeaderCellElement");
	},
	text: null,
	borderLeft: function () {
		return null;
	},
	_doPrepareValue: function (cell) {
		this._super(cell);
		this.setText(cell.displayText());
	},
	_doPrepareElement: function (styles) {
		this._super(styles);
	},
	_doUpdateContent: function(cell) {
		this._super(cell);
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doRender: function(g, r) {
		var fill = this.background();
		if (fill) {
			g.drawRect(fill, null, r);
		}
		var rc = this._getRenderRect(r);
		rc = this.inflatePadding(rc);
		g.drawTextRect(this.font(), this.foreground(), this.text(), rc, this.textAlign());
		this._drawBorders(g, r);
	}
});
var RowGroupHeaderElement = defineClass("RowGroupHeaderElement", RowGroupItemElement, {
	init: function(dom/*, rowGroup*/) {
		this._super(dom, "rowGroupHeaderView");
		this._cellView = new RowGroupHeaderCellElement(dom);
		this.addElement(this._cellView);
	},
	cellView: function() {
		return this._cellView;
	},
	_doUpdateElement: function (styles) {
		this._super(styles);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
		this._cellView.updateCell(this.grid().rowGroup().getHeaderCell(this.index()));
		this._cellView.setBounds(0, 0, this.width(), this.height());
	},
	_doRender: function (g, r) {
	}
});
var RowGroupFooterElement = defineClass("RowGroupFooterElement", RowGroupItemElement, {
	init: function(dom/*, rowGroup*/) {
		this._super(dom, "rowGroupFooterView");
		this._fixed = false;
		this._rightFixed = false;
		this._cells = {};
	},
	isFixed: function () {
		return this._fixed;
	},
	isRightFixed: function () {
		return this._rightFixed;
	},
	setFixed: function (value) {
		this._fixed = value;
	},
	setRightFixed: function (value) {
		this._rightFixed = value;
	},
	getCell: function (index) {
		return null;
	},
	_doUpdateElement: function(styles) {
		this._super(styles);
		var parent = this.item().parent();
		this._level = parent.level();
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doLayoutContent: function(lm) {
		this._prepareCells(lm);
		this._layoutCells(lm);
	},
	_doRender: function(g, r) {
		if (this.isFixed()) {
			var options = this.grid().fixedOptions();
			var styles = options.colBarStyles();
			var fill = styles.background();
			var stroke = styles.borderRight();
			var lstroke = styles.borderLeft();
			var wbar = options.colBarWidth();
			if (this.isRightFixed()) {
				r.setRight(wbar);
			} else {
				r.setLeft(r.right() - wbar);
			}
			if (fill) {
				g.drawRectI(fill, null, r);
			}
			if (stroke) {
				var x = r.right() - 1;
				var y = r.bottom();
				g.drawVertLineI(stroke, x.y, r.bottom(), r.x);
			}
			if (lstroke && this._rightFixed) {
				g.drawVertLineI(lstroke, r.y, r.bottom(), r.x);
			}
		}
	},
	_doDraw: function (g) {
		/*
		var r = this.getClientRect();
		g.drawRectI(SolidBrush.LTGRAY, null, r);
		*/
	},
	_prepareCells: function (lm) {
		var grid = this.grid();
		var rowGroup = this._rowGroup = grid.rowGroup();
		var i;

		var fixed = this.isFixed();
		var rightFixed = this.isRightFixed();
		var start = lm.firstCol(fixed, rightFixed);
		var end = lm.lastCol(fixed, rightFixed);
		var mergeManager = grid.groupFooterMergeManager();
		var merged = mergeManager.count() > 0;

		if (grid.isColumnLayoutChanged()) {
			this.clear();
			this._cells = {};
		}
		this.hideAll();

		for (i = start; i <= end; i++) {
			var room = merged && mergeManager.findRoom(this._level, i);
			this._prepareCell(lm, i, room);
		}
		if (merged) {
			var rooms = mergeManager.getRoomNames(this._level);
			for (var i = 0; i < rooms.length; i++) {
				var room = mergeManager.getRoom(this._level, rooms[i]);
				if (room && ((start > room.base() && start <= room.last()) ||
					         (end   < room.base() && end   >= room.start()))) {
					this._prepareCell(lm, room.base(), room);
				}
			}
		}
	},
	_prepareCell: function(lm, col, room) {
		var grid = this.grid();
		var rowGroup = this._rowGroup;
		var column = lm.getColumn(col);
		var view = _cast(this._cells[column.$_hash], CellElement);

		if (!view) {
			if (column instanceof ColumnGroup) {
				view = new GroupFooterGroupCellElement(this._dom);
			} else {
				view = new GroupFooterCellElement(this._dom);
			}
			this._cells[column.$_hash] = view;
			this.addElement(view);
		}

		view.setVisible(!room || room.base() == col);
		if (column instanceof ValueColumn)
			view.setTextVisible(!room || room.base() == col); 
		var index = CellIndex.temp(grid, this.index(), column);
		var model = rowGroup.getFooterCell(index);
		view.updateCell(model);
	},
	_layoutCells: function (lm) {
		var i;
		var view;	// CellElement
		var r, sr, er;
		var leftPos = this.grid().leftPos();
		var h = this.height();
		var isFixed = this.isFixed();
		var isRightFixed = this.isRightFixed();
		var start = lm.firstCol(isFixed, isRightFixed);
		var end = lm.lastCol(isFixed, isRightFixed);
		var mergeManager = this.grid().groupFooterMergeManager();
		var merged = mergeManager.count() > 0;
		var grid = this.grid();
		var groupedProvider = this.grid()._items._groupedProvider;
		var isExpanded = this._item._parent.isExpanded()
		var footerOnly =  isExpanded ? groupedProvider._expandedAdornments == RowGroupAdornments.SUMMARY : RowGroupAdornments.isFooterOnly(groupedProvider._collapsedAdornments);
		var hasFixed = lm.fixedColCount() > 0;
		var levelIndent = this._rowGroup.levelIndent();
		var w = (lm.rowGroupLevels() - this._item.level() + 1) * levelIndent;
		var isChangeCellPos = footerOnly && ((hasFixed && isFixed) || !hasFixed) && !isRightFixed;
		for (i = start; i <= end; i++) {
			view = this._cells[lm.getColumn(i).$_hash];
			view._shiftLeft = 0;
			r = lm.columnBounds(i);
			r.height = h;
			if (merged && (room = mergeManager.findRoom(this._level, i))) {
				sr = lm.columnBounds(room.start());
				er = lm.columnBounds(room.last());
				r.width = er.right() - sr.x;
				r.x = sr.x;
				if (isChangeCellPos){
					if (start == room.start()) {
						r.width += w;
						view._shiftLeft = w;
					} else {
						r.x += w;
						view._shiftLeft = w;
					}
				}
			} else {
				if (isChangeCellPos) {
					if (i == start) {
						r.width += w;
						view._shiftLeft = w;
					} else {
						r.x += w;
					}
				}
			}
			if (!isFixed && !isRightFixed) {
				r.x -= leftPos;
			}
			view.setRect(r);
			view.layoutContent(lm);
		}
		if (merged) {
			var rooms = mergeManager.getRoomNames(this._level);
			for (var i = 0; i < rooms.length; i++) {
				var room = mergeManager.getRoom(this._level, rooms[i]);
				if (room && ((start > room.base() && start <= room.last()) ||
					         (end   < room.base() && end   >= room.start()))) {
					sr = lm.columnBounds(room.start());
					r = sr;	
					er = lm.columnBounds(room.last());	
					r.width = er.right() - sr.x;
					if (isChangeCellPos){
						if (start == room.start()) {
							r.width += w;
							view._shiftLeft = w;
						} else {
							r.x += w;
							view._shiftLeft = w;
						}
					}
					r.height = h;
					if (!isFixed && !isRightFixed) {
						r.x -= leftPos;
					}
					view = this._cells[lm.getColumn(room.base()).$_hash];
					view.setRect(r);
					view.layoutContent(lm);	
				}
			}		
		}
	}
});
var RowGroupElement = defineClass("RowGroupElement", VisualObjectElement, {
	init: function(dom, rowGroup) {
		this._super(dom, "rowGroupView", rowGroup);
		this._headElement = new LayerElement(dom, "rowGroupHeadContainer");
		this.addElement(this._headElement);
		this._bodyElement = new LayerElement(dom, "rowGroupBodyContainer", true);
		this.addElement(this._bodyElement);
		this._headerBarElement = new LayerElement(dom, "rowGroupHeaderBarContainer");
		this.addElement(this._headerBarElement);
		this._footerBarElement = new LayerElement(dom, "rowGroupFooterBarContainer");
		this.addElement(this._footerBarElement);
		this._barElement = new LayerElement(dom, "rowGroupBarContainer");
		this.addElement(this._barElement);
		this._footElement = new LayerElement(dom, "rowGroupFootContainer");
		this.addElement(this._footElement);
		this._summaryElement = new LayerElement(dom, "rowGroupSummaryContainer");
		this.addElement(this._summaryElement);
		this._headerBuff = [];			// RowGroupHeaderElement
		this._footerBuff = [];			// RowGroupFooterElement
		this._fixedFooterBuff = [];		// RowGroupFooterElement
		this._rfixedFooterBuff = [];	// RowGroupFooterElement
		this._heads = [];				// RowGroupHeadCellElement
		this._foots = [];				// RowGroupFootCellElement
		this._headerBars = [];			// RowGroupItemBarElement
		this._footerBars = [];			// RowGroupItemBarElement
		this._bars = [];				// RowGroupBarElement
		this._headers = [];				// RowGroupHeaderElement
		this._footers = [];				// RowGroupFooterElement
		this._fixedFooters = [];		// RowGroupFooterElement
		this._rfixedFooters = [];		// RowGroupFooterElement
		this._tmpItems = [];			// IGridItem
		this._headerItems = [];			// GroupItem
		this._footerItems = [];			// GroupFooter
		this._headerViews = [];			// RowGroupHeaderElement
		this._footerViews = [];			// RowGroupFooterElement
		this._fixedFooterViews = [];	// RowGroupFooterElement
		this._rfixedFooterViews = [];	// RowGroupFooterElement
		this._summarys = [];		// RowGroupSummeryCellElement
		this.setWidth(200);
		this.setHeight(200);
	},
	destroy: function() {
		this._destroying = true;
		this._headerBuff = null;
		this._footerBuff = null;
		this._fixedFooterBuff = null;
		this._rfixedFooterBuff = null;
		this._heads = null;
		this._foots = null;
		this._headerBars = null;
		this._footerBars = null;
		this._bars = null;
		this._headers = null;
		this._footers = null;
		this._fixedFooters = null;
		this._rfixedFooters = null;
		this._tmpItems = null;
		this._headerItems = null;
		this._footerItems = null;
		this._headerViews = null;
		this._footerViews = null;
		this._fixedFooterViews = null;
		this._rfixedFooterViews = null;
		this._summarys = null;
		this._super();
	},
	model: function () {
		return this._model;
	},
	levelCount: function() {
		return this.grid().layoutManager().rowGroupLevels();
	},
	barCount: function () {
		return this._bars.length;
	},
	getBar: function (index) {
		_assert(index >= 0 && index < this._bars.length, "rowgroup indicator index is invalid: " + index);
		return this._bars[index];
	},
	clearBody: function () {
		this._headerItems = [];
		this._footerItems = [];
	},
	clearFooterViews: function () {
		this.$_clearFooterViews();
	}, 
	addHeader: function (model) {
		this._headerItems.push(model);
	},
	addFooter: function (model) {
		this._footerItems.push(model);
	},
	getCellView: function (index, fixed, rightFixed) {
		var i;
		var header;
		var footer;
		var item = index.item();
		var body = this._bodyElement;
		var cnt = body.childCount();
		if (item instanceof GroupItem || item instanceof GroupFooter) {
			for (i = 0; i < cnt; i++) {
				header = _cast(body.getChild(i), RowGroupHeaderElement);
				if (header && header.isVisible() && header.index() == index.I()) {
					return header.cellView();
				}
				footer = _cast(body.getChild(i), RowGroupFooterElement);
				if (footer && footer._fixed == fixed && footer._rightFixed == rightFixed && footer.isVisible() && footer.index() == index.I()) {
					return footer;
				}
			}
		}
		return null;
	},
	isLayer: function () {
		return true;
	},
	isClickable: function () {
		return false;
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		this._prepareHeads();
		this._prepareFoots();
		this._prepareSummarys();
		this._prepareBars();
		return new Size(this.levelCount() * grid.rowGroup().levelIndent(), hintHeight);
	},
	_doLayoutContent: function (lm) {
		var i;
		var cnt;
		var itemBar;	// RowGroupItemBarElement
		var header;		// GroupItem
		var r;
		var footer;		// GroupFooter
		var bar;		// RowGroupBarElement
		var grid = this.grid();
		var rowGroup = this.model();
		var levelIndent = rowGroup.levelIndent();
		this._headElement.setBounds(0, 0, this.width(), lm.headerBounds().height);
		this._layoutHeads(lm);
		var h = lm.footerBounds().height;
		this._footElement.setBounds(0, this.height() - h, this.width(), h);
		this._layoutFoots(lm);

		this._summaryElement.setBounds(0, lm.headerBounds().height, this.width(),lm.summaryBounds().height)
		this._layoutSummarys(lm);

		this._layoutBars(lm);
		this._bodyElement.setBounds(0, lm.headerBounds().height + lm.summaryBounds().height, this.width(), 
			this.height() - lm.headerBounds().height - lm.footerBounds().height-lm.summaryBounds().height);
		this._layoutHeaders(lm);
		this._prepareHeaderBars();
		for (i = 0, cnt = this._headerItems.length; i < cnt; i++) {
			itemBar = this._headerBars[i];
			header = this._headerItems[i];
			itemBar.setIndex(header.index());
			r = lm.itemBounds(header.index() - grid.topIndex());
			r.setLeft((header.level() - 1) * levelIndent);
			r.width = levelIndent;
			this._headerBarElement.addElement(itemBar);
			itemBar.setRect(r);
			itemBar.setExpanderVisible(true);
			itemBar.layoutContent(lm);
		}
		this._layoutFooters(lm);
		this._prepareFooterBars();
		for (i = 0, cnt = this._footerItems.length; i < cnt; i++) {
			footer = this._footerItems[i];
			if (footer.displayLevel() <= lm.rowGroupLevels()) {
				itemBar = this._footerBars[i];
				itemBar.setIndex(footer.index());
				r = lm.itemBounds(footer.index() - grid.topIndex());
				r.setLeft((footer.displayLevel() - 1) * levelIndent);
				r.width = footer.isExpandable() ? levelIndent : (lm.rowGroupLevels() - footer.displayLevel() + 1) * levelIndent;
				// footerOnly
				// r.width = levelIndent;
				this._footerBarElement.addElement(itemBar);
				itemBar.setRect(r);
				itemBar.setExpanderVisible(footer.isExpandable());
				itemBar.layoutContent(lm);
			}
		}
		this._prepareBars();
		for (i = 0, cnt = lm.rowGroupLevels(); i < cnt; i++) {
			bar = this._bars[i];
			bar.setBounds(i * levelIndent, 0, levelIndent, this._barElement.height());
			bar.setLevel(i + 1);
			this._barElement.addElement(bar);
			this.$_collectItems(lm, i + 1);
			bar.layoutCells(this._tmpItems, lm);
		}
	},
	_doDraw: function (g) {
		/*
		g.beginFill(0xff0000, 0.5);
		var elt:VisualElement = m_footerElement;
		g.drawRect(elt.x, elt.y, elt.width, elt.height);
		g.endFill();
		*/
	},
	_prepareHeads: function () {
		var head;
		var cnt = this.levelCount();
		while (this._heads.length < cnt) {
			head = new RowGroupHeadCellElement(this._dom, "rowGroupHeadCell");
			this._heads.push(head);
		}
		while (this._headElement.childCount() < cnt) {
			this._headElement.addElement(this._heads[this._headElement.childCount()]);
		}
		while (this._headElement.childCount() > cnt) {
			this._headElement.removeChildAt(this._headElement.childCount() - 1);
		}
	},
	_prepareFoots: function () {
		var foot;	// RowGroupFootCellElement
		var cnt = this.levelCount();
		while (this._foots.length < cnt) {
			foot = new RowGroupFootCellElement(this._dom, "rowGroupFootCell");
			this._foots.push(foot);
		}
		while (this._footElement.childCount() < cnt) {
			this._footElement.addElement(this._foots[this._footElement.childCount()]);
		}
		while (this._footElement.childCount() > cnt) {
			this._footElement.removeChildAt(this._footElement.childCount() - 1);
		}
	},
	_prepareSummarys: function () {
		var summary;	// RowGroupSummaryCellElement
		var cnt = this.levelCount();
		while (this._summarys.length < cnt) {
			summary = new RowGroupSummaryCellElement(this._dom, "rowGroupSummaryCell");
			this._summarys.push(summary);
		}
		while (this._summaryElement.childCount() < cnt) {
			this._summaryElement.addElement(this._summarys[this._summaryElement.childCount()]);
		}
		while (this._summaryElement.childCount() > cnt) {
			this._summaryElement.removeChildAt(this._summaryElement.childCount() - 1);
		}
	},
	_prepareHeaderBars: function () {
		var bar;
		this._headerBarElement.clear();
		while (this._headerBars.length < this._headerItems.length) {
			bar = new RowGroupItemBarElement(this._dom, "rowGroupHeaderBar");
			this._headerBars.push(bar);
		}
	},
	_prepareFooterBars: function () {
		var bar;
		this._footerBarElement.clear();
		while (this._footerBars.length < this._footerItems.length) {
			bar = new RowGroupItemBarElement(this._dom, "rowGroupFooterBar");
			this._footerBars.push(bar);
		}
	},
	$_collectItems: function (lm, level) {
		var i;
		var item;
		var grid = this.grid();
		var top = grid.topItem();
		var itemCount = lm.itemCount();
		this._tmpItems.splice(0, this._tmpItems.length);
		i = 0;
		while (i < itemCount) {
			item = grid.getItem(i + top);
			if (item.displayLevel() <= level) {
				this._tmpItems.push(item);
			}
			i++;
		}
	},
	_prepareBars: function () {
		var bar;	// RowGroupBarElement;
		var cnt = this.levelCount();
		this._barElement.clear();
		while (this._bars.length < cnt) {
			bar = new RowGroupBarElement(this._dom, "rowGroupBar");
			this._bars.push(bar);
		}
	},
	$_removeHeaderView: function (view/*RowGroupHeaderElement*/) {
		var idx = this._bodyElement.getChildIndex(view);
		if (idx >= 0) {
			this._bodyElement.removeChildAt(idx);
			view.validate(true);
			this._headerBuff.push(view);
		}
	},
	$_borrowHeaderView: function (header/*GroupItem*/)/*RowGroupHeaderElement*/ {
		var view; // RowGroupHeaderElement;
		if (this._headerBuff.length > 0) {
			view = this._headerBuff.pop();
		} else {
			view = this.grid().delegate().borrowItemView(header, false, false);
		}
		view.recycling = false;
		return view;
	},
	_layoutHeaders: function (lm) {
		var i;
		var view;	// RowGroupHeaderElement;
		var header;	// GroupItem;
		var dirty;
		var r;
		var w;
		var grid = this.grid();
		var rowGroup = this.model();
		var levelIndent = rowGroup.levelIndent();
		var cnt = this._headerViews.length;
		for (i = 0; i < cnt; i++) {
			this._headerViews[i].recycling = false;
		}
		while (cnt < this._headerItems.length) {
			view = this.$_borrowHeaderView(this._headerItems[cnt++]);
			this._bodyElement.addElement(view);
			this._headerViews.push(view);
		}
		while (cnt > this._headerItems.length) {
			this.$_removeHeaderView(this._headerViews[--cnt]);
			this._headerViews.pop();
		}
		for (i = 0; i < cnt; i++) {
			header = this._headerItems[i];
			view = this._headerViews[i];
			dirty = (view.item !== header);
			view.updateElement(header, rowGroup.headerStyles());
			r = lm.itemBounds(header.index() - grid.topIndex());
			w = header.level() * levelIndent;
			r.setLeft(w);
			r.width = this.width() - w - grid.leftPos();
			view.setRect(r);
			if (dirty || !view.recycling) {
				view.layoutContent(lm);
			}
		}
	},
	$_removeFooterView: function (view/*RowGroupFooterElement*/) {
		var idx = this._bodyElement.getChildIndex(view);
		if (idx >= 0) {
			this._bodyElement.removeChildAt(idx);
			view.validate(true);
			this._footerBuff.push(view);
		}
	},
	$_removeFixedFooterView: function (view/*RowGroupFooterElement*/) {
		var idx = this._bodyElement.getChildIndex(view);
		if (idx >= 0) {
			this._bodyElement.removeChildAt(idx);
			view.validate(true);
			this._fixedFooterBuff.push(view);
		}
	},
	$_removeRightFixedFooterView: function (view/*RowGroupFooterElement*/) {
		var idx = this._bodyElement.getChildIndex(view);
		if (idx >= 0) {
			this._bodyElement.removeChildAt(idx);
			view.validate(true);
			this._rfixedFooterBuff.push(view);
		}
	},
	$_borrowFooterView: function (footer/*GroupFooter*/) {
		var view;
		if (this._footerBuff.length > 0) {
			view = this._footerBuff.pop();
		} else {
			view = this.grid().delegate().borrowItemView(footer, false, false);
		}
		view.recycling = false;
		return view;
	},
	$_borrowFixedFooterView: function (footer/*GroupFooter*/) {
		var view; // RowGroupFooterElement
		if (this._fixedFooterBuff.length > 0) {
			view = this._fixedFooterBuff.pop();
		} else {
			view = this.grid().delegate().borrowItemView(footer, true, false);
		}
		view.recycling = false;
		return view;
	},
	$_borrowRightFixedFooterView: function (footer/*GroupFooter*/) {
		var view; // RowGroupFooterElement
		if (this._rfixedFooterBuff.length > 0) {
			view = this._rfixedFooterBuff.pop();
		} else {
			view = this.grid().delegate().borrowItemView(footer, true, true);
		}
		view.recycling = false;
		return view;
	},
	$_clearFooterViews: function() {
		function clearFooter(views, body) {
			var view;
			var idx;
			for (var i = views.length - 1; i >= 0 ;i--) {
				view = views[i];
				idx = body.getChildIndex(view);
				if (idx >= 0) {
					body.removeChildAt(idx);
				}
				views.pop();
			}

		};
		var body = this._bodyElement;
		clearFooter(this._footerViews, body)
		clearFooter(this._fixedFooterViews, body)
		clearFooter(this._rfixedFooterViews, body)

		this._footerBuff = [];
		this._rfixedFooterBuff = [];
		this._fixedFooterBuff = [];

	},
	_layoutFooters: function (lm) {
		var grid = this.grid();
		var width = this.width();
		var rowGroup = this.model();
		var levelIndent = rowGroup.levelIndent();
		var fixCount = lm.fixedColCount();
		var rfixCount = lm.rfixedColCount();
		var hasFixed = fixCount > 0;
		var hasRightFixed = rfixCount > 0;
		var levelCount = this.levelCount();
		var cnt, i, view, footer, dirty, r, w;
		var cellMerge = grid.rowGroup().isFooterCellMerge();
		var groupedProvider = grid._items._groupedProvider;
		var footerOnly;

		cnt = this._footerViews.length;
		for (i = 0; i < cnt; i++) {
			this._footerViews[i].recycling = false;
		}
        while (cnt < this._footerItems.length) {
            view = this.$_borrowFooterView(this._footerItems[cnt]);
            this._bodyElement.addElement(view);
            this._footerViews.push(view);
            cnt++;
        }
        while (cnt > this._footerItems.length) {
            cnt--;
            this.$_removeFooterView(this._footerViews[cnt]);
            this._footerViews.pop();
        }
        for (i = 0; i < cnt; i++) {
            footer = this._footerItems[i];
            footerOnly = (footer._parent.isExpanded() ? groupedProvider._expandedAdornments == RowGroupAdornments.SUMMARY : RowGroupAdornments.isFooterOnly(groupedProvider._collapsedAdornments)) && !hasFixed;
            // var footerFirst = footerOnly && footer._parent.isExpanded() && !hasFixed;
            view = this._footerViews[i];
            view._fixed = false;
            dirty = (view.item !== footer);
            view.updateElement(footer, rowGroup.footerStyles());
            r = lm.itemBounds(footer.index() - grid.topIndex());
            w = footerOnly ? (footer.level() - 1) * levelIndent : lm.rowGroupLevels() * levelIndent + lm.fixedWidth();
            r.setLeft(w);
            r.width = footerOnly ? width - w - grid.leftPos() + (footer.level() - 2) * levelIndent : width - w - grid.leftPos();
            view.setRect(r);
            if (dirty || !view.recycling) {
                view.layoutContent(lm);
            }
        }
		// if (hasFixed) {
			cnt = this._fixedFooterViews.length;
			for (i = 0; i < cnt; i++) {
				this._fixedFooterViews[i].recycling = false;
			}
            while (cnt < this._footerItems.length) {
                view = this.$_borrowFixedFooterView(this._footerItems[cnt]);
                this._bodyElement.addElement(view);
                this._fixedFooterViews.push(view);
                cnt++;
            }
            while (cnt > this._footerItems.length) {
                cnt--;
                this.$_removeFixedFooterView(this._fixedFooterViews[cnt]);
                this._fixedFooterViews.pop();
            }
            for (i = 0; i < cnt; i++) {
                footer = this._footerItems[i];
                footerOnly = (footer._parent.isExpanded() ? groupedProvider._expandedAdornments == RowGroupAdornments.SUMMARY : RowGroupAdornments.isFooterOnly(groupedProvider._collapsedAdornments)) && hasFixed;
                view = this._fixedFooterViews[i];
                view._fixed = true;
                dirty = (view.item !== footer);
                view.updateElement(footer, rowGroup.footerStyles());
                r = lm.itemBounds(footer.index() - grid.topIndex());
                w = footerOnly ? (footer.level()-1) * levelIndent : lm.rowGroupLevels() * levelIndent;
                r.setLeft(w);
                r.width = footerOnly ? lm.fixedWidth() - grid.fixedOptions().colBarWidth() + (lm.rowGroupLevels() - footer.level()+1) * levelIndent :lm.fixedWidth() - grid.fixedOptions().colBarWidth();
                view.setRect(r);
                if (dirty || !view.recycling) {
                    view.layoutContent(lm);
                }
            }
		// }
		// if (hasRightFixed) {
			cnt = this._rfixedFooterViews.length;
			for (i = 0; i < cnt; i++) {
				this._rfixedFooterViews[i].recycling = false;
			}
            while (cnt < this._footerItems.length) {
                view = this.$_borrowRightFixedFooterView(this._footerItems[cnt]);
                this._bodyElement.addElement(view);
                this._rfixedFooterViews.push(view);
                cnt++;
            }
            while (cnt > this._footerItems.length) {
                cnt--;
                this.$_removeRightFixedFooterView(this._rfixedFooterViews[cnt]);
                this._rfixedFooterViews.pop();
            }
            var wbar = grid.fixedOptions().colBarWidth()
            for (i = 0; i < cnt; i++) {
                footer = this._footerItems[i];
                view = this._rfixedFooterViews[i];
                view._fixed = true;
                view._rightFixed = true;
                dirty = (view.item !== footer);
                view.updateElement(footer, rowGroup.footerStyles());
                r = lm.itemBounds(footer.index() - grid.topIndex());
                w = lm.rfixedLeft()-this._x;
                r.setLeft(w);
                r.width = lm.rfixedWidth();// - wbar;
                view.setRect(r);
                if (dirty || !view.recycling) {
                    view.layoutContent(lm);
                }
            }
		// }
	},
	_layoutHeads: function (lm) {
		var grid = this.grid();
		var x = 0;
		var w = grid.rowGroup().levelIndent();
		var h = lm.headerBounds().height;
		for (var i = 0, cnt = this._headElement.childCount(); i < cnt; i++) {
			var head = this._heads[i]; // RowGroupHeadCellElement;
			head.setBounds(x, 0, w, h);
			x += w;
			var model = grid.rowGroup().getHeadCell(i + 1);
			head.updateCell(model);
			head.layoutContent(lm);
		}
	},
	_layoutFoots: function (lm) {
		var grid = this.grid();
		var rowGroup = grid.rowGroup();
		var x = 0;
		var w = rowGroup.levelIndent();
		var h = lm.footerBounds().height;
		for (var i = 0,cnt = this._footElement.childCount(); i < cnt; i++) {
			var foot = this._foots[i]; // RowGroupFootCellElement;
			foot.setBounds(x, 0, w, h);
			x += w;
			var model = rowGroup.getFootCell(i + 1);
			foot.updateCell(model);
			foot.layoutContent(lm);
		}
	},
	_layoutSummarys: function (lm) {
		var grid = this.grid();
		var rowGroup = grid.rowGroup();
		var x = 0;
		var w = rowGroup.levelIndent();
		var h = lm.summaryBounds().height;
		for (var i = 0,cnt = this._summaryElement.childCount(); i < cnt; i++) {
			var summary = this._summarys[i]; // RowGroupSummaryCellElement;
			summary.setBounds(x, 0, w, h);
			x += w;
			var model = rowGroup.getSummaryCell(i + 1);
			summary.updateCell(model);
			summary.layoutContent(lm);
		}
	},
	_layoutBars: function (lm) {
		var y = lm.headerBounds().height + lm.summaryBounds().height;
		var w = this.grid().rowGroup().levelIndent() * lm.rowGroupLevels();
		var h = lm.indicatorBounds().height;
		this._barElement.setBounds(0, y, w, h);
		this._headerBarElement.setBounds(0, y, w, h);
		this._footerBarElement.setBounds(0, y, w, h);
	}
});
var /* @abstract */ GridMergeRule = defineClass("GridMergeRule", null, {
	init: function() {
		this._super();
	},
	parseInit: function (items, field, start, count, flags) {
		throwAbstractError();
	},
	parseBounds: function (items, field, start, end, flags) {
		throwAbstractError();
	}
});
var RowGroupMergeRule = defineClass("RowGroupMergeRule", GridMergeRule, {
	init: function() {
		this._super();
		this._level = 0;
		this._mergeMode = false;
	},
	parseInit: function (items, field, start, count, flags) {
		var itemCount = items.itemCount();
		count = Math.min(itemCount - start, count);
		if (count < 1) {
			return;
		}
		if (this._mergeMode) {
			this.$_parseMerged(items, field, start, count, flags);
		} else {
			this.$_parseNormal(items, field, start, count, flags);
		}
	},
	parseBounds: function (items, field, start, end, flags) {
		var item;
		var itemCount = items.itemCount();
		if (itemCount < 1) return;
		start = Math.max(0, start);
		while (start >= 0 && flags[start] <= 0) {
			item = items.getItem(start);
			if (item == this.$_getAncestor(item, this._level)) {
				break;
			}
			start--;
		}
		while (start <= end && flags[start] > 0) {
			start++;
		}
		if (start <= end) {
			if (this._mergeMode) {
				this.$_parseMergedBounds(items, field, start, end, flags);
			} else {
				this.$_parseNormalBounds(items, field, start, end, flags);
			}
		}
	},
	$_getAncestor: function (item, level) {
		var group = _cast(item, GroupItem);
		if (!group) {
			group = item.parent();
		}
		while (group.level() > level) {
			group = group.parent();
		}
		return group;
	},
	$_parseNormal: function (items, field, start, count, flags) {
		var itemCount = items.itemCount();
		if (itemCount < 1) return;
		var item = items.getItem(start);
		var prev = item;
		var p = start;
		var i = p + 1;
		flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			if (item.level() != prev.level() || item.constructor !== prev.constructor || item instanceof GroupFooter || item instanceof GroupItemImpl) {
				p = i;
			}
			flags[i] = p + 1;
			i++;
			prev = item;
		}
	},
	$_parseMerged: function (items, field, start, count, flags) {
		var itemCount = items.itemCount();
		if (itemCount < 1) return;
		var item = items.getItem(start);
		var group = this.$_getAncestor(item, this._level);
		var parent;
		var p = start;
		var i = flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			parent = this.$_getAncestor(item, this._level);
			if (parent != group) {
				if (i >= count) {
					break;
				}
				group = parent;
				p = i;
			}
			flags[i] = p + 1;
			i++;
		}
	},
	$_parseNormalBounds: function (items, field, start, end, flags) {
		var itemCount = items.itemCount();
		if (itemCount < 1) return;
		var item = items.getItem(start);
		var prev = item;
		var p = start;
		var i = p + 1;
		flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			if (item.level() != prev.level() || item.constructor !== prev.constructor) {
				p = i;
			}
			flags[i] = p + 1;
			i++;
			prev = item;
		}
	},
	$_parseMergedBounds: function (items, field, start, end, flags) {
		var itemCount = items.itemCount();
		if (itemCount < 1) return;
		var item = items.getItem(start);
		var group = this.$_getAncestor(item, this._level);
		var parent;
		var p = start;
		var i = p + 1;
		flags[p] = p + 1;
		while (i < itemCount) {
			item = items.getItem(i);
			parent = this.$_getAncestor(item, this._level);
			if (parent != group) {
				if (i > end) {
					break;
				}
				group = parent;
				p = i;
			}
			flags[i] = p + 1;
			i++;
		}
	}
});
RowGroupMergeRule.$_default = new RowGroupMergeRule();
RowGroupMergeRule.INIT_COUNT = 200;
RowGroupMergeRule.getDefault = function (groupLevel, mergeMode) {
	var rule = RowGroupMergeRule.$_default;
	rule._level = groupLevel;
	rule._mergeMode = mergeMode;
	return rule;
};
var ColumnMergeRule = defineClass("ColumnMergeRule", GridMergeRule, {
	init: function(criteria) {
		this._super();
		ColumnMergeRule.$_runtime = ColumnMergeRule.$_runtime || new ColumnMergeRuntime();
		this._runtime = ColumnMergeRule.$_runtime;
		this._exprNode = null;
		this.setCriteria(criteria);
	},
	criteria: null,
	setCriteria: function (value) {
		value = value ? value.trim() : null;
		if (value != this._criteria) {
			this._criteria = value;
			this._exprNode = value ? ExpressionParser.Default.parse(value, null) : null;
			this._changed();
		}
	},
	$_isRow: function (item, header) {
		var row = item instanceof GridRow && !(item instanceof DummyEditItem);
		if (row && !header) {
			var group = item.parent();
			row = group.isExpanded() || group.firstItem() != item;
		}
		return row;
	},
	parseInit: function (items, field, start, count, flags) {
		var header = false;
		var itemCount = items.itemCount();
		var valueCount = items.dataSource()._values.length;
		count = Math.min(itemCount - start, count);
		if (count < 1 || valueCount <= 0) {
			return;
		}
		this._runtime.setDataSource(items.dataSource());
		this._runtime.setColumn(this._column);
		var item = null;
		var i = start;
		while (i < itemCount) {
			item = items.getItem(i);
			if (this.$_isRow(item, header)) {
				break;
			}
			flags[i] = i + 1;
			i++;
		}
		if (i >= itemCount) {
			return;
		}
		var prev = $$_EMPTY_TEXT_VALUE, v;
		var isValue = this._exprNode.isIdentifier("value");
		var p = start = i;
		flags[p] = p + 1;
		if (item._dataRow >= valueCount) { return };
		if (isValue) {
			prev = item.getData(field);
		} else {
			this._runtime.setItem(item, field);
			prev = this._exprNode.evaluate(this._runtime);
		}				
		for (i = start + 1; i < itemCount; i++) {
			item = items.getItem(i);
			if (this.$_isRow(item, header)) {
				if (item._dataRow >= valueCount) { break };
				if (isValue) {
					v = item.getData(field);
				} else {
					this._runtime.setItem(item, field);
					v = this._exprNode.evaluate(this._runtime);
				}			
				if (v instanceof Date && prev instanceof Date ? +v != +prev : v != prev) {
					if (i >= count) {
						break;
					}
					p = i;
					prev = v;
				}
				flags[i] = p + 1;
			} else {
				if (i >= count) {
					break;
				}
				prev = $$_EMPTY_TEXT_VALUE;
				p = i;
				flags[i] = p + 1;
			}
		}
	},
	parseBounds: function (items, field, start, end, flags) {
		var header = false;
		var itemCount = items.itemCount();
		if (itemCount < 1) {
			return;
		}
		var isValue = this._exprNode.isIdentifier("value");
		var item, prev, i, y;
		var v = UNDEFINED;
		var p = Math.max(0, start);
		var s = p;
		var cont = -1;
		this._runtime.setDataSource(items.dataSource());
		this._runtime.setColumn(this._column);
		if (p > 0 && flags[p] <= 0) {
			item = items.getItem(p);
			if (this.$_isRow(item, header)) {
				if (isValue) {
					prev = items.getItem(p).getData(field);
				} else {
					this._runtime.setItem(item, field);
					prev = this._exprNode.evaluate(this._runtime);
				}				
				p--;
				while (p >= 0) {
					item = items.getItem(p);
					if (!this.$_isRow(item, header)) {
						break;
					}
					if (isValue) {
						v = item.getData(field);
					} else {
						this._runtime.setItem(item, field);
						v = this._exprNode.evaluate(this._runtime);
					}				
					if (v instanceof Date && prev instanceof Date ? +v != +prev : v != prev) { 
						break;
					}
					p--;
				}
				for (i = s - 1; i > p; i--) {
					flags[i] = p + 2;
				}
				if (s - 1 > p) {
					cont = p + 1;
				}
			} else {
				flags[p] = p + 1;
				for (i = s - 1; i > p; i--) {
					flags[i] = p + 2;
				}
				if (s - 1 > p + 1) {
					cont = p + 2;
				}
				p--;
				while (p >= 0 && flags[p] <= 0 && !this.$_isRow(items.getItem(p), header)) {
					flags[p] = p + 1;
					p--;
				}
			}
		}
		p = Math.max(0, start);
		while (p <= end && flags[p] > 0) {
			p++;
		}
		while (p <= end && !this.$_isRow(items.getItem(p), header)) {
			flags[p] = p + 1;
			p++;
		}
		if (p < end) {
			s = p;
			item = items.getItem(p);
			if (isValue) {
				prev = item.getData(field);
			} else {
				this._runtime.setItem(item, field);
				prev = this._exprNode.evaluate(this._runtime);
			}				
			p++;
			while (p < itemCount) {
				item = items.getItem(p);
				if (this.$_isRow(item, header)) {
					if (isValue) {
						v = item.getData(field);
					} else {
						this._runtime.setItem(item, field);
						v = this._exprNode.evaluate(this._runtime);
					}				
					if (v instanceof Date && prev instanceof Date ? +v != +prev : v != prev) {
						y = s;
						if (cont >= 0) {
							y = cont;
							cont = -1;
						}
						for (i = s; i < p; i++) {
							flags[i] = y + 1;
						}
						if (p >= end) {
							break;
						}
						prev = v;
						s = p;
					} else {
						flags[p] = s + 1;
					}
					p++;
				} else {
					y = s;
					if (cont >= 0) {
						y = cont;
						cont = -1;
					}
					for (i = s; i < p; i++) {
						flags[i] = y + 1;
					}
					flags[p] = p + 1;
					p++;
					while ((p < itemCount) && !this.$_isRow(items.getItem(p), header)) {
						flags[p] = p + 1;
						p++;
					}
					s = p;
					if (p >= end) {
						break;
					}
				}
			}
			if (p == itemCount && v instanceof Date && prev instanceof Date ? +v == +prev : v == prev) {
				y = (cont >= 0) ? cont : s;
				for (i = s; i < p; i++) {
					flags[i] = y + 1;
				}
			}
		}
	},
	_changed: function () {
	}
}, {
	INIT_COUNT: 200,
	createRule: function (source) {
		if (source && source.criteria) {
			return new ColumnMergeRule(source.criteria);
		}
		return null;
	}
}, function (f) {
	f.$_runtime = null;
});
var /* abstract */ GridMergeRoom = defineClass("GridMergeRoom", null, {
	init: function() {
		this._super();
	},
	scope: function () {
	},
	group: function () /* GroupItem */ {
	},
	headItem: function () {
		return -1;
	},
	tailItem: function () {
		return -1;
	},
	getHead: function (index) /* CellIndex */ {
	},
	getTail: function (index) /* CellIndex */ {
	},
	isHead: function (index) {
	},
	isTail: function (index) {
	},
	contains: function (index) {
	}
});
var ColumnMergeRoom = defineClass("ColumnMergeRoom", GridMergeRoom, {
	init: function(range) {
		this._super();
		this._column = range.C1();
		this._head = range.top();
		this._tail = range.bottom();
		this._group = null;
	},
	column: function () {
		return this._column;
	},
	head: function () {
		return this._head;
	},
	tail: function () {
		return this._tail;
	},
	scope: function () {
		return this._column;
	},
	group: function () {
		return this._group;
	},
	setGroup: function (value) {
		this._group = value;
	},
	headItem: function () {
		return this._head;
	},
	tailItem: function () {
		return this._tail;
	},
	getHead: function (index)/* CellIndex */ {
		if (!index) {
			index = this._column.grid().getIndex(this._head, this._column);
		} else {
			index.set(this._head, this._column);
		}
		return index;	
	},
	getTail: function (index)/* CellIndex */ {
		if (!index) {
			index = this._column.grid().getIndex(this._tail, this._column);
		} else {
			index.set(this._tail, this._column);
		}
		return index;	
	},
	isHead: function (index) {
		return (index.column() == this._column) && (index.I() == this._head);
	},
	isTail: function (index) {
		return (index.column() == this._column) && (index.I() == this._tail);	
	},
	contains: function (index) {
		return (index.column() == this._column) && (index.I() >= this._head) && (index.I() <= this._tail);	
	}
}, {
	$_rooms: [],
	$_roomCount: 0, // for debug
	borrow: function (range) {
		var room = ColumnMergeRoom.$_rooms.pop();
		if (!room) {
			room = new ColumnMergeRoom(range);
			_trace("########### M E R G E R O O M: " + ++ColumnMergeRoom.$_roomCount);
		} else {
			room._head = range.top();
			room._tail = range.bottom();
		}
		return room;
	},
	returnTo: function (room) {
		if (room) {
			var rooms = ColumnMergeRoom.$_rooms;
			for (var i = 0, cnt = rooms.length; i < cnt; i++) {
				if (rooms[i] === room) {
					return;
				}
			}
			rooms.push(room);
		}
	}
});
var ColumnMergeManager = defineClass("ColumnMergeManager", null, {
	init: function(column) {
		this._super();
		this._column = column;
		this._flags = null;
		this._rooms = [];
		this._inited = false;
	},
	count: function () {
		return this._rooms.length;
	},
	clear: function () {
		this._flags = null;
		this._rooms.splice(0, this._rooms.length);
		this._inited = false;
	},
	initialize: function (count) {
		if (this._inited) {
			return;
		}
		var grid = this._column.grid();
		var rowGroup = grid.rowGroup();
		var items = grid.itemSource();
		var dcolumn = _cast(this._column, DataColumn);
		var level = grid.getGroupLevel(dcolumn.dataIndex());
		var rule = grid.isGroupedColumn(dcolumn) ? RowGroupMergeRule.getDefault(level, grid.rowGroup().isMergeMode()) : this._column.mergeRule();
		if (rule) {
			var flags = this._flags = new Array(items.itemCount());
			for (var i = items.itemCount(); i--;) {
				flags[i] = 0;
			}
			rule._column = dcolumn;
			rule.parseInit(items, dcolumn.dataIndex(), grid.fixedOptions().rowCount(), count, flags);
		}
        this._inited = true;
	},
	refresh: function (first, last) {
		if (!this._inited || !this._flags || last < first) {
			this.initialize(ColumnMergeRule.INIT_COUNT)
		}
		var grid = this._column.grid();
		var fixed = grid.layoutManager().fixedItemCount();
		var items = grid.itemSource();
		var dcolumn = _cast(this._column, DataColumn);
		var level = grid.getGroupLevel(dcolumn.dataIndex());
		var rule = level > 0 ? RowGroupMergeRule.getDefault(level, grid.rowGroup().isMergeMode()) : this._column.mergeRule();
		var i = first;
		var range, room, item, group;
		var editItemMerging = grid.displayOptions().isEditItemMerging();
		this._rooms.length = 0;
		if (rule) {
			rule._column = dcolumn;
			rule.parseBounds(items, dcolumn.dataIndex(), first, last, this._flags);
		}
		while (i <= last) {
			range = this.$_checkMerge(items, this._column, i, this._rooms.length == 0, fixed);
			if (range) {
				if (level < 1) { // rowGrouping이 아닐 때
					// colMerge일때는 header/footer는 merge하지 않는다.
					item = items.getItem(range.R2());
					if (item instanceof MergedGroupHeader || item instanceof MergedGroupFooter) {
					} else {
						room = new ColumnMergeRoom(range);
						this._rooms.push(room);
					}
				} else { // rowGrouping일 때
					// item = items.getItem(range.top());
					// insert 중인 경우 range가 어떻게 나오나??
					item = editItemMerging ? items.source().getItem(range.top()) : items.getItem(range.top());
					if (item.level() >= level) {
						group = (item instanceof GroupItem) ? item : item.parent();
						while (group.level() > level) {
							group = group.parent();
						}
						room = new ColumnMergeRoom(range);
						room.setGroup(group);
						this._rooms.push(room);
					}
				}
				i = range.R2() + 1;
			} else {
				i += 1;
			}
		}
	},
	getRooms: function () {
		return this._rooms.slice();
	},
	scroll: function (delta) {
	},
	getRoom: function (index) {
		var rooms = this._rooms;
		for (var i = rooms.length - 1; i >=  0; i--) {
			if (rooms[i].contains(index))
				return rooms[i];
		}
		return null;
	},
	findRoom: function (itemIndex) {
		var rooms = this._rooms;
		for (var i = rooms.length - 1; i >=  0; i--) {
			if (itemIndex >= rooms[i]._head && itemIndex <= rooms[i]._tail) {
				return rooms[i];
			}
		}
		return null;
	},
	$_checkMerge: function (items, column, start, first, fixed) {
		if (items && column && start >= 0) {
			var p = start;
			var f = this._flags[p];
			var item = items.getItem(p);
			var options = column.grid().displayOptions();
			var editMerge = options.isEditItemMerging();
			if (f <= 0 || (ItemState.isEditing(item.itemState()) && !editMerge)) {
				return null;
			}
			if (first) {
				while (p > fixed) {
					if (this._flags[p - 1] < f || ItemState.isEditing(items.getItem(p - 1).itemState())) {
						break;
					}
					p--;
				}
			}
			var count = items.itemCount();
			var i = start + 1;
			var level, editing;
			while (i < count) {
				editing = ItemState.isEditing(items.getItem(i).itemState());
				if (this._flags[i] > f || this._flags[i] <= 0 || (editing && !editMerge)) {
					//if (this._flags[i] <= 0) debugger;
					if (i > p + 1) { // 적어도 아이템이 두 개 이상
						return GridRange.createRange(p, column, i - 1, column);
					} else {
						item = items.getItem(p);
						level = (column instanceof DataColumn) ? column.groupLevel() : -1;
						if (item instanceof MergedGroupHeader && item.isCollapsed()) {
							return GridRange.createRange(p, column, i - 1, column);
						}
						/*
						if (item instanceof MergedGroupHeader && item.level() == level && item.isCollapsed()) {
							return GridRange.createRange(p, column, i - 1, column);
						}
						*/
						if (item instanceof MergedGroupFooter && item.parent().level() == level &&
							(i == start + 1 || // 첫번째 행에 footer가 있을 때 expander를 표시할 수 있도록
							 item.parent().isCollapsed())) {
							return GridRange.createRange(p, column, i - 1, column);
						}
						if ((item instanceof MergedGroupHeader || item instanceof MergedGroupFooter) && item.parent().level() > level )  {
							return GridRange.createRange(p, column, i - 1, column);
						}
						return null;
					}
				} 
				i++;
			}
			if (i > p) {
				if (i > p + 1) { 
					return GridRange.createRange(p, column, i - 1, column);
				} else {
					item = items.getItem(p);
					level = (column instanceof DataColumn) ? column.groupLevel() : -1;
					if (item instanceof MergedGroupHeader && item.isCollapsed()) {
						return GridRange.createRange(p, column, i - 1, column);
					}
					/*
					if (item instanceof MergedGroupHeader && item.level() == level && item.isCollapsed()) {
						return GridRange.createRange(p, column, i - 1, column);
					}
					*/
					if (item instanceof MergedGroupFooter && item.parent().level() == level && 
						(i == start + 1 || item.parent().isCollapsed())) {
						return GridRange.createRange(p, column, i - 1, column);
					}
					if ((item instanceof MergedGroupHeader || item instanceof MergedGroupFooter) && item.parent().level() > level )  {
						return GridRange.createRange(p, column, i - 1, column);
					}
					return null;
				}
			}
		}
		return null;
	}
}, {
	MERGE_ROOMS: "mergeRooms"
});
var MergedGroupFooter = defineClass("MergedGroupFooter", GroupFooter, {
	init: function() {
		this._super();
	},
	isMerged: function () {
		return true;
	}
});
var MergedGroupHeader = defineClass("MergedGroupHeader", GroupItem, {
	init: function(groupField) {
		this._super();
		this._groupField = groupField;
		this._footer = null;
		this._hasFooter = true;
	},
	groupField: function () {
		return this._groupField;
	},
	footer: function () {
		return this._footer;
	},
	isMerged: function () {
		return true;
	},
	_addChild: function (item, index) {
		this._super(item, index);
		if (item instanceof GroupFooter) {
			this._footer = item;
		}
	}
});
var MergedDataCell = defineClass("MergedDataCell", DataCell, {
	init: function(name) {
		this._super(name || "mergedDataCell");
	},
	value: function() {
		var index = this.index();
		var item = index.item();
		if (item instanceof GridRow) {
			return this._super();
		} else {
			var group = (item instanceof GroupItem) ? item : item.parent();
			item = group.firstItem();
			return item.getData(index.dataField());
		}
	}
});
var MergedSeriesCell = defineClass("MergedSeriesCell", GridCell, {
	init: function() {
		this._super("mergedSeriesCell");
	},
	displayText: function () {
		return null;
	},
	value: function () {
		return UNDEFINED;
	}
});
var MergedDataCellElement = defineClass("MergedDataCellElement", DataCellElement, {
	init: function(dom) {
		this._super(dom, "mergedDataCellView");
		this._values = null;
		this._mergeRoom = null;
        this._topIndex = -1;
        this._bottomIndex = -1;
	},
	mergeRoom: function () {
		return this._mergeRoom;
	},
	setFocused: function (value) {
		if (value != this._focused) {
			this._focused = value;
			this._doLayoutHandles && this._doLayoutHandles();
			this.invalidate(false, true);
		}
	},	
	$_setMergeRoom: function (value) {
		this._mergeRoom = value;
	},
	_getButtonVisible: function (visibility) {
		var grid = this.grid();
		var vis;
		switch (visibility) {
			case ButtonVisibility.ROWFOCUSED:
				var focusedIndex = grid.focusedIndex() ? grid.focusedIndex()._itemIndex : -1;
				vis = this._mergeRoom ? this._mergeRoom._head <= focusedIndex && this._mergeRoom._tail >= focusedIndex : this._super(visibility);
				vis = vis && this._mergeRoom ? grid.getItem(focusedIndex) instanceof GridRow : this._super(visibility);
				break;
			default:
				vis = this._super(visibility);	
		}

		if (vis) {
			if (visibility == ButtonVisibility.VISIBLE || (visibility == ButtonVisibility.DEFAULT && !this._mouseEntered)) {
				var focusIndex = grid.focusedIndex().clone();
				if (this._innerIndex > 0) {
					focusIndex.incRow(-this._innerIndex);
				}
	            if (!CellIndex.areEquals(focusIndex, this._index)) 
	            	return false;
			}

			var index = this._innerIndex == -1 ? 0 : this._innerIndex;
			var item = grid.getItem(this._mergeRoom.headItem()+index);
			if (this._innerIndex == -1 && this.group() instanceof MergedGroupHeader ) {
				index = 0;
				for(var i = this._mergeRoom.headItem(), last = this._mergeRoom.tailItem(); i < last; i++) {
					item = grid.getItem(this._mergeRoom.headItem()+index); 
					if (item instanceof GridRow)
						break;
					index++;
				}
			}
			return item.canEdit();
		} else {
			return false;
		}
	},
	_doPrepareValue: function (cell) {
		this._super(cell);
	},
	_doPrepareElement: function (styles) {
		this._super(styles);
	},
	_doUpdateContent: function (cell) {
		this._super(cell);
	},
	_doRender: function (g, r) {
		this._super(g, r);
		/*
		if (this._innerIndex >= 0) {
			var room = this._mergeRoom;
			var h = r.height / (room.tail() - room.head() + 1);
			r.y += h * this._innerIndex;
			r.height = h;
			g.drawRectI(null, SolidPen.RED, r);
		}
		*/
	},
	/*merged일 경우에는 Blank 상태와 상관없이 선을 그림 - redmine #246.*/
	_drawBordersWithBlank: function (g, r, blankState) {
		this._super(g, r, BlankState.NONE);
	},
	clip: function (g) {

		var grid = this.grid();
		if (grid.fixedOptions().colCount() > 0) {
			this._super(g);
		} else {
			var gr = grid.layoutManager()._gridBounds;
			var br = this.boundsBy();
			this.getClientRect(this._drawRect);
			var dr = this._drawRect.clone();
			if (br.x < gr.x) {
				var sx = gr.x - br.x + grid._x;
				dr.x += sx;
				dr.width -= sx;
			}
			g.clipRect(dr);
		}
	},
});
var MergedSeriesCellElement = defineClass("MergedSeriesCellElement", SeriesCellElement, {
	init: function(dom) {
		this._super(dom, "mergedSeriesCellElement");
		this._values = null;
		this._mergeRoom = null;
        this._topIndex = -1;
        this._bottomIndex = -1;
	},
	value: function() {
		return this._values;
	},
	setValue: function (value) {
		if (_isArray(value) && !_equalsArray(value, this._values)) {
			this._values = value;
			this.invalidate();
		}
	},
	mergeRoom: function () {
		return this._mergeRoom;
	},
	$_setMergeRoom: function (value) {
		this._mergeRoom = value;
	}
});
var MergedHeaderElement = defineClass("MergedHeaderElement", ItemElement, {
	init: function(dom) {
		this._super(dom, "mergedHeaderView");
		this._cellView = new RowGroupHeaderCellElement(dom);
		this.addElement(this._cellView);
	},
	setFixed: function (fixed) {
	},
	setRightFixed: function (fixed) {
	},
	_doUpdateElement: function (styles) {
		this._super(styles);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
		this._cellView.updateCell(this.grid().rowGroup().getHeaderCell(this.index()));
		this._cellView.setRect(this.clientRect());
	},
	_doRender: function (g, r) {
		/*
		g.beginFill(0xffff00, 0.2);
		g.drawRect(r.x, r.y, r.width, r.height);
		g.endFill();
		*/
	}
});
var MergedFooterElement = defineClass("MergedFooterElement", ItemElement, {
	init: function(dom, fixed) {
		this._super(dom, "mergedFooterView");
		this._fixed = fixed;
		this._cells = [];
	},
	destroy:  function() {
		this._destroying = true;
		this._cells = null;
		this._super();
	},
	fixed: false,
	rightFixed: false,
    setFixed: function(value) {
        this._fixed = value;
    },
    setRightFixed: function (value) {
    	this._rightFixed = value;
    },
	_doUpdateElement: function(styles) {
		this._super(styles);
		this._level = this.item().parent().level();
	},
	_doMeasure: function(grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doLayoutContent: function(lm) {
		this.$_prepareCells(lm);
		this.$_layoutCells(lm);
	},
	_doRender: function(g, r) {
	},
	$_prepareCells: function (lm) {
		var grid = this.grid();
        var start = Math.max(this._level, lm.firstCol(this._fixed, this._rightFixed));
        var end = lm.lastCol(this._fixed, this._rightFixed);
        var rowGroup = this._rowGroup = grid.rowGroup();
		var mergeManager = grid.groupFooterMergeManager();
		var merged = mergeManager.count() > 0;

		if (grid.isColumnLayoutChanged()) {
			this.clear();
			this._cells = [];
		}
		this.hideAll();

		for (i = start; i <= end; i++) {
			var room = merged && mergeManager.findRoom(this._level, i);
			this.$_prepareCell(lm, i, room);
		}
		if (merged) {
			var rooms = mergeManager.getRoomNames(this._level);
			for (var i = 0; i < rooms.length; i++) {
				var room = mergeManager.getRoom(this._level, rooms[i]);
				if (room && ((start > room.base() && start <= room.last()) ||
					         (end   < room.base() && end   >= room.start()))) {
					this.$_prepareCell(lm, room.base(), room);
				}
			}
		}
	},
	$_prepareCell: function(lm, col, room) {
		var grid = this.grid();
		var rowGroup = this._rowGroup;
		var column = lm.getColumn(col);
		var view = _cast(this._cells[column.$_hash], CellElement);

		if (!view) {
			if (column instanceof ColumnGroup) {
				view = new GroupFooterGroupCellElement(this._dom);
			} else {
				view = new GroupFooterCellElement(this._dom);
			}
			this._cells[column.$_hash] = view;
			this.addElement(view);
		}
		view.setVisible(!room || room.base() == col);
		if (column instanceof ValueColumn)
			view.setTextVisible(!room || room.base() == col); 
		var index = CellIndex.temp(grid, this.index(), column);
		var model = rowGroup.getFooterCell(index);
        view.updateCell(model);
	},
	$_layoutCells: function (lm) {
		var view;
		var r, sr, er;
		var fixed = lm.fixedColCount();
		var start = Math.max(this._level, lm.firstCol(this._fixed, this._rightFixed));
		var end = lm.lastCol(this._fixed, this._rightFixed);
		var x = this.x();
		var h = this.height();
		var mergeManager = this.grid().groupFooterMergeManager();
		var merged = mergeManager.count() > 0;
		for (var i = start; i <= end; i++) {
			var view = this._cells[lm.getColumn(i).$_hash];
			var r = lm.columnBounds(i);
			if (merged && (room = mergeManager.findRoom(this._level, i))) {
				sr = lm.columnBounds(room.start());
				er = lm.columnBounds(room.last());

				r.width = er.right() - sr.x;
				r.x = sr.x;
			}
			r.x -= x;
			r.height = h;
			view.setRect(r);
			view.layoutContent(lm);
		}
		if (merged) {
			var rooms = mergeManager.getRoomNames(this._level);
			for (var i = 0; i < rooms.length; i++) {
				var room = mergeManager.getRoom(this._level, rooms[i]);
				if (room && ((start > room.base() && start <= room.last()) ||
					         (end   < room.base() && end   >= room.start()))) {
					sr = lm.columnBounds(room.start());
					r = sr;	
					er = lm.columnBounds(room.last());	
					r.width = er.right() - sr.x;
					r.height = h;
					r.x -= x;
					view = this._cells[lm.getColumn(room.base()).$_hash];
					view.setRect(r);
					view.layoutContent(lm);	
				}
			}		
		}
	}
});
var GridMergeHeaderElement = defineClass("GridMergeHeaderElement", VisualObjectElement, {
	init: function(dom) {
		this._super(dom, "mergedGroupHeadersContainer", null);
		this._views = [];
		this._headerMap = {};
		this._headIndex = null;
		this._tailIndex = null;
	},
	destroy: function() {
		this._destroying = true;
		this._views = null;
		this._headerMap = null;
		this._headIndex = null;
		this._tailIndex = null;
		this._super();
	},
	clearHeaders: function() {
		var i;
		var view;
		this._views = [];
		this._headerMap = {};
		for (i = this.childCount() - 1; i >= 0; i--) {
			view = this.getChild(i);
			view.setVisible(false);
			this._views.push(view);
		}
	},
	addHeader: function(header) {
		var view = this._headerMap[header._id];
		if (!view) {
			view = this._views.length > 0 ? this._views.pop() : null;
			if (!view) {
				view = new MergedHeaderElement(this._dom);
				this.addElement(view);
				_trace("########### M E R G E H E A D E R: " + this.childCount());
			}
			view._item = header;
			this._headerMap[header._id] = view;
		}
		view.setVisible(true);
	},
	getHeaderView: function(header) {
		return this._headerMap[header._id];
	},
	getCellView: function(index) {
		var header = _cast(index.item(), MergedGroupHeader);
		if (header) {
			return this._headerMap[header._id];
		}
		return null;
	},
	isLayer: function () {
		return true;
	},
	_doAttached: function (parent) {
		this._super(parent);
		this._headIndex = new CellIndex(this.grid());
		this._tailIndex = new CellIndex(this.grid());
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
		this.$_layoutHeaders(lm);
	},
	_doDraw: function(g) {
	},
	$_layoutHeaders: function (lm) {
		var grid = this.grid();
		var styles = grid.rowGroup().headerStyles();
		var leftPos = lm.leftPos();
		var topIndex = grid.topIndex();
		var fixedCols = lm.fixedColCount();
		var fixedItems = lm.fixedItemCount();
		var fixedWidth = lm.fixedWidth();
		var w = this.width();
		for (var h in this._headerMap) {
			var view = this._headerMap[h];
			var header = view.item();
            var idx = header.index();
			view.updateElement(header, styles);
			idx = (idx < fixedItems) ? idx : idx - topIndex;
			var r = lm.itemBounds(idx);
			r.width = w;
			var c = header.level() - 1;
			var x = lm.columnBounds(c).right();
			if (fixedCols > 0) {
				if (c >= fixedCols) {
					x = Math.max(x + fixedWidth - leftPos, fixedWidth);
				} else if (c == fixedCols - 1) {
					x = fixedWidth;
				}
			} else if (fixedCols == 0) {
				x -= leftPos;
			}
			r.setLeft(x);
			r.width -= leftPos;
			view.setRectI(r);
			view.layoutContent(lm);
		}
		this._views = null;
	}
});
var GridMergeElement = defineClass("GridMergeElement", VisualObjectElement, {
	init: function (dom, fixed, rightFixed) {
		this._super(dom, "mergeLayer", null);
		this._fixed = fixed;
		this._rightFixed = rightFixed;
		this._footerLayer = new LayerElement(dom, "mergedFooterLayer");
		this.addElement(this._footerLayer);
		this._cellLayer = new LayerElement(dom, "mergedCellLayer");
		this.addElement(this._cellLayer);
		this._roomMap = {};
		this._scopeViews = {};
		this._footerMap = {};
		this._footerViews = [];
	},
	destroy: function() {
		this._destroying = true;
		this._roomMap = null;
		this._scopeViews = null;
		this._footerMap = null;
		this._footerViews = null;
		this._super();
	},
	isFixed: function () { return this._fixed; },
	isRightFixed: function () { return this._rightFixed; },
	clearFooters: function () {
		this._footerViews = [];
		this._footerMap = {};
		for (var i = this._footerLayer.childCount() - 1; i >= 0; i--) {
			var view = this._footerLayer.getChild(i);
			view.setVisible(false);
			this._footerViews.push(view);
		}
	},
	addFooter: function (footer) {
		var view = this._footerMap[footer._id];
		if (!view) {
			view = this._footerViews.pop();
			if (!view) {
				view = new MergedFooterElement(this._dom, this._fixed, this._rightFixed);
				this._footerLayer.addElement(view);
				_trace("########### M E R G E F O O T E R: " + this._footerLayer.childCount());
			}
			view._item = footer;
			this._footerMap[footer._id] = view;
		}
		view.setVisible(true);
	},
	clearRooms: function () {
		this._roomMap = {};
		for (var i = this._cellLayer.childCount() - 1; i >= 0; i--) {
			var view = this._cellLayer.getChild(i);
			view.setVisible(false);
			var room = view.mergeRoom();
			var views = this.$_getViews(room.scope());
			if (views.indexOf(view) < 0) {
				views.push(view);
			}
		}
	},
	addColumnRooms: function (column, rooms) {
		var views = this.$_getViews(column);
		for (var i = rooms.length - 1; i >= 0; i--) {
			var room = rooms[i];
            var view;
			if (views.length > 0) {
				view = views.pop();
			} else {
				view = this._createElement(room);
				this._cellLayer.addElement(view);
				_trace("########### M E R G E C E L L: " + this._cellLayer.childCount());
			}
			view.setVisible(true);
			view.$_setMergeRoom(room);
			this._roomMap[room.$_hash] = view;
		}
	},
	getCellView: function (index) {
		for (var r in this._roomMap) {
			var view = this._roomMap[r];
			var room = view.mergeRoom();
            if (room.contains(index)) {
				return view && view.isVisible() ? view : null;
			}
		}
		var item = index.item();
		if (item instanceof MergedGroupFooter) {
			return this._footerMap[item._id];
		}
		return null;
	},
	getFooterView: function (footer) {
		return this._footerMap[footer._id];
	},
	isLayer: function () {
		return true;
	},
	_doAttached: function (parent) {
		this._super(parent);
		var grid = this.grid();
		this._headIndex = new CellIndex(grid);
		this._tailIndex = new CellIndex(grid);
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);	
	},
	_doLayoutContent: function (lm) {
		this.$_layoutCells(lm);
		this.$_layoutFooters(lm);
	},
	_doDraw: function(g) {
	},
	$_getViews: function (scope) {
		var views = this._scopeViews[scope.$_hash];
		if (!views) {
			views = [];
			this._scopeViews[scope.$_hash] = views;
		}
		return views;
	},
	_createElement: function (room)/* DataCellElement */ {
		var view = null;
		if (room instanceof ColumnMergeRoom) {
			var column = room.column();
			if (column instanceof SeriesColumn) {
				view = new MergedSeriesCellElement(this._dom);
			} else if (column instanceof DataColumn) {
				view = new MergedDataCellElement(this._dom);
			}
		}
		return view;
	},
	$_layoutFooters: function (lm) {
		var rowGroup = this.grid().rowGroup();
		var styles = rowGroup.footerStyles();
		var fixedCols = lm.fixedColCount();
		var rfixedCol = lm.rfixedStartCol();
		var fixedItems = lm.fixedItemCount();
		var topIndex = lm.topIndex();
		var itemCount = lm.itemCount();
		var fixed = this.isFixed();
		var rightFixed = this.isRightFixed();
        var leftPos = fixedCols > 0 ?  lm.leftPos() : 0;
		var cellMerge = rowGroup.isFooterCellMerge();
		for (var f in this._footerMap) {
			var view = this._footerMap[f];
			var footer = view._item;
            var idx = footer.index();
            var r, c, x;
            view.updateElement(footer, styles);
			idx = (idx < fixedItems) ? idx : idx - topIndex;
			if (idx < 0 || idx >= itemCount + fixedItems) {
				throw new Error("Invalid MergedGroupFooter index: " + idx);
			}
			r = lm.itemBounds(idx, fixed, rightFixed);
			if (rightFixed) {
				c = Math.max(rfixedCol, footer.parent().level());
				x = lm.columnBounds(c).x;
				r.setLeft(x);				
			} else if (fixed) {
				c = footer.parent().level();
				x = lm.columnBounds(c).x;
				r.setLeft(x);
			} else {
				c = Math.max(fixedCols, footer.parent().level());
				x = lm.columnBounds(c).x;
				r.setLeft(x);
			}
			view.setRect(r);
            /*
            if (!fixed) {
                _trace('%%%%%%%%%%%%%%% ' + r.x);
                if (leftPos > 0 && r.x > leftPos) {
                    r.y = 0;
                    r.x = leftPos;
                    r.width -= leftPos;
                    view.setMask(r);
                } else {
                    view.setMask(null);
                }
            }
            */
            view.setFixed(this._fixed);
            view.setRightFixed(this._rightFixed);
			view.layoutContent(lm);
		}
		this._footerViews = null;
	},
	$_layoutCells: function (lm) {
		var grid = this.grid();
		var merged = grid.rowGroup().isMergeMode();
		var mergeExpander = grid.rowGroup().isMergeExpander();
		var topItem = grid.topItem();
		var topIndex = grid.topIndex();
		var itemCount = lm.itemCount();
		var fixedItems = lm.fixedItemCount();
		for (var hash in this._roomMap) {
			var view = this._roomMap[hash];
			var room = view.mergeRoom();
            var col, cell, r, x, w, i, y, i2, group, h, views;
			room.getHead(this._headIndex);
			if (this._headIndex.I() - topItem > itemCount - 1) {
				view.setVisible(false);
				views = this.$_getViews(room.column());
				if (views.indexOf(view) < 0) {
					views.push(view);
				}
				continue;
			}
			room.getTail(this._tailIndex);
			col = this._headIndex.column();
			cell = grid.body().getCell(this._headIndex, true);
			view.updateCell(cell);
			if (col.parent() instanceof RootColumn) {
				r = lm.columnBounds(col.displayIndex());
			} else {
				r = lm.dataColumnBounds(col);
			}
			x = r.x;
			w = r.width;
			i = Math.min(fixedItems + itemCount - 1, Math.max(fixedItems, this._headIndex.I() - topIndex));
			r = lm.itemBounds(i);
            view._topIndex = i;
			y = r.y;
			i2 = this._tailIndex.I();
			group = room.group();
			i2 = Math.min(fixedItems + itemCount - 1, Math.max(fixedItems, i2 - topIndex));
            view._bottomIndex = i2;
			r = lm.itemBounds(i2);
			h = r.bottom() - y;
			view.setBoundsI(x, y, w, h);
			if (view instanceof MergedDataCellElement) {
				view.setExpanderVisible(merged && mergeExpander && group != null);
			}
			view.layoutContent(lm);
		}
	}
});

var FooterMergeRoom = defineClass("FooterMergeRoom", null, {
	init: function(name, base, start, count, colMap) {
		this._super();
		this._name = name;
		this._base = base;
		this._start = start;
		this._count = count;
		this._colMap = colMap;
	},
	name: null,
	base: -1,
	start: -1,
	count: 0,
	last: function () {
		return this._start + this._count - 1;
	},
	startColumn: function() {
		return this._colMap[this._start];
	},
	lastColumn: function() {
		return this._colMap[this.last()];
	},
	containsColumn: function(column) {
		for (var i in this._colMap) {
			var col = this._colMap[i];
			if (col.$_hash == column.$_hash) {
				return column;
			}
		}
		return null;
	},
	baseColumn:function() {
		return this._colMap["base"]
	}
});

var RowGroupFooterMergeRoom = defineClass("RowGroupFooterMergeRoom", FooterMergeRoom, {
	init: function(level, name, base, start, count) {
		this._super(name, base, start, count);
		this._groupLevel = level;
	},
	groupLevel: -1
});

var FooterMergeManager = defineClass("FooterMergeManager", null, {
	init: function () {
		this.clearRooms();
	},
	clearRooms: function () {
		this._footerRooms = {};
		this._length = 0;
	},
	count: function () {
		return this._length;
	},
	getRoom: function(name) {
		return this._footerRooms[name];
	},
	getRoomNames: function () {
		return Object.keys(this._footerRooms);
	},
	findRoomBy: function(column) {
		for (var r in this._footerRooms) {
			var room = this._footerRooms[r];
			if (room.containsColumn(column)) {
				return room;
			}
		}
	},
	findRoom: function (colIndex) {
		for (var r in this._footerRooms) {
			var room = this._footerRooms[r];
			if (colIndex >= room.start() && colIndex <= room.last()) {
				return room;
			}
		}
		return null;
	},
	addRoom: function (name, base, start, count, colMap) {
		this._footerRooms[name] = new FooterMergeRoom(name, base, start, count, colMap);
		this._length++;
	},
	setRoom: function (name, base, start, count) {
		var room = this._footerRooms[name];
		if (room) {
			room._base = base;
			room._start = start;
			room._count = count;
		} else {
			this.addFooter(name, base, start, count);
		}
	}, 
	// fixed인경우 fixed끼리 merge가능 
	// 동일 group에 해당하는 것끼리만 merge가능.
	// horizental인경우만 가능.
	buildRooms: function (grid, cells) {
		this.clearRooms();
		var fixedCount = grid.fixedOptions().colCount();
		var fixedBase, rFixedBase, baseGroup, fixedCol, rFixedCol, col;
		if (cells) {
			for (var i = 0, len = cells.length; i < len; i++) {
				var baseCol = grid.columnByName(cells[i][0]);
				if (!baseCol || baseCol instanceof ColumnGroup) continue;
				var base = baseCol.displayIndex();
				fixedBase = baseCol.root().displayIndex() < fixedCount;
				rFixedBase = baseCol.isRightFixed();
				baseGroup = baseCol.group();
				if (baseGroup && baseGroup.orientation() == ColumnGroupOrientation.VERTICAL) { continue }
				var indexes = [];
				var colMap = {};
				indexes.push(base);
				colMap["base"] = baseCol;
				colMap[base] = baseCol;
				for (var j = 1, len2 = cells[i].length; j < len2; j++) {
					if (col = grid.columnByName(cells[i][j])) {
						fixedCol = col.root().displayIndex() < fixedCount;
						if (col && col.group() == baseGroup && fixedBase == fixedCol && rFixedBase == col.isRightFixed() && col instanceof ValueColumn) {
							var index = col.displayIndex();
							indexes.push(index);
							colMap[index] = col;
						}
					}
				}
				if (indexes.length > 1) {
					var min = base;
					var max = base;
					indexes.sort(function(a, b) {return a - b}); 
					var baseIndex = indexes.indexOf(base);
					for (var j = baseIndex-1; j >= 0; j--) {
						if (indexes[j] == indexes[j+1]-1) {
                            min = indexes[j];
                        } else {
                        	break;
                        }
                    }
					for (var j = baseIndex+1; j < indexes.length; j++) {
						if (indexes[j] == indexes[j-1]+1) {
							max = indexes[j];
						} else {
							break;
						}
					}
					if (max > min) {
						for (var j = 0, cnt = indexes.length; j < cnt ; j++) {
							(indexes[j] < min || indexes[j] > max) && (delete colMap[indexes[j]]);
						}
						this.addRoom(cells[i][0], base, min, max-min+1, colMap);
					}
				}
			}
		}
	}
});

var RowGroupFooterMergeManager = defineClass("RowGroupFooterMergeManager", null, {
	init: function () {
		this.clearRooms();
	},
	destroy: function() {
		this._groupFooterRooms = null;
		this._super();
	},
	clearRooms: function () {
		this._groupFooterRooms = [];
	},
	count: function () {
		return this._groupFooterRooms.length;
	},
	getRoom: function (level, name) {
		return this._groupFooterRooms[level] ? this._groupFooterRooms[level][name] : null;
	},
	getRoomNames: function (level) {
		return this._groupFooterRooms[level] ? Object.keys(this._groupFooterRooms[level]) : [];
	},
	findRoom: function (level, colIndex) {
		if (this._groupFooterRooms[level]) {
			for (var r in this._groupFooterRooms[level]) {
				var room = this._groupFooterRooms[level][r];
				if (colIndex >= room.start() && colIndex <= room.last()) {
					return room;
				}				
			}
		}
		return null;
	},
	addRoom: function (level, name, base, start, count) {
		if (!this._groupFooterRooms[level])
			this._groupFooterRooms[level] = {};
		this._groupFooterRooms[level][name] = new RowGroupFooterMergeRoom(level, name, base, start, count);
	},
	setRoom: function  (level, name, base, start, count) {
		var room = this._groupFooterRooms[level][base];
		if (room) {
			room._start = start;
			room._count = count;			
		} else {
			this.addGroupFooter(level, name, base, start, count);
		}
	},
	buildRooms: function (grid) {
		var rowGroup = grid.rowGroup();
		var fixedCount = grid.fixedOptions().colCount();
		var level;

		this.clearRooms();

		if (rowGroup && rowGroup.isFooterCellMerge()) {
			var mergeMode = rowGroup.isMergeMode();
			var flds = grid.getGroupByFields();
			var ds = grid.dataSource();
			var grpFields;
			if (flds && ds) {
				grpFields = [];
				for (var i = 0; i < flds.length; i++) {
					grpFields.push(ds.getOrgFieldName(flds[i]));
				}
			}

			var baseCol = mergeMode ? 1 : 0
			var startCol = 0;
			var groups = [];
			if (grpFields) {
				for (var i = 0, cnt = grid.getVisibleColumnCount(); i < cnt; i++) {
					var col = grid.getVisibleColumn(i);
					var fieldName = col.fieldName && col.fieldName();
					if (fieldName && (level = grpFields.indexOf(fieldName)) > -1) {
						if (groups.length == 0)
							startCol = i;
						groups.push({name: fieldName, col: i, level: level+1});
					} else if (groups.length > 0) {
						break;
					}
				}
			}
			startCol += baseCol;

			for (var i = 0; i < groups.length; i++) {
				var start = mergeMode ? startCol + i : startCol;
				var count = mergeMode ? groups.length - i - 1 : groups.length;
				if (fixedCount > start)
					count = Math.min(fixedCount-start,count);
				if (count > 1 && groups[i].col + baseCol < start + count)
					this.addRoom(groups[i].level, groups[i].name, groups[i].col + baseCol, start, count);
			}
		}
	}
});

var GridBaseOptions = defineClass("GridBaseOptions", null, {
	init: function (grid) {
		this._super();
		this._grid = grid;
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		for (var attr in this) {
			if (this[attr] instanceof VisualStyles || this[attr] instanceof SolidPen || this[attr] instanceof SolidBrush) {
				this[attr] = null;
			}
		}
		this._super();
	},
	grid: function () {
		return this._grid;
	},
	_invalidateOwner: function () {
		this._grid && this._grid.invalidate();
	},
	_layoutOwner: function () {
		this._grid && this._grid.invalidateLayout();
	},
	_refreshOwner: function () {
		this._grid && this._grid.refreshView();
	},
	_invalidateEditor: function () {
		this._grid && this._grid.editController().invalidateEditor();
		this._grid && this._grid.editController().reprepareEditor(this._grid.focusedIndex());
	}
});
var RowHoverMask = defineClass("RowHoverMask", null, {
	init : function(grid) {
		this._super(grid);
		this._visible = false;
		this._styles = grid && grid._body && grid._body._rowHoverStyles;
		this._hoverMask = RowFocusMask.ROW;
	},
	destroy: function() {
		this._destroying = true;
		this._styles = null;
	},
	visible: false,
	hoverMask: RowFocusMask.ROW,
	styles: null,
	setStyles: function (value) {
		if (value != this._styles) {
			if (!value) {
				this._styles.clearValues();
			} else {
				this._styles.extend(value);
			}
		}
	}
});
var RowBlockMask = defineClass("RowBlockMask", null, {
	init : function(grid) {
		this._super(grid);
		this._visible = false;
		this._styles = new VisualStyles(this, "rowHoverStyles", GridStyleSheet.Default && GridStyleSheet.Default.bodyRowHover());
		this._BlockMask = RowFocusMask.ROW;
		this._startIndex = -1;
		this._endIndex = -1;
	},
	destroy: function() {
		this._destroying = true;
		this._styles = null;
	},
	visible: false,
	blockMask: RowFocusMask.ROW,
	styles: null,
	startIndex: null,
	endIndex: null,
	setStyles: function (value) {
		if (value != this._styles) {
			if (!value) {
				this._styles.clearValues();
			} else {
				this._styles.extend(value);
			}
		}
	}
});
var RowFocusOption = defineClass("RowFocusOption", GridBaseOptions, {
	init: function(grid) {
		this._super(grid);
		this._visible = false;
		this._styles = grid && grid._body && grid._body._rowFocusStyles;
		this._rowFocusMask = RowFocusMask.ROW;
	},
	destroy: function() {
		this._destroying = true;
		this._styles = null;
	},
	visible: false,
	rowFocusMask: null,
	styles: null,
	setStyles: function(value) {
		if (value != this._styles) {
			if (!value) {
				this._styles.clearValues();
			} else {
				this._styles.extend(value);
			}
		}
	},
	assign: function(source) {
		this._super(source);
		var displayOptions = this._grid.displayOptions();
		displayOptions._rowFocusVisible = this._visible;
		displayOptions._rowFocusBackgroundBrush = this._styles.background();
		displayOptions._rowFocusMask = this._rowFocusMask;
		displayOptions._refreshOwner();
	}
});
var DisplayOptions = defineClass("DisplayOptions", GridBaseOptions, {
	init: function (grid) {
		this._super(grid);
		this._focusPen = new SolidPen(this._focusColor, this._focusBorderWidth);
		this._innerFocusPen = new SolidPen(this._innerFocusColor, 1, [1,1]);
		this._focusActivePen = new SolidPen(this._focusActiveColor, this._focusBorderWidth);
		this._focusBackgroundBrush = new SolidBrush(this._focusBackground);
		this._rowFocusBackgroundBrush = new SolidBrush(this._rowFocusBackground);
		this._rowHoverMask = new RowHoverMask(grid);
		this._rowBlockMask = new RowBlockMask(grid);
		this._rowFocusOption = new RowFocusOption(grid);
		this._scrollBarStyles = new VisualStyles(this, "scrollBarStyles", GridStyleSheet.Default && GridStyleSheet.Default.scrollBar()).addListener(this);
		this._scrollThumbStyles = new VisualStyles(this, "scrollThumbStyles", GridStyleSheet.Default && GridStyleSheet.Default.scrollThumb()).addListener(this);
		this._scrollButtonStyles = new VisualStyles(this, "scrollButtonStyles", GridStyleSheet.Default && GridStyleSheet.Default.scrollButton()).addListener(this);
	},
	destroy: function() {
		this._heightMeasurer = null;
		this._super();
	},
	columnResizable: true,
	columnMovable: true,
	parentChangable: false,
	defaultColumnWidth: 120,
	fitStyle: GridFitStyle.NONE,
	rowResizable: false,
	eachRowResizable:false,
	rowHeight: 0,
	minRowHeight: 4,
	maxRowHeight: 0,
	hscrollBar: true,
	vscrollBar: true,
	liveScroll: true,
	horizLiveScroll: true,
	scrollDuration: 0,
	hscrollDuration: 0,
	hintDuration: 0,
	emptyShowTooltip:false,
    rowChangeDelay: 0,
	horzScrollStep: 8,
	emptyMessage: "이 곳에 표시할 메시지를 DisplayOptions.emptyMessage 속성으로 설정합니다.",
	showEmptyMessage: false,
	heightMeasurer: null,
	fitWhenResized: true,
	focusVisible: true,
	rowFocusOption: null,
	rowFocusVisible : false,
	rowFocusMask : RowFocusMask.ROW,
	rowFocusBackground: null,
	wheelEnabled: true,
	wheelScrollLines : 3,
	wheelScrollHorz: 16,
	wheelAccelDelay : 0,
	wheelAccelScroll : null,
	wheelEventPropagate : true,
    rightClickable: true,
    editItemMerging: false,
    showInnerFocus: true,
    toastZIndex:3000,
    focusBackground:null,
    focusColor: "#ff333333",
    innerFocusColor: "#ff333333",
    focusActiveColor: "#ff5292f7",
    focusBorderWidth: 2,
	rowHoverMask: null,
	rowBlockMask: null,
	useCssStyleProgress: false,
	popupDropdownCount: 0,
	drawBorderTop: true,
	drawBorderBottom: true,
	drawBorderLeft: true,
	drawBorderRight: true,
	drawLastColumnRight:true,
	scrollBarStyles: null,
	scrollThumbStyles: null,
	scrollButtonStyles: null,
	scrollMessageCallback: null,
	cursorCallback: null,
	setFitStyle: function (value) {
		if (value != this._fitStyle) {
			this._grid._columnWidthsDirty = this._grid._columnWidthsDirty || value === GridFitStyle.NONE;
			this._fitStyle = value;
			this._refreshOwner();
		}
	},
	setRowHeight: function (value) {
		if (isNaN(value)) return;
		value = Math.max(0, value);
		if (value != this._rowHeight) {
			this._rowHeight = value;
			this._refreshOwner();
		}
	},
	setMinRowHeight: function (value) {
		value = Math.max(0, value);
		if (value != this._minRowHeight) {
			this._minRowHeight = value;
			this._refreshOwner();
		}
	},
	setMaxRowHeight: function (value) {
		value = Math.max(0, value);
		if (value != this._maxRowHeight) {
			this._maxRowHeight = value;
			this._refreshOwner();
		}
	},
	setHeightMeasurer: function (value) {
		if (value != this._heightMeasurer) {
			this._heightMeasurer = value;
			if (value == "fixed") {
				this._grid.setHeightMeasurer(FixedHeightsMeasurer.Default);
			} else {
				this._grid.setHeightMeasurer(null);
			}
		}
	},
	setFitWhenResized: function (value) {
		if (value != this._setFitWhenResized) {
			this._setFitWhenResized = value;
			this._refreshOwner();
		}
	},
	setFocusVisible: function (value) {
		if (value != this._focusVisible) {
			this._focusVisible = value;
			this._refreshOwner();
		}
	},
	setShowInnerFocus: function (value) {
		if (value != this._showInnerFocus) {
			this._showInnerFocus = value;
			this._refreshOwner();
		}
	},
	setRowResizable:function(value) {
		if (value != this._rowResizable) {
			this._rowResizable = value;
			this._refreshOwner();
		}
	},	
	setEachRowResizable:function(value) {
		if (value != this._eachRowResizable) {
			this._eachRowResizable = value;
			this._refreshOwner();
		}
	},	
    setFocusColor: function (value) {
    	if (value && value != this._focusColor) {
    		this._focusColor = value;
			this._focusPen = new SolidPen(value, this._focusBorderWidth);
			this._refreshOwner();
    	}
    },
    setInnerFocusColor: function (value) {
    	if (value && value != this._innerFocusColor) {
    		this._innerFocusColor = value;
    		this._innerFocusPen = new SolidPen(value, 1, [1,1]);
			this._refreshOwner();
    	}
    },
    setFocusBackground: function (value) {
    	if (value != this._focusBackground) {
    		this._focusBackground = value;
    		this._focusBackgroundBrush = new SolidBrush(value);
			this._refreshOwner();
    	}
    },
    $_changeEditorBorder: function(color, border) {
    	var grid = this.grid();
    	var delegate = grid && grid.delegate();
    	var editors = delegate && delegate._cellEditors;
    	for (var editorType in editors) {
    		editors[editorType]._displayOptions = grid.displayOptions();
    	}
    },
    setFocusActiveColor: function (value) {
    	if (value && value != this._focusActiveColor) {
    		this._focusActiveColor = value;
    		this._focusActivePen = new SolidPen(value, this._focusBorderWidth);
    		this.$_changeEditorBorder();
    	}
    },
    setFocusBorderWidth: function (value) {
    	if (value && !isNaN(value) && value != this._focusBorderWidth) {
    		this._focusBorderWidth = value;
    		this._focusPen = new SolidPen(this._focusColor, value);
    		this._focusActivePen = new SolidPen(this._focusActiveColor, value);
    		this.$_changeEditorBorder();
    	}
    },
    setHintDuration: function(value) {
    	if (value != this._hintDuration) {
    		this._hintDuration = value;
    		var grid = this.grid();
    		if ( grid.toolTipManager && grid.toolTipManager()) {
    			var tm = grid.toolTipManager();
    			tm._hintDuration = value;
    		}
    	}
    },
    setRowFocusBackground: function(value) {
    	if (value != this._rowFocusBackground) {
    		this._rowFocusBackground = value;
    		this._rowFocusBackgroundBrush = null;
    		if (value) {
    			this._rowFocusBackgroundBrush = new SolidBrush(this._rowFocusBackground);
    		}
			this._refreshOwner();
    	}
    	this._rowFocusOption.styles().background(this._rowFocusBackgroundBrush);
    },
    setRowFocusVisible: function(value) {
    	if (value != this._rowFocusVisible) {
	    	this._rowFocusVisible = value;
			this._refreshOwner();
    	}
    	this._rowFocusOption._visible = this._rowFocusVisible;
    },
    setRowFocusMask: function(value) {
    	if (value != this._rowFocusMask) {
	    	this._rowFocusMask = value;
			this._refreshOwner();
    	}
    	this._rowFocusOption._rowFocusMask = this._rowFocusMask;
    },
	propertyChanged: function () {
		this._refreshOwner();
	},
	setRowHoverMask: function(value) {
		if (value != this._rowHoverMask) {
			this._rowHoverMask.assign(value);
		}
	},
	setRowBlockMask: function(value) {
		var activeTool = this._grid.activeTool();
		if (value != this._rowBlockMask) {
			this._rowBlockMask.assign(value);
			activeTool && activeTool.setRowBlockView(this._rowBlockMask._startIndex, this._rowBlockMask._endIndex);
			// this._refreshOwner();
		}
	},
	setRowFocusOption: function(value) {
		if (value != this._rowFocusOption) {
			this._rowFocusOption.assign(value);
		}
	},
	setUseCssStyleProgress: function(value) {
		var progressManager = this._grid._progressManager;
		if (value != this._useCssStyleProgress) {
			this._useCssStyleProgress = value;
			value && progressManager && progressManager.setUseCssStyleProgress(value);
		}
	},
	setPopupDropdownCount: function(value) {
		var popupManager = this._grid.popupMenuManager();
		if (popupManager && value != popupManager.dropdownCount()) {
			this._popupDropdownCount = value;
			popupManager.setDropdownCount(value);
		}
	},
	setCursorCallback: function(value) {
		value = value && typeof value === "function" ? value : null;
		this._cursorCallback = value;
	},
	setScrollBarStyles: function(value) {
		if (value != this._scrollBarStyles) {
			if (!value) {
				this._scrollBarStyles.clearValues();
			} else {
				this._scrollBarStyles.extend(value);
			}
		};
		this._refreshOwner();
	},
	setScrollThumbStyles: function(value) {
		if (value != this._scrollThumbStyles) {
			if (!value) {
				this._scrollThumbStyles.clearValues();
			} else {
				this._scrollThumbStyles.extend(value);
			}
		};
		this._refreshOwner();
	},
	setScrollButtonStyles: function(value) {
		if (value != this._scrollButtonStyles) {
			if (!value) {
				this._scrollButtonStyles.clearValues();
			} else {
				this._scrollButtonStyles.extend(value);
			}
		};
		this._refreshOwner();
	},

	proxy: function() {
		var obj = this._super();
		obj.hasOwnProperty("rowHeight") && obj.rowHeight <= 0 && this._grid._layoutManager._heightMeasurer && (obj.rowHeight = this._grid._layoutManager._heightMeasurer._itemHeight);
		return obj;
	},
	onVisualStylesChanged: function() {
		this._refreshOwner();
	}
});
var EditOptions = defineClass("EditOptions", GridBaseOptions, {
	init: function(grid) {
		this._super(grid);
	},
	readOnly: false,
	editable: _isMobile() ? false : true,
	checkable: true,
	updatable: true,
	appendable: false,
	insertable: false,
	deletable: false,
    revertable: false,
	editWhenFocused: false,
	commitWhenNoEdit: false,
	commitWhenExitLast: false,
	crossWhenExitLast: false,
	validateOnEdited: true,
	validateOnExit: false,
	hintOnError: true,
	deleteRowsMessage: window.RG_CONST && window.RG_CONST.DELETEROWSMESSAGE ? window.RG_CONST.DELETEROWSMESSAGE : "선택된 행(들)을 삭제하시겠습니까??",
	invalidFormatMessage: window.RG_CONST && window.RG_CONST.INVALIDFORMATMESSAGE ? window.RG_CONST.INVALIDFORMATMESSAGE : "잘못된 입력 유형입니다.",
	showInvalidFormatMessage: true,
	deleteRowsConfirm: true,
    confirmWhenDelete: true,
	editWhenClickFocused: false,
	commitLevel: ValidationLevel.IGNORE,
	useTabKey: true,
	useArrowKeys: true,
	skipReadOnly: false,
	skipReadOnlyCell: false,
	verticalMovingStep: VerticalMovingStep.DEFAULT,
	enterToTab: false,
	enterToNextRow: false,
	enterToEdit: false,
	maxLengthToNextCell:false,
	forceInsert: false,
	forceAppend: false,
	checkDiff: false,
    checkCellDiff: false,
    strictDiff: false,
	deletableWhenEdit: true,
    showCommitError: true,
	firstCellWhenInsert: false,
    appendWhenInsertKey: false,
    appendWhenExitLast: false,
	showOnlyValidationMessage: true,
	displayEmptyEditRow: false,
	checkWhenSpace: false,
	buttonClickWhenSpace: false,
	exitGridWhenTab: null,
	innerDraggable: false,
	exceptDataClickWhenButton: false,
    deleteRowsConfirm_: function () {
        return this._confirmWhenDelete;
    },
    setDeleteRowsConfirm: function (value) {
        this.setConfirmWhenDelete(value);
    },
	setReadOnly: function (value) {
		if (value != this._readOnly) {
			this._readOnly = value;
            this._refreshOwner();
			this._invalidateEditor();
		}
	},
	setEditable: function (value) {
		if (value != this._editable) {
			this._editable = value;
            this._refreshOwner();
			this._invalidateEditor();
		}
	},
    isWritable: function () {
        return this._editable && !this._readOnly;
    },
	canUpdate: function () {
		return !this._readOnly && this._updatable;
	},
	canInsert: function () {
		return !this._readOnly && this._insertable;
	},
	canAppend: function () {
		return !this._readOnly && this._appendable;
	},
	canDelete: function () {
		return !this._readOnly && this._deletable;
		
	},
	setAppendable: function(value) {
		this._appendable = value;
		this.setDisplayEmptyEditRow(this._displayEmptyEditRow);
	},
	setDisplayEmptyEditRow: function(value) {
		var grid = this.grid();
		if (grid && grid instanceof TreeView) {
			this._displayEmptyEditRow = false;
			return;
		}
		this._displayEmptyEditRow = value;
		if (this._displayEmptyEditRow && this._appendable) {
			this._grid._items.appendDummy();
		} else {
			this._grid._items.cancelDummy();
		}
		this._refreshOwner();
	}
});
var EditorOptions = defineClass("EditorOptions", GridBaseOptions, {
	init: function(grid) {
		this._super(grid);
		this._titleExprStatement = null;
		this._titleExprRuntime = new EditorTitleExpressionRuntime();
		this._holidayCollection = null;
	},
    yearDisplayFormat: window.RG_CONST && window.RG_CONST.YEARDISPLAYFORMAT ? window.RG_CONST.YEARDISPLAYFORMAT : "{Y}년",
    monthDisplayFormat: window.RG_CONST && window.RG_CONST.MONTHDISPLAYFORMAT ? window.RG_CONST.MONTHDISPLAYFORMAT : "{M}월",
    months: null,
    weekDays: null,
    viewGridInside:false,
    useCssStyle:false,
    useCssStyleDropDownList:false,
    useCssStyleDatePicker:false,
	useCssStylePopupMenu:false,
	useCssStyleMultiCheck:false,
	applyCellFont:false,
	titleStatement: null,
	holidays: null,
	editorZIndex: 2000,
	listZIndex: 3000,
	// zIndex:3000,
	setTitleStatement: function(value) {
		if (value != this._titleStatement) {
			this._titleStatement = value;
			if (value) {
				if (this._titleExprStatement) {
					this._titleExprStatement.setSource(value);
				} else {
					this._titleExprStatement = new ExpressionStatement(value);
				}
			} else {
				this._titleExprStatement = null;
			}
		}
	},
	setHolidays: function(value) {
		if (value != this._holidays) {
			this._holidays = value;
			if (value) {
				this._holidayCollection = this._holidayCollection || new HolidayCollection();
				this._holidayCollection.load(value);
			} else {
				this._holidayCollection && this._holidayCollection.clear();
			};
		}
	}
	// setZIndex: function(value) {
	// 	debugger;
	// }
});


var FixedOptions = defineClass("FixedOptions", GridBaseOptions, {
	init : function(grid) {
		this._super(grid);
		this._styles = new VisualStyles(this, "fixedBody");
		this._rowBarStyles = new VisualStyles(this, "fixedRowBar");
		this._colBarStyles = new VisualStyles(this, "fixedColumnBar");
	},
	destroy: function() {
		this._destroying = true;
		this._styles = null;
		this._rowBarStyles = null;
		this._colBarStyles = null;
		this._super();
	},
	colCount: 0,
	rightColCount: 0,
	rowCount: 0,
	exceptFromFiltering: true,
	exceptFromSorting: true,
	editable: true,
	rowEditable: true,
	resizable: false,
	rowResizable: false,
	movable: false,
	colBarWidth: 3,
	rowBarHeight: 3,
	ignoreColumnStyles: false,
	ignoreDynamicStyles: false,
	styles: null,
	rowBarStyles: null,
	colBarStyles: null,
	onStyleChanged: null,
	setColCount: function (value) {
		value = Math.max(0, value);
		if (value != this._colCount) {
			this._colCount = value;
			this._grid && this._grid.$_rowGroupFooterMergeChanged();
			this._grid && this._grid.$_footerMergeChanged();
			this._grid && this._grid.$_headerSummaryMergeChanged();
			this._refreshOwner();
		}
	},
	setRightColCount: function (value) {
		value = Math.max(0, value);
		if (value != this._rightColCount) {
			this._rightColCount = value;
			this._grid && this._grid.$_rowGroupFooterMergeChanged();
			this._grid && this._grid.$_footerMergeChanged();
			this._grid && this._grid.$_headerSummaryMergeChanged();
			this._refreshOwner();
		}		
	},
	setRowCount: function (value) {
		value = Math.max(0, value);
		if (value != this._rowCount) {
			this._rowCount = value;
			this.$_resetItemSource();
		}
	},
	setEditable: function (value) {
		if (value != this._editable) {
			this._editable = value;
			this._refreshOwner();
		}
	},
	setRowEditable: function (value) {
		if (value != this._rowEditable) {
			this._rowEditable = value;
			this._refreshOwner();
		}
	},
	setExceptFromFiltering: function(value) {
		if (value != this._exceptFromFiltering) {
			this._exceptFromFiltering = value;
			this.$_resetItemSource();
		}
	},
	setExceptFromSorting: function(value) {
		if (value != this._exceptFromSorting) {
			this._exceptFromSorting = value;
			this.$_resetItemSource();
		}
	},
    setIgnoreColumnStyles: function (value) {
        if (value != this._ignoreColumnStyles) {
            this._ignoreColumnStyles = value;
            this._refreshOwner();
        }
    },
    setIgnoreDynamicStyles: function (value) {
        if (value != this._ignoreDynamicStyles) {
            this._ignoreDynamicStyles = value;
            this._refreshOwner();
        }
    },
	setColBarWidth: function (value) {
		value = Math.max(0, value);
		if (value != this._colBarWidth) {
			this._colBarWidth = value;
			this._refreshOwner();
		}
	},
	setRowBarHeight: function (value) {
		value = Math.max(0, value);
		if (value != this._rowBarHeight) {
			this._rowBarHeight = value;
			this._refreshOwner();
		}
	},
	$_resetItemSource: function () {
		var items;
		var grid = this.grid();
		if (grid && (items = grid.itemSource())) {
			items.setFixed(this._rowCount, !this._exceptFromSorting, !this._exceptFromFiltering);
		}
	},
	stylesChanged: function (entry) {
		this._refreshOwner();
	}
});
var SelectOptions = defineClass("SelectOptions", GridBaseOptions, {
	init : function(grid) {
		this._super(grid);
		this._maskStyles = new VisualStyles(this, "selectMask");
		this._mobileStyles = new VisualStyles(this, "mobileSelection", {
			background: new SolidBrush(0x10000000),
			border: new SolidPen(0xff333333, 2),
			figureBackground: new SolidBrush(0xff333333),
			figureBorder: new SolidPen(0xffdddddd, 1)
		});
	},
	destroy: function() {
		this._destroying = true;
		this._maskStyles = null;
		this._mobileStyles = null;
		this._super();
	},
	rangeSelect: true,
	mode: {
		init: SelectionMode.SINGLE,
		set: function (value) {
			this._mode = value;
			this.grid().clearSelection();
		}
	},
	style: {
		init: SelectionStyle.BLOCK,
		set: function (value) {
			if (value != this._style) {
				var grid = this.grid();
				var sels = grid.selections();
				if (sels.count() > 0) {
					var item = sels.getItem(0);
					var rng = item.getBounds();
					sels.clear();
					// if (value != SelectionStyle.NONE) {  // 24버전까지는 style을 변경해도 바로 적용되지 않았다.
					// 	sels.setItemStyle(value);			// 25버전부터는 clear까지만 한다.
					// 	sels.add(grid.getIndex(rng.R1(), rng.C1()), grid.getIndex(rng.R1(), rng.C1()), value);
					// }
				}
				this._style = value;
				this._refreshOwner();
			}
		}
	},
	maskStyles : {
		set: function (value) {
			if (value !== this._maskStyles) {
				this._maskStyles.extend(value);
				this._refreshOwner();
			}
		}
	},
	mobileStyles : {
		set: function (value) {
			if (value !== this._mobileStyles) {
				this._mobileStyles.extend(value);
				this._refreshOwner();
			}
		}
	},
	proxy: function () {
		var val = this._super();
		val["mobileStyles"] = {
			background: VisualStyles.getFillText(this._mobileStyles.background()),
			border: VisualStyles.getStrokeText(this._mobileStyles.border()),
			figureBackground: VisualStyles.getFillText(this._mobileStyles.figureBackground()),
			figureBorder: VisualStyles.getStrokeText(this._mobileStyles.figureBorder()),
		};
		return val;
	}
});

var SortHandleImageOptions = defineClass("SortHandleImageOptions", null, {
	init: function(config) {
		this._super();
		config && this.assign(config);
	},
	ascending: null,
	descending: null,
	hoveredAscending: null,
	hoveredDescending: null,
	none: null,
	hoveredNone: null,
	loadImages: function(container) {
		container.getImage(this._ascending);
		container.getImage(this._descending);
		container.getImage(this._hoveredAscending); 
		container.getImage(this._hoveredDescending); 
		container.getImage(this._none); 
		container.getImage(this._hoveredNone); 
	}
});

var SortingOptions = defineClass("SortingOptions", GridBaseOptions, {
	init: function(grid) {
		this._super(grid);
		this._toast = new ToastOptions();
		this._toast._visible = false;
		this._toast._message = "Sorting...";
		this._handleImages = new SortHandleImageOptions();
		this._sortOrderStyles = new VisualStyles(this, "sortOrderStyles", {textAlignment:"near"});
	},
	destroy: function() {
		this._destroying = true;
		this._toast = null;
		this._handleImages = null;
		this._sortOrderStyles = null;
		this._destroy();
	},
	enabled: true,
	style: SortStyle.EXCLUSIVE,
	handleVisibility: HandleVisibility.VISIBLE,
	handleColor: undefined, 
	handleNoneColor: undefined,
	hoveredHandleColor: undefined, 
	hoveredHandleNoneColor: undefined,
	handleBorderColor: undefined,
	imageHandle: false,
	handleImages: null,
	commitBeforeSorting: true,
	toast:null,
    keepFocusedRow: false,
    textCase: SortCase.SENSITIVE,
    showSortOrder: false,
    sortOrderStyles: undefined,
    pageSorting:false,
	setHandleVisibility: function (value) {
		if (value != this._handleVisibility) {
			this._handleVisibility = value;
			this._refreshOwner();
		}
	},
	setHandleColor: function (value) {
		if (value != this._handleColor) {
			this._handleColor = value;
			this._handleFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHandleNoneColor: function (value) {
		if (value != this._handleNoneColor) {
			this._handleNoneColor = value;
			this._handleNoneFill = value ? new SolidBrush(value) : SolidBrush.EMPTY;
			this._refreshOwner();
		}
	},
	setHoveredHandleColor: function (value) {
		if (value != this._hoveredHandleColor) {
			this._hoveredHandleColor = value;
			this._hoveredHandleFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHoveredHandleNoneColor: function (value) {
		if (value != this._hoveredHandleNoneColor) {
			this._hoveredHandleNoneColor = value;
			this._hoveredHandleNoneFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHandleBorderColor: function (value) {
		if (value != this._handleBorderColor) {
			this._handleBorderColor = value;
			this._handleBorderPen = value ? new SolidPen(value) : SolidPen.GRAY;
			this._refreshOwner();
		}
	},
	setShowSortOrder: function(value) {
		if (value != this._showSortOrder) {
			this._showSortOrder = value;
			this._refreshOwner();
		}
	},
    setSortOrderStyles: function (value) {
        if (value !== this._sortOrderStyles) {
            this._sortOrderStyles.extend(value);
			this._refreshOwner();
        }
    },
	handleFill: function () {
		return this._handleFill;
	},
	handleNoneFill: function () {
		return this._handleNoneFill;
	},
	setToast: function (value) {
		if (value != this._toast) {
			this._toast.assign(value);
		}
	},
	setHandleImages: function (value) {
		this._handleImages.assign(value);
	},
	setPageSorting: function (value) {
		if (value != this._pageSorting) {
			this._pageSorting = value;
			this._grid && this._grid.setPageSorting(value);	
		}
	}
});
var FilterSelectorOptions = defineClass("FilterSelectorOptions", null, {
	init: function(config) {
		this._super();
		this._styles = new VisualStyles(this, "filterSelectorStyles");
		config && this.assign(config);
	},
	destroy: function() {
		this._destroying = true;
		this._styles = null;
		this._super();
	},
	minWidth: null,
	maxWidth: null,
	minHeight: null,
	maxHeight: null,
	styles: null,
	closeWhenClick: false,
	useCssStyle: false,
	showButtons: false,
	showSearchInput: false,
	acceptText: null,
	cancelText: null,
	userFilterAddCallback: null,
	viewGridInside: true,
	enterCallback: false,
	// dropdownCount: 0,
	setMinWidth: function (value) {
		this._minWidth = value ? PercentSize.createFrom(value) : undefined;
	},
	setMaxWidth: function (value) {
		this._maxWidth = value ? PercentSize.createFrom(value) : undefined;
	},
	setMinHeight: function (value) {
		this._minHeight = value ? PercentSize.createFrom(value) : undefined;
	},
	setMaxHeight: function (value) {
		this._maxHeight = value ? PercentSize.createFrom(value) : undefined;
	},
	getMinWidth: function (width) {
		return this._minWidth ? this._minWidth.getSize(width) : undefined;
	},
	getMaxWidth: function (width) {
		return this._maxWidth ? this._maxWidth.getSize(width) : undefined;
	},
	getMinHeight: function (height) {
		return this._minHeight ? this._minHeight.getSize(height) : undefined;
	},
	getMaxHeight: function (height) {
		return this._maxHeight ? this._maxHeight.getSize(height) : undefined;
	}
});

var FilterHandleImageOptions = defineClass("FilterHandleImageOptions", null, {
	init: function(config) {
		this._super();
		config && this.assign(config);
	},
	none: null,
	fill: null,
	hoveredNone: null,
	hoveredFill: null,
	loadImages: function(container) {
		container.getImage(this._none);
		container.getImage(this._fill);
		container.getImage(this._hoveredNone); 
		container.getImage(this._hoveredFill); 
	}
});

var FilteringOptions = defineClass("FilteringOptions", GridBaseOptions, {
	init: function(grid) {
		this._super(grid);
		this._selector = new FilterSelectorOptions();
		this._handleImages = new FilterHandleImageOptions(); 
		this._toast = new ToastOptions();
		this._toast._visible = false;
		this._toast._message = "Filtering...";
	},
	destroy: function() {
		this._destroying = true;
		this._selector = null;
		this._handleImages = null; 
		this._toast = null;
		this._super();
	},
	enabled: true,
	handleVisibility: HandleVisibility.VISIBLE,
	handleColor: undefined,
	handleNoneColor : undefined,
	hoveredHandleColor: undefined,
	hoveredHandleNoneColor : undefined,
	handleBorderColor: undefined,
	imageHandle: false,
	handleImages: null,
	commitBeforeFiltering: true,
	selector: null,
	toast: null,
	addParentNodeOnFiltering:true,
	clearWhenSearchCheck:true,
	setSelector: function (value) {
		this._selector.assign(value);
	},
	setToast: function (value) {
		this._toast.assign(value);
	},
	setHandleImages: function (value) {
		this._handleImages.assign(value);
	},
	setHandleColor: function (value) {
		if (value != this._handleColor) {
			this._handleColor = value;
			this._handleFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHandleNoneColor: function (value) {
		if (value != this._handleNoneColor) {
			this._handleNoneColor = value;
			this._handleNoneFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHoveredHandleColor: function (value) {
		if (value != this._hoveredHandleColor) {
			this._hoveredHandleColor = value;
			this._hoveredHandleFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHoveredHandleNoneColor: function (value) {
		if (value != this._hoveredHandleNoneColor) {
			this._hoveredHandleNoneColor = value;
			this._hoveredHandleNoneFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHandleBorderColor: function (value) {
		if (value != this._handleBorderColor) {
			this._handleBorderColor = value;
			this._handleBorderPen = value ? new SolidPen(value) : SolidPen.GRAY;
			this._refreshOwner();
		}
	},
	setAddParentNodeOnFiltering:function(value) {
		if (value != this._addParentNodeOnFiltering) {
			this._addParentNodeOnFiltering = value;
			var grid = this.grid();
			if (grid && grid instanceof TreeView) {
				var item = grid._items;
				if (item && item instanceof TreeGridItemProvider) {
					item._addParentNodeOnFiltering = value;
					grid.applyFilters();
				}
			}
		}
	}
});

var HeaderCheckImageOptions = defineClass("HeaderCheckImageOptions", null, {
	init: function(config) {
		this._super();
		config && this.assign(config);
	},
	none: undefined,
	fill: undefined,
	hoveredNone: undefined,
	hoveredFill: undefined,
	loadImages: function(container) {
		container.getImage(this._none);
		container.getImage(this._fill);
		container.getImage(this._hoveredNone); 
		container.getImage(this._hoveredFill); 
	}
});

var ColumnHeaderOptions = defineClass("ColumnHeaderOptions", GridBaseOptions, {
	init: function(grid) {
		this._super(grid);
		this._checkImages = new HeaderCheckImageOptions();
	},
	destroy: function() {
		this._destroying = true;
		this._checkImages = null;
		this._super();
		this._popupMenuWidth = 7;
	},
	checkVisibility: HandleVisibility.ALWAYS,
	imageCheckHandle: false,
	checkImages: null,
	checkColor : undefined,
	checkNoneColor : undefined,
	hoveredCheckColor : undefined,
	hoveredCheckNoneColor : undefined,
	checkBorderColor: undefined,
	popupMenuColor: undefined,
	hoveredPopupMenuColor: undefined,
	popupMenuWidth: undefined,
	setCheckVisibility: function (value) {
		if (value != this._checkVisibility) {
			this._checkVisibility = value;
			this._refreshOwner();
		}
	},
	setCheckImages: function (value) {
		this._checkImages.assign(value);
	},
	setCheckColor: function (value) {
		if (value != this._checkColor) {
			this._checkColor = value;
			this._checkFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setCheckNoneColor: function (value) {
		if (value != this._checkNoneColor) {
			this._checkNoneColor = value;
			this._checkNoneFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHoveredCheckColor: function (value) {
		if (value != this._hoveredCheckColor) {
			this._hoveredCheckColor = value;
			this._hoveredCheckFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setHoveredCheckNoneColor: function (value) {
		if (value != this._hoveredCheckNoneColor) {
			this._hoveredCheckNoneColor = value;
			this._hoveredCheckNoneFill = value ? new SolidBrush(value) : SolidBrush.GRAY;
			this._refreshOwner();
		}
	},
	setCheckBorderColor: function (value) {
		if (value != this._checkBorderColor) {
			this._checkBorderColor = value;
			this._checkBorderPen = value ? new SolidPen(value) : SolidPen.GRAY;
			this._refreshOwner();
		}
	},
	setPopupMenuColor: function(value) {
		if (value != this._popupMenuColor) {
			this._popupMenuColor = value;
			this._popupMenuPen = value ? new SolidPen(value) : SolidPen.GRAY;
			this._refreshOwner();
		}
	},
	setHoveredPopupMenuColor: function(value) {
		if (value != this._hoveredPopupMenuColor) {
			this._hoveredPopupMenuColor = value;
			this._hoveredPopupMenuPen = value ? new SolidPen(value) : SoildPen.DKGRAY;
			this._refreshOwner();
		}
	},
	propertyChanged: function () {
		this._refreshOwner();
	},
	
});
var GroupRemoveButton = defineClass("GroupRemoveButton", null, {
	init: function(grid) {
		this._super(grid);
		this._grid = grid;
		this._visible = false;
		this._fill = SolidBrush.DKGRAY;
		this._hoveredFill = SolidBrush.DKGRAY;
		this._color = SolidBrush.DKGRAY.toText();
		this._hoveredColor = SolidBrush.DKGRAY.toText();
		this._size = HEADER_CHECKBOX_SIZE;
	},
	visible: false,
	color: null,
	hoveredColor: null,
	size: 0,
	buttonGap:4,
	setColor: function(value) {
		if (value != this._color) {
			this._color = value;
			this._fill = value ? new SolidBrush(value) : SolidBrush.DKGRAY;
		};
	},
	setHoveredColor: function(value) {
		if (value != this._hoveredColor) {
			this._hoveredColor = value;
			this._hoveredFill = value ? new SolidBrush(value) : SolidBrush.DKGRAY;
		};
	},
	fill: function() {
		return this._fill;
	},
	hoveredFill: function() {
		return this._hoveredFill;
	},
	assign: function(source) {
		this._super(source);
		this._grid && this._grid.refreshView();
	},
	proxy: function () {
		return this._super();
	}
});
var GroupingOptions = defineClass("GroupingOptions", GridBaseOptions, {
	init : function(grid) {
		this._super(grid);
		this._toast = new ToastOptions();
		this._toast._visible = false;
		this._toast._message = "Grouping...";
		this._removeButton = new GroupRemoveButton(grid);
	},
	destroy: function() {
		this._destroying = true;
		this._toast = null;
		this._super();
	},
	enabled: true,
	prompt: window.RG_CONST && window.RG_CONST.GROUPINGPROMPT ? window.RG_CONST.GROUPINGPROMPT :"컬럼 헤더를 이 곳으로 끌어다 놓으면 그 컬럼으로 그룹핑합니다.",
	linear: false,
	expandWhenGrouping: true,
	summarizing: true,
	commitBeforeGrouping: true,
	commitBeforeExpand: true,
	commitBeforeCollapse: true,
	fixMergedColumns: true,
	toast: null,
	removeIncludeLower: false,
	removeButton: null,
	setToast: function (value) {
		if (value != this._toast) {
			this._toast.assign(value);
		}
	},
	propertyChanged: function () {
		this.grid().groupingOptionsChanged();
		this._layoutOwner();
	},
	setRemoveButton: function(value) {
		this._removeButton && this._removeButton.assign(value);
	}
});

var CopyOptions = defineClass("CopyOptions", null, {
	init: function () {
		this._super();
		this._dateWriter = null;
		this._boolWriter = null;
	},
	enabled: true,
	singleMode: false,
	datetimeFormat: null,
	booleanFormat: null,
	lookupDisplay: false,
	copyDisplayText: false,
	includeHeaderText: false,
	dateWriter: function () {
		return this._dateWriter;
	},
	boolWriter: function () {
		return this._boolWriter;
	},
	setDatetimeFormat: function (value) {
		if (value != this._datetimeFormat) {
			this._datetimeFormat = value;
			if (value) {
				this._dateWriter = new DateTimeWriter(value);
			} else {
				this._dateWriter = null;
			}
		}
	},
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			if (value) {
				this._boolWriter = new BooleanFormatter(value);
			} else {
				this._boolWriter = null;
			}
		}
	}
});
var PasteOptions = defineClass("PasteOptions", null, {
	init: function () {
		this._super();
		this._boolReader = null;
		this._dateReaders = null;
		this._numberCharExp = null;
		this._numberCharExpOfCols = null;
	},
	enabled: true,
	singleMode: false,
	startEdit: true,
	commitEdit: true,
	enableAppend: true,
	fillFieldDefaults: false,
	fillColumnDefaults: false,
	forceRowValidation: false,
	forceColumnValidation: false,
	datetimeFormats: null,
	booleanFormat: null,
	numberChars: null,
	numberSeparator: null,
	numberCharsOfCols: {},
	numberSeparatorOfCols: {},
	selectionBase: false,
	selectBlockPaste:false,
	stopOnError: true,
	noEditEvent: false,
	noDataEvent: false,
	eventEachRow: false, 
	checkReadOnly:false,
	checkDomainOnly:false,
	convertLookupLabel:false,
	applyNumberFormat:false,
	applyEditMask:false,
	applyMaxLength:false,
	throwValidationError:true,
	setDatetimeFormats: function (value) {
		if (value != this._datetimeFormats) {
			if (_isArray(value)) {
				this._datetimeFormats = value.concat();
			} else if (value) {
				this._datetimeFormats = [value];
			} else {
				this._datetimeFormats = null;
			}
			if (this._datetimeFormats) {
				this._dateReaders = [];
				for (var i = 0; i < this._datetimeFormats.length; i++) {
					this._dateReaders.push(new DateTimeReader(this._datetimeFormats[i]));
				}
			} else {
				this._dateReaders = null;
			}
		}
	},
	dateReaders: function () {
		return this._dateReaders;
	},
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			if (value) {
				this._boolReader = new BooleanConverter(value);
			} else {
				this._boolReader = null;
			}
		}
	},
	boolReader: function () {
		return this._boolReader;
	},
	setNumberChars: function (value) {
		if (value != this._numberChars) {
			this._numberChars = value;
			if (value && value.length > 0) {
				var s = "[";
				for (var i = 0; i < value.length; i++) {
					var c = value[i];
					if (c == "\\") {
						s += "\\" + c;
					} else {
						s += c;
					}
				}
				s += "]";
				this._numberCharExp = new RegExp(s, "g");
			} else {
				this._numberCharExp = null;
			}
		}
	},
	setNumberCharsOfCols: function (value) {
		this._numberCharsOfCols = value;
		this._numberCharExpOfCols = {};
		if (value) {
			for (var name in value) {
				var col = value[name];
				if (col instanceof Array && col.length > 0) {
					var s = "[";
					for (var i = 0, l = col.length; i < l; i++) {
						var c = col[i];
						if (c == "\\") {
							s += "\\" + c;
						} else {
							s += c;
						}
					}
					s += "]";
					this._numberCharExpOfCols[name] = new RegExp(s, "g");
				} else {
					this._numberCharExpOfCols[name] = null;
				}
			}
		}
	},
	numberCharExp: function () {
		return this._numberCharExp;
	},
	numberCharExpOfCol: function (col) {
		return col && this._numberCharExpOfCols && this._numberCharExpOfCols[col] ? this._numberCharExpOfCols[col] : this._numberCharExp;
	},
	numberSeparatorOfCol: function (col) {
		return col && this._numberSeparatorOfCols && this._numberSeparatorOfCols[col] ? this._numberSeparatorOfCols[col] : this._numberSeparator;
	}
});
var MobileOptions = defineClass("MobileOptions", GridBaseOptions, {
	init: function(grid) {
		this._super(grid);
		this._longTapDuration = 500;
		this._doubleTapInterval = 300;
		this._tapThreshold = 4;
	},
	longTapDuration: null,
	doubleTapInterval: null,
	tapThreshold: null,
	showEditCommander: true,
	showTooltip:false,
	scrollOnEditing: ScrollOnEditing.CANCEL,
	headerToScroll: true,
	assign: function(source) {
		this._super(source);
		var grid = this.grid();
		var touchManager = grid.activeTool() && grid.activeTool()._touchManager;
		if (touchManager) {
			touchManager._longTapDuration = !isNaN(parseInt(this._longTapDuration)) && parseInt(this._longTapDuration) != 0 ? parseInt(this._longTapDuration) : $_LONG_TAP_THRESHOLD;
			touchManager._doubleTapInterval = !isNaN(parseInt(this._doubleTapInterval)) && parseInt(this._doubleTapInterval) != 0 ? parseInt(this._doubleTapInterval) : $_DOUBLE_TAP_THRESHOLD;
			touchManager._tapThreshold = !isNaN(parseInt(this._tapThreshold)) && parseInt(this._tapThreshold) != 0 ? parseInt(this._tapThreshold) : $_TAP_THRESHOLD;
		}
	}
});
var ColumnSummary = defineClass("ColumnSummary", GridObject, {
	init: function (column) {
		this._super();
		this._column = column;
		this._styles = new VisualStyles(this, "columnSummaryStyles");
		this._groupStyles = new VisualStyles(this, "columnRowGroupSummaryStyles");
		this._dynamicStyles = new DynamicStyleCollection(this);
		this._groupDynamicStyles = new DynamicStyleCollection(this);
		this._exprNode = undefined;
		this._groupExprNode = undefined;
		this._dirty = false;

		this._eachStyles = null;
		this._eachDynamicStyles = null;

	},
	destroy: function() {
		this._destroying = true;
		this._column = null;
		this._styles = null;
		this._groupStyles = null;
		this._dynamicStyles = null;
		this._groupDynamicStyles = null;
		this._super();
	},
	stylesChanged: function (styleProp) {
		this._changed();
	},
	styles: null,
	groupStyles: null,
	text: null,
	expression: null,
	groupText: null,
	groupExpression: null,
	dynamicStyles: null,
	groupDynamicStyles: null,
	callback: null,
	groupCallback: null,
	column: function () {
		return this._column;
	},
	isDirty: function () {
		return this._dirty;
	},
	setText: function (value) {
		if (value != this._text) {
			if (value instanceof Array) {
				this._text = [];
				for (var i = 0; i < value.length; i++) {
					this._text.push(value[i]);
				}
			} else {
				this._text = value;
			}
			this._changed();
		}
	},
	setGroupText: function (value) {
		if (value != this._groupText) {
			this._groupText = value;
			this._changed();
		}
	},

	getStyles: function(footerIndex) {
		return this._eachStyles && this._eachStyles[footerIndex] ? this._eachStyles[footerIndex] : this._styles;
	},
	getDynamicStyles: function(footerIndex) {
		return this._eachDynamicStyles && this._eachDynamicStyles[footerIndex] ? this._eachDynamicStyles[footerIndex] : this._dynamicStyles;
	},
	setStyles: function (value) {
		if (!value) {
			this._eachStyles = null;
			this._styles.clearValues();
		} else {
			if (isArray(value)) {
				var i, cnt, styles;
				this._eachStyles = [];
				for (i = 0, cnt = value.length; i < cnt ; i++) {
					styles = new VisualStyles(this, "columnSummaryStyles");
					this._eachStyles.push(styles);
					styles.setSysDefault(this.$_getSysDefaultStyles());
					styles.extend(value[i]);
				}
			} else {
				this._eachStyles = null;
				this._styles.extend(value);
			}
		}
	},
	setDynamicStyles: function(value) {
		if (!value) {
			this._dynamicStyles.setItems(value);
		} else {
			if (isArray(value) && isArray(value[0])) {
				var i, cnt = value.length, styles, s = GridStyleSheet.Default;
				this._eachDynamicStyles = [];
				for (i = 0; i < cnt ; i++) {
					styles = new DynamicStyleCollection(this);
					styles.setItems(value[i]);
					this._eachDynamicStyles.push(styles);
				}
			} else {
				this._eachDynamicStyles = null;
				this._dynamicStyles.setItems(value);
			}
		}
		this._changed();
	},

	setExpression: function (value) {
		if (typeof value == "string") {
			value = trim(value);
		}

		if (value != this._expression) {
			if (value instanceof Array) {
				this._expression = [];
				this._exprNode = [];

				for (var i = 0; i < value.length; i++) {
					this._expression.push(value[i]);
					if (value[i]) {
						this._exprNode.push(ExpressionParser.Default.parse(value[i]));
					} else {
						this._exprNode.push(null);
					}
				}
			}  else {
				this._expression = value;
				
				if (value) {
					this._exprNode = ExpressionParser.Default.parse(value);
				} else {
					this._exprNode = undefined;
				}
			}

			this._changed();
		}
	},
	setGroupExpression: function (value) {
		value = trim(value);
		if (value != this._groupExpression) {
			this._groupExpression = value;
			if (value) {
				this._groupExprNode = ExpressionParser.Default.parse(value);
			} else {
				this._groupExprNode = undefined;
			}
			this._changed();
		}
	},
	setGroupStyles: function (value) {
		if (value !== this._groupStyles) {
			this._groupStyles.extend(value);
		}
	},
	setGroupDynamicStyles: function (value) {
		this._groupDynamicStyles.setItems(value);
		this._changed();
	},
	clean: function () {
		this._dirty = false;
	},
	/* internal */ capitalIndexers: function () {
		return null;
	},
	/* internal */ evaluate: function (runtime, index) {
		if (this._exprNode) {
			if (this._exprNode instanceof Array) {
				if (index !== undefined && this._exprNode[index]) {
					return this._exprNode[index].evaluate(runtime);
				} else {
					return;
				}
			} else {
				return this._exprNode.evaluate(runtime);
			}
		} else { 
			return;
		}
	},
	/* internal */ evaluateGroup: function (runtime) {
		return this._groupExprNode && this._groupExprNode.evaluate(runtime);
	},
	$_getSysDefaultStyles: function() {
		return GridStyleSheet.Default.footer();
	},
	_changed: function () {
		if (!this._dirty) {
			this.dirty = true;
			if (this._column && this._column._footerChanged) {
				this._column._footerChanged();
			}
		}
	}
});

var ColumnHeader = defineClass("ColumnHeader", GridObject, {
	init: function (column) {
		GridObject$.init.call(this);
		this._column = column;
		this._summary = new ColumnHeaderSummary(this);
		this._styles = new VisualStyles(this, "columnHeaderStyles");
        this._subStyles = new VisualStyles(this, "columnHeaderSubStyles");
        this._popupMenu = null;// set을 위한것이다.
        this._popupMenuName = null;  // 실제 등록된 popupMenuName을 가지고 있다.
		this._dirty = false;
	},
	destroy: function() {
		this._destroying = true;
		this._column = null;
		this._summary = null;
		this._styles = null;
        this._subStyles = null;
        this._super();
	},
	stylesChanged: function (/*styleProp*/) {
		this._changed();
	},
	summary: null,
	styles: null,
    subStyles: null,
	text: null,
    subText: null,
    subTextGap: undefined,
    itemOffset: undefined,
    itemGap: undefined,
    subTextLocation: undefined,
    imageIndex: -1,
    imageUrl: null,
	checkLocation: ColumnHeaderItemLocation.NONE,
	imageLocation: ColumnHeaderItemLocation.NONE,
	clickBehavior: ClickBehavior.NONE,
	showTooltip:true,
	tooltip : null,	
	fixedHeight: 0,
	popupMenu: null,
	column: function () {
		return this._column;
	},
	setSummary: function (value) {
		if (value != this._summary) {
			this._summary.assign(value);
			this._changed();
		}
	},
	setStyles: function (value) {
		if (value !== this._styles) {
			this._styles.extend(value);
		}
	},
    setSubStyles: function (value) {
        if (value !== this._subStyles) {
            this._subStyles.extend(value);
        }
    },
    setText: function(value) {
    	if (value !== this._text) {
    		this._text = value == null ? value : String(value);
    		this._changed();
    	}
    },
	displayText: function () {
        var s = this._text;
        if (!s && this._column instanceof DataColumn) {
            var fld = this._column.getField();
            if (fld) {
                s = fld.header() || fld.orgFieldName();
            } else {
                s = this._column.fieldName();
            }
        }
        if (!s) {
            s = this._column.name();
        }
		return s;
	},
	clean: function () {
		this._dirty = false;
	},
	_changed: function () {
		if (!this._dirty) {
			this.dirty = true;
			if (this._column) {
				this._column._headerChanged();
			}
		}
	},
	setPopupMenu: function(value) {
		if (value != this._popupMenu) {
			if (typeof value === "string") {
				this._popupMenu = null;
				this._popupMenuName = value;
			} else if (_isArray(value) || _isObject(value)) {
				this._popupMenu = value;
				this._popupMenuName = null;
			} else {
				this._popupMenu = null;
				this._popupMenuName = null;
			}
			this._changed();
			this._popupMenuChanged = true;
		}
	},
	resetPopupMenu:function(popupMenuManager) {
		var menu;
		if ((menu = this._popupMenu) && !this._popupMenuName) {
			this._popupMenuName = "$$_columnHeader_popup"+ $$_autoInc++ +"menu";
			menu = _isArray(menu) ? menu : [menu];
			popupMenuManager.addMenu(this._popupMenuName, menu, true);
		}
	}
});

var ColumnFooter = defineClass("ColumnFooter", ColumnSummary, {
	init: function (column) {
		this._super(column);
	},
	$_getSysDefaultStyles: function() {
		return GridStyleSheet.Default.footer();
	}
});

var ColumnHeaderSummary = defineClass("ColumnHeaderSummary", ColumnSummary, {
	init: function (columnHeader) {
		this._super(columnHeader._column);
	},
	$_getSysDefaultStyles: function() {
		return GridStyleSheet.Default.headerSummary();
	}
});

var Column = defineClass("Column", null, {
	init: function (config) {
		this._super();
		this._initColumn();
		config && this.assign(config);
	},
	destroy : function() {
		this._destroying = true;
		this._styles = null;
		this._header = null;
		this._states = null;
		this._layoutRect = null;
		this._super();
	},
	_initColumn: function () {
		this._header = this._createHeader();
		this._styles = new VisualStyles(this, "columnStyles");
		this._index = -1;
		this._layoutRect = new Rectangle();
		this._orgWidth = NaN;
        this._groupWidth = NaN;
        this._displayOffset = NaN;
        this._displayWidth = NaN;
		this._fitOffset = NaN;
		this._fitWidth = NaN;
		this._measuredHeight = -1;
		this._dataRoot = null;
		this._distance = 0;
		this._value = UNDEFINED;
		this._states = {};
		this._parent = null;
        this.$_grid = null;
        this.$_fixed = false;
        this.$_rightFixed = false;
	},
	stylesChanged: function (styleProp) {
		this._changed();
	},
	header: null,
	styles: null,
	dirty: false,
	name: null,
	tag: null,
	visible: true,
	width: 100,
	height: 0,
	/* @internal */ saveWidth: NaN,
	/* @internal */ fillWidth: 0,
	/* @internal */ fillHeight: 0,
	thickness: 1.0,
	resizable: true,
	movable: true,
	styleName: null,
	displayIndex: -1,
    checked: false,
    minWidth: -1,
    maxWidth: -1,
	grid: function () {
		return this.$_grid || (this._parent ? this._parent.grid() : null);
	},
	parent: function () {
		return this._parent;
	},
	setParent: function (value) {
		if (value != this._parent) {
			if (this._parent) {
				this._parent._removeInternal(this);
			}
			if (value) {
				value._addInternal(this);
			}
			var grid = this.grid();
			if (grid) {
				grid._columnsReset();
			}
		}
	},
	group: function () {
		return (this._parent instanceof RootColumn) ? null : this._parent;
	},
	root: function () {
		var g = this.group();
		return g ? g.root() : this;
	},
	isRoot: function () {
		return this === this.root();
	},
	dataRoot: function () {
		return this._dataRoot;
	},
	isDataRoot: function () {
		return this._dataRoot === this;
	},
	isDirty: function () {
		return this._dirty || this._header._isDirty;
	},
	setHeader: function (value) {
		if (typeof value == "string") {
			value = { text: value };
		}
		this._header.assign(value);
	},
	setVisible: function (value) {
		if (value != this._visible) {
			this._visible = value;
			this._invalidateSize();
			var merges = this.stateFor(ColumnMergeManager.MERGE_ROOMS);
			if (this.isVisible() && this.canMerge && this.canMerge()) {
				if (merges) {
					merges.clear();
					if (this instanceof DataColumn && this.isMergeGrouped()) {
						level = this.grid().getGroupLevel(this.dataIndex());
						if (level > 0) {
							merges.initialize(RowGroupMergeRule.INIT_COUNT);
						}
					} else {
						merges.initialize(ColumnMergeRule.INIT_COUNT);
					}
				}
			} else if (merges) {
				merges.clear();
			}
			this._invalidateVisible();
		}
	},
	setWidth: function (value) {
		value = Math.max(0, value);
		if (value != this._width) {
			this._width = value;
            if (!this.group() || isNaN(this._groupWidth)) {
                this._displayWidth = this._groupWidth = value;
            }
			this._invalidateSize();
		}
	},
	setHeight: function (value) {
		value = Math.max(0, _int(value));
		if (value != this._height) {
			this._height = value;
			this._changed();
		}
	},
	setFillWidth: function (value) {
		value = Math.max(0, _int(value));
		if (value != this._fillWidth) {
			this._fillWidth = value;
			this._changed();
		}
	},
	setFillHeight: function (value) {
		value = Math.max(0, _int(value));
		if (value != this._fillHeight) {
			this._fillHeight = value;
			this._changed();
		}
	},
    groupWidth: function () {
        return this._groupWidth;
    },
	displayOffset: function () {
		return isNaN(this._fitOffset) ? this._displayOffset : this._fitOffset;
	},
	displayWidth: {
		get: function () {
            return isNaN(this._fitWidth) ? this._displayWidth : _int(this._fitWidth);
		},
		set: function (value) {
			value = Math.max(0, value);
			var w = this.displayWidth();
			isNaN(w) && (w = 0);
			if (!isNaN(value) && value != w) {
				ColumnGroup.changeWidth(this, value - w);
			}
			/*
			if (isNaN(w)) w = 0;
			if (value != w) {
				ColumnGroup.changeWidth(this, value - w);
			}
			*/
		}
	},
	saveWidth_: function () {
		return isNaN(this._fitWidth) ? this._groupWidth : this._fitWidth;
	},
	setSaveWidth: function (value) {
		this._saveWidth = value;
	},
	measuredHeight: function () {
		return this._measuredHeight;
	},
	index: function () {
		return this._index;
	},
	displayIndex_: function () {
		return this._visible ? this._displayIndex : -1;
	},
	setDisplayIndex: function (value) {
        if (this._parent) {
            if (value < 0) {
                this.setVisible(false);
            } else {
                value = Math.min(value, this._parent.visibleCount() - 1);
                this._parent.setVisibleIndex(this, value);
            }
        }
	},
	setStyles: function (value) {
		if (value !== this._styles) {
			this._styles.extend(value);
			this._changed();
		}
	},
    setChecked: function (value) {
        if (value != this._checked) {
            this._checked = value;
            this._changed();
            var grid = this.grid();
            grid && grid._columnCheckedChanged(this);
        }
    },
	distance: function () {
		return this._distance;
	},
	displayText: function () {
		return this._name ? this._name : this.header() ? this.header().text()  : "col:" + this._index;
	},
    isFixed: function () {
        return this.$_fixed;
    },
    isRightFixed: function () {
    	return this.$_rightFixed;
    },
	prepare: function (grid, fixed, rightFixed) {
        this.$_grid = grid;
        this.$_fixed = fixed;
        this.$_rightFixed = rightFixed;
        if (this._header._popupMenuChanged) {
			var popupMenuManager = grid.popupMenuManager();
			this._header.resetPopupMenu(popupMenuManager);
			this._header._popupMenuChanged = false;
        }
	},
	clean: function () {
		this._dirty = false;
		this._header.clean();
	},
	$_getOffset: function () {
		var x = 0,
			c = this,
			p = c.group();
		while (p) {
			x += c.displayOffset();
			c = p;
			p = p.group();
		}
		return x;
	},
	stateFor: function (state) {
		return this._states[state];
	},
	setState: function (state, value) {
		this._states[state] = value;
	},
	propertyChanged: function (/*prop, oldValue, newValue*/) {
		this._changed();
	},
	_setParent: function (group) {
		if (group != this._parent) {
			if (group) {
				group._columnRemoved(this);
			}
			this._parent = group;
			if (group) {
				group._columnAdded(this);
			}
			this._parentChanged();
		}
	},
	_parentChanged: function () {
		// column element의 style을 처리하는 부분이 없다. 임시로 여기에 처리한다.
		var grid = this.grid && this.grid();
		var s;
		if (grid) {
			if (this._header && (s = this._header._styles) && !this._header._styles._parent) {
				var h = grid._header.styles();
				var hd = h.sysDefault();
				s.setParentAndDefault(h,hd);
				if ( (s = this._header._subStyles) && !this._header._subStyles._parent) {
					var h = grid._header.subStyles();
					var hd = h.sysDefault();
					s.setParentAndDefault(h,hd);
				}
			}
		}
	},
	_createHeader: function () {
		return new ColumnHeader(this);
	},
	_headerChanged: function () {
		this._changed();
	},
	_invalidateSize: function () {
		var grid = this.grid();
		if (grid) {
			this._dirty = true;
			grid.invalidateColumnWidths();
		}
	},
	_invalidateVisible: function () {
		var grid = this.grid();
		grid && grid._columnVisibleIndexChanged(this);
	},
	_changed: function () {
		if (!this._dirty) {
			this._dirty = true;
			var grid = this.grid();
			grid &&	grid.invalidateColumns();
		}
	},
	checkGroupExist: function (orientation) {
		var c = this;
		var parent = c.group();
		while (parent) {
			if (!orientation || parent.orientation() === orientation) {
				return true;
			}
			parent = parent.group();
		}
		return false;		
	}
}, {
	compareLoc: function (col1, col2) {
		if (col1 == null || col2 == null) {
			return 0;
		}
		if (col1 == null) {
			return -1;
		}
		if (col2 == null) {
			return 1;
		}
		var idx1 = col1.root().displayIndex();
		var idx2 = col2.root().displayIndex();
		if (idx1 == idx2) {
			if (col1.group() == col2.group()) {
				idx1 = col1.displayIndex();
				idx2 = col2.displayIndex();
			} else {
				idx1 = col1.dataRoot().displayIndex();
				idx2 = col2.dataRoot().displayIndex();
			}
		}
		return idx1 - idx2;
	}
});
Column.MIN_WIDTH = 2;
var Column$ = Column.prototype;
var ColumnGroupHeader = defineClass("ColumnGroupHeader", ColumnHeader, {
	init: function (group) {
		this._super(group);
		this._fillHeight = 0; // fixedHeight가 지정된 컬럼이 포함된 그룹의 높이 계산용 
	},
	stylesChanged: function (styleProp) {
		this._changed();
	},
	visible: true,
	group: function () {
		return this._column;
	}
});
var ColumnGroup = defineClass("ColumnGroup", Column, {
	init: function (config) {
		this._super(config);
	},
	destroy: function() {
		this._destroying = true;
		this._headerLevel = null;
		this._columns && !this._columns.destroying && this._columns.destroy && this._columns.destroy();
		this._columns = null;
		this._dataLevel = null;
		this._super();
	},
	_initColumn: function() {
		this._super();
		this._columns = new ColumnCollection(this);
		this._sum = UNDEFINED;
	},
	orientation: ColumnGroupOrientation.HORIZONTAL,
    hideChildHeaders: false,
    columns: null,
	setOrientation: function (value) {
		value = value == ColumnGroupOrientation.VERTICAL ? value : ColumnGroupOrientation.HORIZONTAL;
		if (value != this._orientation) {
			this._orientation = value;
			this.resetGroupWidths();
			this._changed();
			this.grid() && this.grid()._resetColumnPositions();
		}
	},
	columns_: function () {
		return this._columns.items();
	},
	setColumns: function (value) {
		var i,
			cnt,
			column,
			orgColumn,
			columns = this._columns,
			grid = this.grid();
		columns.clear();
		if (value && (cnt = value.length) > 0) {
			for (i = 0; i < cnt; i++) {
				column = value[i];
				if (column instanceof Column && columns.indexOf(column) < 0) {
					this._columns.add(column);
				// grid.setColumn을 이용해서 column의 속성을 다시 지정할때.
				} else if (column.$_hash >= 0 && grid && (orgColumn = grid.columnByHash(column.$_hash))) {
					orgColumn.assign(column);
					this._columns.add(orgColumn);
				} else if (!(column instanceof Column)) {
					column = GridBase.createColumn(column);
					this._columns.add(column);
				}
			}
			this.$_attachChildren();
		}
		if (this.grid()) {
			this.grid()._columnsReset(this);
		}
	},
    visibleItems: function () {
        return this._columns.visibleItems();
    },
    getOrderedColumns: function () {
    	return this._columns.getOrderedColumns();
    },
    /*internal */ dataLevel: function () {
        return this._dataLevel;
    },
    /*internal */ headerLevel: function () {
        return this._headerLevel;
    },
	count: function () {
		return this._columns.count();
	},
	visibleCount: function () {
		return this._columns.visibleCount();
	},
	isVertical: function () {
		return this._orientation == ColumnGroupOrientation.VERTICAL;
	},
	isHorizontal: function () {
		return this._orientation != ColumnGroupOrientation.VERTICAL;
	},
	first: function () {
		return $_getFirstColumn(this) || this;
	},
	last: function () {
		return $_getLastColumn(this) || this;
	},
	getItem: function (index) {
		return this._columns.getItem(index);
	},
	getVisibleItem: function (index) {
        if (index < 0 || index >= this._columns.visibleCount()) {
            throw "Invalid visible index: " + index;
        }
		return this._columns.getVisibleItem(index);
	},
	getOrderedItem: function (index) {
		return this._columns.getOrderedItem(index);
	},
	isAncestorOf: function (column) {
		if (column && column !== this) {
			var p = column._parent;
			while (p) {
				if (p === this) {
					return true;
				}
				p = p._parent;
			}
		}
		return false;
	},
    setChildrenProperty: function (prop, value, recursive, visibleOnly) {
        this._columns.setChildrenProperty(prop, value, recursive, visibleOnly);
    },
	/* @internal */ calcHeaderLevels: function (visibleOnly, showColumns, hideColumns) {
		visibleOnly = arguments.length < 1 ? true : visibleOnly;
		showColumns = arguments.length < 2 ? [] : showColumns;
		hideColumns = arguments.length < 3 ? [] : hideColumns;
		var levels = this.header().isVisible() ? 1 : 0;
		if (!this._hideChildHeaders) {
			var i,
				group,
				cols = (visibleOnly && showColumns.length < 1) ? this.visibleCount() : this._columns.count(),
				cnt = 0;
			if (cols > 0) {
				if (this.isHorizontal()) {
					cnt = 0;
					for (i = 0; i < cols; i++) {
						group = (visibleOnly && showColumns.length < 1) ? this.getVisibleItem(i) : this.getItem(i);
						if (((!visibleOnly || group.isVisible()) && hideColumns.indexOf(group.name()) < 0) || (!group.isVisible() && showColumns.indexOf(group.name()) >= 0)) {
							if (group instanceof ColumnGroup) {
								cnt = Math.max(cnt, group.calcHeaderLevels(visibleOnly, showColumns, hideColumns));
							} else {
								cnt = Math.max(cnt, 1);
							}
						}
					}
				} else {
					for (i = 0; i < cols; i++) {
						group = (visibleOnly && showColumns.length < 1) ? this.getVisibleItem(i) : this.getItem(i);
						if (((!visibleOnly || group.isVisible()) && hideColumns.indexOf(group.name()) < 0) || (!group.isVisible() && showColumns.indexOf(group.name()) >= 0)) {
							if (group instanceof ColumnGroup) {
									cnt += group.calcHeaderLevels(visibleOnly, showColumns, hideColumns);
							} else {
								cnt++;
							}
						}
					}
				}
			}
			levels = cnt === 0 ? 0 : levels + cnt;
		}
		return this._headerLevel = levels;
	},
	/* @internal */ calcDataLevels: function (visibleOnly, showColumns, hideColumns) {
		visibleOnly = arguments.length < 1 ? true : visibleOnly;
		showColumns = arguments.length < 2 ? [] : showColumns;
		hideColumns = arguments.length < 3 ? [] : hideColumns;
		var	levels = 0;
		var	cols = (visibleOnly && showColumns.length  < 1) ? this.visibleCount() : this.count();
		var	cnt = 0;
        var i, group;
		if (cols > 0) {
			if (this.isHorizontal()) {
				cnt = 0;
				for (i = 0; i < cols; i++) {
					group = (visibleOnly && showColumns.length  < 1) ? this.getVisibleItem(i) : this.getItem(i) ;
					if (((!visibleOnly|| group.isVisible()) && hideColumns.indexOf(group.name()) < 0) || (!group.isVisible() && showColumns.indexOf(group.name()) >= 0)) {
						if (group instanceof ColumnGroup) {
							cnt = Math.max(cnt, group.calcDataLevels(visibleOnly, showColumns, hideColumns));
						} else {
							cnt = Math.max(cnt, 1);
						}
					}
				}
			} else {
				for (i = 0; i < cols; i++) {
					group = (visibleOnly && showColumns.length  < 1) ? this.getVisibleItem(i) : this.getItem(i) ;
					if (((!visibleOnly || group.isVisible()) && hideColumns.indexOf(group.name()) < 0) || (!group.isVisible() && showColumns.indexOf(group.name()) >= 0)) {
						if (group instanceof ColumnGroup) {
							cnt += group.calcDataLevels(visibleOnly, showColumns, hideColumns);
						} else {
							cnt++;
						}
					}
				}
			}
		}
		return this._dataLevel = levels + cnt;
	},
	/* @interal */ calcHorz: function (visibleOnly, showColumns, hideColumns) {
		visibleOnly = arguments.length < 1 ? true : visibleOnly;
		showColumns = arguments.length < 2 ? [] : showColumns;
		hideColumns = arguments.length < 3 ? [] : hideColumns;
		var	column;
		var	cnt = (visibleOnly && showColumns.length < 1) ? this.visibleCount() : this.count();
		var	result = 1;
        var i;
		if (cnt >= 1) {
			if (this.isVertical()) {
				result = 0;
				for (i = 0; i < cnt; i++) {
					column = (visibleOnly && showColumns.length < 1) ? this.getVisibleItem(i) : this.getItem(i);
					if (((!visibleOnly || column.isVisible()) && hideColumns.indexOf(column.name()) < 0) || (!column.isVisible() && showColumns.indexOf(column.name()) >= 0)) {
						if (column instanceof ColumnGroup) {
							result = Math.max(result, column.calcHorz(visibleOnly, showColumns, hideColumns));
						} else {
							result = Math.max(result, 1);
						}
					}
				}
			} else {
				result = 0;
				for (i = 0; i < cnt; i++) {
					column = (visibleOnly && showColumns.length < 1) ? this.getVisibleItem(i) : this.getItem(i);
					if (((!visibleOnly || column.isVisible()) && hideColumns.indexOf(column.name()) < 0) || (!column.isVisible() && showColumns.indexOf(column.name()) >= 0)) {
						if (column instanceof ColumnGroup) {
							result += Math.max(1, column.calcHorz(visibleOnly, showColumns, hideColumns));
						} else {
							result++;
						}
					}
				}
			}
		}
		return result;
	},
	right: function (column) {
		if (this.isHorizontal()) {
            try {
                var idx = this._checkVisible(column);
                if (idx < this.visibleCount() - 1) {
                    column = $_getRightColumn(this, idx + 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	left: function (column) {
		if (this.isHorizontal()) {
            try {
                var idx = this._checkVisible(column);
                if (idx > 0) {
                    column = $_getLeftColumn(this, idx - 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	next: function (column) {
        try {
            var idx = this._checkVisible(column);
            if (idx < this.visibleCount() - 1) {
                column = $_getNextColumn(this, idx + 1);
                return column;
            }
        } catch (err) {
        }
		return null;
	},
	prev: function (column) {
        try {
            var idx = this._checkVisible(column);
            if (idx > 0) {
                column = $_getPrevColumn(this, idx - 1);
                return column;
            }
        } catch (err) {
        }
		return null;
	},
	lower: function (column) {
		if (this.isVertical()) {
            try {
                var idx = this._checkVisible(column);
                if (idx < this.count() - 1) {
                    column = $_getLowerColumn(this, idx + 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	upper: function (column) {
		if (this.isVertical()) {
            try {
                var idx = this._checkVisible(column);
                if (idx > 0) {
                    column = $_getUpperColumn(this, idx - 1);
                    return column;
                }
            } catch (err) {
            }
		}
		return null;
	},
	getDataColumn: function (fieldIndex) {
		for (var i = 0, cnt = this.count(); i < cnt; i++) {
			var column = this.getItem(i);
			if (column instanceof DataColumn) {
				if (column.dataIndex() == fieldIndex) {
					return column;
				}
			} else if (column instanceof ColumnGroup) {
				column = column.getDataColumn(fieldIndex);
				if (column) {
					return column;
				}
			}
		}
		return null;
	},
	columnAtPoint: function (x, y) {
		var i, column, group;
		var cnt = this.visibleCount();
		if (this.isVertical()) {
			for (i = 0; i < cnt; i++) {
				column = this.getVisibleItem(i);
				if (y < column._layoutRect.bottom()) {
					group = _cast(column, ColumnGroup);
					if (group) {
						y -= column._layoutRect.y;
						return group.columnAtPoint(x, y);
					}
					return column;
				}
			}
		} else {
			for (i = 0; i < cnt; i++) {
				column = this.getVisibleItem(i);
				if (x < column._layoutRect.right()) {
					group = _cast(column, ColumnGroup);
					if (group) {
						x -= column._layoutRect.x;
						return group.columnAtPoint(x, y);
					}
					return column;
				}
			}
		}
		return this;
	},
	_addInternal: function (column, index) {
		if (!(column instanceof Column)) {
			column = GridBase.createColumn(column);
		}
		if (column && !(column instanceof ColumnGroup && column.isAncestorOf(this)) && column.parent() !== this) {
			this._columns.add(column, index);
			return column;
		}
		return null;
	},
	add: function (column, index) {
		var grid;
		var col = this._addInternal(column, index);
		if (col && (grid = this.grid())) {
			grid._columnsReset(this);
			return $$_getColumnProxy(col)
		}
		return null;
	},
	_removeInternal: function (column) {
		var index = this._columns.indexOf(column);
		if (index >= 0) {
			this._columns.removeAt(index);
			var grid = this.grid();

			var summaryView = grid._summaryView;
			var cell = summaryView && summaryView.findCell(this);
			if (cell && cell instanceof SummaryGroupCellElement) {
				var elt = cell._elements;
				cell.removeElement(cell.findCell(column));
				cell._cells && (delete cell._cells[column.$_hash]);
			}

			var footerView = grid._footerView;
			for (var i = 0 , cnt = grid.footer().count(); i < cnt; i++) {
				var cell = footerView && footerView.findCell(i, this);
				if (cell && cell instanceof FooterGroupCellElement) {
					var elt = cell._elements;
					cell.removeElement(cell.findCell(column));
					cell._cells && (delete cell._cells[column.$_hash]);
				}
			}
			return true;
		}
		return false;
	},
	remove: function (column) {
		if (this._removeInternal(column)) {
			var grid = this.grid();
			if (grid) {
				grid._columnsReset(this);
			}
			return true;
		}
		return false;
	},
	removeAt: function (index) {
		if (index >= 0 && index < this.count()) {
			this._columns.removeAt(index);
            var grid = this.grid();
			if (grid) {
				grid._columnsReset(this);
			}
            return true;
		}
        return false;
	},
	clear: function () {
		if (this.count() > 0) {
			this._columns.clear();
            var grid = this.grid();
            if (grid) {
                grid._columnsReset(this);
			}
		}
	},
	setChildIndex: function (column, newIndex) {
		var grid = this.grid();
		if (column && column.parent() === this && column.index() != newIndex) {
			if (this._columns.move(column, newIndex) && grid) {
				grid._columnIndexChanged(column);
			}
		}
	},
	setVisibleIndex: function (column, newIndex) {
		var grid = this.grid();
		if (column && column.parent() === this) {
			if (this._columns.moveVisible(column, newIndex) && grid) {
				grid._columnVisibleIndexChanged(column);
			}
		}
	},
	/* @internal */ initGroupWidths: function () {
		var cnt = this._columns.count();
		if (cnt < 1) {
			return;
		}
		for (var i = 0; i < cnt; i++) {
			var column = this._columns.getItem(i);
			column._displayWidth = column._groupWidth = NaN;
			if (column instanceof ColumnGroup) {
				column.initGroupWidths();
			}
		}
		/*
		var column, sum, i, w, len;
		var gw = this._groupWidth;
		if (this.isVertical()) {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				column._groupWidth = gw;
				column._displayOffset = 0;
			}
		} else {
			sum = 0;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				sum += column._width;
			}
			len = 0;
			for (i = 0; i < cnt - 1; i++) {
				column = this._columns.getItem(i);
				w = gw * column._width / sum;
				column._groupWidth = w;
				column._displayOffset = _int(len);
				len += w;
			}
			column = this._columns.getItem(cnt - 1);
			w = gw - len;
			column._groupWidth = w;
			column._displayOffset = _int(len);
		}
		for (i = 0; i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column instanceof ColumnGroup) {
				column.initGroupWidths();
			}
		}
		*/
	},
	/* @internal */ restoreGroupWidths: function () {
		var cnt = this._columns.count();
		if (cnt < 1) {
			return;
		}
		var column, sum, i, w, len;
		var gw = this._groupWidth;
		if (this.isVertical()) {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				column._displayWidth = column._groupWidth = gw;
				column._displayOffset = 0;
			}
		} else {
			sum = 0;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				sum += column._displayWidth = !isNaN(column._saveWidth) ? column._saveWidth : column._groupWidth;
			}
			len = 0;
			for (i = 0; i < cnt - 1; i++) {
				column = this._columns.getItem(i);
				w = column._displayWidth * gw / sum;
				column._groupWidth = w;
				column._displayOffset = _int(len);
				len += w;
                column._displayWidth = _int(len) - column._displayOffset;
			}
			column = this._columns.getItem(cnt - 1);
			w = gw - len;
			column._groupWidth = w;
			column._displayOffset = _int(len);
            column._displayWidth = _int(len + w) - column._displayOffset;
		}
		for (i = 0; i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column instanceof ColumnGroup) {
				column.restoreGroupWidths();
			}
		}
	},
	/* TODO group에 fillWidth가 있거나 하위 컬럼이 fillWidth가 있는 경우 fitStyle을 fill로 변경후 width 변경 다시 none으로 변경하고 width 변경시 
	   원래의 크기로 돌아가는 경우가 발생한다. 
	   또한 fillWidth가 있는 컬럼의 크기 변경을 제한해야하는 경우가 발생할수 있다.
	*/
	/* @internal */ resetGroupWidths: function () {
		var cnt = this._columns.visibleCount();
		if (cnt < 1) {
			return;
		}
		var i, column, sum, w, len, wSum, fillWidths = 0, dx;
		var gw = this._groupWidth;
		var grid = this.grid();
		var isFill = grid.displayOptions().fitStyle() === GridFitStyle.FILL;
		if (this.isVertical()) {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				column._displayWidth = column._groupWidth = gw;
				column._displayOffset = 0;
			}
		} else {
			sum = 0;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				column._displayWidth = column._width;
				if (isFill && column.fillWidth() > 0) {
					fillWidths +=  column.fillWidth();
				} else {
					sum += column._displayWidth;
				}
			}
			len = 0;
			wSum = 0;
			if (isFill && fillWidths > 0) {
				sum = gw - sum;
				for (i = 0; i < cnt ; i++) {
					column = this._columns.getVisibleItem(i);
					column._displayOffset = _int(len);
					if ((dx = column.fillWidth()) > 0) {
						len += column._groupWidth = _int(sum * dx / fillWidths);
					} else {
						len += column._groupWidth = (column._fitWidth ? column._fitWidth : column._displayWidth);
					}
					column._displayWidth = _int(len) - column._displayOffset;
				}
			} else {
				for (i = 0; i < cnt - 1; i++) {
					column = this._columns.getVisibleItem(i);
					wSum += column._displayWidth;
					w = _int(gw * wSum / sum) - len;
					column._groupWidth = w;
					column._displayOffset = _int(len);
					len += w;
	                column._displayWidth = _int(len) - column._displayOffset;
				}
				column = this._columns.getVisibleItem(cnt - 1);
				w = gw - len;
				column._groupWidth = w;
				column._displayOffset = _int(len);
	            column._displayWidth = _int(len + w) - column._displayOffset;
	        }
		}
		for (i = 0; i < cnt; i++) {
			column = this._columns.getVisibleItem(i);
			if (column instanceof ColumnGroup) {
				column.resetGroupWidths();
			}
		}
	},
	collectColumns: function (list, columnsOnly, visibleOnly, ordered) {
		var columns = ordered ? this._columns.getOrderedColumns() : this._columns.items();

		for (var i = 0, cnt = columns.length; i < cnt ; i++) {
			var column = columns[i];
			if (!visibleOnly || column.isVisible()) {
				if ((!columnsOnly || !(column instanceof ColumnGroup))) {
					list.push(column);
				}
				if (column instanceof ColumnGroup) {
					column.collectColumns(list, columnsOnly, visibleOnly, ordered);
				}
			}
		}
	},
	collectGroups: function (list) {
		for (var i = 0, cnt = this._columns.count(); i < cnt; i++) {
			var group = _cast(this._columns.getItem(i), ColumnGroup);
			if (group) {
				list.push(group);
				group.collectGroups(list);
			}
		}
	},
	collectColumnNames: function (list, columnsOnly, visibleOnly, ordered) {
		var columns = ordered ? this._columns.getOrderedColumns(): this._columns.items();
		for (var i = 0, cnt = columns.length; i < cnt; i++) {
			var column = columns[i];
            var name;
			if (column && (name = column.name()) && (!columnsOnly || !(column instanceof ColumnGroup)) && (!visibleOnly || column.isVisible())) {
                list.push(name);
			}
			if (column instanceof ColumnGroup) {
				column.collectColumnNames(list, columnsOnly, visibleOnly, ordered);
			}
		}
		return list;
	},
	collectGroupNames: function (list) {
		for (var i = 0, cnt = this._columns.count(); i < cnt; i++) {
			var column = this._columns.getItem(i);
			if (column instanceof ColumnGroup) {
                var name = column.name();
				name && list.push(name);
				column.collectGroupNames(list);
			}
		}
		return list;
	},
	/* @intenral */ clearMergeGrouped: function () {
		var i, column,
			cnt = this._columns.count();
		for (i = 0; i < cnt; i++) {
			column = this._columns.getItem(i);
			if (column instanceof DataColumn) {
				column._setMergeGrouped(false);
			}
			if (column instanceof ColumnGroup) {
				column.clearMergeGrouped();
			}
		}
	},
	columnByName: function (name) {
		return this._columns.columnByName(name);
	},
	valueColumnByName: function (name) {
		return this._columns.valueColumnByName(name);
	},
	columnByField: function (fieldIndex) {
		if (fieldIndex >= 0) {
			var i,
				cnt = this._columns.count(),
				column;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column instanceof DataColumn && column.fieldName() && column.dataIndex() == fieldIndex) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column.columnByField(fieldIndex);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	columnByFieldName: function (fieldName) {
		if (fieldName) {
			var fld = fieldName.toLowerCase(),
				i,
				cnt = this._columns.count(),
				column;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column instanceof DataColumn && column.fieldName() && column.fieldName().toLowerCase() == fld) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column.columnByFieldName(fieldName);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	collectColumnsByFieldName: function (fieldName, list) {
		if (fieldName) {
			var fld = fieldName.toLowerCase(),
				i,
				cnt = this._columns.count(),
				column;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column instanceof DataColumn && column.fieldName() && column.fieldName().toLowerCase() == fld) {
					list.push(column);
				}
				if (column instanceof ColumnGroup) {
					column.collectColumnsByFieldName(fieldName, list);
				}
			}
		}
	},
	columnByTag: function (tag) {
		if (tag) {
			var i,
				cnt = this._columns.count(),
				column;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column.tag() == tag) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column.columnByTag(tag);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	collectColumnsByTag: function (tag, list) {
		if (tag) {
			var i,
				cnt = this._columns.count(),
				column;
			for (i = 0; i < cnt; i++) {
				column = this._columns.getItem(i);
				if (column.tag() == tag) {
					list.push(column);
				}
				if (column instanceof ColumnGroup) {
					column.collectColumnsByTag(tag, list);
				}
			}
		}
	},
    getLeafItems: function (visibleOnly) {
        visibleOnly = arguments.length > 0 ? visibleOnly : true;
        var columns = [];
        $_collectColumns(this, columns, visibleOnly);
        return columns;
    },
    getHorzColumns: function (start, count) {
        var columns = [];
        var end = start != undefined && count != undefined ? start + count - 1 : undefined;
        $_collectHorzColumns(this, columns, start, end);
        return columns;
    },
    getValueColumns: function (visibleOnly) {
        visibleOnly = arguments.length > 0 ? visibleOnly : true;
        var columns = [];
        $_collectValueColumns(this, columns, visibleOnly);
        return columns;
    },
	getDataColumns: function (visibleOnly) {
		visibleOnly = arguments.length > 0 ? visibleOnly : true;
		var columns = [];
		$_collectDataColumns(this, columns, visibleOnly);
		return columns;
	},
	/* @internal */ clearFitWidths: function () {
		this._columns.$_clearFitWidths();
	},
	/* @internal */ resetFitWidths: function () {
		var cnt = this._columns.visibleCount();
		if (cnt < 1) {
			return;
		}
		var i;
		var w;
		var len;
		var column;
		var group;
		var sum = 0;
		var wSum = 0;
		var fSum = 0;
		var gw = this._fitWidth;
		var isFill = this.grid().displayOptions().fitStyle() === GridFitStyle.FILL;
		var lastCol;
		if (this.isHorizontal()) {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				isFill && column._fillWidth > 0 ? (fSum += column._fillWidth, lastCol = column) : (sum += column._groupWidth);
			}
			len = 0;
			wSum = 0;
			if (isFill && fSum > 0) {
				sum = gw - sum;
				for (i = 0; i < cnt ; i++) {
					column = this._columns.getVisibleItem(i);
					if (column.fillWidth() > 0) {
						wSum += w = column._fitWidth = _int(sum * column._fillWidth / fSum);
					} else {
						w = column._fitWidth = column._groupWidth;
					}
				}
				for (i = 0; i < cnt ; i++) {
					column = this._columns.getVisibleItem(i);
					column._fitOffset = len;
					lastCol === column && (column._fitWidth += (sum - wSum));
					len += column._fitWidth;
				}
			} else {
				for (i = 0; i < cnt - 1; i++) {
					column = this._columns.getVisibleItem(i);
					column._fitOffset = len;
					wSum += column._groupWidth;
					w = _int(wSum * gw / sum) - len;
					column._fitWidth = w;
					len += w;
				}
				column = this._columns.getVisibleItem(cnt - 1);
				w = gw - len;
				column._fitWidth = w;
				column._fitOffset = len;
			}
		} else {
			for (i = 0; i < cnt; i++) {
				column = this._columns.getVisibleItem(i);
				column._fitWidth = this._fitWidth;
				column._fitOffset = 0;
			}
		}
		for (i = 0; i < cnt; i++) {
			group = _cast(this._columns.getVisibleItem(i), ColumnGroup);
			if (group) {
				group.resetFitWidths();
			}
		}
	},
	_createHeader: function () {
		return new ColumnGroupHeader(this);
	},
	clean: function () {
		this._super();
		for (var i = this.count(); i--;) {
			this.getItem(i).clean();
		}
	},
	$_attachChildren: function () {
		var i;
		var column;
		var cnt = this.count();
		for (i = 0; i < cnt; i++) {
			column = this.getItem(i);
			column._setParent(this);
			if (column instanceof ColumnGroup) {
				column.$_attachChildren();
			}
		}
	},
	_columnAdded: function (column) {
	},
	_columnRemoved: function (column) {
	},
	_parentChanged: function () {
		this._super();
		var cols = this.columns();
		for (var i = 0; i < cols.length; i++) {
			cols[i]._parentChanged();
		}
	},

	initVisibles: function () {
		this._columns.$_initVisibles();
	},
	resetVisibles: function () {
		this._columns.$_resetVisibles();
	},
	resetStates: function () {
		this._columns.$_resetStates(this.grid());
	},
	resetIndicies: function (grid) {
		this._columns.$_resetIndicies(grid);
	},
	_checkVisible: function (column) {
		var i;
		if (!column || (i = column._displayIndex) < 0 || column !== this.getVisibleItem(i)) {
			throw new Error("Column is not a visible group member");
		}
		return i;
	},
	_clearSavedWidths: function () {
		for (var i = 0, cnt = this.count(); i < cnt; i++) {
			var c = this.getItem(i);
			c._saveWidth = NaN;
			if (c instanceof ColumnGroup) {
				c._clearSavedWidths();
			}
		}
	},
	_saveOrgWidths: function () {
		for (var i = 0, cnt = this.count(); i < cnt; i++) {
			var c = this.getItem(i);
			c._orgWidth = c.saveWidth();
			if (c instanceof ColumnGroup) {
				c._saveOrgWidths();
			}
		}
	},
	_restoreOrgWidths: function () {
		for (var i = 0, cnt = this.count(); i < cnt; i++) {
			var c = this.getItem(i);
			c._saveWidth = c._orgWidth;
			if (c instanceof ColumnGroup) {
				c._restoreOrgWidths();
			}
		}
	}
}, {
	getRight: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.right(column);
			if (!column) {
				column = ColumnGroup.getRight(group);
			}
			return column;
		}
		return null;
	},
	getLeft: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.left(column);
			if (!column) {
				column = ColumnGroup.getLeft(group);
			}
			return column;
		}
		return null;
	},
	getNext: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.next(column);
			if (!column) {
				column = ColumnGroup.getNext(group);
			}
			return column;
		}
		return null;
	},
	getPrev: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.prev(column);
			if (!column) {
				column = ColumnGroup.getPrev(group);
			}
			return column;
		}
		return null;
	},
	getLower: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.lower(column);
			if (!column) {
				column = ColumnGroup.getLower(group);
			}
			return column;
		}
		return null;
	},
	getUpper: function (column) {
		var group = column && column._parent;
		if (group) {
			column = group.upper(column);
			if (!column) {
				column = ColumnGroup.getUpper(group);
			}
			return column;
		}
		return null;
	},
	getTop: function (column) {
		var upper;
		var top = null;
		while (column) {
			if (ColumnGroup.isTop(column)) {
				top = column;
				break;
			}

			upper = ColumnGroup.getUpper(column);
			if (!upper) {
				top = column;
				break;
			}

			column = upper;
		}
		if (top) {
			var group = top.group();
			if (group) {
				return top; //group.first();
			} else {
				return top;
			}
		} else {
			return null;
		}
	},
	getBottom: function (column) {
		var lower;
		var bottom = null;
		while (column) {
			if (ColumnGroup.isBottom(column)) {
				bottom = column;
				break;
			}

			lower = ColumnGroup.getLower(column);
			if (!lower) {
				bottom = column;
				break;
			}

			column = lower;
		}

		if (bottom) {
			var group = bottom.group();
			if (group) {
				return bottom;//group.last();
			} else {
				return bottom;
			}
		} else {
			return null;
		}
	},
	isTop: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.isVertical() && group.visibleCount() > 1 && column._displayIndex > 0) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	isBottom: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.isVertical() && group.visibleCount() > 1 && column._displayIndex < group.visibleCount() - 1) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	isLeft: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.isHorizontal() && group.visibleCount() > 1 && column._displayIndex > 0) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	isRight: function (column) {
		var group = column && column._parent;
		while (group) {
			if (group.isVertical() && group.visibleCount() > 1 && column._displayIndex < group.visibleCount() - 1) {
				return false;
			}
			column = group;
			group = column._parent;
		}
		return true;
	},
	getAncestors: function (column, ancestors) {
		if (!ancestors) {
			ancestors = [];
		} else {
			ancestors.length = 0;
		}
		var g = column._parent;
		while (g && !(g instanceof RootColumn)) {
			ancestors.push(g);
			g = g._parent;
		}
		return ancestors;
	},
	getFirstDataRoot: function (group) {
		var c;
		var g;
		var cnt = group.visibleCount();
		if (cnt < 1) {
			c = group;
		} else if (group.isVertical() && cnt > 1) {
			c = group;
		} else {
			c = group.getVisibleItem(0);
			if (c instanceof ColumnGroup) {
				c = ColumnGroup.getFirstDataRoot(c);
			}
		}
		return c;
	},
	getLastDataRoot: function (group) {
		var c;
		var g;
		var cnt = group.visibleCount();
		if (cnt < 1) {
			c = group;
		} else if (group.isVertical() && cnt > 1) {
			c = group;
		} else {
			c = group.getVisibleItem(group.visibleCount() - 1);
            if (c instanceof ColumnGroup) {
				c = ColumnGroup.getLastDataRoot(c);
			}
		}
		return c;
	},
	/**
	 * setWidthByRate와 달리 사용자가 실제 변경한 셀의 너비를 정확히 반영하고,
	 * 그 상태를 상위로 전달한다.
	 */
	changeWidth2: function (column, delta, fitting, minWidth) {
		if (!column || delta == 0) {
			return;
		}
        if (isNaN(minWidth)) {
            minWidth = 0;
        } else {
            minWidth = Math.max(0, minWidth);
        }
		var p = column.parent();
		var sum = 0;
		var dx = delta;
        var i, col,	cnt, cnt2;
		if (fitting) {
			var sumFit = 0;
			sum = 0;
			for (i = 0, cnt = p.visibleCount(); i < cnt; i++) {
				sum += p.getVisibleItem(i)._groupWidth;
				sumFit += p.getVisibleItem(i)._fitWidth;
			}
			dx = delta * (sum / sumFit);
			dx = delta > 0 ? Math.max(1, dx) : Math.min(-1, dx);
		}
		if (column.group()) {
			var c, group;
			column._groupWidth = Math.max(minWidth, column._groupWidth + dx);
			if (column instanceof ColumnGroup) {
				column.resetGroupWidths();
			}
			var groups = ColumnGroup.getAncestors(column);
			for (i = 0, cnt = groups.length; i < cnt; i++) {
				group = groups[i];
				if (group.isVertical()) {
					group._groupWidth = column._groupWidth;
					for (c = 0, cnt2 = group.count(); c < cnt2; c++) {
						col = group.getItem(c);
						if (col !== column) {
							col._groupWidth = column._groupWidth;
							if (col instanceof ColumnGroup) {
								col.resetGroupWidths();
							}
						}
						col._displayOffset = 0;
					}
				} else {
					sum = 0;
					for (c = 0, cnt2 = group.visibleCount(); c < cnt2; c++) {
						col = group.getVisibleItem(c);
						col._displayOffset = _int(sum);
						sum += col._groupWidth;
					}
					group._groupWidth = sum;
				}
				if (group == column.root()) {
					group.setWidth(group._groupWidth);
				} else {
					column = group;
				}
			}
		} else if (column) {
			column.setWidth(Math.max(0, column._width + dx));
		}
	},
    /**
     * setWidthByRate와 달리 사용자가 실제 변경한 셀의 너비를 정확히 반영하고,
     * 그 상태를 상위로 전달한다.
     */
    changeWidth: function (column, delta, fitting, minWidth, columnFitted) {
        if (!column || delta == 0) {
            return;
        }
        if (isNaN(minWidth)) {
            minWidth = 2;
        } else {
            minWidth = Math.max(0, minWidth);
        }
        if (column.displayWidth() + delta < minWidth) {
            return;
        }
        var p = column.parent();
        var sum = 0;
        var dx = delta;
        var i, g, cnt, w;
        if (fitting) {
            var sumFit = 0;
            sum = 0;
            for (i = 0, cnt = p.visibleCount(); i < cnt; i++) {
                sum += p.getVisibleItem(i)._groupWidth;
                sumFit += p.getVisibleItem(i)._fitWidth;
            }
            dx = delta * (sum / sumFit);
            dx = delta > 0 ? Math.max(1, dx) : Math.min(-1, dx);
        }
        if (g = column.group()) {
            var groups = ColumnGroup.getAncestors(column);
            if (!g.isVertical()) {
				w = column._groupWidth > 0 ? column._width * dx / column._groupWidth : 0;
				if (_int(column._width + w) <= 0 && columnFitted) {
					return;
				}
                column.setWidth(Math.max(0, column._width + w));
            }
            for (i = 0; i < groups.length - 1; i++) {
                g = groups[i];
				w = g._groupWidth > 0 ? g._width * dx / g._groupWidth : 0;
                g.setWidth(Math.max(minWidth, g._width + w));
            }
            g = groups[groups.length - 1];
            g.setWidth(Math.max(minWidth, _int(g._width + dx)));
            for (i = groups.length; i--;) {
                g = groups[i];
                g.resetGroupWidths();
            }
            if (column instanceof ColumnGroup) {
                column.resetGroupWidths();
            }
        } else if (column) {
            column.setWidth(Math.max(minWidth, column._width + dx));
        }
    }
});
var ColumnGroup$ = ColumnGroup.prototype;
var $_collectColumns = function (group, list, visibleOnly) {
	var cnt = visibleOnly ? group.visibleCount() : group.count();
	for (var i = 0; i < cnt; i++) {
		var column = visibleOnly ? group.getVisibleItem(i) : group.getItem(i);
		if (column._columns) {
			$_collectColumns(column, list, visibleOnly);
		} else {
			list.push(column);
		}
	}
};
var $_collectHorzColumns = function (group, list, start, end) {
	if (group.isHorizontal()) {
		var cnt = group.visibleCount();
		start = start == undefined ? 0 : start;
		end = end == undefined ? cnt-1 : end;
		for (var i = 0; i < cnt; i++) {
			if (i >= start && i <= end) {
				var column = group.getVisibleItem(i);
				if (column._columns) {
					$_collectHorzColumns(column, list);
				} else {
					list.push(column);
				}
			}
		}
	}
};
var $_collectValueColumns = function (group, columns, visibleOnly) {
    var cnt = visibleOnly ? group.visibleCount() : group.count();
    for (var i = 0; i < cnt; i++) {
        var column = visibleOnly ? group.getVisibleItem(i) : group.getItem(i);
        if (column instanceof ValueColumn) {
            columns.push(column);
        } else if (column instanceof ColumnGroup) {
            $_collectValueColumns(column, columns, visibleOnly);
        }
    }
};
var $_collectDataColumns = function (group, columns, visibleOnly) {
    var cnt = visibleOnly ? group.visibleCount() : group.count();
    for (var i = 0; i < cnt; i++) {
        var column = visibleOnly ? group.getVisibleItem(i) : group.getItem(i);
        if (column instanceof DataColumn) {
            columns.push(column);
        } else if (column instanceof ColumnGroup) {
            $_collectDataColumns(column, columns, visibleOnly);
        }
    }
};
var $_getFirstColumn = function (group) {
	var cnt = group.visibleCount();
	for (var i = 0; i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = $_getFirstColumn(column);
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getLastColumn = function (group) {
	for (var i = group.visibleCount() - 1; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = $_getLastColumn(column);
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getRightColumn = function (group, idx) {
	for (var i = idx, cnt = group.visibleCount(); i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.first();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getLeftColumn = function (group, idx) {
	for (var i = idx; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.last();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getNextColumn = function (group, idx) {
	for (var i = idx, cnt = group.visibleCount(); i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.first();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getPrevColumn = function (group, idx) {
	for (var i = idx; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.last();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getLowerColumn = function (group, idx) {
	for (var i = idx, cnt = group.visibleCount(); i < cnt; i++) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.first();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var $_getUpperColumn = function (group, idx) {
	for (var i = idx; i >= 0; i--) {
		var column = group.getVisibleItem(i);
		if (column instanceof ValueColumn) {
			return column;
		}
        if (column instanceof ColumnGroup) {
            column = column.last();
            if (column instanceof ValueColumn) {
                return column;
            }
        }
	}
	return null;
};
var ColumnCollection = defineClass("ColumnCollection", null, {
	init: function (owner) {
		this._super();
		this._owner = owner; // ColumnGroup
		this._items = [];
		this._visibles = [];
		this._orderedColumns = [];	// 숨겨진 컬럼이 있는 상태에서 moving이 발생하는 경우를 대비한다.
	},
	destroy: function() {
		this._destroying = true;
		this._items = null;
		this._visibles = null;
		this._orderedColumns = null;
		this._super();
	},
	owner: function () {
		return this._owner;
	},
	grid: function () {
		return this._owner && this._owner.grid();
	},
	count: function () {
		return this._items.length;
	},
	items: function () {
		return this._items.slice();
	},
	setItems: function (value) {
		var items = this._items;
		var orderedColumns = this._orderedColumns;
		items.length = orderedColumns.length = 0;
		if (value) {
			for (var i = 0, cnt = value.length; i < cnt; i++) {
				items.push(value[i]);
				value[i]._setParent(this._owner);
			}
			orderedColumns = items.slice();
		}
	},
    visibleItems: function () {
        return this._visibles.slice();
    },
    getOrderedColumns: function() {
    	return this._orderedColumns.slice();
    },
	visibleCount: function () {
		return this._visibles.length;
	},
	getItem: function (index) {
		return this._items[index];
	},
	getVisibleItem: function (index) {
		return this._visibles[index];
	},
	getOrderedItem: function (index) {
		return this._orderedColumns[index];
	},
	clear: function () {

		this._items.length = this._visibles.length = this._orderedColumns.length = 0;
	},
	indexOf: function (column) {
		return this._items.indexOf(column);
	},
	add: function (column, index) {
		if (column == null) {
			if ($_debug) debugger;
			throw new Error("column is null");
		}
		if (this.indexOf(column) >= 0) {
			if ($_debug) debugger;
			throw new Error("column is already contained");
		}
		index = index == null ? this._items.length : index;
		this._items.splice(index, 0, column);
		column._setParent(this._owner);
		this._orderedColumns.splice(index, 0, column);
		return this._items.length;
	},
	removeAt: function (index) {
		if (index < 0 || index >= this._items.length) {
			throw new Error("index is invalid: " + index);
		}
		var column = this._items[index];
		this._items.splice(index, 1);
		var visibleIndex = this._orderedColumns.indexOf(column);
		if (visibleIndex >= 0) {
			this._orderedColumns.splice(visibleIndex,1)
		} else {}
		column._setParent(null);
	},
	move: function (column, newIndex) {
		if (column == null) {
			throw new Error("column is null");
		}
		if (newIndex < 0 || newIndex >= this._items.length) {
			throw new Error("newIndex is invalid: " + newIndex);
		}
		if (column._parent !== this._owner || column._index == newIndex) {
			return false;
		}
		this._items.splice(column.index, 1);
		this._items.splice(newIndex, 0, column);
		return true;
	},
	moveVisible: function (column, newIndex) {
		if (column == null) {
			throw new Error("column is null");
		}
		if (newIndex < 0 || newIndex >= this._items.length) {
			return false;
		}
		if (column._parent === this._owner && column._visible) {
			if (!this.$_isVisible(column)) {
				this.$_resetVisibles(false);
				return true;
			}
			var visibles = this._visibles;
			var index = column._displayIndex;
			var prevColumn;
			if (index != newIndex) {
				visibles.splice(index, 1);
				visibles.splice(newIndex, 0, column);
				if (newIndex > 0) {
					prevColumn = visibles[newIndex-1];
				}// 옮기는 컬럼이 첫번째가 아니면 앞의 컬럼을 기억.
				var orderedColumns = this._orderedColumns;
				var idx = orderedColumns.indexOf(column);
				if (idx >= 0) {
					orderedColumns.splice(idx, 1);
				}
				if (prevColumn) {
					newIndex = orderedColumns.indexOf(prevColumn)+1;
				}// prevColumn이 있다면 옮기는 컬럼은 prevColumn뒤쪽에 추가할수 있도록 index가져오기.
				orderedColumns.splice(newIndex, 0, column);
				this.$_resetVisibles(false);
				if (this._owner instanceof ColumnGroup) {
					var grid = this._owner.grid && this._owner.grid();
					if (grid) {
						grid._columnWidthsDirty = true;
					}
				}
				return true;
			}
		}
		return false;
	},
	columnByName: function (name) {
		if (name) {
			for (var i = 0, cnt = this._items.length; i < cnt; i++) {
				var column = this._items[i];
				if (column.name() == name) {
					return column;
				}
				if (column instanceof ColumnGroup) {
					column = column._columns.columnByName(name);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	valueColumnByName: function (name) {
		if (name) {
			for (var i = 0, cnt = this._items.length; i < cnt; i++) {
				var column = this._items[i];
				if (column instanceof ColumnGroup) {
					column = column._columns.valueColumnByName(name);
					if (column) {
						return column;
					}
				} else if (column.name() == name) {
					return column;
				}
			}
		}
		return null;
	},
    setChildrenProperty: function (prop, value, recursive, visibleOnly) {
        var cols = visibleOnly ? this._visibles : this._items;
        for (var i = cols.length; i--;) {
            var col = cols[i];
            col.setProperty(prop, value);
            col instanceof ColumnGroup && col.setProperty(prop, value, true, true);
        }
    },
	$_isVisible: function (column) {
		return this._visibles.indexOf(column) >= 0;
	},
	$_initVisibles: function () {
		var i,
			cnt,
			column,
			items = this._items;
		for (i = 0, cnt = items.length; i < cnt; i++) {
			column = items[i];
			column._displayIndex = i;
			if (column instanceof ColumnGroup) {
				column.initVisibles();
			}
		}
	},
	$_resetVisibles: function (recursive) {
		if (arguments.length < 1) {
			recursive = true;
		}
		var findVisibleIdx = function (cols, column) {
			var ret = -1;
			for (var i = 0, cnt=cols.length; i<cnt ; i++)
			{
				cols[i]._visible && ret++;
				if (cols[i] === column) {
					var grid = this.grid();
					if (column._parent instanceof RootColumn && !( column instanceof DataColumn && grid.isGroupedColumn(column))) {
						var groupCnt = grid.isMergedRowGrouped && grid.isMergedRowGrouped() ? grid.rowGroupFields().length : 0;
						return Math.max(ret, groupCnt);
					} else {
						return ret;
					}
				}
			}
			return -1;
		}.bind(this);
		var i,
			cnt,
			column,
			items = this._items,
			visibles = this._visibles,
			orderedColumns = this._orderedColumns;
		for (i = visibles.length - 1; i >= 0; i--) {
			column = visibles[i];
			if (!column._visible || items.indexOf(column) < 0) {
				visibles.splice(i, 1);
			}
		}
		for (i = 0, cnt = items.length; i < cnt; i++) {
			column = items[i];
			if (column._visible) {
				if (!this.$_isVisible(column)) {
					var dIdx = findVisibleIdx(this._orderedColumns, column);
					dIdx = dIdx >= 0 ? dIdx : column._displayIndex;
					if (dIdx >= 0) {
						visibles.splice(Math.min(visibles.length, dIdx), 0, column);
					} else {
						visibles.push(column);
					}
				}
			} else {
			}
		}
		for (i = visibles.length; i--;) {
			column = visibles[i];
			column._displayIndex = i;
			column._isLastColumn = column._parent._isLastColumn && ((i == visibles.length - 1) || (column._parent instanceof ColumnGroup && column._parent.isVertical()));
			if (column instanceof ColumnGroup && recursive) {
				column.resetVisibles();
			}
			// visibles[i]._displayIndex = i;
		}
	},
	$_clearFitWidths: function () {
		for (var i = this._items.length; i--;) {
			var col = this._items[i];
			col._fitWidth = NaN;
            col._fitOffset = NaN;
			if (col instanceof ColumnGroup) {
				col.clearFitWidths();
			}
		}
	},
	$_resetStates: function (grid) {
		var i,
			c,
			column,
			sortFlds,
			sortDirs,
			items = this._items,
			cols = items.length,
			itemSource = grid.itemSource();
		for (i = 0; i < cols; i++) {
			column = items[i];
			if (column instanceof DataColumn) {
				column._setSortOrder(-1);
			}
		}
		if (itemSource) {
			sortFlds = grid.getSortFields();
			if (sortFlds) {
				sortDirs = grid.getSortDirections();
				for (i = 0; i < sortFlds.length; i++) {
					for (c = 0; c < cols; c++) {
						column = items[c];
						if (column instanceof DataColumn && column.dataIndex() == sortFlds[i]) {
							column._setSortOrder(i);
							column.setSortDirection(sortDirs[i]);
						}
					}
				}
			}
		}
		for (i = 0; i < cols; i++) {
			column = items[i];
			if (column instanceof ColumnGroup) {
				column.resetStates();
			}
		}
	},
	$_resetIndicies: function (grid) {
		var i,
			column,
			items = grid.itemSource(),
			ds = items && items.dataSource(),
			cnt = this._items.length;
		for (i = 0; i < cnt; i++) {
			column = this._items[i];
			column._index = i;		// 컬렉션 상의 위치
			if (column instanceof DataColumn) {
				column._resetDataIndex(ds);
				column._resetImages(grid);
			} else if (column instanceof SeriesColumn) {
				column.resetIndicies(ds);
			} else if (column instanceof ColumnGroup) {
				column.resetIndicies(grid);
			}
		}
	}
});

var ValueColumn = defineClass("ValueColumn", Column, {
	init: function (config) {
		this._super(config);
	},
	_initColumn: function () {
		this._super();
		this._footer = new ColumnFooter(this);
		this._rendererChanged = false;
		this._rendererObj = null;
	},
	footer: null,
	renderer: null,
	mergeRule: null,
	cursor: null,
    ignoreDefaultDynamicStyles: false,
	blankWhenCopy: false,
	blankWhenExport: false,
	textInputCase: TextInputCase.NORMAL,
	setFooter: function (value) {
		this._footer.assign(value);
	},
	rendererObj: function () {
		return this._rendererObj || this._defaultRenderer();
	},
	setRenderer: function (value) {
		//if (value != this._renderer) { renderer가 proxy가 아니므로 외부에서 변경시 즉시 변경됨. 따라서 비교가 불가능
		this._renderer = value;
		this._rendererChanged = true;
		this._changed();
		//}
	},
	setMergeRule: function (value) {
		if (value != this._mergeRule) {
			if (!(value instanceof GridMergeRule)) {
				value = ColumnMergeRule.createRule(value);
			}
			this._mergeRule = value;
			var grid = this.grid();
			if (grid) {
				grid._columnMergeRuleChanged(this);
			}
		}
	},
	isWritable: function () {
		return false;
	},
	canMerge: function () {
		return this._mergeRule !== null;
	},
	assign: function (source) {
		this._super(source);
	},
	prepare: function (grid, fixed, rightFixed) {
		Column$.prepare.call(this, grid, fixed, rightFixed);
		var delegate = grid.delegate();
		if (this._rendererChanged) {
			this._rendererObj = delegate.createRenderer(this._renderer);
			this._rendererChanged = false;
		}
	},
	clean: function () {
		this._super();
		this._footer.clean();
	},
	_footerChanged: function () {
		this._changed();
	},
	_defaultRenderer: function () {
		return TextCellRenderer.Default;
	}
}); 
var ValueColumn$ = ValueColumn.prototype;
var DataColumn = defineClass("DataColumn", ValueColumn, {
	init: function (config) {
		this._super(config);
	},
	_initColumn: function () {
		this._super();
		this._dataIndex = -1;
		this._baseIndex = -1;
		this._valueType = ValueType.TEXT;
		this._sortOrder = -1;
		this._menu = null;
		this._images = null;
		this._lookupSource = null;
		this._lookupKeyFields = null;
		this._lookupKeyFieldIds = null;
		this._lookupMap = null;
		this._labelFieldIndex = -1;
		this._mergeGrouped = false;
		this._editorOptions = null;
		this._filters = new ColumnFilterCollection(this);
		this._filters.addListener(this);
		this._filterActions = [];
		this._dynamicStyles = new DynamicStyleCollection(this);
		this._validations = new EditValidationCollection();
		this._imageButtonsRenderer = null;
		this._displayRegExpObj = null;
		this._excelFormulaStatement = null;
		this._equalBlankExpression = null;
		this._equalBlankRuntime = null;
	},
	destroy: function() {
		this._destroying = true;
		this._filters.removeListener(this);
		this._filters && !this._filters._destroying && this._filters.destroy && this._filters.destroy();
		this._filterActions = null;
		this._filters = null;
		this._dynamicStyles = null;
		this._validations = null;
		this._displayRegExpObj = null;
		this._excelFormulaStatement = null;
		this._equalBlankRuntime = null;
		this._super();
	},
	capitalIndexers: function () {
		return DataColumn.CAPITAL_INDEXERS;
	},
	fieldIndex: -1,
	fieldName: null,
	editable: true,
	readOnly: false,
	sortable: true,
	filterable: true,
	filterIconVisible: true,
	sortDirection: SortDirection.ASCENDING,
	sortByLabel: false,
	groupable: true,
	button: CellButton.NONE,
	buttonCursor: null,
	alwaysShowButton: false,
	alwaysShowEditButton: false,
    buttonVisibility: ButtonVisibility.DEFAULT,
    editButtonVisibility: ButtonVisibility.DEFAULT,
	popupMenu: null,
	imageButtons: null,
	defaultValue: UNDEFINED,
	required: false,
	requiredMessage: null,
	requiredLevel: ValidationLevel.ERROR,
	nanText: null,
	zeroText: null,
	dynamicStyles: null,
	validations: null,
	autoFilter: false,
	lookupDisplay: false,
	lookupCase: LookupCase.SENSITIVE,
	lookupValues: null,
	lookupLabels: null,
	lookupData: null,
	labelField: null,
	lookupSourceId: null,
	lookupKeyFields: null,
	valueSeparator: null,
	textOfInvalid: undefined,
	editor: null,
	imageList: null,
	equalBlank: false,
	equalBlankExpression: null,
	groupLevel: -1,
	filters: null,
	filterActions: null,
	error: null,
	errorLevel: ValidationLevel.IGNORE,
	excelFormat: undefined,
	excelFormulaStatement: null,
	displayRegExp: null,
	displayReplace: null,
	displayCallback: null,
	editorOptions:null,
	displayMinusZero: null,
	setLookupData: function(value) {
		var valueProp, labelProp, data, code;
		var datas = {};
		this._lookupData = value;
		if (value) {
			if (_isArray(value)) {
				datas['list'] = value;
			} else {
				datas = value;
			}
			this._lookupLabels = [];
			this._lookupValues = [];
			this._lookupMap = null;
			valueProp = datas.hasOwnProperty("value") ? datas["value"] : "value";
			labelProp = datas.hasOwnProperty("label") ? datas["label"] : "label";
			for (var i = 0, cnt = datas.list.length; i < cnt ; i++) {
				data = datas.list[i];
				code = data[valueProp] != null ? data[valueProp] : data["code"];
				code != null && this._lookupValues.push(data[valueProp] != null ? data[valueProp] : data["code"]);
				code != null && this._lookupLabels.push(data[labelProp] != null ? data[labelProp] : data["text"] != null ? data["text"] : code);
			}
		} else {
			this._lookupLabels = null;
			this._lookupValues = null;
			this._lookupMap = null;
		}
		this._changed();
	},
	setEditable: function (value) {
		if (value != this._editable) {
			this._editable = value;
			var grid = this.grid();
			if (grid) {
				grid._dataColumnChanged(this);
			}
		}
	},
	setReadOnly: function (value) {
		if (value != this._readOnly) {
			this._readOnly = value;
			var grid = this.grid();
			if (grid) {
				grid._dataColumnChanged(this);
			}
		}
	},
	setDisplayRegExp: function (value) {
		if (value) {
			this._displayRegExp = value;
			if (typeof value == "string") {
				this._displayRegExpObj = new RegExp(value);
			} else {
				this._displayRegExpObj = value;
			}
		} else {
			this._displayRegExp = null;
			this._displayRegExpObj = null;
		}
	},
	getDisplayRegExp: function () {
		return this._displayRegExpObj;
	},
	setDisplayMinusZero: function(value) {
		if (value != this._displayMinusZero) {
			this._displayMinusZero = value;
			this._numberFormatter && this._numberFormatter.setDisplayMinusZero(value);
		}
	},
    alwaysShowButton_: function () {
        return this._buttonVisibility == ButtonVisibility.ALWAYS;
    },
    setAlwaysShowButton: function (value) {
        if (value) {
            this.setButtonVisibility(ButtonVisibility.ALWAYS);
        } else if (this._buttonVisibility == ButtonVisibility.ALWAYS) {
            this.setButtonVisibility(ButtonVisibility.DEFAULT);
        }
    },
    alwaysShowEditButton_: function () {
        return this._editButtonVisibility == ButtonVisibility.ALWAYS;
    },
    setAlwaysShowEditButton: function (value) {
        if (value) {
            this.setEditButtonVisibility(ButtonVisibility.ALWAYS);
        } else if (this._editButtonVisibility == ButtonVisibility.ALWAYS) {
            this.setEditButtonVisibility(ButtonVisibility.DEFAULT);
        }
    },
    getImageButtonRenderer: function () {
    	return this._imageButtonsRenderer;
    },
    setImageButtons: function (value) {
    	if (value && typeof value == "object" && value.hasOwnProperty("images")) {

    		this._imageButtons = value;
    		if (!this._imageButtonsRenderer) {
    			this._imageButtonsRenderer = new ImageButtonsRenderer();
    		}
    		this._imageButtonsRenderer.assign(value);
    		if (value.hasOwnProperty("width")) {
    			this._imageButtonsRenderer.setImageWidth(value.width);
    		}
    		if (value.hasOwnProperty("height")) {
    			this._imageButtonsRenderer.setImageHeight(value.height);
    		}
    		this._imageButtonsRenderer.setImageUrls(value.images);
    	} else {
    		this._imageButtonsRenderer = null;
    	}
    },
	dataIndex: function () {
		return this._dataIndex;
	},
	baseIndex: function () {
		return this._baseIndex;
	},
	valueType: function () {
		return this._valueType;
	},
	sortOrder: function () {
		return this._sortOrder;
	},
	setValidations: function (value) {
		this._validations.assign(value);
	},
    getFilters: function () {
        return this._filters.items();
    },
	hasFilters: function () {
		return this._filters.count() > 0 || this._filterActions.length > 0;
	},
	isFiltered: function () {
		return this._filters.activeCount() > 0;
	},
	filters_: function () {
		return this._filters.items();
	},
	setFilters: function (value) {
        var grid = this.grid();
        if (!grid || grid.canFiltering()) {
            this._filters.assign(value);
        }
	},
	filterActions_: function () {
		return this._filterActions.concat();
	},
	setFilterActions: function (value) {
		if (value != this._filterActions) {
			if (value !== this._filterActions) {
				this._filterActions = [];
				if (value) {
					value = _isArray(value) ? value : [value];
					for (var i = 0, cnt = value.length; i < cnt; i++) {
						if (value[i]) {
							var fa = new ColumnFilterAction(this);
							fa.assign(value[i]);
							this._filterActions.push(fa);
						}
					};
				}
			}
			var grid = this.grid();
			grid && grid.$_columnFilterActionsChanged(this);
		}
	},
	hasFilterAction: function () {
		return this._filterActions.length > 0;
	},
	setLookupValues: function (value) {
		if (value != this._lookupValues) {
			this._lookupValues = value && value.slice();
			this._lookupMap = null;
			this._changed();
		}
	},
	setLookupLabels: function (value) {
		if (value != this._lookupLabels) {
			this._lookupLabels = value && value.slice();
			this._lookupMap = null;
			this._changed();
		}
	},
	setValueSeparator: function (value) {
		if (value != this._valueSeparator) {
			this._valueSeparator = value;
			this._changed();
		}
	},
	labelFieldIndex: function () {
		return this._labelFieldIndex;
	},
	lookupSource: function () {
		return this._lookupSource;
	},
	setLookupKeyFields: function (value) {
		if (value != this._lookupKeyFields) {
			if (value && !isArray(value)) {
				value = [value];
			}
			this._lookupKeyFields = value;
			this._changed();
		}
	},
	lookupKeyFieldIds: function () {
		return this._lookupKeyFieldIds;
	},
	setDynamicStyles: function (value) {
		this._dynamicStyles.setItems(value);
		this._changed();
	},
	setEditor: function (value) {
		if (typeof value == "string") {
			this._editor = value;
		} else if (value) {
			if (value.hasOwnProperty("type")) {
				this._editor = value.type;
			}
			this._editorOptions = this._editorOptions || {};
			for (var prop in value) {
				var v = value[prop];
				if (_isArray(v)) {
					this._editorOptions[prop] = v.slice();
				} else {
					this._editorOptions[prop] = v;
				}
			}
		}
	},
	hasDomain: function () {
		return this._lookupValues && this._lookupLabels;
	},
	setImageList: function (value) {
		if (value != this._imageList) {
			this._imageList = value;
			var grid = this.grid();
			if (grid) {
				this._images = grid.getImageList(this._imageList);
			}
		}
	},
	images: function () {
		return this._images;
	},
	_resetImages: function (grid) {
		if (this._imageList) {
			this._images = grid.getImageList(this._imageList);
		} else {
			this._images = null;
		}
	},
	getImages: function () {
		return this._images;
	},
	isMergeGrouped: function () {
		return this._mergeGrouped;
	},
	_setMergeGrouped: function (value) {
		this._mergeGrouped = value;
	},
    getField: function () {
        var f = this._dataIndex;
        if (f >= 0) {
            var grid = this.grid();
            var ds = grid.dataSource();
            if (ds) {
                return ds.getField(f);
            }
        }
        return null;
    },
	getLookupLabel: function (value) {
		if (!this._lookupMap) {
			var lookupValues = this._lookupValues;
			var lookupLabels = this._lookupLabels;
			if (lookupValues && lookupValues.length > 0) {
				this._lookupMap = {};
				for (var i = 0; i < lookupValues.length; i++) {
					if (lookupLabels && lookupLabels.length > i) {
						this._lookupMap[lookupValues[i]] = lookupLabels[i];
					} else {
						this._lookupMap[lookupValues[i]] = lookupValues[i];
					}
				}
			}
		}
		var label;
		if (value && this._valueSeparator) {
			var values = value.split(this._valueSeparator);
			var labels = [];
			for (var i = 0, cnt = values.length; i < cnt; i++) {
				labels.push(this._lookupMap && this._lookupMap[values[i]] ? this._lookupMap[values[i]] : values[i]);
			}
			if (labels.length <= 0) {
				return "";
			}
			label = labels.join(this._valueSeparator);
		} else {
			label = this._lookupMap ? this._lookupMap[value] : undefined;
		}
		
		return label ? label : this.textOfInvalid() != null ? this.textOfInvalid() : value;
	},
	getLookupIndex: function (value) {
		if (this._lookupValues && this._lookupValues.length > 0) {
			for (var i = 0, cnt = this._lookupValues.length; i < cnt; i++) {
				if (this._lookupValues[i] == value) {
					return i;
				}
			}
		}
		return -1;
	},
	getLookupIndices: function (value) {
		var indices = [];
		if (value && this._lookupValues && this._lookupValues.length > 0) {
			var values = _isArray(value) ? value : value.split(this._valueSeparator);
			for (var i = 0, cnt = values.length; i < cnt ; i++) {
				if (this._lookupValues.indexOf(values[i]) >= 0) {
					indices.push(this._lookupValues.indexOf(values[i]));
				}
			}
		}
		return indices;
	},
	getLookupValue: function (index) {
		if (this._lookupValues && this._lookupValues.length > 0) {
			return this._lookupValues[index];
		}
		return undefined;
	},
	getLookupValues: function (indices) {
		var ret = [];
		if (this._lookupValues && this._lookupValues.length > 0) {
			for (var i = 0, cnt = indices.length; i < cnt ; i++) {
				if (indices[i] >= 0 && indices[i] < this._lookupValues.length) {
					ret.push(this._lookupValues[indices[i]]);
				}
			}
		}
		return ret;
	},
	getSourceValue: function (label) {
		var lookupValues = this._lookupValues;
		var lookupLabels = this._lookupLabels;
		if (lookupLabels && lookupValues) {
			var i = lookupLabels.indexOf(label);
			if (i >= 0 && lookupValues.length > i) {
				return lookupValues[i];
			}
			i = lookupValues.indexOf(label);
			if (i >= 0) {
				return lookupValues[i];
			}
		}
		return undefined;
	},
	getSourceValues: function(labels) {
		var lookupValues = this._lookupValues;
		var lookupLabels = this._lookupLabels;
		if (lookupLabels && lookupValues) {
			var idx;
			var values = [];
			var vs = this._valueSeparator;
			var labels = _isArray(labels) ? labels : vs && labels ? labels.split(vs) : [labels];
			for (var i = 0, cnt = labels.length; i < cnt ; i++) {
				idx = lookupLabels.indexOf(labels[i]);
				if (idx >= 0 && lookupValues.length > idx) {
					values.push(lookupValues[idx]);
				} else {
					values.push(labels[i])
				}
			}
			if (values.length > 0 && vs) {
				return values.join(vs);
			} else if (values.length > 0) {
				return values.join();
			}
		}
		return undefined;
	},
	clearFilters: function () {
		this.setFilters(null);
	},
	addFilters: function (filters, overwrite) {
		if (filters) {
            var grid = this.grid();
            if (!grid || grid.canFiltering()) {
                this._filters.addItems(_makeArray(filters), overwrite);
            }
		}
	},
	removeFilters: function (filterNames) {
		if (filterNames) {
            var grid = this.grid();
            if (!grid || grid.canFiltering()) {
                this._filters.removeItems(_makeArray(filterNames));
            }
		}
	},
	activateFilters: function (filterNames, active) {
		if (filterNames) {
            var grid = this.grid();
            if (!grid || grid.canFiltering()) {
                this._filters.activateItems(_makeArray(filterNames), active);
            }
		}
	},
	activateAllFilters: function (active) {
        var grid = this.grid();
        if (!grid || grid.canFiltering()) {
            this._filters.activateAll(active);
        }
	},
	hideColumnFilters: function( filterNames, hide) {
		this._filters.hideFilters(_makeArray(filterNames), hide);
	},
	hideAllColumnFilters: function (hide) {
		this._filters.hideAllFilters(hide);
	},
	toggleFilters: function (filterNames) {
		if (filterNames) {
            var grid = this.grid();
            if (!grid || grid.canFiltering()) {
                this._filters.toggleItems(_makeArray(filterNames));
            }
		}
	},
	toggleAllFilters: function () {
        var grid = this.grid();
        if (!grid || grid.canFiltering()) {
            this._filters.toggleAll();
        }
	},
	getFilter: function (filterName) {
		return this._filters.getItem(filterName);
	},
	getActiveFilters: function (active) {
		return this._filters.getActiveItems(active);
	},
	assign: function (source) {
		this._super(source);
	},
	canMerge: function () {
		return this._mergeGrouped || this._super();
	},
	prepare: function (grid, fixed, rightFixed) {
		ValueColumn$.prepare.call(this, grid, fixed, rightFixed);
		this._menu = grid.popupMenuManager().getMenu(this.popupMenu());
		var ds = grid.dataSource();
		if (this._saveFieldName != this._fieldName || this._saveLabelField != this._labelField) {
			this._resetDataIndex(ds);
		}
		var i, len;
		if (this._lookupKeyFields && (len = this._lookupKeyFields.length) > 0) {
			this._lookupKeyFieldIds = new Array(len);
			for (i = 0; i < len; i++) {
				this._lookupKeyFieldIds[i] = ds.getFieldIndex(this._lookupKeyFields[i]); 
			}
			if (this._lookupSourceId) {
				this._lookupSource = grid.lookupProvider().getSource(this._lookupSourceId);
			} else {
				this._lookupSource = null;
			}
		} else {
			this._lookupKeyFieldIds = null;
			this._lookupSource = null;
		}
		if (this._imageButtonsRenderer) {
    		this._imageButtonsRenderer.prepare(grid);
		}
		this._rendererObj && this._rendererObj.prepare && this._rendererObj.prepare(grid);
	},
	getAdapter: function (adapter) {
		if (adapter === ColumnFilterCollection) {
			return this._filters;
		}
		return this._super(adapter);
	},
	isWritable: function () {
		var w = this._editable && !this._readOnly;
        if (w && this.$_grid) {
            w = !this.$_fixed || !this.$_rightFixed || this.$_grid.$_fixedColEditable;
        }
        return w;
	},
	menu: function () {
		return this._menu;
	},
	_setSortOrder: function (value) {
		this._sortOrder = value;
	},
	_resetDataIndex: function (dataSource) {
		this._dataIndex = -1;
		this._baseIndex = -1;
		this._labelFieldIndex = -1;
		this._objectKey = this._objectCallback = undefined;
		if (dataSource) {
			if (this._fieldName) { 
				this._dataIndex = dataSource.getFieldIndex(this._fieldName);
			} else {
				this._dataIndex = this._fieldIndex;
			}
			if (this._dataIndex >= 0) {
				var field = dataSource.getField(this._dataIndex);
				this._baseIndex = dataSource.getBaseField(this._dataIndex);
				this._valueType = dataSource.getValueType(this._dataIndex);
				this._objectKey = field._objectKey;
				this._objectCallback = field._objectCallback;
			}
			this._labelFieldIndex = dataSource.getFieldIndex(this._labelField);
			this._saveFieldName = this._fieldName;
			this._saveLabelField = this._labelField;
		}
	},
	$_filterActionClick: function (action, x, y) {
		this.grid() && this.grid().$_columnFilterActionClicked(action, x, y);
	},
	onColumnFilterChanged: function (filterCollection, filter) {
		if (this.grid()) {
			this.grid().$_columnFiltersChanged(filterCollection, filter);
		}
	},
	setExcelFormulaStatement: function (value) {
		if (value != this._excelFormulaStatement) {
			this._excelFormulaStatement = value;
			if (value) {
				if (this._excelFormulaExprStatement) {
					this._excelFormulaExprStatement.setSource(value);
				} else {
					this._excelFormulaExprStatement = new ExpressionStatement(value);
				}
			} else {
				this._excelFormulaExprStatement = null;
			}
		}
	},
	setEqualBlankExpression: function(value) {
		if (value != this._equalBlankExpression) {
			this._equalBlankExpression = value;
			if (value) {
				this._equalBlankNode = ExpressionParser.Default.parse(value);
			} else {
				this._equalBlankNode = undefined;
			}
			this._changed();
		}
	}
}, {
	CAPITAL_INDEXERS: ["value", "values"]
}); 
var DerivedColumn = defineClass("DerivedColumn", ValueColumn, {
	init: function (config) {
		this._super(config);
	},
	_initColumn: function () {
		this._super();
	}
}); 
var SeriesColumn = defineClass("SeriesColumn", DerivedColumn, {
	init: function (config) {
		this._super(config);
	},
	_initColumn: function () {
		this._super();
		this._fieldArray = [];
		this._fields = null;
	},
	fieldNames: null,
	setFieldNames: function (value) {
		if (value != this._fieldNames) {
			this._fieldNames = value;
			this._fieldArray = value ? value.split(",") : [];
		}
	},
	fields: function () {
		return this._fields;
	},
	resetIndicies: function (dataSource) {
		this._fields = [];
		if (dataSource) {
			var i, fld, arr, first, last, f1, f2, j,
				cnt = this._fieldArray.length;
			for (i = 0; i < cnt; i++) {
				fld = this._fieldArray[i];
				arr = fld.split("..");
				if (arr.length > 1) {
					first = dataSource.getFieldIndex(arr[0]);
					last = dataSource.getFieldIndex(arr[1]);
					if (first >= 0 && last >= 0) {
						f1 = Math.min(first, last);
						f2 = Math.max(first, last);
						for (j = f1; j <= f2; j++) {
							this._fields.push(j);
						}
					}
				} else {
					j = dataSource.getFieldIndex(fld);
					if (j >= 0) {
						this._fields.push(j);
					}
				}
			}
		}
	},
	_defaultRenderer: function () {
		return SeriesTextCellRenderer.Default;
	}
}); 
var /* @internal */ ColumnGroupProxy = defineClass("ColumnGroupProxy", ColumnGroup, {
	init: function (source) {
		ColumnGroup$.init.call(this);
		this._items = null;
		if (source) {
			this.assignProps(source, [
				"name", "tag", "saveWidth", "width", "fillWidth", "fillHeight",
				"visible", "resizable", "movable",
				"styles",
				"orientation", "hideChildHeaders"
			]);
			var header = source.header;
			if (typeof header == "string") {
				this.header().setText(header);
			} else if (header) {
				this.header().assign(header);
			}
		}
	},
	build: function (grid) {
		var columns = ColumnGroupProxy.buildColumns(grid, this._items);
		ColumnGroup$.setColumns.call(this, columns);
	},
	setColumns: function (value) {
		this._items = value;
	}
}, {
	buildColumns: function (grid, items) {
		var columns = [];
		if (items) {
			var item;
			var column;
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				item = items[i];
				if (item instanceof ColumnGroupProxy) {
					item.build(grid);
					columns.push(item);
				} else if (item instanceof Column) {
					columns.push(item);
				} else if (typeof item == "string") {
					column = grid.layoutColumnByName(item);
					if (column) {
						columns.push(column);
					}
				} else if (item && item.name) {
					column = grid.layoutColumnByName(item.name);
					if (column) {
						column.assignProps(item, [
							"tag", "saveWidth", "width", "fillWidth", "fillHeight",
							"visible", "resizable", "movable",
							"styles"
						]);
						columns.push(column);
					}
				}
			}
		}
		return columns;
	}
}); 
var ColumnLayout = defineClass("ColumnLayout", null, {
	init: function (name) {
		Base.init.call(this);
		this._name = name;
	},
	name: null,
	items: null,
	build: function (grid) {
		var columns = ColumnGroupProxy.buildColumns(grid, this._items);
		this.$_validate(columns);
		return columns;
	},
	$_validate: function (columns) {
		if (columns && columns.length > 0) {
			var list = [];
			this.$_validateColumns(columns, list);
		}
	},
	$_validateColumns: function (columns, list) {
		for (var i = columns.length - 1; i >= 0; i--) {
			var column = columns[i];
			if (list.indexOf(column) >= 0) {
				throw new Error("Column is dupulicated: " + column.name());
			}
			list.push(column);
			if (column instanceof ColumnGroup) {
				this.$_validateColumns(column.columns(), list);
			}
		}
	}
}, {
	create: function (source) {
		if (source) {
			var items = _isArray(source) ? source : source.columns;
			var colMap = {};
			items = ColumnLayout.$_parseColumns(items, colMap);
			if (items) {
				var layout = new ColumnLayout(_isArray(source) ? null : source.name);
				layout.setItems(items);
				return layout;
			}
		}
		return null;
	},
	$_parseColumns: function (items, colMap) {
		var columns = [];
		if (items) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var c = items[i];
				var col = null;
				if (typeof c == "string") {
					if (!colMap.hasOwnProperty(c)) {
						colMap[c] = 1;
						col = c;
					}
				} else if (c) {
					if (c.type == "group") {
						col = ColumnLayout.$_parseGroup(c, colMap);
					} else if (c.hasOwnProperty("columns") && _isArray(c.columns) && c.columns.length > 0) {
						col = ColumnLayout.$_parseGroup(c, colMap);
					} else if (c.name) {
						if (!colMap.hasOwnProperty(c.name)) {
							colMap[c.name] = 1;
							col = c;
						}
					}
				}
				if (col) {
					columns.push(col);
				}
			}
		}
		return columns;
	},
	$_parseGroup: function (source, colMap) {
		var group = new ColumnGroupProxy(source);
		var columns = source.columns;
		if (columns) {
			columns = ColumnLayout.$_parseColumns(columns, colMap);
			group.setColumns(columns);
		}
		return group;
	}
}); 
var ColumnLayoutCollection = defineClass("ColumnLayoutCollection", null, {
	init : function() {
		Base.init.call(this);
		this._layouts = [];
	},
	items: function () {
		return this._layouts.concat();
	},
	count: function () {
		return this._layouts.length;
	},
	getItem: function (index) {
		if (index < 0 || index >= this._layouts.length) {
			throw "Invalid ColumnLayoutCollection index: " + index;
		}
		return this._layouts[index];
	},
	find: function (name) {
		for (var i = 0, cnt = this._layouts.length; i < cnt; i++) {
			if (this._layouts[i].name() == name) {
				return this._layouts[i];
			}
		}
		return null;
	},
	clear: function () {
		this._layouts = [];
	},
	load: function (source) {
		if (source) {
			var layout;
			if (_isArray(source)) {
				for (var i = 0, cnt = source.length; i < cnt; i++) {
					layout = ColumnLayout.create(source[i]);
					if (layout) {
						this._layouts.push(layout);
					}
				}
			} else {
				layout = ColumnLayout.create(source);
				if (layout) {
					this._layouts.push(layout);	
				}
			}
		}
	}
}); 
var GridDelegate = defineClass("GridDelegate", null, {
	init : function(grid) {
		this._super();
		this._grid = grid;
        this._dom = grid._dom;
		this._defaultEditor = null;
		this._defaultButtonRenderer = new DefaultCellButtonRenderer();
		this._defaultEditButtonRenderer = new EditButtonRenderer();
		this._cellEditors = {};
		this._selectionViews = [];
		this._rowViews = [];
		this._groupHeaderViews = [];
		this._groupFooterViews = [];
		this._mergedHeaderViews = [];
		this._mergedFooterViews = [];
		this._footerHeadRenderer = new FooterHeadRenderer();
	},
	destroy: function() {
		this._destroying = true;
		for (var type in this._cellEditors) {
			this._cellEditors[type] && !this._cellEditors[type]._destroying && this._cellEditors[type].destroy && this._cellEditors[type].destroy();
			this._cellEditors[type] = null;
			delete this._cellEditors[type]
		}
		this._cellEditors = null;
		this._grid = null;
		this._cellEditors = null;
		this._selectionViews = null;
		this._rowViews = null;
		this._groupHeaderViews = null;
		this._groupFooterViews = null;
		this._mergedHeaderViews = null;
		this._mergedFooterViews = null;
		this._defaultEditor = null;
		this._super();
	},
	isFixed: function () { return this._fixed; },
	prepareResources: function () {
		this._defaultButtonRenderer.prepare(this._grid);
	},
	createRenderer: function (renderer) {
		var r = null;
		if (renderer) {
			var type, options = null;
			if (typeof renderer === "string") {
				type = renderer;
			} else {
				type = renderer.type || "text";
				options = renderer;
			}
			switch (type) {
			case "text":
				r = new TextCellRenderer();
				break;
			case "bar":
				r = new BarCellRenderer();
				break;
			case "check":
				r = new CheckCellRenderer();
				break;
			case "icon":
				r = new IconCellRenderer();
				break;
			case "shape":
				r = new ShapeCellRenderer();
				break;
			case "signal":
				r = new SignalBarCellRenderer();
				break;
			case "image":
				r = new ImageCellRenderer();
				break;
			case "link":
				r = new LinkCellRenderer();
				break;
            case "imageButton":
                r = new ImageButtonCellRenderer();
                break;
            case "imageButtons":
                r = new ImageButtonsCellRenderer();
                break;
			case "code39":
				r = new Code39CellRenderer();
				break;
			case "code128":
				r = new Code128CellRenderer();
				break;
			case "seriesText":
				r = new SeriesTextCellRenderer();
				break;
			case "sparkLine":
				r = new SparkLineRenderer();
				break;
			case "sparkColumn":
				r = new SparkColumnRenderer();
				break;
			case "sparkWinLoss":
				r = new SparkWinLossRenderer();
				break;
			case "actualTargetBullet":
				r = new ActualTargetBulletRenderer();
				break;
			case "actualTargetText":
				r = new ActualTargetTextRenderer();
				break;
			case "multiIcon":
				r = new MultiIconCellRenderer();
				break;
			}
			if (r && options) {
				r.assign(options);
			}
		}
		return r;
	},
	borrowItemView: function (item, fixed, rightFixed) {
		var view = null;
		if (item instanceof GridRow) {
			view = this._rowViews.pop() || new RowElement(this._dom);
			view.setFixed(fixed);
			view.setRightFixed(rightFixed);
		} else if (item instanceof GroupItemImpl) {
			view = this._groupHeaderViews.pop() || new RowGroupHeaderElement(this._dom);
		} else if (item instanceof MergedGroupFooter) {
			view = this. _mergedFooterViews.pop() || new MergedFooterElement(this._dom);
			view.setFixed(fixed);
			view.setRightFixed(rightFixed);
		} else if (item instanceof GroupFooter) {
			view = this._groupFooterViews.pop() || new RowGroupFooterElement(this._dom);
			view.setFixed(fixed);
			view.setRightFixed(rightFixed);
		} else if (item instanceof MergedGroupHeader) {
			view = this._mergedHeaderViews.pop() || new MergedHeaderElement(this._dom);
			view.setFixed(fixed);
			view.setRightFixed(rightFixed);
		}
		return view;
	},
	returnItemView: function (view) {
		if (view instanceof RowElement && this._rowViews.indexOf(view) < 0) {
			this._rowViews.push(view);
		} else if (view instanceof RowGroupHeaderElement && this._groupHeaderViews.indexOf(view) < 0) {
			this._groupHeaderViews.push(view);
		} else if (view instanceof RowGroupFooterElement && this._groupFooterViews.indexOf(view) < 0) {
			this._groupFooterViews.push(view);
		} else if (view instanceof MergedHeaderElement && this._mergedHeaderViews.indexOf(view) < 0) {
			this._mergedHeaderViews.push(view);
		} else if (view instanceof MergedFooterElement && this._mergedFooterViews.indexOf(view) < 0) {
			this._mergedFooterViews.push(view);
		}
	},
	borrowSelectionView: function (item) {
		var view = this._selectionViews.pop() || (_isMobile() ? new MobileSelectionView(this._dom) : new SelectionView(this._dom));
		return view;
	},
	returnSelectionView: function (view) {
		if (view && this._selectionViews.indexOf(view) < 0) {
			this._selectionViews.push(view);
		}
	},
	getDefaultCellRenderer: function () {
		return TextCellRenderer.Default;
	},
	getCellButtonRenderer: function (index) {
		var column = index.column();
		return (column && column.button() == CellButton.IMAGE) ? column.getImageButtonRenderer() : this._defaultButtonRenderer;
	},
	createDefaultCellEditor: function () {
		var parent = this._grid._container._container;
		var editor = this._defaultEditor = new LineCellEditor(this._grid, parent);
        this._cellEditors[null] = editor;
        editor.setController(this._grid._editController);
        return editor;
	},
	getDefaultCellEditor: function () {
		if (!this._defaultEditor) {
			var parent = this._grid._container._container;
			this._defaultEditor = new LineCellEditor(this._grid, parent);
			this._cellEditors[null] = this._defaultEditor;
            this._defaultEditor.setController(this._grid._editController);
		}
		return this._defaultEditor;
	},
	getCellEditor: function (index) {
        var editorType = this.$_getCellEditorType(index);
        var parent = this._grid._container._container;
        var editor = this._cellEditors[editorType];
        if (!editor) {
            switch (editorType) {
                case "dropdown":
                    editor = new DropDownCellEditor(this._grid, parent);
                    break;
                case "multiline":
                    editor = new MultiLineCellEditor(this._grid, parent);
                    break;
                case "number":
                    editor = new NumberCellEditor(this._grid, parent);
                    break;
                case "date":
                    editor = new DateCellEditor(this._grid, parent);
                    break;
                case "btdate":
                	editor = new BTDateCellEditor(this._grid, parent);
                	break;
                case "search":
                    editor = new SearchCellEditor(this._grid, parent);
                    break;
                case "multicheck":
                	editor = new MultiCheckCellEditor(this._grid, parent);
                	break;
                case "password":
                	editor = new PasswordCellEditor(this._grid, parent);
                	break;
                case "line":
                default:
                    editor = this.getDefaultCellEditor();
                    break;
            }
            this._cellEditors[editorType] = editor;
            editor && editor.setController(this._grid._editController);
		}
		return editor;
	},
    hasEditorButton: function (index) {
        var editorType = this.$_getCellEditorType(index);
        if (editorType) {
            switch (editorType) {
                case "dropdown":
                case "date":
                case "btdate":
                case "search":
                case "multicheck":
                    return true;
                case "multiline":
                case "number":
                case "line":
                default:
                    return false;
            }
        }
        return false;
    },
	getCellEditButtonRenderer: function (index) {
		var renderer = null;
		var column = index.dataColumn();
		if (column) {
			var editorType = this.$_getCellEditorType(index);
			renderer = this._defaultEditButtonRenderer;
			if (editorType == "date" || editorType == "btdate") {
				renderer.setButtonType(EditButtonType.CALENDAR);
			} else {
				renderer.setButtonType(EditButtonType.COMBO);
			}
		}
		return renderer;
	},
	getFooterHeadRenderer: function () {
		return this._footerHeadRenderer;
	},
    getRowHeaderSummaryRenderer: function () {
        return this._footerHeadRenderer;
    },
    createGridEventHandler: function () {
        return null;
    },
    $_getCellEditorType: function (index) {
    	var editor = this._grid.getCellEditor(index);
    	if (editor) {
    		return typeof editor === "string" ? editor.toLowerCase() : (editor.type || "text");
    	};
        var column = index.dataColumn();
        if (column) {
            editor = column.editor() ? column.editor().toLowerCase() : null;
            return editor;
        }
        return null;
    }
});
var $$_FONT_HEIGHT_EX = 3;
var /* @internal */ HeightMeasurer = defineClass("HeightMeasurer", null, {
	init : function() {
		this._super();
		this._itemHeight = 0;
		this._headerHeight = 0;
		this._footerHeight = 0;
        this._summaryHeight = 0;
	},
	destroy: function() {
		return false;
	},
    itemHeight: function () { return this._itemHeight; },
    headerHeight: function () { return this._headerHeight; },
    footerHeight: function () { return this._footerHeight; },
    summaryHeight: function () { return this._summaryHeight; },
    calculate: function (grid, body, header, footer, summary) {
		grid.calcGroupLevels();
		this._itemHeight = body ? this.$_calcItemHeights(grid, grid.getDataLevel()) : 0;
		this._headerHeight = header ? this.$_calcHeaderHeights(grid, grid.getHeaderLevel()) : 0;
		this._footerHeight = footer ? this.$_calcFooterHeights(grid, grid.getDataLevel()) : 0;
        this._summaryHeight = summary ? this.$_calcSummaryHeights(grid, grid.getDataLevel()) : 0;
    },
	_calcItemLine: function (grid) {
		var styles = grid.body().styles();
		var h = styles.fontSize() + $$_FONT_HEIGHT_EX;
		var indicator = grid.indicator();
		var statebar = grid.stateBar();
		if (indicator.isVisible()) {
			h = Math.max(h, indicator.styles().fontSize() + $$_FONT_HEIGHT_EX);
		}
		if (statebar.isVisible()) {
			h = Math.max(h, statebar.styles().fontSize() + $$_FONT_HEIGHT_EX);
		}
		h = h + Math.max(1, styles.borderTopWidth()) + Math.max(1, styles.borderBottomWidth()) +
			Math.max(1, styles.paddingTop()) + Math.max(1, styles.paddingBottom());
		return _int(h);
	},
	_calcHeaderLine: function (grid) {
		var styles = grid.header().styles();
		var h = styles.fontSize() + $$_FONT_HEIGHT_EX;
		h = h + Math.max(1, styles.borderTopWidth()) + Math.max(1, styles.borderBottomWidth()) +
			Math.max(1, styles.paddingTop()) + Math.max(1, styles.paddingBottom());
		return _int(h);
	},
	_calcFooterLine: function (grid) {
		var styles = grid.footer().styles();
		var h = styles.fontSize() + $$_FONT_HEIGHT_EX;
		h = h + Math.max(1, styles.borderTopWidth()) + Math.max(1, styles.borderBottomWidth()) +
			Math.max(1, styles.paddingTop()) + Math.max(1, styles.paddingBottom());
		return _int(h);
	},
    _calcSummaryLine: function (grid) {
        var styles = grid.header().summary().styles();
        var h = styles.fontSize() + $$_FONT_HEIGHT_EX;
        h = h + Math.max(1, styles.borderTopWidth()) + Math.max(1, styles.borderBottomWidth()) +
        Math.max(1, styles.paddingTop()) + Math.max(1, styles.paddingBottom());
        return _int(h);
    },
	_setMeasuredHeight: function (column, value) {
		column._measuredHeight = value;
	},
	_getRootColumn: function (grid) {
		return grid._rootGroup();
	},
	$_calcHeaderHeights: function (grid, levels) {
		var header = grid.header();
		var hItem = _int(header.height());
		if (hItem <= 0) {
			hItem = levels * this._calcHeaderLine(grid);
		}
		hItem = _int(Math.max(header.minHeight(), hItem));
		return hItem;
	},
	$_calcFooterHeights: function (grid, levels) {
		var footer = grid.footer();
		var hItem = _int(footer.height());
		if (hItem <= 0) {
			hItem = levels * this._calcFooterLine(grid);
		}
		hItem = _int(Math.max(footer.minHeight(), hItem));
		return hItem;
	},
    $_calcSummaryHeights: function (grid, levels) {
        var summary = grid.header().summary();
        var hItem = _int(summary.height());
        if (hItem <= 0) {
            hItem = levels * this._calcSummaryLine(grid);
        }
        hItem = _int(Math.max(summary.minHeight(), hItem));
        return hItem;
    }
});
var /* @internal */ SimpleHeightsMeasurer = defineClass("SimpleHeightsMeasurer", HeightMeasurer, {
	init : function() {
		this._super();
	},
	calculate: function (grid, body, header, footer, summary) {
		this._super(grid, body, header, footer, summary);
	},
	$_arrangeItemHeights: function (group, hConst) {
		var i, h, column;
		var	total = 0;
		var cnt = group.visibleCount();
		if (group.isVertical()) {
			var hLevel = _int(hConst / group.dataLevel());
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				if (i == cnt - 1) {
					h = Math.max(0, hConst - total);
				} else if (column instanceof ColumnGroup) {
					h = hLevel * column.dataLevel();
					total += h;
				} else {
					h = hLevel;
					total += h;
				}
				this._setMeasuredHeight(column, h);
				if (column instanceof ColumnGroup) {
					this.$_arrangeItemHeights(column, h);
				}
			}
		} else {
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				this._setMeasuredHeight(column, hConst);
				if (column instanceof ColumnGroup) {
					this.$_arrangeItemHeights(column, hConst);
				}
			}
		}
	},
	$_calcItemHeights: function (grid, levels) {
		var h;
		var options = grid.displayOptions();
		var hItem = _int(options.rowHeight());
		if (hItem <= 0) {
			h = this._calcItemLine(grid);
			hItem = levels * h;
		}
		hItem = _int(Math.max(options.minRowHeight(), hItem));
		if ((h = options.maxRowHeight()) > 0 && hItem > h) {
			hItem = h;
		}
		var root = this._getRootColumn(grid);
		this.$_arrangeItemHeights(root, hItem);
		return hItem;
	}
});
SimpleHeightsMeasurer.Default = new SimpleHeightsMeasurer();
var /* @internal */ FixedHeightsMeasurer = defineClass("FixedHeightsMeasurer", HeightMeasurer, {
	init : function() {
		this._super();
	},
	calculate: function (grid, body, header, footer, summary) {
		this._super(grid, body, header, footer, summary);
	},
	$_checkHeight: function (group, hLine) {
		var cnt = group.visibleCount();
		for (var i = 0; i < cnt; i++) {
			var column = group.getVisibleItem(i);
			column._value = column.height() > 0 ? column.height() : hLine;
			if (column instanceof ColumnGroup) {
				this.$_checkHeight(column, hLine);
			}
		}
	},
	/**
	 * 밑에서 위로
	 */
	$_calcGroupHeight: function (group) {
		var i, column;
		var h = 0;
		var cnt = group.visibleCount();
		if (group.isVertical()) {
			for (var i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				if (column instanceof ColumnGroup) {
					h += this.$_calcGroupHeight(column);
				} else {
					h += column._value;
				}
			}
		} else {
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				if (column instanceof ColumnGroup) {
					h = Math.max(h, this.$_calcGroupHeight(column));
				} else {
					h = Math.max(h, column._value);
				}
			}
		}
		group._sum = h;
		return h;
	},
	/**
	 * 위에서 아래로
	 */
	$_arrangeHeights: function (group, hConst) {
		var i, h, column, hFill;
		var cnt = group.visibleCount();
		if (group.isVertical()) {
			var total = 0;
			if (group._sum > hConst) {
				for (i = 0; i < cnt; i++) {
					var column = group.getVisibleItem(i);
					if (i < cnt - 1) {
						h = _int(hConst * column._value / group._sum);
						total += h;
					} else {
						h = Math.max(0, hConst - total);
					}
					this._setMeasuredHeight(column, h);
					if (column instanceof ColumnGroup) {
						this.$_arrangeHeights(column, h);
					}
				}
			} else if (group._sum < hConst) {
				var fillSum = 0;
				for (i = 0; i < cnt; i++) {
					column = group.getVisibleItem(i);
					if ((hFill = column.fillHeight()) > 0) {
						fillSum += hFill;
					}
				}
				if (fillSum > 0) {
					var surplus = hConst - group._sum;
					for (i = 0; i < cnt; i++) {
						column = group.getVisibleItem(i);
						if (i < cnt - 1) {
							h = column._value;
							if ((hFill = column.fillHeight()) > 0) {
								h += _int(surplus * hFill / fillSum);
							}
							total += h;
						} else {
							h = Math.max(0, hConst - total);
						}
						this._setMeasuredHeight(column, h);
						if (column instanceof ColumnGroup) {
							this.$_arrangeHeights(column, h);
						}
					}
				} else {
					for (i = 0; i < cnt; i++) {
						column = group.getVisibleItem(i);
						if (i < cnt - 1) {
							h = _int(hConst * column._value / group._sum);
							total += h;
						} else {
							h = Math.max(0, hConst - total);
						}
						this._setMeasuredHeight(column, h);
						if (column instanceof ColumnGroup) {
							this.$_arrangeHeights(column, h);
						}
					}
				}
			} else {
				for (i = 0; i < cnt; i++) {
					column = group.getVisibleItem(i);
					if (i < cnt - 1) {
						h = column._value;
						total += h;
					} else {
						h = Math.max(0, hConst - total);
					}
					this._setMeasuredHeight(column, h);
					if (column instanceof ColumnGroup) {
						this.$_arrangeHeights(column, column._value);
					}
				}
			}
		}
		else {
			for (i = 0; i < cnt; i++) {
				column = group.getVisibleItem(i);
				this._setMeasuredHeight(column, hConst);
				if (column instanceof ColumnGroup) {
					this.$_arrangeHeights(column, hConst);
				}
			}
		}
	},
	$_calcItemHeights: function (grid, levels) {
		var hLine = this._calcItemLine(grid);
		var root = this._getRootColumn(grid);
		this.$_checkHeight(root, hLine);
		var options = grid.displayOptions();
		var hItem = this.$_calcGroupHeight(root);
		var h = _int(options.rowHeight());
		if (h > 0) {
			hItem = h;
		}
		hItem = _int(Math.max(hItem, options.minRowHeight()));
		if ((h = _int(options.maxRowHeight())) > 0 && hItem > h) {
			hItem = h;
		}
		this.$_arrangeHeights(root, hItem);
		return hItem;
	}
});
FixedHeightsMeasurer.Default = new FixedHeightsMeasurer();
var LM_RECT = new Rectangle();
var GridLayoutManager = defineClass("GridLayoutManager", null, {
	init: function (grid) {
		this._super();
		this._grid = grid;
        this._options = null;
		this._items = null;
		this._panelBounds = null;
		this._indicatorBounds = null;
		this._stateBarBounds = null;
		this._checkBarBounds = null;
		this._rowGroupBounds = null;
		this._rowGroupBarWidth = 0;
		this._fixedBounds = null;
		this._nonfixedBounds = null;
		this._headerBounds = null;
		this._fixedHeaderBounds = null;
        this._summaryBounds = null;
        this._fixedSummaryBounds = null;
		this._editBarBounds = null;
		this._footerBounds = null;
		this._fixedFooterBounds = null;
		this._bodyBounds = null;
		this._gridBounds = null;
		this._scrollBounds = null;
		this._columnGrouped = false;
		this._columnCount = 0;
		this._columns = [];
		this._fixedColumnPoints = [];
		this._rfixedColumnPoints = [];
		this._columnPoints = [];
		this._fixedItemCount = 0;
		this._itemCount = 0;
		this._fullItemCount = 0;
		this._availableItemCount = 0;
		this._fixedItemPoints = [];
		this._itemPoints = [];
		this._itemHeights = {};
		this._fixedCols = 0;
		this._rfixedCols = 0;
		this._fixedRows = 0;
		this._fixedWidth = 0;
		this._fixedHeight = 0;
		this._rfixedWidth = 0;
		this._focusIndex = null;
		this._columnFitted = false;
		this._columnsLength = 0;
		this._prevFirst = 0;
		this._prevLast = 0;
		this._firstCol = 0;
		this._lastCol = 0;
		this._clientRect = null;
		this._leftPos = 0;
		this._topIndex = 0;
		this._hscrollBar = false;
		this._vscrollBar = false;
		this._heightMeasurer = null;
		this._columnMerged = false;
	},
	destroy: function() {
		this._destroying = true;
		this._columns = null;
		this._fixedColumnPoints = null;
		this._rfixedColumnPoints = null;
		this._columnPoints = null;
		this._fixedItemPoints = null;
		this._itemPoints = null;
		this._itemHeights = null;
		this._grid = null;
		this._topIndex = null;
		this._leftPos = null;
		this._heightMeasurer = null;
		this._super();
	},
	heightMeasurer: null,
	grid: function () {
		return this._grid;
	},
	isColumnGrouped: function () {
		return this._columnGrouped;
	},
	isColumnMerged: function () {
		return this._columnMerged;
	},
	itemCount: function () {
		return this._itemCount;
	},
	fullItemCount: function () {
		return this._fullItemCount;
	},
	columnCount: function () {
		return this._columnCount;
	},
	isHscrollBar: function () {
		return this._hscrollBar;
	},
	isVscrollBar: function () {
		return this._vscrollBar;
	},
	columnsLength: function () {
		return this._columnsLength;
	},
	topIndex: function () {
		return this._topIndex;
	},
	leftPos: function () {
		return this._leftPos;
	},
	prevFirst: function (fixed, rfixed) {
		return fixed ? rfixed ? this.rfixedStartCol() : 0 : this._prevFirst;
	},
	prevLast: function (fixed, rfixed) {
		return fixed ? rfixed ? this._columnCount - 1 : this._fixedCols - 1 : this._prevLast;
	},
	firstCol: function (fixed, rfixed) {
		return fixed ? rfixed ? this.rfixedStartCol() : 0 : this._firstCol;
	},
	lastCol: function (fixed, rfixed) {
		return fixed ? rfixed ? this._columnCount - 1 : this._fixedCols - 1 : this._lastCol;
	},
	fixedItemCount: function () {
		return this._fixedItemCount;
	},
	fixedColCount: function () {
		return this._fixedCols;
	},
	rfixedColCount: function () {
		return this._rfixedCols;
	},
	rfixedStartCol: function () {
		return this._columnCount - this._rfixedCols;
	},
	fixedRowCount: function () {
		return this._fixedRows;
	},
	isRowGrouped: function () {
		return false;
	},
	rowGroupLevels: function () {
		return 0;
	},
	panelBounds: function () {
		return this._panelBounds.clone();
	},
	indicatorBounds: function () {
		return this._indicatorBounds.clone();
	},
	stateBarBounds: function () {
		return this._stateBarBounds.clone();
	},
	checkBarBounds: function () {
		return this._checkBarBounds.clone();
	},
	rowGroupBounds: function () {
		return this._rowGroupBounds.clone();
	},
	headerBounds: function () {
		return this._headerBounds.clone();
	},
    fixedHeaderBounds: function () {
        return this._fixedHeaderBounds.clone();
    },
    summaryBounds: function () {
        return this._summaryBounds.clone();
    },
    fixedSummaryBounds: function () {
        return this._fixedSummaryBounds.clone();
    },
	editorBounds: function () {
		return this._editorBounds.clone();
	},
	footerBounds: function () {
		return this._footerBounds.clone();
	},
    fixedFooterBounds: function () {
        return this._fixedFooterBounds.clone();
    },
	fixedBounds: function () {
		return this._fixedBounds.clone();
	},
	rfixedBounds: function () {
		return this._rfixedBounds.clone();
	},
	nonfixedBounds: function () {
		return this._nonfixedBounds.clone();
	},
	bodyBounds: function () {
		return this._bodyBounds.clone();
	},
	gridBounds: function () {
		return this._gridBounds.clone();
	},
	clientRect: function () {
		return this._clientRect.clone();
	},
	fixedWidth: function () {
		return this._fixedWidth;
	},
	rfixedLeft: function () {
		return this._rfixedBounds.x;
	},
	rfixedWidth: function () {
		return this._rfixedWidth;
	},
	fixedHeight: function () {
		return this._fixedHeight;
	},
	setHeightMeasurer: function (value) {
		this._heightMeasurer = value;
	},
	cellIsVisible: function (index) {
		var i = index.I();
		var fixed = this._fixedItemCount;
		if (i >= fixed) {
			if (i < this._topIndex + fixed) {
				return false;
			}
			if (this._fullItemCount == 0 && i == this._topIndex + fixed) {
				return true;
			}
			if (i >= this._topIndex + fixed + this._fullItemCount) {
				return false;
			}
		}
		var x;
		var column = index.column();
		if (!column) {
			if ($_debug) debugger;
		}
		var root = column.root();
		var c = root.displayIndex();
		fixed = this._fixedCols;
		if (c >= fixed) {
			x = this.columnBounds(c).x;
			while (column != root) {
				x += column.displayOffset();
				column = column.parent();
			}
			if (x < this._leftPos) {
				return false;
			}
			if (x + index.column().displayWidth() - this._leftPos > this._nonfixedBounds.width) {
				return false;
			}
		}
		return true;
	},
	makeCellVisible: function (index) {
		this._focusIndex = index.clone();
	},
	getColumn: function (index) {
		return this._columns[index];
	},
	getColumnBounds: function (index) {
        return this.columnBounds(index);
	},
    columnBounds: function (index) {
        var r, i;
        var rfixedCol = this.rfixedStartCol();
        if (index < this._fixedCols) {
            r = new Rectangle(this._fixedColumnPoints[index], 0, this._fixedColumnPoints[index + 1] - this._fixedColumnPoints[index], 0);
        } else if (index >= rfixedCol) {
        	r = new Rectangle(this._rfixedColumnPoints[index-rfixedCol], 0, this._rfixedColumnPoints[index - rfixedCol + 1] - this._rfixedColumnPoints[index-rfixedCol], 0);
        	r.offset(this._grid.fixedOptions().colBarWidth(),0);
        } else {
            i = index - this._fixedCols;
            r = new Rectangle(this._columnPoints[i], 0, this._columnPoints[i + 1] - this._columnPoints[i], 0);
        }
        return r;
    },
    getDataColumnBounds: function (column) {
        return this.dataColumnBounds(column);
    },
    dataColumnBounds: function (column) {
		var root = column.root();
		var	dataRoot = column.dataRoot();
		var	r = this.columnBounds(root.displayIndex());
		if (dataRoot !== root) {
			r.x += column.$_getOffset(dataRoot);
			r.width = !isNaN(dataRoot._fitWidth) ? _int(dataRoot._fitWidth) : dataRoot.groupWidth();
		}
		return r;
	},
	yU: function () {
		return this._grid._feedbackLayer;
	},
	getColumnRect: function (index) {
		return this.columnRect(index);
	},
	columnRect: function (index) {
		var sx, i, r;
		var rfixedCol = this.rfixedStartCol();
		if (index < this._fixedCols) {
			sx = this._gridBounds.x; 
			i = index;
			r = new Rectangle(this._fixedColumnPoints[i] + sx, 0, this._fixedColumnPoints[i + 1] - this._fixedColumnPoints[i], 0);
		} else if (index >= rfixedCol) {
			sx = this._rfixedBounds.x + this._grid.fixedOptions().colBarWidth(); 
			i = index - rfixedCol;
			r = new Rectangle(this._rfixedColumnPoints[i] + sx, 0, this._rfixedColumnPoints[i + 1] - this._rfixedColumnPoints[i], 0);
		} else {
			sx = this._bodyBounds.x; //this._fixedCols > 0 ? this._bodyBounds.x - this._leftPos : this._bodyBounds.x; // fixed Column이 존재하면 _bodyBounds에 _leftPos를 빼지 않는다.
			i = index - this._fixedCols;
			r = new Rectangle(this._columnPoints[i] + sx, 0, this._columnPoints[i + 1] - this._columnPoints[i], 0);
		}
		return r;
	},
	getDataColumnRect: function (column) {
        return this.dataColumnRect(column);
    },
    dataColumnRect: function (column) {
		var root = column.root();
		var	dataRoot = column.dataRoot();
		var	r = this.columnBounds(root.displayIndex());
		if (dataRoot !== root) {
			r.leftBy(column.$_getOffset(dataRoot));
			r.width = dataRoot.groupWidth();
		}
		return r;
	},
	dataRootBounds: function (column) {
		var root = column.root();
		var dataRoot = column.dataRoot();
		var r = this.columnBounds(root.displayIndex());
		if (dataRoot != root) {
			this._getColumnRectInRoot(dataRoot, LM_RECT);
			r.leftBy(LM_RECT.x);
			r.setWidth(dataRoot.displayWidth());
		}
		return r;
	},
	dataRootRect: function (column) {
		var root = column.root();
		var dataRoot = column.dataRoot();
		var r = this.columnRect(root.displayIndex());
		if (dataRoot != root) {
			var p = column.parent();
			var offset = column.displayOffset();
			while(p) {
				var pOffset = p.displayOffset();
				offset += isNaN(pOffset) ? 0 : pOffset;
				p = p.parent();
				if (p instanceof RootColumn) break;
			}
			r.setLeft(r.x + offset);
			r.width = dataRoot.displayWidth();
		}
		return r;
	},
	itemBounds: function (index, fixed, rfixed) {
		var r = rfixed ? this._rfixedBounds : fixed ? this._fixedBounds : this._bodyBounds;
		if (index < this._fixedItemCount) {
			return new Rectangle(0, this._fixedItemPoints[index], r.width, this._fixedItemPoints[index + 1] - this._fixedItemPoints[index]);
		} else {
			return new Rectangle(0, this._itemPoints[index - this._fixedItemCount], r.width, this._itemPoints[index - this._fixedItemCount + 1] - this._itemPoints[index - this._fixedItemCount]);
		}
	},
	getItemBounds: function (index, fixed) {
		return this.itemBounds(index, fixed);
	},
	itemRect: function (index, fixed) {
		var r = fixed ? this._fixedBounds : this._bodyBounds;
		var sy = r.y;
		if (index < this._fixedItemCount) {
			return new Rectangle(0, this._fixedItemPoints[index] + sy, r.width, this._fixedItemPoints[index + 1] - this._fixedItemPoints[index]);
		} else {
			return new Rectangle(0, this._itemPoints[index - this._fixedItemCount] + sy, r.width, this._itemPoints[index - this._fixedItemCount + 1] - this._itemPoints[index - this._fixedItemCount]);
		}
	},
	getItemRect: function (index, fixed) {
		return this.itemRect(index, fixed);
	},
	dataCellRect: function (index) {
		var grid = this._grid;
		if (!grid.isValid(index) || this._fixedItemCount + this._itemCount < 1) {
			return new Rectangle();
		}
		var column = index.C(),
			root = column.group() ? column.root() : index.C(),
			r = this.columnRect(root.displayIndex()),
			rc = null,
			row;
		if (index.I() < this._fixedItemCount) {
			rc = this.getItemBounds(index.I());
			r.y = rc.y + this._bodyBounds.y;
			r.height = rc.height;
		} else {
			row = index.I() - grid.topIndex();
			if (row < 0 || row >= this._itemCount + this._fixedItemCount) {
				r.y = this.getItemBounds(0).y + this._bodyBounds.y;
				r.height = 0;
			} else {
				rc = this.getItemBounds(row);
				r.y = rc.y + this._bodyBounds.y;
				r.height = rc.height;
			}
		}
		if (column !== root) {
			if (!rc) {
				rc = new Rectangle();
			}
			this._getColumnRectInRoot(column, rc);
			rc.offset(r.x, r.y);
			r.copy(rc);
		}
		return r;
	},
	mouseToIndex: function (x, y, index) {
		index.itemIndex(-1);
		index.column(null);
		if (this._columnCount < 1) {
			return;
		}
		var i,
			r = -1,
			grid = this.grid(),
			h = this._summaryBounds.bottom();
		if (y >= h && y < this._footerBounds.y) {
			for (i = 0; i < this._fixedItemCount; i++) {
				if (y >= h + this._fixedItemPoints[i] && y < h + this._fixedItemPoints[i + 1]) {
					r = i;
					y -= h + this._fixedItemPoints[i];
					break;
				}
			}
			if (r < 0 && this._itemCount > 0) {
				for (i = 0; i < this._itemCount; i++) {
					if (y >= h + this._itemPoints[i] && y < h + this._itemPoints[i + 1]) {
						r = i;
						y -= h + this._itemPoints[i];
						break;
					}
				}
				if (r >= 0) {
					r += grid.topItem();
				}
			}
		} else if (y >= this._footerBounds.y) { // footer
			r = -2;
		} else if (y < this._headerBounds.y) { // panel
			r = -3;
		}
		index.itemIndex(r);
		var c = -1,
			w = this._gridBounds.x;
		if (x >= w && x <= this._clientRect.width) {
			x = x - w;
			for (i = 0; i < this._fixedCols; i++) {
				if (x >= this._fixedColumnPoints[i] && x < this._fixedColumnPoints[i + 1]) {
					c = i;
					x -= this._fixedColumnPoints[i];
					break;
				}
			}
			if (c < 0 && this._rfixedCols > 0) {
				var rx = x - this._rfixedBounds.x + this._grid.fixedOptions().colBarWidth() + w;
				for (i = 0; i < this._rfixedCols; i++) {
					if (rx >= this._rfixedColumnPoints[i] && rx < this._rfixedColumnPoints[i+1]) {
						c = i + this.rfixedStartCol();
						x = rx -= this._rfixedColumnPoints[i];
						break;
					}
				}
			}
			if (c < 0) {
				x = x - this._fixedWidth + this._leftPos;
				for (i = this._firstCol; i <= this._lastCol; i++) {
					if (x >= this._columnPoints[i - this._fixedCols] && x < this._columnPoints[i - this._fixedCols + 1]) {
						c = i;
						x -= this._columnPoints[i - this._fixedCols];
						break;
					}
				}
			}
		}
		if (c >= 0 && c < grid.visibleColumnCount()) {
			index.column(grid.getVisibleColumn(c));
			var root = _cast(index.column().root(), ColumnGroup);
			if (root) {
				index.column(root.columnAtPoint(x, y));
			}
		} else {
			index.column(null);
			index.itemIndex(-1);
		}
        return index;
	},
	mouseToIndexEx: function (x, y, index) {
		if (this._columnCount < 1) {
			return index;
		}
		var i;
		var r = 0;
		var grid = this.grid();
		var topItem = this._topIndex + this._fixedItemCount;
		var h = this._bodyBounds.y;
		if (y < h) { 
			r = -1;
		} else if (y >= this._bodyBounds.bottom() && y < this._footerBounds.y) {
			r = topItem + this._fullItemCount;
		} else if (y >= this._footerBounds.y) {
			r = topItem + this._fullItemCount;
		} else {
			r = -1;
			for (i = 0; i < this._fixedItemCount; i++) {
				if (y >= h + this._fixedItemPoints[i] && y < h + this._fixedItemPoints[i + 1]) {
					r = i;
					break;
				}
			}
			if (r < 0 && this._itemCount > 0) {
				for (i = 0; i < this._itemCount; i++) {
					if (y >= h + this._itemPoints[i] && y < h + this._itemPoints[i + 1]) {
						r = i;
						break;
					}
				}
				if (r >= 0) {
					r += topItem;
				}
			}
		}
		index.itemIndex(r);
		var c = -1;
		var w = this._gridBounds.x;
		if (x < w) {
			c = Math.max(0, this._firstCol - 1);
		} else if (x >= this._bodyBounds.right() && x < this._clientRect.right()) {
			c = grid.visibleColumnCount() - 1;
		} else if (x > this._clientRect.right()) {
			c = Math.min(grid.visibleColumnCount() - 1, this._lastCol + 1);
		} else {
			x = x - w;
			for (i = 0; i < this._fixedCols; i++) {
				if (x >= this._fixedColumnPoints[i] && x < this._fixedColumnPoints[i + 1]) {
					c = i;
					break;
				}
			}
			if (c < 0 && this._rfixedCols > 0) {
				var rx = x - this._rfixedBounds.x + this._grid.fixedOptions().colBarWidth() + w;
				for (i = 0; i < this._rfixedCols; i++) {
					if (rx >= this._rfixedColumnPoints[i] && rx < this._rfixedColumnPoints[i+1]) {
						c = i + this.rfixedStartCol();
						break;
					}
				}
			}
			if (c < 0) {
				x = x - this._fixedWidth + this._leftPos;
				for (i = this._firstCol; i <= this._lastCol; i++) {
					if (x >= this._columnPoints[i - this._fixedCols] && x < this._columnPoints[i - this._fixedCols + 1]) {
						c = i;
						break;
					}
				}
			}
		}
		if (c >= 0 && c < grid.visibleColumnCount()) {
			index.column(grid.getVisibleColumn(c));
		} else {
			index.column(null);
		}
        return index;
	},
	measure: function (bounds, leftPos, topIndex, scrollBarWidth, scrollBarHeight) {
		this._items = this._grid.itemSource();
        this._options = this._grid.displayOptions();
		this._leftPos = leftPos;
		this._topIndex = topIndex;
		this._columnMerged = false;
		if (this._focusIndex && !this._grid.isValid(this._focusIndex)) {
			this._focusIndex.setItemIndex(Math.max(0, Math.min(this._focusIndex.I(), this._grid.itemCount() - 1)));
		}
		this._doMeasure(bounds, scrollBarWidth, scrollBarHeight);
		this._focusIndex = null;
	},
	layout: function (bounds) {
		this._doLayout(bounds);
	},
	fitColumnWidth: function (column, visibleOnly, minWidth, maxWidth) {
		if (column instanceof ColumnGroup) {
			this._doFitGroupWidth(column, visibleOnly, minWidth, maxWidth);
		} else if (column instanceof ValueColumn) {
			this._doFitColumnWidth(column, visibleOnly, minWidth, maxWidth, false);
		}
	},
	fitRowHeight: function (itemIndex, maxHeight, textOnly, refresh) {
		var grid = this.grid();
		var dMaxHeight = grid.displayOptions().maxRowHeight();
		var item = this._items.getItem(itemIndex);
		var dataId = item && item.dataId ? item.dataId() : -1;
		if (!this._heightMeasurer || dataId < 0) {
			return;
		}
		delete this._itemHeights[dataId];
		var dHeight = this._heightMeasurer.$_calcItemHeights(grid, 1);
		var mHeight = Math.max(dHeight, (itemIndex < this._fixedItemCount ? this._gridBounds.height - 3 : this._gridBounds.height - this._fixedHeight - 3));
		mHeight = dMaxHeight && mHeight > dMaxHeight ? dMaxHeight : mHeight;
		if (!maxHeight) {
			maxHeight = mHeight;
		} else {
			maxHeight = Math.min(Math.max(dHeight, maxHeight), mHeight);
		}
		var cols = grid.getLeafColumns(true);
		var sz;
		var h = dHeight;
		var column, cw;
		for (var cnt=cols.length; cnt--; ) {
			column = cols[cnt];
			cw = column.displayWidth();
			if (!textOnly || (column.rendererObj && column.rendererObj() instanceof TextCellRenderer)) {
				sz = this.$_dofitCellHeight(itemIndex, cols[cnt], cw, maxHeight);
				h = sz.height ? Math.max(h, sz.height) : h;
			}
		}
		if (h > dHeight) {
			this._itemHeights[dataId] = h;
		}
		!!refresh && grid.refreshView();
	},
	fitRowHeightAll: function(maxHeight, textOnly) {
		if (!this._heightMeasurer) {
			return;
		}
		var grid = this.grid();
		var dMaxHeight = grid.displayOptions().maxRowHeight();
		var dHeight = this._heightMeasurer.$_calcItemHeights(grid, 1);
		var item;
		var mHeight;
		var cols = grid.getLeafColumns(true);
		var column, cw;
		var sz;
		var h;
		var dataId;
		this._itemHeights = {};
		for (var itemIndex = 0, itemCount = grid.itemCount(); itemIndex < itemCount; itemIndex++) {
			item = grid.getItem(itemIndex);
			if (item && (item instanceof GridRow || item instanceof TreeItem) && item.dataId) {
				dataId = item.dataId();
				if (dataId < 0) {
					continue;
				}
				mHeight = Math.max(dHeight, (itemIndex < this._fixedItemCount ? this._gridBounds.height - 3 : this._gridBounds.height - this._fixedHeight - 3));
				mHeight = dMaxHeight && mHeight > dMaxHeight ? dMaxHeight : mHeight;
				if (!maxHeight) {
					maxHeight = mHeight;
				} else {
					maxHeight = Math.min(Math.max(dHeight, maxHeight), mHeight);
				}
				h = dHeight;
				for (var cnt=cols.length; cnt--; ) {
					column = cols[cnt];
					cw = column.displayWidth();
					if (!textOnly || (column.rendererObj && column.rendererObj() instanceof TextCellRenderer)) {
						sz = this.$_dofitCellHeight(itemIndex, cols[cnt], cw, maxHeight);
						h = sz.height ? Math.max(h, sz.height) : h;
					}
				}
				if (h > dHeight) {
					this._itemHeights[dataId] = h;
				} else {
					delete this._itemHeights[dataId];
				}
			}
		}
		grid.refreshView();
	},
	$_dofitCellHeight: function (itemIndex, column, cw, maxHeight) {
		var grid = this._grid;
		var body = grid.body();
		var cellView = (column instanceof SeriesColumn) ? new TestSeriesCellElement(grid) : new TestDataCellElement(grid);
		var r = new Rectangle(0, 0, cw, maxHeight);
		cellView.updateCell(body.getCell(CellIndex.temp(grid, itemIndex, column)));
		r = cellView._getRenderRect(r);
		cellView.inflatePadding(r);
		return cellView.measureHeight(grid, r.width, maxHeight);
	},
	setRowHeight: function (itemIndex, height, refresh) {
		var item = this._items.getItem(itemIndex);
		if (!item.dataId || item.dataId() < 0) {
			return;
		}
		var grid = this.grid();
		var displayOptions = grid.displayOptions();
		if (!displayOptions.isEachRowResizable()) {
			return;
		}
		var minHeight = displayOptions.minRowHeight();
		var maxHeight = displayOptions.maxRowHeight();
		this.$_doSetRowHeight(item, height, minHeight, maxHeight, refresh);
	},
	getRowHeight: function (itemIndex) {
		var grid = this.grid();
		var delegate = grid.delegate();
		return this.$_calcItemHeight(grid, delegate, itemIndex);
	},
	$_doSetRowHeight: function (item, height, minHeight, maxHeight, refresh) {
		var grid = this.grid();
		height = Math.min(height, this._gridBounds.height - this._fixedHeight);
		var h = Math.max(height, minHeight);
		var dataId = item.dataId();
		this._itemHeights[dataId] = h;
		refresh ? grid.refreshView() : null;
	},
	clearRowHeights: function (refresh) {
		var grid = this.grid();
		this._itemHeights = {};
		refresh ? grid.refreshView() : null;
	},
	isMergedCell: function (index) {
        var grid = this._grid;
		if (grid.rowGroup().isMergeMode()) {
			if (grid.isGroupedColumn(index.dataColumn())) {
				return true;
			}
		}
		var column = index.column();
		if (column instanceof ValueColumn && column.canMerge()) {
			var merges = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
			if (merges) {
				return merges.getRoom(index) != null;
			}
		}
		return false;
	},
	getMergedCell: function (index) {
		var column = index.column();
		if (column instanceof ValueColumn && column.canMerge()) {
			var merges = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
			if (merges) {
				return merges.getRoom(index);
			}
		}
		return null;
	},
	scrollToNextColumn: function () {
		for (var i = 0; i < this._columnCount; i++) {
			if (this._columnPoints[i] > this._leftPos) {
				return this._columnPoints[i];
			}
		}
		return this._leftPos;
	},
	scrollToPrevColumn: function () {
		for (var i = this._columnCount - 1; i >= 0; i--) {
			if (this._columnPoints[i] < this._leftPos) {
				return this._columnPoints[i];
			}
		}
		return this._leftPos;
	},
	positionToColumn: function(position) {
		for (var i = 0; i < this._columnCount; i++) {
			if (this._columnPoints[i+1] > position) {
				return i;
			}
		}
		return -1;
	},
	_isColumnsDirty: function () {
		return this._grid._isColumnsDirty();
	},
	_isHeaderDirty: function () {
		return this._grid._isStylesDirty() || this._grid.header().isDirty() || this._grid._isColumnsDirty();
	},
	_isFooterDirty: function () {
		return this._grid._isStylesDirty() || this._grid.footer().isDirty() || this._grid._isColumnsDirty();
	},
	_getFixedRowCount: function () {
		var items = this._grid.itemSource();
		if (items) {
			return Math.min(items.fixedCount(), items.itemCount());
		} else {
			return 0;
		}
	},
	_getItem: function (index) {
		return this._items.getItem(index);
	},
	_doMeasure: function (bounds, sw, sh) {
        var	grid = this._grid;
        var	r = bounds.clone();
		var view, sz, y;
		this._hscrollBar = this._vscrollBar = false;
		this._prevFirst = this._firstCol;
		this._prevLast = this._lastCol;
		this._firstCol = 0;
		this._lastCol = -1;
		this.$_checkColumnGrouping();
		this.$_calcFixedColumnPoints();
		this.$_calcColumnPoints();
		this.$_calcRightFixedColumnPoints();
		this._heightMeasurer.calculate(grid, true, grid.header().isVisible(), grid.footer().isVisible(), grid.header().summary().isVisible());
		this._panelBounds = r.clone();
		if (grid.panel().isVisible() && (view = grid.panelView())) {
			view.setModel(grid.panel());
			sz = view.measure(grid, r.width, r.height);		
		} else { 
			sz = Size.EMPTY;
		}
		grid._panel._realHeight = sz.height;
		this._panelBounds.height = sz.height;
		r.topBy(sz.height);

		this._indicatorBounds = r.clone();
		if (grid.indicator().isVisible()) {
			view = grid.indicatorView();
			sz = view.measure(grid, r.width, r.height);
		} else {
			sz = Size.EMPTY;
		}
		grid._indicator._realWidth = sz.width;
		this._indicatorBounds.width = sz.width;
		r.leftBy(sz.width);
		this._stateBarBounds = r.clone();
		if (grid.stateBar().isVisible()) {
			view = grid.stateBarView();
			sz = view.measure(grid, r.width, r.height);
		} else {
			sz = Size.EMPTY;
		}
		this._stateBarBounds.width = sz.width;
		r.leftBy(sz.width);
		this._checkBarBounds = r.clone();
		if (grid.checkBar().isVisible()) {
			view = grid.checkBarView();
			sz = view.measure(grid, r.width, r.height);
		} else {
			sz = Size.EMPTY;
		}
		this._checkBarBounds.width = sz.width;
		r.leftBy(sz.width);
		this._rowGroupBounds = r.clone();
		if (this.isRowGrouped()) {
			sz = grid.rowGroupView().measure(grid, r.width, r.height);
		} else {
			sz = Size.EMPTY;
		}
		this._rowGroupBounds.width = sz.width;
		r.leftBy(sz.width);
		this._fixedBounds = r.clone();
		this._fixedBounds.width = this._fixedWidth;
		r.leftBy(this._fixedWidth);
		this._rfixedBounds = r.clone();
		this._rfixedBounds.x = Math.min(r.x+this._columnsLength+this._rfixedWidth, r.right())-this._rfixedWidth;
		this._rfixedBounds.width = this._rfixedWidth;
		r.width -= this._rfixedWidth;

		this._headerBounds = r.clone();
		if (grid.header().isVisible()) {
			view = grid.headerView();
			sz = view.measure(grid, r.width, r.height);
			sz.height = Math.max(sz.height, this._heightMeasurer.headerHeight());
		} else {
			sz = Size.EMPTY;
		}
		grid._header._realHeight = sz.height;
		this._headerBounds.height = sz.height;
		this._headerBounds.width = sz.width;
		this._fixedHeaderBounds = new Rectangle(this._fixedBounds.x, this._headerBounds.y, this._fixedBounds.width, this._headerBounds.height);
        this._rfixedHeaderBounds = new Rectangle(this._rfixedBounds.x, this._headerBounds.y, this._rfixedBounds.width, this._headerBounds.height);
        r.topBy(sz.height);
        this._summaryBounds = r.clone();
        if (grid.header().summary().isVisible()) {
            view = grid.summaryView();
            sz = view.measure(grid, r.width, r.height);
            sz.height = Math.max(sz.height, this._heightMeasurer.summaryHeight());
        } else {
            sz = Size.EMPTY;
        }
        grid._header._summary._realHeight = sz.height;
        this._summaryBounds.height = sz.height;
        this._summaryBounds.width = sz.width;
        this._fixedSummaryBounds = new Rectangle(this._fixedBounds.x, this._summaryBounds.y, this._fixedBounds.width, this._summaryBounds.height);
		this._rfixedSummaryBounds = new Rectangle(this._rfixedBounds.x, this._summaryBounds.y, this._rfixedBounds.width, this._summaryBounds.height);
		
		this._editBarBounds = r.clone();
		this._editBarBounds.y += this._summaryBounds.height;
		if (grid.editBar().isVisible()) {
			view = grid.editBarRenderer();
			view.setModel(grid.getEditBar());
			sz = view.measure(grid, r.width, r.height);
			sz.height = Math.max(sz.height, this._heightMeasurer.itemHeight(0));
		} else {
			sz = Size.EMPTY;
		}
		this._editBarBounds.height = sz.height;
		this._editBarBounds.width = sz.width;
		this._footerBounds = r.clone();
		if (grid.footer().isVisible()) {
			view = grid.footerView();
			sz = view.measure(grid, r.width, r.height);
			sz.height = Math.max(sz.height, this._heightMeasurer.footerHeight());
		} else {
			sz = Size.EMPTY;
		}
		grid._footer._realHeight = sz.height;
		this._footerBounds.y = r.bottom() - sz.height;
		this._footerBounds.width = sz.width;
		this._footerBounds.height = sz.height;
		this._fixedFooterBounds = new Rectangle(this._fixedBounds.x, this._footerBounds.y, this._fixedBounds.width, this._footerBounds.height);
		this._rfixedFooterBounds = new Rectangle(this._rfixedBounds.x, this._footerBounds.y, this._rfixedBounds.width, this._footerBounds.height);
		this._gridBounds = new Rectangle(this._fixedBounds.x, this._editBarBounds.bottom(), 
			bounds.right() - this._fixedBounds.x, this._footerBounds.y - this._editBarBounds.bottom());
		var rBody = new Rectangle(this._headerBounds.x, this._editBarBounds.bottom(), 
			this._headerBounds.width, this._footerBounds.y - this._editBarBounds.bottom() + 1);
		this.$_calcHorzScroll(sh, rBody, this._gridBounds);
		if (this._hscrollBar) {
			rBody.bottomBy(-sh);
		}
		this._calcItemPoints(rBody);
		this._bodyBounds = rBody.clone();
		this.$_updateScrollInfo(bounds, sw, sh);
		this.$_checkColumnMerging();

		if (this._vscrollBar && this._rfixedBounds.right() > this._gridBounds.right()) {
			 this._rfixedBounds.x = this._gridBounds.right()-this._rfixedWidth;
			 this._rfixedHeaderBounds.x = this._rfixedFooterBounds.x = this._rfixedSummaryBounds.x = this._rfixedBounds.x;
		}
		
		this._fixedBounds.y = this._rfixedBounds.y = this._bodyBounds.y;
		this._fixedBounds.height = this._rfixedBounds.height = this._bodyBounds.height;
		this._nonfixedBounds = this._gridBounds.clone();
		this._nonfixedBounds.setLeft(this._nonfixedBounds.x + this._fixedWidth);
		this._nonfixedBounds.rightBy(-this._rfixedWidth);
		if (this._fixedHeight > 0) {
			this._nonfixedBounds.setTop(this._nonfixedBounds.y + this._fixedHeight + grid.fixedOptions().rowBarHeight());
		}
		this.$_measureFitting(this._nonfixedBounds, this._vscrollBar ? sw : 0);
		if (this._columnFitted) {
			this.$_fitColumns(this._nonfixedBounds.width);
			this._bodyBounds.width = this._columnsLength;
			this._rfixedBounds.x = r.x+this._columnsLength;
			this._rfixedBounds.width = this._rfixedWidth;
	        this._rfixedHeaderBounds = new Rectangle(this._rfixedBounds.x, this._headerBounds.y, this._rfixedBounds.width, this._headerBounds.height);
			this._rfixedSummaryBounds = new Rectangle(this._rfixedBounds.x, this._summaryBounds.y, this._rfixedBounds.width, this._summaryBounds.height);
			this._rfixedFooterBounds = new Rectangle(this._rfixedBounds.x, this._footerBounds.y, this._rfixedBounds.width, this._footerBounds.height);
		} else {
			this._clearFitWidths();
		}
		this.$_calcLeftPos();
		if (this.isRowGrouped()) {
			this._rowGroupBounds.setRight(this._bodyBounds.right()+this._rfixedWidth);
			this._rowGroupBounds.setTop(this._headerBounds.y);
			this._rowGroupBounds.setBottom(this._footerBounds.bottom());
		}
		this._bodyBounds.x -= this._leftPos;
		var bwidth = this._bodyBounds.width+this._rfixedWidth;
		this._panelBounds.setRight(this._bodyBounds.right()+this._rfixedWidth);
		this._headerBounds.x = this._bodyBounds.x;
		this._headerBounds.width = bwidth;
        this._summaryBounds.x = this._bodyBounds.x;
        this._summaryBounds.width = bwidth;
		this._editBarBounds.x = this._bodyBounds.x;
		this._editBarBounds.width = bwidth;
		this._footerBounds.x = this._bodyBounds.x;
		this._footerBounds.width = bwidth;
        y = Math.min(this._footerBounds.y, this._bodyBounds.bottom());
		this._indicatorBounds.y = this._bodyBounds.y;
		this._indicatorBounds.setBottom(y);
		this._stateBarBounds.y = this._bodyBounds.y;
		this._stateBarBounds.setBottom(y);
		this._checkBarBounds.y = this._bodyBounds.y;
		this._checkBarBounds.setBottom(y);
	},
	$_calcHorzScroll: function (sh, rBody, bounds) {
		this._hscrollBar = this._options.fitStyle() != GridFitStyle.EVEN_FILL;
        if (this._hscrollBar) {
            if (this._fixedWidth + this._rfixedWidth >= bounds.width) {
                this._hscrollBar = this._columnsLength > 0;
            } else {
                this._hscrollBar = this._columnsLength > bounds.width - this._fixedWidth - this._rfixedWidth;
            }
        }
		rBody.width = this._columnsLength;
	},
	/**
	 * 고정 영역을 제외하고 계산한다.
	 */
	$_updateScrollInfo: function (bounds, sw, sh) {
		var even = this._options.fitStyle() == GridFitStyle.EVEN_FILL;
		var grid = this.grid();
		var rBody = this._bodyBounds;
		var bodyRight = rBody.right()+this._rfixedWidth;
		var rFooter = this._footerBounds;
		var hscroll = !even && this._columnsLength > 0 && (this._leftPos > 0 || bodyRight > bounds.right());
		var vscroll = this._itemCount > 0 && (this._topIndex > 0 || rBody.bottom() > rFooter.y);
        var i, w, h, y, dy;
		if (hscroll) {
			w = vscroll ? sw : 0;
			if (this._columnsLength < this._gridBounds.width - this._fixedBounds.width - this._rfixedBounds.width - w) {
				hscroll = false;
			}
		}
		if (hscroll != vscroll) {
			if (hscroll) {
				vscroll = this._itemCount > 0 && rBody.bottom() > rFooter.y - sh;
			} else { // vscroll
				hscroll = !even && this._columnsLength > 0 && (bodyRight > bounds.right() - sw);
			}
		}
		if (!hscroll) {
			this._leftPos = 0;
		} else /*if (this._itemCount > 0)*/ {
			if (!this._hscrollBar && this._itemCount > 0) { // vscrollbar로 인해 hscrollbar가 생긴 경우
				var r = rBody.clone();
				r.setBottom(rFooter.y - sh);
				this._calcItemPoints(r);
				if (this._itemCount > 0) {
					rBody.height = this._itemPoints[this._itemCount];
				}
			}
			this._rfixedFooterBounds.y = this._fixedFooterBounds.y = rFooter.y -= sh;
			rBody.setBottom(Math.min(rBody.bottom(), rFooter.y));
			this._gridBounds.setBottom(rFooter.y);
			if (this._itemCount > 0) {
				i = this._fullItemCount;
				while (i > 0 && rBody.y + this._itemPoints[i] > rFooter.y) {
					this._fullItemCount--;
					i--;
				}
				i = this._itemCount;
				while (i > 0 && rBody.y + this._itemPoints[i - 1] > rFooter.y) {
					this._itemCount--;
					this._itemPoints.pop();
					i--;
				}
			}
		}
		y = rBody.bottom();
		if (this._itemCount > 0 && y < this._fixedFooterBounds.y) {
			var eachRowResizable = grid.displayOptions().isEachRowResizable() && grid._rootColumn._dataLevel == 1;
			if (eachRowResizable) {
				var points = this._itemPoints;
				var item ,
					dataId, 
					dummyIdx;
				h = this._itemHeights[dataId] ? this._itemHeights[dataId] : this._heightMeasurer.itemHeight(0);
				while (this._topIndex > 0 && y < this._fixedFooterBounds.y) {
					dummyIdx = this._topIndex - 1;
					item = this._getItem(dummyIdx + this._fixedItemCount);
					dataId = item && item.dataId();
					h = this._itemHeights[dataId] ? this._itemHeights[dataId] : this._heightMeasurer.itemHeight(0);
					if (y+h < this._fixedFooterBounds.y ) {
						rBody.bottomBy(h);
						y = rBody.bottom();
						points.splice(1,0,points[0]+h);
						for (var i = 2; i<points.length;i++) {
							points[i]+=h
						}
						this._topIndex = dummyIdx;
						this._itemCount++;
						this._fullItemCount++;
					} else {
						break;
					}
				}
				if (vscroll && this._topIndex == 0 && y < this._fixedFooterBounds.y) {
					vscroll = false;
					if (hscroll) {
						hscroll = bodyRight > bounds.right();
					}
				}
			} else {
				h = this._heightMeasurer.itemHeight(0);
				dy = _int((this._fixedFooterBounds.y - y) / h);
				this._availableItemCount = this._fullItemCount + dy;
				while (this._topIndex >  0 && dy > 0) {
					this._topIndex--;
					this._itemCount++;
					this._fullItemCount++;
					this._itemPoints.push(this._itemPoints[this._itemPoints.length - 1] + h);
					rBody.bottomBy(h);
					dy--;
				}
				if (vscroll && this._topIndex == 0 && this._availableItemCount >= this._fullItemCount) {
					vscroll = false;
					if (hscroll) {
						hscroll = bodyRight > bounds.right();
					}
				}
			}
		} else {
			this._availableItemCount = this._fullItemCount;
		}
		this._clientRect = bounds.clone();
		this._clientRect.width -= vscroll ? sw : 0;
		this._clientRect.height -= hscroll ? sh : 0;
		this._gridBounds.setRight(this._clientRect.right());
		this._gridBounds.setBottom(this._footerBounds.y);
		this._hscrollBar = hscroll;
		this._vscrollBar = vscroll;
	},
	$_calcLeftPos: function () {
		var column;
		var root;
		var i;
		var dx;
		var x;
		var prevLeftPos = this._leftPos;
		if (this._leftPos > 0) {
			i = this._columnPoints.length - 1;
			dx = this._nonfixedBounds.width - (this._columnPoints[i] - this._leftPos);
			if (dx > 0) {
				this._leftPos = Math.max(0, this._leftPos - dx);
			}
		}
		if (this._focusIndex && (column = this._focusIndex.column())) {
            root = column.root();
            i = root.displayIndex();
            if (i >= this._fixedCols && i < this.rfixedStartCol()) {
                x = this._columnPoints[i - this._fixedCols];
                while (column != root) {
                    x += column.displayOffset();
                    column = column.parent();
                }
                if (x < this._leftPos) {
                    this._leftPos = x;
                } else {
                    dx = x + this._focusIndex.column().displayWidth() - this._leftPos - this._nonfixedBounds.width;
                    if (dx > 0) {
                        this._leftPos = Math.min(x, this._leftPos + dx);
                    }
                }
            }
		}
		var leftPos = this._leftPos;
		var cw = this._clientRect.width;
		this._firstCol = this._fixedCols;
		this._lastCol = -1;
		for (i = this._fixedCols; i < this._columnCount; i++) {
			if (this._columnPoints[i + 1 - this._fixedCols] > leftPos) {
				this._firstCol = i;
				break;
			}
		}
		for (i = this._columnCount - this._rfixedCols - 1; i >= this._fixedCols; i--) {
			if (this._columnPoints[i - this._fixedCols] - leftPos < cw - this._headerBounds.x) {
				this._lastCol = i;
				break;
			}
		}
		if (prevLeftPos != this._leftPos && this._focusIndex) {
			var grid = this.grid();
			grid._horzScrolling = true;
		}
	},
	_doLayout: function (bounds) {
		var elt, r,
			gr = this._gridBounds,
			grid = this._grid,
			header = grid.header(),
            summary = header.summary(),
			footer = grid.footer(),
			indicator = grid.indicator(),
			stateBar = grid.stateBar(),
			checkBar = grid.checkBar(),
			fixed = this._fixedCols > 0,
			rfixed = this._rfixedCols > 0;
		if ((elt = grid.panelView())) {
			elt.setVisible(grid.panel().isVisible());
			if (elt.isVisible()) {
				elt.setRect(this._panelBounds);
				elt.layoutContent(this);
			}
		}
		elt = grid.indicatorView();
		elt.setVisible(indicator.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._indicatorBounds);
			elt.layoutContent(this);
		}
		elt = grid.stateBarView();
		elt.setVisible(stateBar.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._stateBarBounds);
			elt.layoutContent(this);
		}
		elt = grid.checkBarView();
		elt.setVisible(checkBar.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._checkBarBounds);
			elt.layoutContent(this);
		}
		elt = grid.rowGroupView();
		elt.setVisible(this.isRowGrouped());
		if (elt.isVisible()) {
			elt.setRect(r = this._rowGroupBounds);
			elt.setClipBounds(r.x, r.y, gr.right() - r.x, r.height);
		}
		elt = grid.headerView();
		elt.setVisible(header.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._headerBounds);
			elt.setClipBounds(this._nonfixedBounds.x, 0, this._nonfixedBounds.width, bounds.height);
			elt.layoutContent(this);
		}
		elt = grid.fixedHeaderView();
		elt.setVisible(fixed && header.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._fixedHeaderBounds);
			elt.layoutContent(this);
		}
		elt = grid.rfixedHeaderView();
		elt.setVisible(rfixed && header.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._rfixedHeaderBounds);
			elt.layoutContent(this);
		}
        elt = grid.summaryView();
        elt.setVisible(summary.isVisible());
        if (elt.isVisible()) {
            elt.setRect(this._summaryBounds);
            elt.setClipBounds(this._nonfixedBounds.x, 0, this._nonfixedBounds.width, bounds.height);
            elt.layoutContent(this);
        }
        elt = grid.fixedSummaryView();
        elt.setVisible(fixed && summary.isVisible());
        if (elt.isVisible()) {
            elt.setRect(this._fixedSummaryBounds);
            elt.layoutContent(this);
        }
        elt = grid.rfixedSummaryView();
        elt.setVisible(rfixed && summary.isVisible());
        if (elt.isVisible()) {
            elt.setRect(this._rfixedSummaryBounds);
            elt.layoutContent(this);
        }
		elt = grid.indicatorHeadView();
		elt.setVisible(indicator.isVisible() && header.isVisible());
		if (elt.isVisible()) {
			elt.updateCell(indicator.getHeadCell());
			elt.setBounds(this._indicatorBounds.x, this._headerBounds.y, this._indicatorBounds.width, this._headerBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.stateBarHeadView();
		elt.setVisible(stateBar.isVisible() && header.isVisible());
		if (elt.isVisible()) {
			elt.updateCell(stateBar.getHeadCell());
			elt.setBounds(this._stateBarBounds.x, this._headerBounds.y, this._stateBarBounds.width, this._headerBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.checkBarHeadView();
		elt.setVisible(checkBar.isVisible() && header.isVisible());
		if (elt.isVisible()) {
			elt.updateCell(checkBar.getHeadCell());
			elt.setBounds(this._checkBarBounds.x, this._headerBounds.y, this._checkBarBounds.width, this._headerBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.footerView();
		elt.setVisible(footer.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._footerBounds);
			elt.setClipBounds(this._nonfixedBounds.x, 0, this._nonfixedBounds.width, this._footerBounds.bottom());
			elt.layoutContent(this);
		}
		elt = grid.fixedFooterView();
		elt.setVisible(fixed && footer.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._fixedFooterBounds);
			elt.layoutContent(this);
		}
		elt = grid.rfixedFooterView();
		elt.setVisible(rfixed && footer.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._rfixedFooterBounds);
			elt.layoutContent(this);
		}
		elt = grid.indicatorFootView();
		elt.setVisible(indicator.isVisible() && footer.isVisible());
		if (elt.isVisible()) {
			elt.updateCell(indicator.getFootCell());
			elt.setBounds(this._indicatorBounds.x, this._footerBounds.y, this._indicatorBounds.width, this._footerBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.stateBarFootView();
		elt.isVisible = stateBar.isVisible && footer.isVisible;
		if (elt.isVisible()) {
			elt.updateCell(stateBar.getFootCell());
			elt.setBounds(this._stateBarBounds.x, this._footerBounds.y, this._stateBarBounds.width, this._footerBounds.height);
			elt.layoutContent(this);
		}
		elt = grid.checkBarFootView();
		elt.setVisible(checkBar.isVisible() && footer.isVisible());
		if (elt.isVisible()) {
			elt.updateCell(checkBar.getFootCell());
			elt.setBounds(this._checkBarBounds.x, this._footerBounds.y, this._checkBarBounds.width, this._footerBounds.height);
			elt.layoutContent(this);
		}
        elt = grid.indicatorSummaryView();
        elt.setVisible(indicator.isVisible() && summary.isVisible());
        if (elt.isVisible()) {
            elt.updateCell(indicator.getSumCell());
            elt.setBounds(this._indicatorBounds.x, this._summaryBounds.y, this._indicatorBounds.width, this._summaryBounds.height);
            elt.layoutContent(this);
        }
        elt = grid.stateBarSummaryView();
        elt.isVisible = stateBar.isVisible && summary.isVisible;
        if (elt.isVisible()) {
            elt.updateCell(stateBar.getSumCell());
            elt.setBounds(this._stateBarBounds.x, this._summaryBounds.y, this._stateBarBounds.width, this._summaryBounds.height);
            elt.layoutContent(this);
        }
        elt = grid.checkBarSummaryView();
        elt.setVisible(checkBar.isVisible() && summary.isVisible());
        if (elt.isVisible()) {
            elt.updateCell(checkBar.getSumCell());
            elt.setBounds(this._checkBarBounds.x, this._summaryBounds.y, this._checkBarBounds.width, this._summaryBounds.height);
            elt.layoutContent(this);
        }
		var fixedView = grid.fixedBodyView();
		var rfixedView = grid.rfixedBodyView();
		elt = grid.bodyView();
		if (this._fixedItemCount + this._itemCount > 0) {
			if (this._fixedCols > 0) {
				fixedView.setVisible(true);
				fixedView.setRect(this._fixedBounds);
                fixedView.setClipBounds(this._fixedBounds.x, this._gridBounds.y, this._fixedBounds.width, this._gridBounds.height);
			} else {
				fixedView.setVisible(false);
			}
			if (this._rfixedCols > 0) {
				rfixedView.setVisible(true);
				rfixedView.setRect(this._rfixedBounds);
                rfixedView.setClipBounds(this._rfixedBounds.x, this._gridBounds.y, this._rfixedBounds.width, this._gridBounds.height);
			} else {
				rfixedView.setVisible(false);
			}
			elt.setRect(this._bodyBounds);
			elt.setClipBounds(this._nonfixedBounds.x, this._gridBounds.y, this._nonfixedBounds.width, this._gridBounds.height);
			// var p1 = window.performance.now ? window.performance.now() : new Date();
			this.$_layoutItems(elt, this._bodyBounds);
			// var p2 = window.performance.now ? window.performance.now() : new Date();
			// p1 && console.log(p2 - p1);
			fixedView.setEmpty(false);
			rfixedView.setEmpty(false);
			elt.setEmpty(false);
		} else {
			fixedView.setBounds(0, this._fixedBounds.y, this._fixedBounds.width, this._footerBounds.y - this._bodyBounds.y);
			rfixedView.setBounds(0, this._rfixedBounds.y, this._rfixedBounds.width, this._footerBounds.y - this._bodyBounds.y);
			elt.setBounds(0, this._bodyBounds.y, this._bodyBounds.width, this._footerBounds.y - this._bodyBounds.y);
			// var p1 = window.performance.now();
			this.$_layoutItems(elt, this._bodyBounds);
			// var p2 = window.performance.now();
			// console.log(p2 - p1);
			fixedView.setEmpty(true);
			rfixedView.setEmpty(true);
			elt.setEmpty(true);
		}
		elt = grid.fixedMergeView();
		elt.setVisible(fixed);
		if (fixed) {
			r = this._fixedBounds;
			elt.setRect(r);
			elt.setClipBounds(r.x, r.y, Math.min(r.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
		}
		elt = grid.rfixedMergeView();
		elt.setVisible(rfixed);
		if (rfixed) {
			r = this._rfixedBounds;
			elt.setRect(r);
			elt.setClipBounds(r.x, r.y, Math.min(r.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
		}
		elt = grid.mergeView();
		r = this._bodyBounds.clone();
		r.width += this._rfixedWidth;
		elt.setRect(r);
        if (fixed) {
            r.x = Math.max(r.x, this._fixedBounds.right());
            elt.setClipBounds(r.x, r.y, Math.min(r.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
        } else {
            elt.setClipBounds(r.x, r.y, Math.min(r.width, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
        }
		r = this._fixedBounds;
		grid.mergeHeaderView().setBounds(r.x, r.y, r.width + this._bodyBounds.width + this._rfixedWidth, r.height);
		grid.mergeHeaderView().setClipBounds(r.x, r.y, Math.min(r.width + this._bodyBounds.width + this._rfixedWidth, gr.right() - r.x), Math.min(r.height, gr.bottom() - r.y));
		this.$_layoutMerges();
		/*
		elt = grid.getEditBarRenderer();
		elt.setVisible(editBar.isVisible());
		if (elt.isVisible()) {
			elt.setRect(this._editBarBounds);
			elt.layoutContent(this);
		}
		*/
	},
	$_checkColumnGrouping: function () {
		var i, cnt, column, grid = this._grid;
		this._columnGrouped = false;
		for (i = 0, cnt = grid.visibleColumnCount(); i < cnt; i++) {
			column = grid.getVisibleColumn(i);
			if (column instanceof ColumnGroup) {
				this._columnGrouped = true;
				break;
			}
		}
	},
	$_calcFixedColumnPoints: function () {
		var i, x, column;
		var grid = this._grid;
		var fixed = grid.fixedOptions();
		this._columnCount = grid.visibleColumnCount();
		this._fixedCols = Math.min(fixed.colCount(), this._columnCount);
		this._rfixedCols = Math.min(fixed.rightColCount(), this._columnCount - this._fixedCols);
		this._columns = [];
		this._fixedColumnPoints = [];
		this._fixedWidth = 0;
		if (this._fixedCols > 0) {
			x = 0;
			this._fixedColumnPoints.push(x);
			for (i = 0; i < this._fixedCols; i++) {
				column = grid.getVisibleColumn(i);
				this._columns.push(column);
				x += column.width();
				this._fixedColumnPoints.push(x);
			}
			this._fixedWidth = this._fixedColumnPoints[this._fixedCols] + grid.fixedOptions().colBarWidth();
		}
	},
	$_calcRightFixedColumnPoints: function () {
		var i, x, column;
		var grid = this._grid;
		var fixed = grid.fixedOptions();
		this._rfixedColumnPoints = [];
		this._rfixedWidth = 0;
		if (this._rfixedCols > 0) {
			x = 0;
			var cols = this._columnCount;
			this._rfixedColumnPoints.push(x);
			for (i = cols - this._rfixedCols; i < cols; i++) {
				column = grid.getVisibleColumn(i);
				this._columns.push(column);
				x += column.width();
				this._rfixedColumnPoints.push(x);
			}
			var wbar = grid.fixedOptions().colBarWidth();
			this._rfixedWidth = x + wbar;
		}
	},
	$_calcColumnPoints: function () {
		var cnt, 
			i,	
			x, 
			column,
			grid = this._grid;
        this._columnsLength = 0;
		this._columnPoints = [];
		cnt = grid.visibleColumnCount() - this._fixedCols - this._rfixedCols;
		if (cnt < 1) {
			return;
		}
		x = 0;
		this._columnPoints.push(x);
		for (i = 0; i < cnt; i++) {
			column = grid.getVisibleColumn(i + this._fixedCols);
			this._columns.push(column);
			x += column.width();
			this._columnPoints.push(x);
		}
		this._columnsLength = x;
	},
	$_measureFitting: function (bounds) {
		var grid = this.grid();
		this._columnFitted = this._options.fitStyle() != GridFitStyle.NONE;
		if (this._columnFitted) {
			var cnt = this._columnPoints.length;
			if (cnt > 0) {
                var w = bounds.width;
				if (this._options.fitStyle() == GridFitStyle.EVEN_FILL) {
					for (var i = 1; i < cnt; i++) {
						this._columnPoints[i] = this._columnPoints[i] * w / this._columnsLength;
					}
					this._columnPoints[cnt - 1] = w;
					this._columnsLength = w;
				} else {
					this._columnFitted = w - this._columnPoints[cnt - 1] > 0;
				}
			} else {
				this._columnFitted = false;
			}
		}
	},
	$_fitColumns: function (w) {
        if (!this._columnFitted) return;
		var i, dx, column, sum, fsum;
		var cw = this._columnsLength;
		var cnt = this._columnPoints.length;
		var grid = this.grid();
		var options = this._options;
		var fitStyle = options.fitStyle();
		if (cnt > 0) {
			if (fitStyle == GridFitStyle.EVEN || fitStyle == GridFitStyle.EVEN_FILL) {
				for (i = 1; i < cnt; i++) {
					this._columnPoints[i] = _int(this._columnPoints[i] * w / cw);
				}
			} else if (fitStyle == GridFitStyle.FILL) {
				sum = 0;
				fsum = 0;
				for (i = 0; i < cnt - 1; i++) {
					if ((dx = this._columns[this._fixedCols + i].fillWidth()) > 0) {
						fsum += dx;
					} else {
						sum += this._columns[this._fixedCols + i].width();
					}
				}
				if (fsum > 0) {
					sum = w - sum;
					for (i = 1; i < cnt; i++) {
						if ((dx = this._columns[this._fixedCols + i - 1].fillWidth()) > 0) {
							this._columnPoints[i] = _int(this._columnPoints[i - 1] + dx * sum / fsum);
						} else {
							this._columnPoints[i] = _int(this._columnPoints[i - 1] + this._columns[this._fixedCols + i - 1].width());
						}
					}
				} else {
					for (i = 1; i < cnt; i++) {
						this._columnPoints[i] = _int(this._columnPoints[i] * w / cw);
					}
				}
			}
			//columnPoints[i]의 값이 컬럼 최소넓이 보다 작을 때 이를 교정하기 위한 로직
			var correction = 0;
			for (i = 1; i < cnt - 1; i++) {
				var colw = this._columnPoints[i] - this._columnPoints[i-1];
				if (colw < Column.MIN_WIDTH) {
					correction = Column.MIN_WIDTH - colw;
					this._columnPoints[i] += Column.MIN_WIDTH - colw;
				} else if (correction > 0 && colw > Column.MIN_WIDTH + correction) {
					this._columnPoints[i] -= correction;
					correction = 0;
				}
			}

			for (i = 0; i < cnt - 1; i++) {
				column = this._columns[this._fixedCols + i];
				this._setFitWidth(column, this._columnPoints[i + 1] - this._columnPoints[i]);
			}
		}
		this._columnPoints[cnt - 1] = w;
		this._columnsLength = w;
	},
	$_calcItemHeight: function (grid, delegate, index) {
		var item = this._items.getItem(index);
		var view = delegate.borrowItemView(item, false, false);
		var styles = null;
		if (view instanceof RowGroupHeaderElement && item instanceof GroupItem) {
			styles = grid.rowGroup().headerStyles();
		} else if (item instanceof GridItem) {
			styles = grid.body().styles();
		} 
		if (!view) {
			if ($_debug) debugger;
		}
		view.updateElement(item, styles);
		var h = this._heightMeasurer.itemHeight(0);
		var eachRowResizable = grid.displayOptions().isEachRowResizable() && grid._rootColumn._dataLevel == 1;
		if (eachRowResizable) {
			var dataId = item.dataId();
			if (this._itemHeights[dataId]) {
				h = this._itemHeights[dataId];
			}
		}
		var sz = view.measure(grid, 10000, h);
		delegate.returnItemView(view);
		return sz.height;
	},
	$_compensateItems: function (bounds) {
		var i, y, h, cnt;
		var grid = this.grid();
		var delegate = grid.delegate();
		var focusIndex = this._focusIndex ? this._focusIndex.I() : -1;
		var eachRowResizable = grid.displayOptions().isEachRowResizable() && grid._rootColumn._dataLevel == 1;
		if (focusIndex >= this._topIndex + this._fixedItemCount + this._fullItemCount) {
			if (this.fixedItemCount() > 0) {
				y = this._fixedHeight + grid.fixedOptions().rowBarHeight();
			} else {
				y = 0;
			}
			if (eachRowResizable) {
				h = this.$_calcItemHeight(grid, delegate, focusIndex);
				if (h >= bounds.height - this._fixedHeight) {
					this._topIndex = focusIndex - this._fixedItemCount;
				} else {
					for (i=focusIndex-1;i >= this._fixedItemCount ;i--) {
						h += this.$_calcItemHeight(grid, delegate, i);
						if (h >= bounds.height - y) {
							this._topIndex = Math.max(i-this._fixedItemCount+1,0);
							break;
						}
					}
				}
			} else {
				this._topIndex = focusIndex - this._fixedItemCount - Math.max(0, this._fullItemCount - 1); // fullItemCount가 0일 수 있다.
			}
			this._itemPoints = [y];
			this._itemCount = 0;
			this._fullItemCount = 0;
			this._availableItemCount = 0;
			cnt = grid.itemCount() - this._fixedItemCount;
			for (i = this._topIndex; i < cnt && y < bounds.height; i++) {
				h = this.$_calcItemHeight(grid, delegate, i + this._fixedItemCount);
				y += h;
				this._itemCount++;
				this._itemPoints.push(y);
			}
			this._fullItemCount = this._itemCount - (y >= bounds.height ? 1 : 0);
			return y;
		} else {
			return -1;
			y =  this._itemPoints[this._itemCount];
			while (this._topIndex > 0 && y < bounds.height) {
				h = this.$_calcItemHeight(grid, delegate, this._topIndex + this._fixedItemCount);
				if (y + h <= bounds.height) {
					this._topIndex--;
					this._itemCount++;
					this._fullItemCount++;
					this._itemPoints.unshift(this._itemPoints[0] - h);
				}
				y += h;
			}
			h = this._itemPoints[0];
			if (h < 0) {
				for (i = 0, cnt = this._itemPoints.length; i < cnt; i++) {
					this._itemPoints[i] += -h;
				}
			}
		}
	},
	_calcItemPoints: function (bounds) {
		var i, cnt, h, top,
			focusIndex = -1,
			grid = this._grid,
			delegate = grid.delegate(),
			y = 0;
		this._fixedRows = this._getFixedRowCount();
		this._fixedItemCount = 0;
		this._fixedHeight = 0;
		this._fixedItemPoints = [];
		if (this._fixedRows > 0) {
			this._fixedItemPoints.push(y);
			for (i = 0; i < this._fixedRows && y < bounds.height; i++) {
				h = this.$_calcItemHeight(grid, delegate, i);
				y += h;
				this._fixedItemPoints.push(y);
				this._fixedItemCount++;
			}
			this._fixedHeight = y;
			y += grid.fixedOptions().rowBarHeight();
		}
		cnt = grid.itemCount() - this._fixedItemCount;
		this._itemPoints = [];
		this._itemCount = 0;
		this._fullItemCount = 0;
		this._availableItemCount = 0;
		if (cnt > 0 && y < bounds.height) {
			this._itemPoints.push(y);
			top = this._topIndex;
			if (this._focusIndex) {
				focusIndex = this._focusIndex.I();
				if (focusIndex >= this._fixedItemCount && focusIndex < top + this._fixedItemCount) {
					top = this._topIndex = focusIndex - this._fixedItemCount;
				}
			}	
			for (i = top; i < cnt && y < bounds.height; i++) {
				h = this.$_calcItemHeight(grid, delegate, i + this._fixedItemCount);
				y += h;
				this._itemCount++;
				this._itemPoints.push(y);
			}
			this._fullItemCount = this._itemCount - (y >= bounds.height ? 1 : 0);
			h = this.$_compensateItems(bounds);
			if (h >= 0) y = h;
		}
		bounds.height = y;
	},
	$_checkColumnMerging: function () {
		var	grid = this._grid;
		var	mergeView = grid.mergeView();
		var	fixedMergeView = grid.fixedMergeView();
		var rfixedMergeView = grid.rfixedMergeView();
		var	first = this._fixedItemCount + this._topIndex;
		var	last = Math.min(grid.itemCount() - 1, this._fixedItemCount + this._topIndex + this._itemCount - 1);
		var	fixed = this._fixedCols > 0;
		var rfixed = this._rfixedCols > 0;
        var i, cnt, col, merges, rooms;
		mergeView.clearRooms();
		if (fixed) {
			fixedMergeView.clearRooms();
		}
		if (rfixed) {
			rfixedMergeView.clearRooms();
		}

		var dataColumns = grid.getDataColumns().slice();

		function calcMerge(columns, view) {
			for (i = 0, cnt = columns.length; i < cnt; i++) {
				col = columns[i];
				dataColumns.indexOf(col) >= 0 && dataColumns.splice(dataColumns.indexOf(col), 1);
				if (col instanceof ValueColumn && col.canMerge()) {
					merges = col.stateFor(ColumnMergeManager.MERGE_ROOMS);
					if (!merges) {
						merges = new ColumnMergeManager(col);
						col.setState(ColumnMergeManager.MERGE_ROOMS, merges);
					}
					merges.refresh(first, last);
					rooms = merges.getRooms();
					view.addColumnRooms(col, rooms);
					this._columnMerged = true;
				}
			}

		};

		// left fixed merge view
		var horzColumns = grid.getHorzColumns(0, this._fixedCols);
		calcMerge.call(this, horzColumns, fixedMergeView);

		// right fixed merge view
		horzColumns = grid.getHorzColumns(this.rfixedStartCol(), this._rfixedCols);
		calcMerge.call(this, horzColumns, rfixedMergeView);

		// body merge view
		horzColumns = grid.getHorzColumns(this._fixedCols, this._columns.length - this._fixedCols - this._rfixedCols);
		calcMerge.call(this, horzColumns, mergeView);

		mergeView.clearFooters();
		if (fixed) {
			fixedMergeView.clearFooters();
		}
		if (rfixed) {
			rfixedMergeView.clearFooters();
		}
		grid.mergeHeaderView().clearHeaders();

		for (i = 0, cnt = dataColumns.length; i < cnt; i++) {
			merges = dataColumns[i].stateFor(ColumnMergeManager.MERGE_ROOMS);
			merges && merges.clear();
		}
	},
	$_layoutItems: function (parent, r) {
		var i, model, top;
		var grid = this._grid;
		var isTree = this._grid instanceof TreeView;
		var rowGroupView = grid.rowGroupView();
		var bodyView = grid.bodyView();
		var fixedView = grid.fixedBodyView();
		var rfixedView = grid.rfixedBodyView();
		var fixed = this._fixedCols > 0;
		var rfixed = this._rfixedCols > 0;
		rowGroupView.clearBody();
		bodyView.clearItems();
		fixedView.clearItems();
		rfixedView.clearItems();
		for (i = 0; i < this._fixedItemCount; i++) {
			model = this._items.getItem(i);
			if (model instanceof GroupItemImpl) {
				rowGroupView.addHeader(model);
			} else if (model instanceof GroupFooter) {
				rowGroupView.addFooter(model);
			} else if (!model.isMerged()) {
				bodyView.addItem(model);
				if (fixed) {
					fixedView.addItem(model);
				}
				if (rfixed) {
					rfixedView.addItem(model);
				}
			}
		}
		top = this._topIndex + this._fixedRows;
		for (i = 0; i < this._itemCount; i++) {
			model = this._items.getItem(i + top);
			if (model instanceof GroupItemImpl) {
				rowGroupView.addHeader(model);
			} else if (model instanceof GroupFooter) {
				rowGroupView.addFooter(model);
			} else if (!model.isMerged()) {
				bodyView.addItem(model);
				if (fixed) {
					fixedView.addItem(model);
				}
				if (rfixed) {
					rfixedView.addItem(model);
				}
			}
		}
		bodyView.layoutContent(this);
		if (fixed || (fixedView.childCount() > 0 && !isTree)) {
			fixedView.layoutContent(this);
		}
		if (rfixed || (rfixedView.childCount() > 0 && !isTree)) {
			rfixedView.layoutContent(this);
		}
		if (this.isRowGrouped() || (rowGroupView.childCount() > 0 && !isTree)) {
			rowGroupView.layoutContent(this);
		}
	},
	$_layoutMerges: function () {
		var i,
			mergeView,
			top,
			model,
			fixedView,
			rfixedView,
			headerView,
			grid = this._grid,
			fixed = this._fixedCols > 0,
			rfixed = this._rfixedCols > 0;
		mergeView = grid.mergeView();
		top = this._topIndex + this._fixedRows;
		for (i = 0; i < this._itemCount; i++) {
			model = this._items.getItem(i + top);
			if (model instanceof MergedGroupFooter) {
				mergeView.addFooter(model);
			}
		}
		mergeView.layoutContent(this);
		if (fixed) {
			fixedView = grid.fixedMergeView();
			for (i = 0; i < this._itemCount; i++) {
				model = this._items.getItem(i + top);
				if (model instanceof MergedGroupFooter) {
					fixedView.addFooter(model);
				}
			}
			fixedView.layoutContent(this);
		}
		if (rfixed) {
			rfixedView = grid.rfixedMergeView();
			for (i = 0; i < this._itemCount; i++) {
				model = this._items.getItem(i + top);
				if (model instanceof MergedGroupFooter) {
					rfixedView.addFooter(model);
				}
			}
			rfixedView.layoutContent(this);
		}
		headerView = grid.mergeHeaderView();
		for (i = 0; i < this._itemCount; i++) {
			model = this._items.getItem(i + top);
			if (model instanceof MergedGroupHeader) {
				headerView.addHeader(model);
			}
		}
		headerView.layoutContent(this);
	},
	_doFitGroupWidth: function (group, visibleOnly, minWidth, maxWidth) {
		var grid = this._grid,
			itemCount = grid.itemCount(),
			maxw = 0,
			groupWidth = 0,
			view = grid._headerView.findCell(group);
		if (view instanceof HeaderGroupCellElement)  {
			groupWidth = (view = view._getCell(group)) ? (view._calcWidth ? view._calcWidth : 0) : groupWidth;
		}
		if (itemCount < 1) {
			// return groupWidth ? groupWidth : 2;
		}
		for (var i = group.visibleCount(); i--;) {
			var column = group.getVisibleItem(i);
			var w;
			if (column instanceof ColumnGroup) {
				w = this._doFitGroupWidth(column, visibleOnly, 0, 0);
			} else {
				w = this._doFitColumnWidth(column, visibleOnly, 0, 0, true);
			}
			if (group.orientation() == ColumnGroupOrientation.HORIZONTAL) {
				ColumnGroup.changeWidth(column, w - column.groupWidth(), false);
				maxw += w;
			} else {
				maxw = Math.max(maxw, w);
			}
		}
		if (group.orientation() == ColumnGroupOrientation.VERTICAL || groupWidth > maxw || minWidth > 0 || maxWidth > 0) {
			maxw = Math.max(groupWidth, maxw);
			if (maxWidth > 0) {
				maxw = Math.min(maxw, maxWidth);
			}
			if (minWidth > 0) {
				maxw = Math.max(maxw, minWidth);
			}
			maxw = Math.max(maxw,Column.MIN_WIDTH);
			ColumnGroup.changeWidth(group, maxw - group.groupWidth(), false);
		}
		return maxw;
	},
	_doFitColumnWidth: function (column, visibleOnly, minWidth, maxWidth, calcOnly) {
		var i, cellView, renderer, sz,
			w = 2,
			grid = this._grid,
			body = grid.body(),
			defWidth = this._options.defaultColumnWidth(),
			itemCount = grid.itemCount();
		var options, treeItem, treeIcon, handleWidth = 0, wHandle = 0, wCheck = 0, wIcon = 0, level = 0, styles, isTree;
		isTree = this instanceof TreeGridLayoutManager && grid.getFirstColumn() === column;
		if (isTree) {
			options = grid.treeOptions();
			wHandle = options.expanderWidth();
			wCheck = (options.isShowCheckBox() ? options.checkBoxSize() : 0) + options.expanderStyles().paddingRight();
			wIcon = options.iconWidth();
		}
		if (grid.header().isVisible()) {
			var headerWidth;
			var header = grid.header();
			var headerView = column.isFixed() ? grid.fixedHeaderView() : column.isRightFixed() ? grid.rfixedHeaderView() : grid.headerView();
			var colHead = headerView && headerView.findCell(column, true);
			if (!colHead && column instanceof DataColumn) {
				var hCell = header.getCell(CellIndex.temp(grid, -1, column));
				if (hCell) {
					colHead = new TestHeaderCellElement(grid);
					colHead.updateCell(hCell);
					var cw = grid.measureText(colHead.font(), colHead.text()) + colHead.paddingHorz() + (colHead._handleWidth || 0);
					colHead._calcWidth = cw;
				};
			};
			headerWidth = colHead && colHead._calcWidth;
			w = headerWidth ? Math.max(w, headerWidth) : w;
			if (grid.header().summary().isVisible()) {
				cellView = grid._summaryView.findCell(column);
				var sz = cellView && cellView.measure(grid, w, MAX_INT);
				w = sz && sz.width ? Math.max(w, sz.width) : w;
			}
		}
		if (itemCount < 1) {
			// return w;
		}
		cellView = (column instanceof SeriesColumn) ? new TestSeriesCellElement(grid) : new TestDataCellElement(grid);
		var start = 0;
		var end = itemCount;
		if (visibleOnly) {
			start = grid.topItem();
			end = start + this.itemCount();
			if ((itemCount = this.fixedItemCount()) > 0) {
				for (i = 0; i < itemCount; i++) {
					cellView.updateCell(body.getCell(CellIndex.temp(grid, i, column)));
					sz = cellView.measure(grid, defWidth, MAX_INT);
					w = Math.max(w, sz.width);
				}
			}
		}
		for (i = start; i < end; i++) {
			var index = CellIndex.temp(grid, i, column);
			if (index.dataRow() > -1) {
				cellView.updateCell(body.getCell(index));
				sz = cellView.measure(grid, defWidth, MAX_INT);
				if (isTree) {
					var treeItem = grid.getItem(i);
					if (treeItem) {
						level = treeItem.level();
						if (wIcon <= 0 && options.icons()) {
							treeIcon = grid.getTreeIcon(treeItem);
							if (treeIcon) {
								wIcon = treeIcon.width;
							}
						}						
					};
					handleWidth = wHandle * level + wCheck + wIcon;
				}
				w = Math.max(w, sz.width + handleWidth);
			}		
		}
		if (maxWidth > 0) {
			w = Math.min(w, maxWidth);
		}
		if (minWidth > 0) {
			w = Math.max(w, minWidth);
		}
		if (grid.footer().isVisible()) {
			for (i = grid.footer().count()-1; i >= 0; i--) {
				cellView = grid._footerView.findCell(i, column);
				var fb = cellView && cellView.measure(grid, w, MAX_INT);
				w = fb && fb.width ? Math.max(w, fb.width) : w;
			}
		}
		!calcOnly && ColumnGroup.changeWidth(column, w - column.groupWidth(), false);
		return w;
	},
	_getColumnRectInRoot: function (column, r) {
		var root = column.root();
		var c = column.parent();
		r.copy(column.layoutRect());
		while (c != root) {
			r.offset(c.layoutRect().x, c.layoutRect().y);
			c = c.parent();
		}
	},
	_clearFitWidths: function () {
		this.grid()._clearFitWidths();
	},
	_getColumnWidth: function (index) {
		var rfixedCol = this.rfixedStartCol();
		return index < this._fixedCols ? (this._fixedColumnPoints[index + 1] - this._fixedColumnPoints[index]) :
			index >= rfixedStart ? (this._rfixedColumnPoints[index - rfixedCol + 1] - this._rfixedColumnPoints[index - rfixedCol]) :
				this._columnPoints[index - this._fixedCols + 1] - this._columnPoints[index - this._fixedCols];
	},
	_setFitWidth: function (column, w) {
		column._fitWidth = w;
		var group = _cast(column, ColumnGroup);
		if (group) {
			group.resetFitWidths();
		}
	}
});
var TestDataCellElement = defineClass("TestDataCellElement", DataCellElement, {
	init : function(grid) {
		this._super();
		this._grid = grid;
	},
	grid: function () {
		return this._grid;
	}
});
var TestSeriesCellElement = defineClass("TestSeriesCellElement", SeriesCellElement, {
	init : function(grid) {
		this._super();
		this._grid = grid;
	},
	grid: function () {
		return this._grid;
	}
});
var TestHeaderCellElement = defineClass("TestHeaderCellelement", HeaderCellElement, {
	init: function(grid, dom) {
		this._super(grid, dom);
		this._grid = grid;
	},
	grid: function() {
		return this._grid;
	}
});
var $$_EDITOR_THRESHOLD = _isSafari ? 1 : 0;
var $$_EMPTY_TEXT_VALUE = '***1-da*&23%^1//+)(lu%v\\3d!#~`{``~er';
var $$_EDITOR_FONT_NAME = 'Tahoma';
var $$_EDITOR_FONT_SIZE = '10pt';
var CellEditor = defineClass("CellEditor", EventAware, {
	init: function (grid, parentElement/* <body> */) {
		this._super();
		this._grid = grid;
		this._options = grid.editorOptions();
		this._displayOptions = grid.displayOptions();
		this._editorBorder = "2px solid rgb(82, 146, 247)";
		this._editorShadow = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		this._parentElement = parentElement;
		this._editor = this._createEditor(parentElement);
		this._editor.$_owner = this;
		this._editIndex = new CellIndex();
		this._controller = null;
		this._started = false;
		this._oldValue = undefined;
		this._dateConverter =  DatetimeConverter.Default;
		this._saveDateConverter = null;
		this._boolConverter = BooleanConverter.Default;
		this._saveBoolConverter = null;
		this._cellBounds = new Rectangle();
		this._onfocus = function (e) {
			this._grid.$_setEditFocused(true,e);
		}
		this._onfocusin = function (e) {
			this._grid.$_setEditFocused(true,e);
		}
		this._onblur = function (e) {
			if (_isMobile()) {
				setTimeout(function() {
					this._grid.commitEditor(true);
				}.bind(this), 50);
			} 
			this._grid.$_setEditFocused(false,e);
		}
		this._onfocusout = function (e) {
			this._grid.$_setEditFocused(false,e);
		}
		if (this._editor) {
			this._editor.addEventListener("focus", this._onfocus.bind(this));
			this._editor.addEventListener("focusin", this._onfocusin.bind(this));
			this._editor.addEventListener("blur", this._onblur.bind(this));
			this._editor.addEventListener("focusout", this._onfocusout.bind(this));
		}
		this.setVisible(false, true);
		this.setEditorId(this._editor);
	},
	destroy: function() {
		this._destroying = true;
		if (this._editor) {
			this._editor.removeEventListener("focus", this._onfocus.bind(this));
			this._editor.removeEventListener("focusin", this._onfocusin.bind(this));
			this._editor.removeEventListener("blur", this._onblur.bind(this));
			this._editor.removeEventListener("focusout", this._onfocusout.bind(this));
			this._editor._inputHandlerStock = null;
		}
		this._defMaxLength = null;
		this._editorShadow = null;
		this._editorBorder = null;
		Dom.clearElements(this._container);
		if (this._container.parentNode) {
			this._container.parentNode.removeChild(this._container);
		};
		this._editor = null;
		this._container = null;
		this._grid = null;
		this._oldValue = null;
		this._super();
	},
	emptyValue: undefined,
	textCase: TextInputCase.DEFAULT,
	fontFamily: null,
	fontSize: null,
	datetimeFormat: null,
	todayChar: null,
	nowChar: null,
	booleanFormat: null,
    visible: false,
	editorZIndex: undefined,
	listZIndex: undefined,
	setDatetimeFormat: function (value) {
		if (value != this._datetimeFormat) {
			this._datetimeFormat = value;
			if (value) {
				if (!this._saveDateConverter) {
					this._saveDateConverter = new DatetimeConverter(value);
				}
				this._saveDateConverter.setFormatString(value);
				this._dateConverter = this._saveDateConverter;
			} else {
				this._dateConverter = DatetimeConverter.Default;
			}
		}
	},
	setBooleanFormat: function (value) {
		if (value != this._booleanFormat) {
			this._booleanFormat = value;
			if (value) {
				if (!this._saveBoolConverter) {
					this._saveBoolConverter = new BooleanConverter(value);
				}
				this._saveBoolConverter.setFormat(value);
				this._boolConverter = this._saveBoolConverter;
			} else {
				this._boolConverter = BooleanConverter.Default;
			}
		}
	},
	setEditorZIndex: function(value) {
		if (value != this._editorZIndex) {
			this._editorZIndex = value;
		}
	},
	getEditorZIndex: function() {
		var editorOptions = this._grid.editorOptions();
		return this._editorZIndex != undefined ? this._editorZIndex : editorOptions.editorZIndex != undefined ? editorOptions._editorZIndex : 2000;
	},
	setListZIndex: function(value) {
	},
	getListZIndex: function() {
		var editorOptions = this._grid.editorOptions();
		return this._listZIndex != undefined ? this._listZIndex : editorOptions.listZIndex != undefined ? editorOptions._listZIndex : 3000;
	},
	editor: function () {
		return this._editor;
	},
	visible_: function () {
		return parseInt(this._container.style.width) > $$_EDITOR_THRESHOLD && parseInt(this._container.style.height) > $$_EDITOR_THRESHOLD;
	},
	setVisible: function (value, force) {
		if (value) {
			var v;
			if (this._fontFamily) {
				v = this._fontFamily;
			} else {
				v = $$_EDITOR_FONT_NAME;
			}
			if (v != this._editor.style.fontFamily) {
				this._editor.style.fontFamily = v;
			}
			if (this._fontSize) {
				v = this._fontSize;
			} else {
				v = $$_EDITOR_FONT_SIZE;
			}
			if (v != this._editor.style.fontSize) {
				this._editor.style.fontSize = v;
			}
			this._container.style.zIndex = this.getEditorZIndex();
		}
        if (value && this._editor.value == $$_EMPTY_TEXT_VALUE) {
            this._editor.value = "";
        } else if (!value && (this._editor.value == null || this._editor.value == undefined || this._editor.value == "")) {
            this._editor.value = $$_EMPTY_TEXT_VALUE;
            if (this._grid.$_editFocused) {
                this.selectAll();
            }
        }
		if (!value) {
            Dom.setSize(this._container, $$_EDITOR_THRESHOLD, $$_EDITOR_THRESHOLD);
        }
	},
	isEditing: function () {
		return this._started;
	},
	editIndex: function () {
		return this._editIndex;
	},
	hasButton: function () {
		return false;
	},
	initOptions: function () {
		this._emptyValue = undefined;
		this.setBooleanFormat(null);
		this._todayChar = null;
		this._nowChar = null;
		this.setDatetimeFormat(null);
		this._textCase = TextInputCase.DEFAULT;
		this._fontFamily = null;
		this._fontSize = null;
		this._checkHangeul = false;
		this._editorZIndex = null,
		this._listZIndex = null;
	},
	applyOptions: function (options) {
		options && this.assign(options);
	},
    setController: function (value) {
        this._controller = value;
    },
	beginEdit: function (clear, select) {
		if (!this._started) {
			this._started = this._doBeginEdit();
            clear && this.clear();
            select && this.selectAll();
		}
	},
	endEdit: function () {
		if (this._started) {
			this._doEndEdit();
			this._started = false;
		}
	},
    caretToLast: function () {
    },
	commit: function () {
		this._doCommit();
	},
	setEditIndex: function (index) {
		this._editIndex.assign(index);
	},
	setReadOnly: function (value) {
	},
	getEditValue: function (throwError, validateValue) {
		return undefined;
	},
	setEditValue: function (value) {
		this._oldValue = value;
	},
	setCellEditValue: function(value, dropdown) {
		if (!this.isReadOnly() && this._requestStart(dropdown)) {
			this.setEditValue(value);
			this._doChanged();
		}
	},
	getEditText: function () {
		return "";
	},
	clear: function () {
		this._editor.value = "";
	},
	setFocus: function () {
            this._editor.focus({preventScroll:true});
	},
	selectAll: function () {
        if (this._grid.$_editFocused) {
            this._selectAll();
        }
	},
	setEditorTitle:function(index) {
		var grid = index.grid();
		var options = grid.editorOptions();
		if (!grid._loading && this._editor && index && index.I() >= 0 && options && options._titleExprStatement) {
			this._editor.title = "";
			var item = index.item();
			if (!(item instanceof GridRow || item instanceof TreeItem)) {
				return;
			}
			var cell = grid._body.getCellSimple(index);
			if (!(cell instanceof DataCell)) {
				return;
			}
			var runtime = options._titleExprRuntime;
			var v = cell.value() instanceof Date ? this._dateConverter.getText(cell.value()) : cell.displayText();
			runtime.setCell(cell);
			runtime.setValue(v);
			var title = options._titleExprStatement.evaluate(options._titleExprRuntime)			
			this._editor.title = title;
		}
	},
	setEditorId: function(editor) {
		var containerId = this._grid.container()._containerDiv.id;
		if (containerId && editor && editor instanceof HTMLElement) {
			var id = "_"+ (this.$name && this.$name.indexOf("CellEditor") > 0 ? this.$name.substr(0,this.$name.indexOf("CellEditor")) : "input");
			editor.id = containerId+id.toLowerCase();
		}
	},
	setBounds: function (x, y, w, h) {
	},
	setCellBounds: function (x, y, w, h) {
		this._cellBounds.set(x, y, w, h);
	},
	closeList: function (accept) {
	},
	dropDownList: function(force) {
	},
	buttonClicked: function (index) {
	},
	_createEditor: function (parent) {
		return null;
	},
    _selectAll: function () {
    },
	_editField: function () {
		return this._grid.dataSource() ? this._grid.dataSource().getField(this._editIndex.dataField()) : null;
	},
    _isDateEditor: function () {
        return false;
    },
	_doBeginEdit: function () {
		return true;
	},
	_doEndEdit: function () {
	},
	_requestStart: function () {
		if (!this._started) {
			this.selectAll();
			return this._controller.onEditorStart(this);
		}
		return this._started;
	},
	$_valToStr: function (value) {
		var index = this.editIndex();
		var s = "";
		try {
			if (value !== UNDEFINED || this._mask) {
				var fld = index.grid().dataSource().getField(index.dataField());
				if (fld) {
					switch (fld.dataType()) {
						case ValueType.DATETIME:
							if (value) {
								s = this._dateConverter.getText(value);
							}
							if (this._mask) {
								s = this._mask.writeBuffer(s);
							}
							break;
						case ValueType.BOOLEAN:
							s = this._boolConverter.toText(value);
							break;
						case ValueType.NUMBER:
							if (!isNaN(value)) {
								s = _toStr(value);
							}
							break;
						case ValueType.OBJECT:
							var col = index.column();
							var dataRow = index.dataRow();
							var key = col._objectKey;
							var fn = col._objectCallback;
							if (value) {
								s = fn && typeof fn === "function" ? fn(fld.orgFieldName(), dataRow, value) : key && value.hasOwnProperty(key) ? value[key] : value != null && typeof value == "object" ? JSON.stringify(value) : "";
							}
							break;
						default:
							s = this._mask ? this._mask.writeBuffer(value) : value;
							break;
					}
				} else {
					s = value;
				}
			}
		} catch (err) {
			_throwDebug(err);
			s = value;
		}
		return s === null ? "" : s;
	},
	$_strToVal: function (s) {
		s = _toStr(s);
		var index = this._editIndex;
		var tcase = index.dataColumn() && this._textCase == TextInputCase.DEFAULT ? index.dataColumn().textInputCase() : this._textCase;
		try {
			var fld = index.grid().dataSource().getField(index.dataField());
			if (fld) {
                var t = fld.dataType();
				if (t == ValueType.DATETIME || (s && this._isDateEditor() && t == ValueType.TEXT)) {
                    var dateFld = t == ValueType.DATETIME;
                    var d = null;
					if (s && s == this._nowChar) {
						d = new Date();
					}
					if (!d && s && s == this._todayChar) {
						d = new Date();
						d.setHours(0, 0, 0, 0);
					}
                    if (!d) {
                    	this._mask && (s = this._mask.getStripValue(s));
                        d = this._dateConverter.getDate(s);
                    }
					return dateFld ? (!d || isNaN(d.getFullYear()) ? undefined : d) : d ? this._dateConverter.getText(d) : undefined;
				} else if (t == ValueType.BOOLEAN) {
					return this._boolConverter.toBoolEx(s);
				} else if (t == ValueType.NUMBER) {
                    return parseFloat(s);
                } else if (t == ValueType.TEXT) {
                   	this._mask && (s = this._mask.getStripValue(s));
                }
			}
			if (tcase === TextInputCase.UPPER) {
				return s ? s.toLocaleUpperCase() : s;
			} else if (tcase === TextInputCase.LOWER) {
				return s ? s.toLocaleLowerCase() : s;
			} else {
				return s;
			}
		} catch (err) {
			_throwDebug(err);
			return undefined;
		} 
	},
	_dispatchKeyDown: function (keyCode, ctrl, shift, alt) {
        if (!this._controller) debugger;
		return this._controller.onEditorKeyDown(this, keyCode, ctrl, shift, alt);
	},
	_dispatchKeyPress: function (keyCode) {
        if (!this._controller) debugger;
		return this._controller.onEditorKeyPress(this, keyCode);
	},
	_dispatchKeyUp: function (keyCode, ctrl, shift, alt) {
        if (!this._controller) debugger;
		return this._controller.onEditorKeyUp(this, keyCode, ctrl, shift, alt);
	},
	_dispatchChange: function () {
		this._controller.onEditorChange(this);
	},
	_dispatchSearch: function (text) {
		this._controller.onEditorSearch(this, text);
	},
	_dispatchSearchCellButtonClick: function(text) {
		return this._controller.onSearchCellButtonClick(this, text);
	},
    _dispatchCommit: function () {
        this._controller.onEditorCommit(this);
    },
	_sendToParent: function (e, flag, nohandle) {
        try {
            var ctrl = _isMac && e.metaKey || !_isMac && e.ctrlKey;
            if (flag == 2) { // key press
	            if (this._dispatchKeyPress(e.keyCode || e.which)) {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                }
	                return true;
	            }
            } else if (flag == 3) { // key up
	            if (this._dispatchKeyUp(e.keyCode, ctrl, e.shiftKey, e.altKey)) {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                }
	                return true;
	            };
                // maxLength를 체크해서 maxLength가 입력되었으면 다음 셀로 넘어간다.
				try {
					var grid = this._controller._grid;
					var options = grid.editOptions();
					var moveNextCell = options.isMaxLengthToNextCell();
					if (!!moveNextCell) {
						var skip = options.isSkipReadOnly();
						var activeTool = grid.activeTool && grid.activeTool();
						var maxLength = this.maxLength && this.maxLength();
						var idx = this.editIndex().clone();
						var isSpecialKey = _included(e.keyCode, Keys.UP, Keys.PAGEUP, Keys.DOWN, Keys.PAGEDOWN, Keys.F2, Keys.TAB, Keys.ENTER);
						if (!this._checkHangeul && !isSpecialKey && !ctrl && !e.altKey && grid && grid.isEditing(idx) && maxLength > 0 && !this._composing && e.keyCode > 47) {
							var s = this._mask ? this._mask.getStripValue(this._editor.value, true) : this._editor.value;
							if (s && s.length >= maxLength) {
								idx.right();
								if (skip && activeTool.checkReadOnly(idx)) {
									if (!activeTool.skipReadOnly(idx, 1)) {
										idx = this.editIndex().clone();
									}
								}
								if (!CellIndex.areEquals(idx, this.editIndex())) {
									activeTool.setFocused(idx, true);
								}
								return true;
							}
						}
					}
				} catch (err) {
					if (err instanceof ValidationError) {
						throw err;
					}
					return true;
					// 오류가 나도. 정상처리하도록 한다.
	            }
            } else { // key down
	            if (this._dispatchKeyDown(e.keyCode, ctrl, e.shiftKey, e.altKey)) {
	                if (e.preventDefault) {
	                    e.preventDefault();
	                }
	                return true;
	            }
	        }
            return false;
        } finally {

        }
	}
}, {
	Unselected: {},
	InvalidFormat: {}
});
var DefaultDefinitions = function () {
	return {
        "9": new RegExp("[0-9 ]"),
        "0": new RegExp("[0-9]"),
        "a": new RegExp("[A-Za-z]"),
        "*": new RegExp("[A-Za-z0-9]")
	}
}
/* */
var EditMask = defineClass("EditMask", null, {
	init: function(editor, options) {
		this._super(true);
		this._definitions = new DefaultDefinitions();
		this._tests = [];
		this._placeHolder = undefined;
		this._buffer = undefined;
		this._defBuffer = [];
		this._editMask = undefined;
		this._editor = editor;
		this._caretTimer = undefined;
		this._showInvalidFormatMessage = true,
		this._overWrite = false;
		this.setOptions(options);
	},
	includedFormat: false,
	placeHolder:undefined,
	editMask:undefined,
	definitions:undefined,
	invalidFormatMessage: undefined,
	showInvalidFormatMessage:true,
	overWrite:false,
	allowEmpty:false, // 공백이 허용되지 않는 mask이지만 입력값이 없을때는 허용
	restrictNull: false,
	destroy: function() {
		this._destroying = true;
		this._definitions = null;
		this._tests = null;
		this._editor._editor && (this._editor._editor.onclick = null);
		this._editor = null;
		this._super();
	},
	clickHandler: function(event) {
		if (!this.isRestrictNull()) {
			return;
		};
		this._moveCaret();
	},
	_moveCaret: function(start, end) {
		var editor = this._editor._editor;
		start = arguments.length > 0 ? start : editor.selectionStart;
		end = arguments.length > 1 ? end : editor.selectionEnd;
		var st = start, ed = end, i;
		for (i = start-1; i >= 0; i--) {
			if (this._tests[i] && this._tests[i].test(this._buffer[i])) {
				st = i+1;
				break;
			} else {
				st = i;
			}
		}
		for (i = end-1; i >= 0; i--) {
			if (this._tests[i] && this._tests[i].test(this._buffer[i])) {
				ed = i+1;
				break;
			} else {
				ed = i;
			}
		}
		if (st != start || ed != end) {
			for (i = st; i <= start; i++) {
				if (this._tests[i]) {
					break;
				} else {
					st++;
				}
			}
			for (i = ed; i <= end; i++) {
				if (this._tests[i]) {
					break;
				} else {
					ed++;
				}
			}
			editor.setSelectionRange(st, ed);
			return true;
		};
		return st != start || ed != end;
	},
	clearBuffer: function (begin, end) {
		begin = arguments.length > 0 ? begin : 0;
		end = arguments.length > 1 ? end : this._tests.length;
		for (var i = begin; i < end; i++) {
			this._buffer[i] = this.$_getPlaceHolder(i);
			this._defBuffer[i] = "";
		}
	},
	writeBuffer: function(value, isPaste) {
		var c;
		if (value) {
			isPaste && this.clearBuffer();
			for (var i = 0, j = 0, cnt = this._tests.length; i < cnt ; i++) {
				if (this._tests[i] && (this._tests[i] instanceof RegExp)) {
					while((c = value[j++])) {
						if (this._tests[i].test(c)) {
							this._buffer[i] = c;
							this._defBuffer[i] = c;
							break;
						}
					}
				}
			}
		};
		return this._buffer && this._buffer.join("");
	},
	// textOnly
	getStripValue: function(value, textOnly) {
		textOnly = typeof textOnly === "boolean" ? textOnly : false;
		var ret = [];
		var buf = [];
		var allowEmpty = this.isAllowEmpty(); // 
		var i, cnt;
		var c;
		if (this._defBuffer.join("") == "") {
			return null;
		}
		if (this.isIncludedFormat() && !textOnly) {
			for (var i = 0, cnt = this._buffer.length; i < cnt ; i++) {
				c = this._buffer[i];
				if (!this._tests[i] || this._tests[i].test(c)) {
					ret.push(c)
				} else if (c == this.$_getPlaceHolder(i) && this._tests[i].test(" ")) {
					ret.push(" ");
				} else {
					// 입력된 문자가 올바르지 않은 경우 checkValid에서 걸러줘야 한다.
				}
			}
		} else {
			for (var i = 0, cnt = this._buffer.length; i < cnt ; i++) {
				if (this._tests[i] && this._tests[i] instanceof RegExp && this._tests[i].test(this._buffer[i])) {
					buf.length > 0 && (ret = ret.concat(buf), buf = []);
					ret.push(this._buffer[i]);
				} else if (this._tests[i] && typeof this._tests[i] == "function") {
					buf.length > 0 && (ret = ret.concat(buf), buf = []);
					ret.push(this._buffer[i]);
				} else {
					// buf.push(" ");// 입력되지 않은 경우 공백으로 처리할수 있는지 확인해 보아야 한다. 
				}
			}
		}
		return ret.join("");
	},
	setOptions: function(options) {
		if (typeof options == "string") {  // mask:"9999-99-99"등과 같이 문자열로 입력한 경우 사용한다.
			this.$_parseMask(options);
		} else {
			// 순서가 문제가 되는 경우가 있어서 하나씩 지정한다. (defineClass로 만들지 않음.)
			options.definitions && this.$_parseDefinitions(options.definitions);
			options.placeHolder && (this._placeHolder = options.placeHolder);
			options.editMask && this.$_parseMask(options.editMask);
			options.includedFormat && (this._includedFormat = options.includedFormat);
			options.invalidFormatMessage && (this._invalidFormatMessage = options.invalidFormatMessage);
			options.showInvlidFormatMessage && (this._showInvalidFormatMessage = options.showInvalidFormatMessage);
			options.overWrite != null && (this._overWrite = !!options.overWrite);
			options.allowEmpty != null && (this._allowEmpty = !!options.allowEmpty);
			options.restrictNull !== undefined && (this._restrictNull = !!options.restrictNull);
			if (this._restrictNull) {
				var editor = this._editor._editor;
				!editor.onclick && (editor.onclick = this.clickHandler.bind(this));
			}
		}
	},
	$_setCaret: function(start, end) {
		var editor = this._editor._editor;
		// clearTimeout(this._caretTimer);
		// this._caretTimer = setTimeout(function() {
			editor.setSelectionRange(start ,end);
		// }, 0);
	},
	checkValid: function(s) {
		var allowEmpty = this.isAllowEmpty(); // 
		var i, cnt;
		var checkData = [];
		if (allowEmpty) {
			for (i = 0, cnt = this._tests.length; i < cnt ; i++) {
				checkData[i] = this.$_getPlaceHolder(i);
			}
			if (checkData.join("") === this._buffer.join("")) {
				return true;
			}
		};
		for (i = 0, cnt = this._tests.length; i < cnt ; i++) {
			var c = this._buffer[i];// == this.$_getPlaceHolder(i) ? " ": this._buffer[i];
			if (this._tests[i] && !this._tests[i].test(c)) {
				if (c == this.$_getPlaceHolder(i) && !this._tests[i].test(" ")) {
					return false;
				}
			}
		};
		return true;
	},
	/* 사용자가 지정한 format function은 아직 사용할수 없다. */
	$_parseDefinitions: function (defs) {
		for (def in defs) {
			typeof defs[def] === "string" && (this._definitions[def] = new RegExp(defs[def]));
		}
	},
	$_parseMask: function(mask) {
		var tests = this._tests = [];
		var defs = this._definitions;
		var am = mask.split("");
		this._editMask = mask;
		this._buffer = [];
		for (var i =0, cnt = am.length; i < cnt; i++) {
			tests.push(defs[am[i]]);
			this._buffer.push(defs[am[i]] ? this.$_getPlaceHolder(i) : am[i])
		}
	},
	$_getPlaceHolder: function (n) {
		if (this._placeHolder && this._placeHolder.length > n) {
			return this._placeHolder[n]
		}
		return this._tests[n] ? "_" : (this._editMask && this._editMask.length > n ? this._editMask[n] : "_");
	},
	$_seekPrev: function(pos) {
		for (;--pos >= 0 && !this._tests[pos]; ) ;
		return pos;
	},
	$_seekNext: function(pos) {
		for (;++pos < this._editMask.length && !this._tests[pos];);
		return pos;
	},
	$_shiftL: function(begin, end) {
		var i, j;
		var len = this._editMask.length;
		var buffer = this._buffer;
		if ( begin >= 0) {
			for (i = begin, j=this.$_seekNext(end); len > i ; i++) {
				if (this._tests[i]) {
					if (!(len > j && this._tests[i].test(buffer[j]))) break;
					buffer[i] = buffer[j];
					this._defBuffer[i] = this._defBuffer[j];
					buffer[j] = this.$_getPlaceHolder(j);
					this._defBuffer[j] = "";
					j = this.$_seekNext(j);
				}
			}
		}
	},
	$_shiftR: function(begin) {
		var i, c, j, t;
		var len = this._editMask.length;
		var buffer = this._buffer;
		for (i = begin, c = this.$_getPlaceHolder(begin); len > i; i++)
			if (this._tests[i]) {
				if (j = this.$_seekNext(i), t = buffer[i], this._defBuffer[i] = c, buffer[i] = c, !(len > j && this._tests[j].test(t)))
					break;
				c = t;
			}
	},
	keydown: function(e) {
		var editor = this._editor._editor;
		if (editor.readOnly) {
			return;
		}
		var k = e.which || e.keyCode;
		var start = editor.selectionStart, end = editor.selectionEnd;
		if (k === 46 || k === 8) {
			if (start == end) {
				start = k !== 46 ? this.$_seekPrev(start) : end = this.$_seekNext(start-1);
				end = k === 46 ? this.$_seekNext(end) : end;
			}
			this.clearBuffer(start, end);
			!this._overWrite && this.$_shiftL(start, end-1);
			editor.value = this.writeBuffer();
			this.$_setCaret(Math.max(0,start), Math.max(0,start));
		} else if (k === Keys.RIGHT || k === Keys.END) {
			return this._moveCaret();
		}
		this._pStart = editor.selectionStart;
	},
	keyPress: function(e) {
		var editor = this._editor._editor;
		if (editor.readOnly) {
			return;
		}
		this.isRestrictNull() && this._moveCaret();
		var pStart = editor.selectionStart, pEnd = editor.selectionEnd, k = e.which || e.keyCode, c;
		this.clearBuffer(pStart, pEnd);
		pStart !== pEnd && this.$_shiftL(pStart, pEnd-1);
		var p = this.$_seekNext(pStart-1);
		if (this._editMask && this._editMask.length > p && this._tests[p] && this._tests[p].test(c=String.fromCharCode(k))) {
			!this._overWrite && this.$_shiftR(pStart);
			this._buffer[p] = c;
			this._defBuffer[p] = c;
			editor.value = this.writeBuffer();
			p = this.$_seekNext(p);
			this.$_setCaret(Math.max(0,p), Math.max(0,p));
		};
		this._pStart = editor.selectionStart;
	},
	input: function(e) {
		var editor = this._editor._editor;
		if (editor.readOnly) {
			return;
		}
		var pStart = editor.selectionStart, pEnd = editor.selectionEnd;
		var value = editor.value;
		if (/[ㄱ-ㅎㅏ-ㅣ가-힝]/.test(value)) { // chrome, fireFox의 경우 한글을 입력할때 selectionStart, selectionEnd가 동일하다.
			editor.value = editor.value.replace(/[ㄱ-ㅎㅏ-ㅣ가-힝]/g,"");
			this._pStart != null && editor.setSelectionRange(this._pStart, this._pStart) ;
			return;
		}		
	}
});

var TextCellEditor = defineClass("TextCellEditor", CellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._borderable = true;
		this._modified = false;
		this._inputValue = undefined;
		this._mask = undefined;
	},
	readOnly: false,
	maxLength: 0,
	mask : null,
	textAlignment: undefined,
	setMask: function(options) {
		this._mask = null;
		if (options)
			this._mask = new EditMask(this, options);
	},

	text: function () {
		return this._editor.value;
	},
	setAlignment: function (align) {
		this._container.style.textAlign = "left";
	},
	setText: function (value) {
		if (this._editor && (value != this._editor.value || value != this._controller._getData(this._editIndex))) {
			this._editor.value = value;
			this._doChanged();
		}
	},
	setTextAlignment: function (value) {
		if (value != this._textAlignment) {
			this._textAlignment = value;
			this.$_resetStyle();
		}
	},
	initOptions: function () {
		this._super();
		this._editor.readOnly = this._readOnly = false;
		this._maxLength = 0;
		this._mask && (this._mask.destroy() , this._mask = null);
		this.setTextAlignment(Alignment.NEAR);
	},
	setReadOnly: function (value) {
		this._editor.readOnly = this._readOnly = value;
	},
	_selectAll: function () {
        this._editor.select();
	},
	_doBeginEdit: function (clear, select) {
		this._modified = false;
        if (this.isVisible()) { // 당연히 visible이어야 한다.
            if (!this._editor.value) {
                this._editor.setSelectionRange(0, 0);
            }
        }
		return true;
	},
	_doEndEdit: function () {
		this._modified = false;
	},
    caretToLast: function () {
        var len = _toStr(this._editor.value).length;
        this._editor.setSelectionRange(len, len);
    },
	_doCommit: function () {
	},
	setEditIndex: function (index) {
		this._super(index);
		var grid = index && index.grid();
		if (grid) {
			/*
			 m_editor.useArrowKeys = grid.editOptions.useArrowKeys;
			 if (index.dataField >= 0 && grid.dataSource.getValueType(index.dataField) == GridValueType.Datetime) {
			 }
			 m_editor.tabConsumer = grid;
			 */
		}
		/*
		 m_editor.editable = !readOnly;
		 m_editor.maxChars = maxLength;
		 m_editor.textCase = textCase == TextInputCase.Default ? index.dataColumn.textInputCase : textCase;
		 setEditFont(grid, m_editor);
		 */
		var vcolumn = index.valueColumn();
		if (vcolumn) {
			var tcase = this._textCase == TextInputCase.DEFAULT ? vcolumn.textInputCase() : this._textCase;
			switch (tcase) {
				case TextInputCase.LOWER:
					this._editor.style.textTransform = "lowercase";
					break;
				case TextInputCase.UPPER:
					this._editor.style.textTransform = "uppercase";
					break;
				default:
					this._editor.style.textTransform = "none";
					break;
			}
			this._editor.maxLength = this._maxLength > 0 ? this._maxLength : this._defMaxLength;
		}
	},
	setEditValue: function (value) {
		this._super(value);
		this._editor.value = this.$_valToStr(value);
	},
	setCellEditValue: function(value, dropdown) {
		this._super(value, dropdown);
	},
	getEditValue: function (throwError, validateValue) {
		throwError = arguments.length > 0 ? throwError : true;
		var fld = this._editField();
		var v = this._emptyValue;
		try {
			var t = fld.dataType();
			var s = this._editor.value;
			if (t == ValueType.TEXT) {
				if (!s && this._emptyValue !== undefined) {
					s = this._emptyValue;
				}
				v = this.$_strToVal(s);
                if (v === undefined) {
                    v = "";
                }
			} else {
				if (!_isWhiteSpace(s)) {
					v = this.$_strToVal(s);
				} else if (this._emptyValue !== undefined) {
					v = this.$_strToVal(this._emptyValue);
				} else {
					switch (t) {
						case ValueType.NUMBER:
							if (isNaN(this._oldValue)) {
								v = NaN;
							}
							break;
						case ValueType.DATETIME:
							if (this._oldValue === null) {
								v = null;
							}
							break;
						case ValueType.BOOLEAN:
							break;
					}
				}
			}
			if (v === CellEditor.InvalidFormat) 
				return v;
			v = fld.readValue(v);
		} catch (e) {
			if (throwError) throw e;
			v = this._emptyValue;
		}
		return v;
	},
	getEditText: function () {
		return this._editor.value;
	},
	isEdited: function () {
		return this._modified;
	},
	setVisible: function (value, force) {
		this._super(value, force);
		if (value && this._borderable) {
			var editorBorder = this._displayOptions ? this._displayOptions._focusActivePen.css() : this._editorBorder;
			this._container.style["border"] = editorBorder;
			this._container.style["box-shadow"] = this._editorShadow;
		} else {
			this._container.style["border"] = "none";
			this._container.style["box-shadow"] = "none";
		}
		if (_isWinSafari) {
			try {
				this._editor.style["width"] = this._container.getBoundingClientRect().width+"px";
				this._container.style.cssText = this._container.style.cssText.replace(/border-width: initial; border-color: initial; /g,"");			
			} catch(err) {}
			setTimeout(function() {this._editor.style["width"] = "100%";}.bind(this), 0);
		}
	},
	_createContainer: function () {
		var elt = document.createElement("div");
		elt.spellcheck = false;
		// elt["aria-hidden"] = false;
		elt.setAttribute("aria-hidden", "true");
		elt.style["outline"] = "none";
		elt.style["aria-hidden"] = false;
		elt.style["position"] = "absolute";
		elt.style["z-index"] = 2000;
		elt.style.boxSizing = "border-box";
		elt.style["overflow"] = "hidden";
		elt.style["border"] = "none";
		elt.style["width"] = "0px";
		elt.style["height"] = "0px";
		elt.style["padding"] = "0px";
		elt.style["margin"] = "0px";
		elt.style.border = this._editorBorder;
		elt.style.boxShadow = this._editorShadow;
		elt.style.resize = "none";
		/*
		elt["spellCheck"] = false;
		elt["aria-hidden"] = false;
		elt.style["outline"] = "none";
		elt.style["aria-hidden"] = false;
		elt.style["max-width"] = "none";
		elt.style["max-height"] = "none";
		elt.style["background-color"] = "rgb(255, 255, 255)";
		elt.style["box-shadow"] = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		elt.style["color"] = "rgb(68, 84, 106)";
		elt.style["word-wrap"] = "break-word";
		*/
		return elt;
	},
	_createEditor: function (parent) {
		this._container = this._createContainer();
		parent.appendChild(this._container);
		var elt = document.createElement("input");
		elt.setAttribute("aria-hidden", "true");
		elt.autocomplete = "off";
		elt.style.position = "absolute";
		elt.style.margin = "0px";
		elt.style.padding = "0px";
		elt.style.fontFamily = $$_EDITOR_FONT_NAME;
		elt.style.fontStyle = "normal";
		elt.style.fontVariant = "normal";
		elt.style.fontWeight = "normal";
		elt.style.fontSize = $$_EDITOR_FONT_SIZE;
		elt.style.lineHeight = "normal";
		elt.style.wordWrap = "normal";
		elt.style.overflow = "hidden";
		elt.style.resize = "none";
		elt.style.border = "none";
		elt.style.outline = "none";
		elt.style.textAlign = "left";
		elt.style.color = "rgb(68, 84, 106)";
		elt.style.left = "0px";
		elt.style.top = "0px";
		elt.style.width = "100%";
		elt.style.height = "100%";
		elt.style.imeMode = "auto";
		elt.style.cursor = "text";
		elt.style["-webkit-user-modify"] = "read-write-plaintext-only";
		elt.style["white-space"] = "pre-wrap";
		elt.style["-webkit-transform"] = "translateZ(0)";
		elt.tabIndex = -1;
		elt.onkeydown = this._keyDownHandler.bind(this);
		elt.onkeyup = this._keyUpHandler.bind(this);
		elt.onkeypress = this._keyPressHandler.bind(this);
		elt.onchange = this._changeHandler.bind(this);
		elt.oninput = this._inputHandlerStock = this._inputHandler.bind(this);
		elt.onpaste = this._pasteHandler.bind(this);
		elt.oncopy = this._copyHandler.bind(this);

		elt.addEventListener("compositionstart", this._compositionstartHandler.bind(this));
		elt.addEventListener("compositionupdate", this._compositionupdateHandler.bind(this));
		elt.addEventListener("compositionend", this._compositionendHandler.bind(this));
		elt.addEventListener("text", this._textHandler.bind(this));

		this._container.appendChild(elt);
		this._defMaxLength = elt.maxLength > 0 ? elt.maxLength : 1000000; // ff에서는 기본값이 -1
		return elt;
	},
	_focusHandler: function () {
		if ($_debug) debugger;
	},
	_keyDownHandler: function (e) {
		var editor = this._editor;
        var k = e.keyCode;
        if ((_isIE || _isEdge) && !this.isVisible() && e.ctrlKey && k == Keys.Z) {
            return false;
        }
        if ((_isIE) && e.ctrlKey && e.keyCode == Keys.V && editor.readOnly) {
        	e.preventDefault();
        	this._pasteHandler(e);
        	return false;
        }
        this._inputValue = editor.value;
		switch (k) {
		case Keys.BACK:
		case Keys.DELETE:
			if (!this._sendToParent(e)) {
				if (!this.isVisible() && this._requestStart()) {
                    if (!this._editor.readOnly && this._controller._getData(this._editIndex)) {
						if (this._mask) {
			                e.preventDefault();
			                e.stopImmediatePropagation();
							this._mask.keydown(e);
							this._doChanged(); // 일반 editor에서는 _inputHandler 에서 doChanged가 발생된다.
						} else {                 	
                        	this.setText("");
                        }
                    }
				} else if (this._mask) {
	                e.preventDefault();
	                e.stopImmediatePropagation();
					this._mask.keydown(e);
					this._doChanged(); // 일반 editor에서는 _inputHandler 에서 doChanged가 발생된다.
				};
 				if ( k === Keys.BACK && this._editor.readOnly) {// readonly일때 BackSpace이면 이전페이지가 실행되는것을 막아준다.
					e.preventDefault();
					e.stopImmediatePropagation();
                }				
			}
			break;
		case Keys.TAB:
			return !this._sendToParent(e);
		case Keys.LEFT:
			if (!this.isVisible() || (editor.selectionEnd == 0 && editor.selectionEnd == editor.selectionStart)) {
				return !this._sendToParent(e);
			}
			if (this._editor.readOnly && _isChrome) {
				return !this._sendToParent(e);
			}
			break;
		case Keys.RIGHT:
			if (!this.isVisible() || (editor.selectionEnd == editor.value.length && editor.selectionEnd == editor.selectionStart)) {
				return !this._sendToParent(e);
			}
			if (this._editor.readOnly && _isChrome) {
				return !this._sendToParent(e);
			}
			if (!(e.altKey || e.ctrlKey || e.shiftKey) &&this._mask && this._mask.isRestrictNull()) {
				var start = this._editor.selectionStart;
				if (this._mask._moveCaret(start+1, start+1)) {
	                e.preventDefault();
	                e.stopImmediatePropagation();
				}
			}
			break;
		case Keys.HOME:
			if (!this.isVisible()) {
				return !this._sendToParent(e);
			}
			e.stopImmediatePropagation();
			break;
		case Keys.END:
			if (!this.isVisible()) {
				return !this._sendToParent(e);
			}
			if (this._mask && this._mask.isRestrictNull()) {
				var end = this._editor.value ? this._editor.value.length-1 : 0;
				if (this._mask._moveCaret(end, end)) {
	                e.preventDefault();
	                e.stopImmediatePropagation();
				}// null이 제한되면.
			}
			e.stopImmediatePropagation();
			break;
		case Keys.SPACE:
			if (!this.isVisible()) {
				return !this._sendToParent(e);
			}
			break;
		case Keys.UP:
		case Keys.DOWN:
		case Keys.PAGEUP:
		case Keys.PAGEDOWN:
		case Keys.ENTER:
		case Keys.ESCAPE:
		case Keys.F2:
        case Keys.INSERT:
			e.preventDefault(); // 이걸 먼저 하지 않으면 ff 등에서 input 이벤트로 발생된다.
			e.stopImmediatePropagation();
			return !this._sendToParent(e);
		case 229: // ime 변환 키 등...
			this._sendToParent(e);
			break;
		default: 
			return !this._sendToParent(e, null, true);
		}

		if (_isFirefox) {
			if (!e.ctrlKey && !e.altKey && (k == 0 || k >= 32) && (k < 0x70 || k > 0x82)) {
				this._requestStart();
			}
		}
		else if (_isIE) {
			if (k == 229) {
			}
		}
		return true; // false를 return하면 chrome에서는 key 입력이 진행되지 않는다.
	},
	_keyUpHandler: function (e) {
		var key = e.keyCode;
		if (key == Keys.BACK || key == Keys.DELETE) {
			if (_ieOld && this.isVisible() && !this._editor.readOnly && this._editor.value != this._inputValue) {
				this._doChanged();
			}
		}
		switch (e.keyCode) {
			case Keys.LEFT:
			case Keys.RIGHT:
			case Keys.HOME:
			case Keys.END:
			case Keys.SPACE:
				if (!this.isVisible()) {
					this._sendToParent(e,3);
				}
				break;
			default:
				this._sendToParent(e,3);
				break;			
		}
	},
	_keyPressHandler: function (e) {
        var k = e.which || e.keyCode;
		this._sendToParent(e,2);
        if (_isFirefox) {
            // if (!e.ctrlKey && !e.altKey && (k == 0 || k >= 32) && (k < 0x70 || k > 0x82)) {
        	if (!e.ctrlKey && !e.altKey && (k == 0 || k >= 32)) {	
            	if (!this._requestStart()) {
					e.preventDefault()
            	} else if (this._mask){
            		this._mask._pStart = e.target.selectionStart;
					this._mask.keyPress(e);
					this._doChanged();
					e.preventDefault();
            	};
            }
        } else if (k >= 32) {
        	if (!this._requestStart()) {
        		e.preventDefault();
        	} else {
        		if (this._mask) {
            		this._mask._pStart = e.target.selectionStart;
					this._mask.keyPress(e);
					this._doChanged();
					e.preventDefault();
        		}
        	}
			// !this._requestStart() ? e.preventDefault() : null; 
		}
	},
    _textHandler: function () {
        this._requestStart();
    },
    _compositionstartHandler: function (e) {
        this._composing = true;
        this._requestStart();
        if (this._started && !this._editor.readOnly) {
            this._modified = true;
            this._dispatchChange();
            this._checkHangeul = true;
        }
    },
    _compositionupdateHandler: function (e) {
        this._composing = true;
    },
    _compositionendHandler: function (e) {
        this._composing = false;
    },
	/*
	  키 입력 외에 값이 변겨됐을 때 모두 호출되므로 피해야 한다.
	_changeHandler: function (e) {
		if (this.isVisible() && !this._editor.readOnly) {
			this._doChanged();
		}
	},
     */
    _changeHandler: function (e) {
        /*
        if (this.isVisible() && !this._editor.readOnly) {
            console.log("### EDITOR.VALUE = " + this._editor.value);
        }
        */
    },
	_inputHandler: function (e) {
		/* IE 10에서는 placeholder가 있는 경우 oninput event가 focusin, focusout시점에 발생한다. 입력된 값을 확인해서 입력이 아니면 return*/
		if (_ieTen) {
			if (this._editor.value == $$_EMPTY_TEXT_VALUE) {
				return;
			}
			if (((this._inputValue == undefined || this._inputValue == null) ? "" : this._inputValue) === this._editor.value) {
				return;
			};
		}
		this._mask && this._mask.input(e);
		this._doChanged();
	},
	_pasteHandler: function (e) {
		function getClipText(e) {
			if (e instanceof KeyboardEvent) {
				return window.clipboardData.getData("text");
			} else {
				var clp = (e.originalEvent || e).clipboardData;
				if (clp) {
					return clp.getData('text/plain');
				} else {
					return window.clipboardData.getData("text");
				}
			}
		};
		var text = getClipText(e);
		var data = new ClipboardSource(text);
		var mask = this._mask;
		var grid = this._grid;
		var options = grid && grid._pasteOptions;
		if (this.isVisible()) {
			if (mask) {
				e.preventDefault();
				text = data.get(0)[0];
				var editText = this._editor.value;
				var startPos = this._editor.selectionStart;
				var endPos = this._editor.selectionEnd;
				editText = editText.substr(0, startPos) + text + editText.substr(endPos);
				this._editor.value = mask.writeBuffer(editText, true);
			}
			this._doChanged();
			return;
		}
		e.preventDefault();
		try {
			// if (mask) {
			// 	if (data.isSingle() && this._requestStart()) {
			// 		this._editor.value = mask.writeBuffer(data.get(0)[0],true);
			// 		this._doChanged();
			// 		return;
			// 	}
			// }
			if (text != null) {
				this._grid.pasteFromClipboard(text, e);
			}
		} catch (err) {
			if (err instanceof ValidationError) {
				if (!options || options.isThrowValidationError()) {
					throw err;
				}
			} else if (err instanceof AbortError) {
				alert(err.message);
			} else if (err) {
				throw err;
			}
		}
	},
	_copyHandler: function (e) {
		if (!this.isEditing()) {
			var data = this._grid.copyToClipboard(e);
			if (data != null) {
				if (_win.clipboardData) {
					_win.clipboardData.setData("Text", data);
				} else {
					e.clipboardData.setData('text/plain', data);
				}
			}
			return e.preventDefault();
		}
	},
	_doChanged: function () {
		this._requestStart();
		if (this._started && !this._editor.readOnly) {
			this._modified = true;
			this._dispatchChange();
		}
	},
	setBounds: function (x, y, w, h) {
		Dom.setBounds(this._container, x, y, w, h);
	},
	$_resetStyle: function () {
		var align = "left";
		switch (this._textAlignment) {
			case Alignment.FAR :
				align = "right";
				break;
			case Alignment.CENTER :
				align = "center";
				break;
		}
		this._editor.style["text-align"] = align;
	}
});
var LineCellEditor = defineClass("LineCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
	},
	_createEditor: function (parent) {
		var editor = this._super(parent);
		editor.tabIndex = _isMobile() ? -1 : 0;
		return editor;
	}
});
var PasswordCellEditor = defineClass("PasswordCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
	},
	_createEditor: function (parent) {
		var editor = this._super(parent);
		editor.setAttribute("type","password");
		editor.tabIndex = _isMobile() ? -1 : 0;
		return editor;
	}
});
var MultiLineCellEditor = defineClass("MultiLineCellEditor", CellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._modified = false;
	},
	readOnly: false,
	maxLength: 0,
	minHeight: 0,
	altEnterNewLine:false,
	text: function () {
		return this._editor.value;
	},
	setAlignment: function (align) {
		this._container.style.textAlign = "left";
	},
	initOptions: function () {
		this._super();
		this._editor.readOnly = this._readOnly = false;
		this._maxLength = 0;
		this._minHeight = 0;
	},
	setReadOnly: function (value) {
		this._editor.readOnly = this._readOnly = value;
	},
	_selectAll: function () {
		this._editor.select();
	},
	_doBeginEdit: function (clear, select) {
		this._modified = false;
        if (this.isVisible()) { // 당연히 visible이어야 한다.
            if (!this._editor.value) {
                this._editor.setSelectionRange(0, 0);
            }
        }
		return true;
	},
	_doEndEdit: function () {
		this._modified = false;
	},
	_doCommit: function () {
	},
	setEditIndex: function (index) {
		this._super(index);
		var grid = index && index.grid();
		if (grid) {
			/*
			 m_editor.useArrowKeys = grid.editOptions.useArrowKeys;
			 if (index.dataField >= 0 && grid.dataSource.getValueType(index.dataField) == GridValueType.Datetime) {
			 }
			 m_editor.tabConsumer = grid;
			 */
		}
		/*
		 m_editor.editable = !readOnly;
		 m_editor.maxChars = maxLength;
		 m_editor.textCase = textCase == TextInputCase.Default ? index.dataColumn.textInputCase : textCase;
		 setEditFont(grid, m_editor);
		 */
		var tcase = this._textCase == TextInputCase.DEFAULT ? index.dataColumn().textInputCase : this._textCase;
		switch (tcase) {
			case TextInputCase.LOWER:
				this._editor.style.textTransform = "lowercase";
				break;
			case TextInputCase.UPPER:
				this._editor.style.textTransform = "uppercase";
				break;
			default:
				this._editor.style.textTransform = "none";
				break;
		}
		this._editor.maxLength = this._maxLength > 0 ? this._maxLength : 2000000000;
	},
	setEditValue: function (value) {
		this._super(value);
		this._editor.value = this.$_valToStr(value);
	},
	setCellEditValue: function(value) {
		this._super(value);
	},
	getEditValue: function (throwError, validateValue) {
		throwError = arguments.length > 0 ? throwError : true;
		var fld = this._editField();
		var v = fld.nullValue;
		try {
			var t = fld.dataType();
			var s = this._editor.value;
			if (t == ValueType.TEXT) {
				if (!s && this._emptyValue !== undefined) {
					s = this._emptyValue;
				}
				v = this.$_strToVal(s);
                if (v === undefined) {
                    v = "";
                }
			} else {
				if (!_isWhiteSpace(s)) {
					v = this.$_strToVal(s);
				} else if (this._emptyValue !== undefined) {
					v = this.$_strToVal(this._emptyValue);
				} else {
					switch (t) {
						case ValueType.NUMBER:
							if (isNaN(this._oldValue)) {
								v = NaN;
							}
							break;
						case ValueType.DATETIME:
							if (this._oldValue === null) {
								v = null;
							}
							break;
						case ValueType.BOOLEAN:
							break;
					}
				}
			}
			v = fld.readValue(v);
		} catch (e) {
			if (throwError) throw e;
		}
		return v;
	},
	getEditText: function () {
		return this._editor.value;
	},
	isEdited: function () {
		return this._modified;
	},
	setVisible: function (value, force) {
		this._super(value, force);
		if (value) {
			var editorBorder = this._displayOptions ? this._displayOptions._focusActivePen.css() : this._editorBorder;
			this._container.style["border"] = editorBorder;
			this._container.style["box-shadow"] = this._editorShadow;
		} else {
			this._container.style["border"] = "none";
			this._container.style["box-shadow"] = "none";
		}
		if (_isWinSafari) {
			try {
				this._editor.style["width"] = this._container.getBoundingClientRect().width+"px";
				this._container.style.cssText = this._container.style.cssText.replace(/border-width: initial; border-color: initial; /g,"");			
			} catch(err) {}
			setTimeout(function() {this._editor.style["width"] = "100%";}.bind(this), 0);
		}
	},
	_createContainer: function () {
		var elt = document.createElement("div");
		elt.spellcheck = false;
		elt.setAttribute("aria-hidden", "true");
		elt.style["position"] = "absolute";
		elt.style["z-index"] = 2000;
		elt.style.boxSizing = "border-box";
		elt.style["overflow"] = "hidden";
		elt.style["border"] = "none";
		elt.style["width"] = "0px";
		elt.style["height"] = "0px";
		elt.style["padding"] = "0px";
		elt.style["margin"] = "0px";
		elt.style.backgroundColor = "#fff";
		elt.style.border = "none";
		elt.style.boxShadow = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		elt.style.resize = "none";
		/*
		 elt["spellCheck"] = false;
		 elt["aria-hidden"] = false;
		 elt.style["outline"] = "none";
		 elt.style["aria-hidden"] = false;
		 elt.style["max-width"] = "none";
		 elt.style["max-height"] = "none";
		 elt.style["background-color"] = "rgb(255, 255, 255)";
		 elt.style["box-shadow"] = "rgba(0, 0, 0, 0.4) 1px 2px 5px";
		 elt.style["color"] = "rgb(68, 84, 106)";
		 elt.style["word-wrap"] = "break-word";
		 */
		return elt;
	},
	_createEditor: function (parent) {
		this._container = this._createContainer();
		parent.appendChild(this._container);
		var elt = document.createElement("textarea");
		elt.autocomplete = "off";
		elt.setAttribute("aria-hidden", "true");
		// elt.style.tabIndex = -1;
		elt.style.position = "absolute";
		elt.style.margin = "0px";
		elt.style.padding = "0px";
		elt.style.fontFamily = $$_EDITOR_FONT_NAME;
		elt.style.fontStyle = "normal";
		elt.style.fontVariant = "normal";
		elt.style.fontWeight = "normal";
		elt.style.fontSize = $$_EDITOR_FONT_SIZE;
		elt.style.lineHeight = "normal";
		elt.style.wordWrap = "normal";
		elt.style.overflow = "hidden";
		elt.style.resize = "none";
		elt.style.border = "none";
		elt.style.outline = "none";
		elt.style.textAlign = "left";
		elt.style.color = "rgb(68, 84, 106)";
		elt.style.left = "0px";
		elt.style.top = "0px";
		elt.style.width = "100%";
		elt.style.height = "100%";
		elt.style.imeMode = "auto";
		elt.style.cursor = "text";
		elt.style["-webkit-user-modify"] = "read-write-plaintext-only";
		elt.style["white-space"] = "pre";
		elt.style["-webkit-transform"] = "translateZ(0)";
		elt.tabIndex = -1;
		elt.onkeydown = this._keyDownHandler.bind(this);
		elt.onkeyup = this._keyUpHandler.bind(this);
		elt.onkeypress = this._keyPressHandler.bind(this);
		elt.oninput = this._inputHandler.bind(this);
		elt.onpaste = this._pasteHandler.bind(this);
		elt.oncopy = this._copyHandler.bind(this);
		if (elt.addEventListener) {
			elt.addEventListener("compositionstart", this._compositionstartHandler.bind(this));
			elt.addEventListener("compositionupdate", this._compositionupdateHandler.bind(this));
			elt.addEventListener("compositionend", this._compositionendHandler.bind(this));

			elt.addEventListener("text", this._textHandler.bind(this));
		}
		this._container.appendChild(elt);
		return elt;
	},
	_textHandler: function () {
		this._requestStart();
	},
	_compositionstartHandler: function () {
		trace("########## COMPOSITION START: ");
        this._composing = true;
		this._requestStart();
	},
	_compositionendHandler: function () {
        this._composing = false;
	},
	_compositionupdateHandler: function() {
        this._composing = true;
	},
	_keyDownHandler: function (e) {
        trace("########## EDITOR KEYDOWN: " + e.keyCode);
		var editor = this._editor;
        var k = e.keyCode;
        if ( (_isIE || _isEdge) && !this.isVisible() && e.ctrlKey && k == Keys.Z) {
            return false;
        }
        switch (k) {
			case Keys.BACK:
			case Keys.DELETE:
				if (!this._sendToParent(e)) {
					if (!this.isVisible() && this._requestStart()) {
						e.preventDefault();
						e.stopImmediatePropagation();
                        if (!this._editor.readOnly && this._controller._getData(this._editIndex) /*this._editor.value*/) {
                            this._editor.value = ""; // null이라고 하면 "NULL"이라 쓰는 브라우저가 있더라...
                            this._modified = true;
                            this._dispatchChange();
                        }
					}
				}
				break;
			case Keys.TAB:
				return !this._sendToParent(e);
			case Keys.LEFT:
				if (!this.isVisible() || (editor.selectionEnd == 0 && editor.selectionEnd == editor.selectionStart)) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.RIGHT:
				if (!this.isVisible() || (editor.selectionEnd == editor.value.length && editor.selectionEnd == editor.selectionStart)) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.HOME:
				if (!this.isVisible()) {
					return !this._sendToParent(e);
				}
				e.stopImmediatePropagation();
				break;
			case Keys.END:
				if (!this.isVisible()) {
					return !this._sendToParent(e);
				}
				e.stopImmediatePropagation();
				break;
			case Keys.UP:
			case Keys.PAGEUP:
				if (!this.isVisible()) {
					return !this._sendToParent(e);
				}
				e.stopImmediatePropagation();
				break;
			case Keys.DOWN:
			case Keys.PAGEDOWN:
				if (!this.isVisible()) {
					return !this._sendToParent(e);
				}
				e.stopImmediatePropagation();
				break;
			case Keys.SPACE:
				if (!this.isVisible()) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.ENTER:
				if (this.isAltEnterNewLine()) {
					if ( (!e.altKey || !this.isEditing() ) && !e.shiftKey) {
						return !this._sendToParent(e);
					}
				} else {
					if ( (!e.ctrlKey || !this.isEditing() ) && !e.shiftKey) {
						return !this._sendToParent(e);
					}
				}
				if (( (this.isAltEnterNewLine() && e.altKey) || (!this.isAltEnterNewLine() && e.ctrlKey)) && !e.shiftKey) {
					e.preventDefault();
					e.stopImmediatePropagation();
					var s = editor.value === $$_EMPTY_TEXT_VALUE ? "" : editor.value;
					if (s) {
						var i = editor.selectionEnd;
						s = s.substring(0, i) + "\r\n" + s.substring(i);
						editor.value = s;
						editor.setSelectionRange(i + 1, i + 1);
						this._doChanged();
					}
				}
				break;
			case Keys.ESCAPE:
			case Keys.F2:
			case Keys.INSERT:
				e.preventDefault();
				e.stopImmediatePropagation();
				return !this._sendToParent(e);
			case 229: // ime 변환 키 등...
				break;
			default: 
				this._sendToParent(e, null, true);
				return true;
		}
		if (e.keyCode == 0) {
		}
		return true;
	},
	_keyUpHandler: function (e) {
		var key = e.keyCode;
		if (key == Keys.BACK || key == Keys.DELETE) {
			if (_ieOld && this.isVisible() && !this._editor.readOnly && this._editor.value != this._inputValue) {
				this._doChanged();
			}
		}
		switch (e.keyCode) {
			case Keys.LEFT:
			case Keys.RIGHT:
			case Keys.HOME:
			case Keys.END:
			case Keys.SPACE:
				if (!this.isVisible()) {
					this._sendToParent(e,3);
				}
				break;
			default:
				this._sendToParent(e,3);
				break;			
		}
	},
	_keyPressHandler: function (e) {
		if (e.keyCode >= 32) {
			!this._requestStart() ? e.preventDefault() : null;
		}
	},
	_inputHandler: function (e) {
		this._doChanged();
	},
	_pasteHandler: function (e) {
		if (this.isVisible()) {
			this._doChanged();
			return;
		}
		e.preventDefault();
		try {
			var text;
			var clp = (e.originalEvent || e).clipboardData;
			var options = this._grid && this._grid._pasteOptions;
			if (clp) {
				text = clp.getData('text/plain');
			} else {
				text = window.clipboardData.getData("text");
			}
			if (text != null) {
				this._grid.pasteFromClipboard(text, e);
			}
		} catch (err) {
			if (err instanceof ValidationError) {
				if (!options || options.isThrowValidationError()) {
					throw err;
				}
			} else if (err instanceof AbortError) {
				alert(err.message);
			} else if (err) {
				throw err;
			}
		}
	},
	_copyHandler: function (e) {
		if (!this.isEditing()) {
			var data = this._grid.copyToClipboard(e);
			if (data != null) {
				if (_win.clipboardData) {
					_win.clipboardData.setData ("Text", data);
				} else {
					e.clipboardData.setData('text/plain', data);
				}
			}
			return e.preventDefault();
		}
	},
	setBounds: function (x, y, w, h) {
		Dom.setBounds(this._container, x, y, w, h);
		if (x > $_INVISIBLE_EDIT_BOUNDS.x)
			this.$_resetBounds();
	},
	_doChanged: function () {
		this._requestStart();
		if (this._started && !this._editor.readOnly) {
			this._modified = true;
			this._dispatchChange();
			this.$_resetBounds();
		}
	},
	$_resetBounds: function () {
		var r = Dom.getBounds(this._container);
		var x = r.cx;
		var y = r.cy;
		var w = r.width;// Math.max(r.width, this._editor.scrollWidth + 4);
		var h = Math.round(r.height); //Math.max(r.height, this._editor.scrollHeight + 4);
		var empty = this._editor.value == $$_EMPTY_TEXT_VALUE;
		if (!empty && this._editor.scrollWidth > w) {
			w = this._editor.scrollWidth + 6;
		}
		if (!empty && this._editor.scrollHeight > h) {
			h = this._editor.scrollHeight + 6;
		}
		var minHeight = isNaN(parseInt(this._minHeight)) ? 0 : parseInt(this._minHeight);
		if ( minHeight > 0 ) {
			h = Math.max(h, minHeight);
		}
		r = Dom.getBounds(this._parentElement);
		w = Math.min(r.width, w);
		h = Math.min(r.height, h);
		if (x + w > r.width) {
			x = r.width - w;
		}
		if (y + h > r.height) {
			y = r.height - h;
		}
		Dom.setBounds(this._container, Math.max(x, 0), Math.max(y, 0), w, h);
	}
});

var DropDownPosition = _enum({
	BUTTON: "button",
	EDITOR: "editor"
});
var DropDownSortStyle = _enum({
	NONE: "none",
	ASCENDING: "ascending",
	DESCENDING: "descending"
});
var ItemSortStyle = DropDownSortStyle;
var DropDownCellEditor = defineClass("DropDownCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._list = new DropDownList(grid._container, this._options && (this._options._useCssStyle || this._options._useCssStyleDropDownList));
		this._list.addListener(this);
		this._items = null; // listing items
		this._values = [];
		this._labeling = false;
		this._lookup = false;
		this._domain = null;
		this._closing = false;
		this._value = undefined;
		this._selectedIndex = -1;
		this._borderable = false;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._list._element) {
					return;
				}
				p = p.parentNode;
			}
			this.closeUp(true);
		}.bind(this);
	},
	destroy: function() {
		this._destroying = true;
		this._list && !this._list._destroying && this._list.destroy && this._list.destroy() && (this._list = null);
		this._globalMouseHandler = null;
		this._items = null;
		this._values = null;
		this._labels = null;
		this._value = null;
		return this._super();
	},
	values: null,
	items: null, // for realgrid+
	labels: null,
	displayLabels: null, // true:label false:value -> Label, Value, LabelValue, ValueLabel로 수정.
	domainOnly: false,
	textReadOnly: false,
	dropDownWidth: -1,
	dropDownPosition: DropDownPosition.BUTTON,
	dropDownCount: 8,
	itemSortStyle: ItemSortStyle.NONE,
	caseSensitive: false,
	partialMatch: false,
	commitOnSelect: true,
	dropDownWhenClick: false,
	trimLabelText: true,
	separator: null,
	itemColumned: false,
	setMask: function(options) {
		this._mask = null;
	},
	setValues: function (value) {
		this._values = value ? value.slice() : [];
	},
	setItems: function (value) {
		this.setValues(value);
	},
	items_: function () {
		return this._value;
	},
	setLabels: function (value) {
		this._labels = value ? value.slice() : [];
	},
	isListing: function () {
		return this._list.isListing();
	},
	dropDown: function (force) {
		if (!this.isReadOnly() && !this.isListing() && !this._closing) {
            this._refreshItems();
            if (force || this._items && this._items.length > 0) {
				this._list.setViewGridInside(this._options && this._options._viewGridInside);
				this._list.setDisplayLabels(this.displayLabels());
				this._list.setSeparator(this.separator());
				this._list.setItemColumned(this.isItemColumned());
                this._list.setItems(this._items);
                var r = Dom.getBounds(this._container);
				this._saveIndex = this._selectedIndex;
				this._saveText = this._editor.value;
                this._list.setCaseSensitive(this._caseSensitive);
                this._list.setPartialMatch(this._partialMatch);
                this._list.setDropDownCount(this._dropDownCount);
				this._list.setDropDownWidth(this._dropDownWidth);
				this._list.setDropDownPosition(this._dropDownPosition);
				this._list.setSortStyle(this._itemSortStyle);
                this._list.setValueIndex(this._selectedIndex);
                this._list.setTrimLabelText(this._trimLabelText);
                this._list.setListZIndex(this.getListZIndex());
                this._list.show(_doc.documentElement, r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
                this._list.$_search(this._editor.value, true);
                $_evl ? _win.addEventListener("mousedown", this._globalMouseHandler) : _win.attachEvent("onmousedown", this._globalMouseHandler);
                return true;
            }
		}
		return false;
	},
	closeUp: function (accept) {
		if (this.isListing()) {
			this._closing = true;
			try {
				var idx;
				$_evl ? _win.removeEventListener("mousedown", this._globalMouseHandler) : _win.detachEvent("onmousedown", this._globalMouseHandler);
				this._list.hide();
				if (accept && this._list.isSelected() && (idx = this._list.itemIndex()) >= 0 && this._items && this._items.length > idx) {
					this._selectedIndex = this._list.valueIndex();
					this._editor.value = this._labeling ? this._items[idx].label : this._items[idx].value;
					if (this._selectedIndex != this._saveIndex || this._editor.value != this._saveText) {
						this._dispatchChange();
					}
                    if (this._commitOnSelect) {
                        this._dispatchCommit();
                    }
				} else {
					this._selectedIndex = -1;
				}
			} finally {
				this._closing = false;
			}
			return true;
		}
		return false;
	},
	hasButton: function () {
		return true;
	},
	initOptions: function () {
		this._super();
		this._values = [];
		this._labels = [];
		this._displayLabels = DropDownValueLabel.LABEL;
		this._separator = " - ";
		this._itemColumned = false;
		this._domainOnly = false;
		this._textReadOnly = false;
		this._dropDownWidth = -1;
		this._dropDownPosition = DropDownPosition.BUTTON;
		this._dropDownCount = 8;
		this._itemSortStyle = ItemSortStyle.NONE;
		this._caseSensitive = false;
		this._partialMatch = false;
		this._commitOnSelect = true;
		this._dropDownWhenClick = false;
		this._viewGridInside = false;
		this._initCount = 0;
		this._moreItemCount = 25;
		this._moreText = window.RG_CONST && window.RG_CONST.MORETEXT || "더보기";
	},
	setEditIndex: function (index) {
		this._super(index);
		this._lookup = false;
		this._labeling = false;
		this._domain = null;
		this._items = null;
		/*
		m_editor.editable = !readOnly && !textReadOnly;
		m_editor.listable = !readOnly;
		m_editor.dropDownCount = dropDownCount;
		m_editor.sortStyle = itemSortStyle;
		m_editor.caseSensitive = caseSensitive;
		*/

		// if (this._textReadOnly) {
		// 	this._editor.readOnly = true;
		// }

		this._refreshItems();
		/*
		var col = index.dataColumn();
		if (col) {
			this.setItems(col.lookupValues());
		}
		*/
	},
	setEditValue_2: function (value) {
		this._super(value);
		this._value = value;
		this._editor.value = this.$_valToStr(value);
	},
	setEditValue: function (value) {
		var i, cnt, v;
		var index = -1;
		this._value = value;
		if (this._lookup) {
			var domain = this._domain;
			if (domain) {
				i = index = domain.keys ? domain.keys.indexOf(value) : -1;
				v = (i >= 0 && domain.values && domain.values.length > i) ? domain.values[i] : value;
			} else {
				index = this._editIndex.dataColumn().getLookupIndex(value);
			}
			if (this._labeling) {
				if (domain) {
					v = (index >= 0 && domain.values && domain.values.length > index) ? domain.values[index] : value;
				} else {
					v = index >= 0 ? this._editIndex.dataColumn().getLookupLabel(value) : value;
				}
				this._super(v);
			} else {
				this._super(value);
			}
		} else if (this._values) {
			for (i = 0, cnt = this._values.length; i < cnt; i++) {
				if (value == this._values[i]) {
					index = i;
					break;
				}
			}
			if (this._labeling && this._labels && (index < 0 || this._labels.length > index)) {
				v = index >= 0 ? this._labels[i] : value;
				this._super(v);
			} else {
				this._super(value);
			}
		} else {
			this._super(value);
		}
		this._selectedIndex = index;
	},
	isEdited: function () {
		var modified = this._super();
		if (modified && this.isDomainOnly()) {
			modified = this.$_getEditValue(false) !== undefined;
		}
		return modified;
	},
	setCellEditValue: function(value, dropdown) {
		this._super(value, dropdown);
	},
	getEditValue: function (throwError, validateValue) {
		if (!this.isEdited() && this._selectedIndex < 0) {
			return this._value;
		} else {
			return this.$_getEditValue(throwError, validateValue);
		}
	},
	_createContainer: function () {
		var elt = this._super();
		elt.style.border = "none";
		elt.style.boxShadow = "none";
		return elt;
	},
	setBounds: function (x, y, w, h) {
		x += 2;
		y += 2;
		w -= 4;
		h -= 4;
		this._super(x, y, w, h);
	},
	_createEditor: function (parent) {
		var editor = this._super(parent);
		return editor;
	},
	_textHandler: function () {
		this._requestStart();
	},
	_compositionstartHandler: function (e) {
		this._super(e);
	},
	_keyDownHandler: function (e) {
		var list = this._list;
		switch (e.keyCode) {
			case Keys.BACK:
			case Keys.DELETE:
				if (!e.ctrlKey && this.isTextReadOnly()) {
					this._requestStart();
					e.preventDefault();
					return true;
				}
				break;
			case Keys.SPACE:
				if (this.isListing() && list.currentIsMore()) {
					list.addMoreItems();
					e.preventDefault();
					return true;
				}
				break;
			case Keys.ENTER:
				if (this.isListing() && list.currentIsMore()) {
					list.addMoreItems();
					e.preventDefault();
					return true;
				};
				if (this.closeUp(true)) {
					return !this._sendToParent(e);
				}
				break;
			case Keys.ESCAPE:
				if (this.closeUp(false)) {
					e.preventDefault();
					return true;
				}
				break;
			case Keys.DOWN:
				if (e.altKey && !this.isListing()) {
					this._requestStart();
					e.preventDefault();
					return true;
				} else if (this.isListing()) {
					this._list.setItemIndex(Math.min(list.itemCount() - 1, list.itemIndex() + 1));
					e.preventDefault();
					return true;
				}
				break;
			case Keys.PAGEDOWN:
				if (this.isListing()) {
					this._list.setItemIndex(Math.min(list.itemCount() - 1, list.itemIndex() + list.dropDownCount()));
					e.preventDefault();
					return true;
				}
				break;
			case Keys.UP:
				if (e.altKey && this.isListing()) {
					this.closeUp(false);
					e.preventDefault();
					return true;
				} else if (this.isListing()) {
					this._list.setItemIndex(Math.max(0, list.itemIndex() - 1));
					e.preventDefault();
					return true;
				}
				break;
			case Keys.PAGEUP:
				if (this.isListing()) {
					this._list.setItemIndex(Math.max(0, list.itemIndex() - list.dropDownCount()));
					e.preventDefault();
					return true;
				}
				break;
		}
		return this._super(e);
	},
	_keyPressHandler: function (e) {
		this._super(e);
		e.keyCode && /* e.keyCode === Keys.SPACE &&*/ this.isTextReadOnly && this.isTextReadOnly() && e.preventDefault();
	},
	_inputHandler: function (e) {
		if (this.isTextReadOnly && this.isTextReadOnly()) {
			e.target.value = this._oldValue || "";
		}
		return this._super(e);
	},
	_pasteHandler: function (e) {
		return this._super(e);
	},
	_copyHandler: function (e) {
		return this._super(e);
	},
	_requestStart: function (dropdown) {
		if (this._super()) {
			dropdown !== false && this.dropDown();
			return true;
		}
		return false;
	},
	_doChanged: function () {
		this._super();
		if (this.isListing()) {
			this._list.$_search(this._editor.value);
			this._selectedIndex = -1;
		}
	},
	dropDownList: function(force) {
		this.dropDown(force)
	},
	closeList: function (accept) {
		this.closeUp(accept);
	},
	buttonClicked: function (index) {
		this.isListing() ? this.closeUp(false) : this.dropDown();
	},
	$_setItems: function(values, labels) {
		this._items = [];
		for (var i = 0, cnt = values.length; i < cnt ; i++) {
			this._items.push({
				value: values[i],
				label: labels && labels.length > i ? labels[i] : values[i]
			})
		}
	},
	_refreshItems: function (updateList, force) {
		var index = this.editIndex();
		var item = index.item();
		if (this._values && (this._values.length > 0 || force)) {
			this.$_setItems(this._values, this._labels);
			this._labeling = this.displayLabels() !== false && this.displayLabels() !== DropDownValueLabel.VALUE && this._labels && this._labels.length >= this._values.length;
		} else if (index.dataColumn() && index.item() && (index.dataRow() >= 0 || ItemState.isEditing(item.itemState()))) {
			var column = index.dataColumn();
			if (column.lookupSource()) {
				var flds = column.lookupKeyFieldIds();
				var keys = [];
				for (var i = 0; i < flds.length - 1; i++) {
					keys.push(item.getData(flds[i]));
				}
				var domain = column.lookupSource().getTextDomain(keys);
				if (domain && domain.values && domain.values.length > 0) {
					this.$_setItems(domain.keys, domain.values);
					this._labeling = true;
					this._lookup = true;
					this._domain = domain;
				}
			} else if (column.lookupValues() && column.lookupValues().length > 0) {
				this.$_setItems(column.lookupValues(), column.lookupLabels());
				this._labeling = this.displayLabels() !== false && this.displayLabels() !== DropDownValueLabel.VALUE && column.lookupLabels() && column.lookupLabels().length >= column.lookupValues().length;
				this._lookup = true;
			}
		}
		if (updateList && this.isListing()) {
			this._list.setItems(this._items);
			var r = Dom.getBounds(this._container);
			this._list.$_resetItems(r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
		}
	},
	$_getEditValue: function (throwError, validateValue) {
		var i;
		var t = this.text();
		var org = TextCellEditor.prototype.getEditValue.call(this, throwError, validateValue);
		var v = org;
		var col = this._editIndex.dataColumn();
		var index = this._selectedIndex;
		var selected = index >= 0;
		if (this._lookup) {
			if (this._domain) {
				if (this._labeling) {
					i = selected ? index : this._domain.values ? this._domain.values.indexOf(t) : -1;
					v = (i >= 0 && this._domain.keys && this._domain.keys.length > i) ? this._domain.keys[i] : v;
				}
				if (this.isDomainOnly()) {
					if (!this._domain.keys || this._domain.keys.indexOf(v) < 0) {
						return CellEditor.Unselected;
					}
				}
			} else {
				if (this._labeling) {
					if (selected) {
						v = col.getLookupValue(index);
					} else {
						v = col.getSourceValue(t);
					}
					if (v === undefined) {
						v = org;
					}
				}
				if (this.isDomainOnly()) {
					if (!col.lookupValues() || col.lookupValues().indexOf(v) < 0) {
						return CellEditor.Unselected;
					}
				}
			}
		} else {
			if (this._labeling) {
				i = selected ? index : this._labels ? this._labels.indexOf(t) : -1;
				if (i >= 0 && i < this._values.length) {
					v = this._values[i];
				}
			}
			if (this.isDomainOnly()) {
				if (!this._values || this._values.indexOf(v) < 0) {
					return CellEditor.Unselected;
				}
			}
		}
		return v;
	},
	onDropDownListCloseUp: function (list, accept) {
		this.closeUp(accept);
		!_isMobile() && this.setFocus();
	},
	onDropDownListEditorFocus: function() {
		this.setFocus();
	},
});
var /* internal */ DropDownList = defineClass("DropDownList", EventAware, {
	init: function (container, useCssStyle) {
		this._super();
		this._useCssStyle = useCssStyle;
		this._container = container; // grid container
		this._containerElement = null; // list parent element
		this._dom = new Dom(this._element = this.$_createList());
		this._firstChild = null;
		this._selected = false;
		this._initCount = 0;
		this._mouseoverHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
			if (Dom.getChildIndex(div) != this._itemIndex) {
				div.style.background = "rgba(0, 255, 0, 0.2)";
			}
		}.bind(this);
		this._mouseoutHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
			if (Dom.getChildIndex(div) != this._itemIndex) {
				div.style.background = "";
			}
		}.bind(this);
		this._clickHandler = function (e) {
			var div = e.currentTarget;
			var idx = Dom.getChildIndex(div);
			if (idx >= 0) {
				this._itemIndex = idx;
				this._selected = true;
				this.fireEvent(DropDownList.CLOSE_UP, true);
			}
		}.bind(this);
		this._nextClickHandler = function(e) {
			var div = e.currentTarget;
			this.$_addMoreItems(div);
		}.bind(this);
	},
	destroy: function() {
		this._destroying = true;
		this._container = null;
		this._containerElement = null;
		this._items = null;
		this._dom = null;

		Dom.clearElements(this._element);
		if (this._element.parentNode) {
			this._element.parentNode.removeChild(this._element);
		};
		this._element = null;

		return this._super();
	},
	minWidth: 0,
	maxWidth: 0,
	dropDownCount: 8,
	caseSensitive: false,
	partialMatch : false,
	sortStyle: ItemSortStyle.NONE,
	items: null,
	itemIndex: -1,
	dropDownPosition: DropDownPosition.BUTTON,
	dropDownWidth: -1, // -1: column width, 0: measured width, 0 < explicit width
	displayLabels: null,
	separator: null,
	itemColumned: false,
	viewGridInside: false,
	trimLabelText: true,
	initCount: 0,
	moreItemCount: 25,
	moreText: null,
	listZIndex: 3000,
    isListing: function () {
        return this._containerElement && this._containerElement.contains(this._element);
    },
	setItems: function (items) {
		this._items = [];
		if (items) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				this._items.push({ label: items[i].label, value:items[i].value, index: i });
			}
		}
	},
	setItemIndex: function (value, forceRefresh, isSearch) {
		value = Math.max(-1, value);
		var child = this._element.childNodes;
		if (value < this._items.length && (forceRefresh || value != this._itemIndex || value >= child.length -1)) {
			if (isSearch && value >= child.length-1) {
				var div = child[child.length-1];
				if (div.isMoreButton) {
					var addCount = value - (child.length-1);
					addCount = (Math.floor(addCount/this.moreItemCount())+1)*this.moreItemCount()
					this.$_addMoreItems(div, addCount);
				}
			}
			this._itemIndex = value;
			this.isListing() && this.$_refreshItems();
			this._selected = value >= 0;
		};
	},
	itemCount: function () {
		return this.initCount() == 0 ? (this._items && this._items.length) : this._element.children.length;
	},
	valueIndex: function () {
        var items = this._items;
        var i = this._itemIndex;
		return (items && i >= 0 && i < items.length) ? items[i].index : -1;
	},
	setValueIndex: function (value) {
		value = Math.max(-1, value);
		this._itemIndex = -1;
		if (value >= 0) {
			for (var i = 0, cnt = this._items.length; i < cnt; i++) {
				if (this._items[i].index == value) {
					this._itemIndex = value;
					break;
				}
			}
		}
		this.isListing() && this.$_refreshItems();
		this._selected = true;
	},
	isSelected: function () {
		return this._selected;
	},
	show: function (containerElement, x, y, cellWidth, editBounds) {
		this._containerElement = this._viewGridInside ? this._container._container : containerElement;
        (this._sortStyle != ItemSortStyle.NONE) && this.$_sortItems();
		this.$_show(x, y, cellWidth, editBounds);
	},
	hide: function () {
		this._dom.detach();
		this._containerElement = null;
	},
	$_createList: function () {
		var element = document.createElement("div");
		if (this._useCssStyle) {
			element.className = "rg-dropdownlist";	
		}
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.fireEvent(DropDownList.CLOSE_UP, false);
			}
		}.bind(this);
		return element;
	},
	$_sortItems: function () {
		if (this._sortStyle == ItemSortStyle.ASCENDING) {
			this._items.sort(function (i1, i2) {
				return i1.label < i2.label ? -1 : i1.label > i2.label ? 1 : 0;
			});
		} else {
			this._items.sort(function (i1, i2) {
				return i1.label > i2.label ? -1 : i1.label < i2.label ? 1 : 0;
			});
		}
	},
	$_show: function (x, y, cellWidth, editBounds) {
		var elt = this._element;
		if (!elt) {
			return;
		}
		var elt = this._dom.element();
		this._dom.setStyles({
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			minWidth: "20px",
			minHeight: "10px",
			overflow: "auto",
			zIndex: this._listZIndex
		});
		!this._useCssStyle && this._dom.setStyles({
			background: "#fff",// "rgb(233, 233, 233)",
			border: "1px solid rgb(50, 50, 50)", //"1px solid rgb(200, 200, 200)",
			boxShadow: "rgba(0, 0, 0, 0.8) 1px 2px 5px",
			fontFamily: "Tahoma",
			fontStyle: "normal",
			fontVariant: "normal",
			fontWeight: "normal",
			fontSize: "10pt",
			padding: "0px",
			margin: "0px"
		});
        this._firstChild = null;
		this._dom.clearChildren();
		this._dom.disableSelection();
		this._containerElement.appendChild(elt);
		this._cellWidth = cellWidth;
		this._editBounds = editBounds;
		elt.style.width = "10px";
        this.$_buildItems();
		this.$_resetHeight();
        this.$_resetWidth(cellWidth);
		this.$_resetPosition(x, y, cellWidth, editBounds);
		this._selected = false;
	},
	$_resetHeight: function () {
		var elt = this._dom.element();
		if (this._firstChild) {
			var cr = Dom.getBounds(this._firstChild);
			var style = this._firstChild.currentStyle || window.getComputedStyle(this._firstChild);
			var marginTop = parseInt(style.marginTop.replace("px",""));
			marginTop = isNaN(marginTop) ? 0 : marginTop;
			var marginBottom = parseInt(style.marginBottom.replace("px",""));
			marginBottom = isNaN(marginBottom) ? 0 : marginBottom;
            var h = (this._dropDownCount > 0) ? Math.min(this._dropDownCount, this._items.length) : this._items.length;
			elt.style.height = ((cr.height + marginTop) * h + 4 + marginBottom) + "px";
		} else {
			elt.style.height = "10px";			
		}
	},
    $_resetWidth: function (cellWidth) {
        var elt = this._dom.element();
		var r = Dom.getBounds(elt);
        var dw = this._dropDownWidth, w = this._dropDownWidth;
        var ew = elt.offsetWidth ? elt.offsetWidth + (_ieOld && elt.style.boxSizing === "border-box" ? 17 : 0) : 0;
		if (w < 0) {
			w = cellWidth;
		} else if (w == 0) {
			w = 10; // Dom Size가 큰 상태에서는 줄어들지 않으므로 최소 크기(10)으로 설정 후 계산
		}
		elt.style.width = w + "px";
		var cw = 0;
		if (this._firstChild) {
			var style = this._firstChild.currentStyle || window.getComputedStyle(this._firstChild);
			var marginLeft = parseInt(style.marginLeft.replace("px",""));
			marginLeft = isNaN(marginLeft) ? 0 : marginLeft;
			var marginRight = parseInt(style.marginRight.replace("px",""));
			marginRight = isNaN(marginRight) ? 0 : marginRight;

			var childs = elt.childNodes;
			for (var i = 0; i < childs.length; i++) {
				cw = Math.max(cw, childs[i].scrollWidth);
			}
			cw += elt.offsetWidth - elt.clientWidth + marginLeft + marginRight + 2;
		}
		//r = Dom.getBounds(elt);
		//cw = Math.max(cw, r.width);
		if (dw < 0)
			cw = Math.max(cw,w);
		r = _getBrowserSize();// Dom.getBounds(this._containerElement);
		cw = Math.min(cw, r.width);
		w = cw;
		if (_ieOld && (dw >= 0 || cw > w)) // boxSizing: "border-box"일 때 IE 9에서 width가 text보다 작아지는 현상
			w += 20;
		if (w < r.width)
			elt.style.overflowX = "hidden";
		else 
			elt.style.overflowX = "auto";
		elt.style.width = Math.max(w, ew) + "px";
    },
	$_resetPosition: function (x, y, cellWidth, editBounds) {
        var br = _getBrowserSize();
        var pr = Dom.getBounds(this._containerElement);
		var cr = Dom.getBounds(this._container._container);
		var w = br.width; // this._container.width(); // _container: grid container
		var h = br.height; //this._container.height();
		var r = this._dom.getBounds();
        var sx = window.pageXOffset || document.documentElement.scrollLeft;
        var sy = window.pageYOffset || document.documentElement.scrollTop;
        if (document.documentElement.scrollWidth > document.documentElement.clientWidth) {
            h -= 18;
        }
        if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
            w -= 18;
        }
        x += cr.left - pr.left;
        y += cr.top - pr.top;
		if (_ieTen || _ieOld || _ieLeg) {
			x += document.documentElement.scrollLeft;
			y += document.documentElement.scrollTop;
		}
		if (y + r.height > h + sy) {
			y = y - editBounds.height - r.height;
			if (y < 0) {
				y = h - r.height - 2;
			}
		}
		if (this._dropDownPosition != DropDownPosition.EDITOR) { // BUTTON 이거나 잘못된 값.
			x = Math.max(0, x + cellWidth - r.width);
		} else {
			if (x + r.width > w + sx) {
				x = w - r.width;
			}
		}
		if (this._viewGridInside) {
			y = editBounds.bottom - pr.top + 2;
			if ( (pr.bottom < editBounds.bottom+r.height) || (h+sy < editBounds.bottom+r.height)) {
				y = editBounds.top - r.height - pr.top - 2;
			}
		}
		this._dom.move(Math.max(0, x), Math.max(0, y));
	},
	$_resetItems: function (x, y, cellWidth, editBounds) {
		this._dom.clearChildren();
		this._firstChild = null;
		this.$_buildItems();
		this.$_resetHeight();
        this.$_resetWidth(cellWidth);
		this.$_resetPosition(x, y, cellWidth, editBounds);
	},
	$_buildItems: function (startIndex, addCount) {
		startIndex = arguments.length > 0 ? startIndex : 0;
		addCount = arguments.length > 1 ? addCount : 0;
		var itemWidth = 0;
		var g = this._container._defContext._graphics;
		var font;
		var span;
		addValue = function (div, item) {
			var s = (item && item.value ? item.value.toString() : "");
			var span = Dom.createElement("span");
			span.style.whiteSpace = "pre";
			span.innerHTML = s ? Dom.htmlEncode(s) : "&nbsp;";
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
			return span;
		}.bind(this);
		addLabel = function (div, item, calcWidth) {
			var s = (item && item.label ? item.label.toString() : "");
			s = this._trimLabelText ? s.trim() : s;
			var span = Dom.createElement("span");
			!this._trimLabelText && (span.style.whiteSpace = "pre");
			span.innerHTML = s ? Dom.htmlEncode(s) : "&nbsp;";
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
			return span;
		}.bind(this);
		addSeparator = function (div, separator) {
			var span = Dom.createElement("span");
			span.style.whiteSpace = "pre";
			span.innerHTML = separator ? Dom.htmlEncode(separator) : "&nbsp;";
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
		}.bind(this);
		calcWidth = function(span) {
			if (!font) {
				var style = window.getComputedStyle(span);
				font = {
					font: style.fontSize+" "+style.fontFamily,
					size: parseInt(style.fontSize)
				}
			};
			return Math.max(itemWidth, g.getTextWidth(font, span.innerText));
		}.bind(this);
		var items = this._items;
		var moreCount = addCount || (this._element.children.length > 0 ? this.moreItemCount() : this.initCount());
		if (!items || items.length < 1) {
			return;
		}
		for (var i = startIndex, cnt = items.length; i < cnt; i++) {
			if (this._initCount && i - startIndex >= moreCount && i < cnt) {
				var div = Dom.createElement("div", {
					position: "relative",
					float: "none",
					paddingTop: "1px",
					paddingBottom: "1px",
					paddingLeft: "2px",
					paddingRight: "2px",
					whiteSpace: "nowrap",
					cursor: "pointer",
					textAlign: "center"
				});
				Dom.disableSelection(div);
				div.nextIndex = i;
				div.onmouseover = !this._useCssStyle ? this._mouseoverHandler : null;
				div.onmouseout = !this._useCssStyle ? this._mouseoutHandler : null;
				div.onclick = this._nextClickHandler;
				div.isMoreButton = true;
				div.className = "rg-dropdown-more";
				addLabel(div,{label:this.moreText()});
				this._element.appendChild(div);
				break;
			}
			var item = items[i];
			var div = Dom.createElement("div", {
				position: "relative",
				float: "none",
				paddingTop: "1px",
				paddingBottom: "1px",
				paddingLeft: "2px",
				paddingRight: "2px",
				whiteSpace: "nowrap",
				cursor: "default",
			});
			!this._useCssStyle && (div.style.background = i == this._itemIndex ? "#333" : "");
			!this._useCssStyle && (div.style.color = i == this._itemIndex ? "#fff" : "");
			this._useCssStyle && (div.className = i == this._itemIndex ? "rg-dropdown-select" : "rg-dropdown-item");
			Dom.disableSelection(div);
			this._element.appendChild(div);
			if (i == 0) this._firstChild = div;
			div.onmouseover = !this._useCssStyle ? this._mouseoverHandler : null;
			div.onmouseout = !this._useCssStyle ? this._mouseoutHandler : null;
			div.onclick = this._clickHandler;
			span = null;
			switch(this.displayLabels()) {
				case true:
				case DropDownValueLabel.LABEL:
					addLabel(div, item);
					break;
				case false:
				case DropDownValueLabel.VALUE:
					addValue(div, item);
					break;
				case DropDownValueLabel.LABEL_VALUE:
					span = addLabel(div, item, true);
					addSeparator(div, this._separator);
					addValue(div, item);
					break;
				case DropDownValueLabel.VALUE_LABEL:
					span = addValue(div, item, true);
					addSeparator(div, this._separator);
					addLabel(div, item);
					break;
			};
			if (span && this._itemColumned) {
				itemWidth = Math.max(itemWidth, calcWidth(span))
			}
		};
		if (this._itemColumned && itemWidth) {
			for (var i = 0, cnt = this._element.childNodes.length; i < cnt ; i++) {
				span = this._element.childNodes[i].firstChild;
				span.style.display = "inline-block";
				span.style.width = itemWidth+"px";
			}
		}
	},
	currentIsMore: function (itemIndex) {
		var item = this._element.childNodes[itemIndex != null ? itemIndex : this._itemIndex];
		return item && item.isMoreButton;
	},
	$_addMoreItems: function (div, addCount) {
		var idx = div.nextIndex;
		div.parentNode && div.parentNode.removeChild(div);
		this.$_buildItems(idx, addCount);
		this.$_resetWidth(this._cellWidth);
		this.fireEvent(DropDownList.EDITOR_FOCUS);
	},
	addMoreItems: function() {
		if (this.currentIsMore()) {
			var item = this._element.childNodes[this._itemIndex];
			this.$_addMoreItems(item);
		}
	},
	$_refreshItems: function () {
		var item;
		var items = this._element.childNodes;
		for (var i = 0; i < items.length; i++) {
			item = items[i];
			if (this._useCssStyle) {
				item.className = i == this._itemIndex ? "rg-dropdown-select" : "rg-dropdown-item";
			} else {
				item.style.background = i == this._itemIndex ? "#333" : "";
				item.style.color = i == this._itemIndex ? "#fff" : "";
			}
		}
		var idx = this._itemIndex;
		if (idx >= 0 && idx < items.length) {
			item = items[idx];
			if (item.offsetTop < this._element.scrollTop) {
				this._element.scrollTop = item.offsetTop;
			} else {
				var y = item.offsetTop + Dom.getSize(item).height;
				if (y >= this._element.scrollTop + this._element.clientHeight) {
					this._element.scrollTop = y - this._element.clientHeight;
				}
			}
		}
	},
	hangulToChosungAll: function (str){
		var cho = ["ㄱ","ㄲ","ㄴ","ㄷ","ㄸ","ㄹ","ㅁ","ㅂ","ㅃ","ㅅ","ㅆ","ㅇ","ㅈ","ㅉ","ㅊ","ㅋ","ㅌ","ㅍ","ㅎ"];
		var result = "";
		for(i=0;i<str.length;i++) {
			var code = str.charCodeAt(i)-44032;
			if(code>-1 && code<11172) result += cho[Math.floor(code/588)];
			else result += str[i];
		}
		return result;
	},
	hangulToChosung: function (str){
		var result = {};
		if(/[ㄱ-힝]/.test(str)){
			var rCho = ["ㄱ", "ㄲ", "ㄴ", "ㄷ", "ㄸ", "ㄹ", "ㅁ", "ㅂ", "ㅃ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅉ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"];
			var rJung = ["ㅏ", "ㅐ", "ㅑ", "ㅒ", "ㅓ", "ㅔ", "ㅕ", "ㅖ", "ㅗ", "ㅘ", "ㅙ", "ㅚ", "ㅛ", "ㅜ", "ㅝ", "ㅞ", "ㅟ", "ㅠ", "ㅡ", "ㅢ", "ㅣ"];
			var rJong = ["", "ㄱ", "ㄲ", "ㄳ", "ㄴ", "ㄵ", "ㄶ", "ㄷ", "ㄹ", "ㄺ", "ㄻ", "ㄼ", "ㄽ", "ㄾ", "ㄿ", "ㅀ", "ㅁ", "ㅂ", "ㅄ", "ㅅ", "ㅆ", "ㅇ", "ㅈ", "ㅊ", "ㅋ", "ㅌ", "ㅍ", "ㅎ"];
			var cho, jung, jong;
			var nTmp = str.charCodeAt(0) - 0xAC00;
			jong = nTmp % 28;
			jung = ( (nTmp-jong)/28 ) % 21;
			cho = ( ( (nTmp-jong)/28 ) - jung ) / 21;
			result.cho = rCho[cho] ? rCho[cho] : str;
			if(rJung[jung])
				result.org = str;
		}else {
			result.cho = str;
			result.org = str;
		}
		return result;
	},
	$_search: function (text, ignoreSelected) {
		try {
			if (this._items && this._items.length > 0 && text) {
                var items = this._items;
                var cnt = items.length;
				var t = this._caseSensitive ? text : text.toLowerCase();
                var list = [];
                var i, s, c, sc;
				for (i = 0; i < cnt; i++) {
					s = items[i].label.toString();
					if (s) {
						s = this._caseSensitive ? s : s.toLowerCase();
						if(this._partialMatch){
							sc = "";
							var htcS, htcT;
							for(var y = 0; y < s.length; y++){
								htcS = this.hangulToChosung(s[y]);
								htcT = this.hangulToChosung(t[y]);
								sc += htcT.org ? htcS.org : htcS.cho;
							}
							if(sc == t) {
								this.setItemIndex(i, ignoreSelected, true);
								return;
							}
						} else {
							if (s == t) {
								this.setItemIndex(i, ignoreSelected, true);
								return;
							}
						}
					}
					list.push(s);
				}
                for (i = 0; i < cnt; i++) {
                    s = list[i];
                    if(this._partialMatch){
						var match = false;
						for(var y = 0; y < t.length; y++){
							c = this.hangulToChosung(s[y]);
							if((c.org && c.org == t[y]) || (c.cho && c.cho == t[y])) 
								match = true;
							else {
								match = false;
								break;
							}
						}
						if(match) {
							this.setItemIndex(i, ignoreSelected, true);
							return;
						}
                    } else {
                    	if (s && s.indexOf(t) == 0) {
                    		this.setItemIndex(i, ignoreSelected, true);
                    		return;
                    	}
                    }
                }
                for (i = 0; i < cnt; i++) {
                    s = list[i];
                    if(this._partialMatch){
						var htcS, htcT, htcSA, htcTA;
						htcSA = this.hangulToChosungAll(s);
						htcTA = this.hangulToChosungAll(t);
						var idx = htcSA.indexOf(htcTA);
						sc = s.substr(0,idx);
						if(~idx){
							for(var y = 0, z = idx, len = t.length; y < len; y++, z++){
								htcS = this.hangulToChosung(s[z]);
								htcT = this.hangulToChosung(t[y]);
								sc += htcT.org ? htcS.org : htcS.cho;
							}
						}
						if(sc && sc.indexOf(t) > 0) {
							this.setItemIndex(i, ignoreSelected, true);
							return;
						}
					}else {
						if (s && s.indexOf(t) > 0) {
							this.setItemIndex(i, ignoreSelected, true);
							return;
						}
					}
                }
			}
			this.setItemIndex(-1);
		} finally {
			if (ignoreSelected) {
				this._selected = true;
			}
		}
	}
});
DropDownList.CLOSE_UP = "onDropDownListCloseUp";
DropDownList.EDITOR_FOCUS = "onDropDownListEditorFocus";
var MultiCheckCellEditor = defineClass("MultiCheckCellEditor", DropDownCellEditor, {
	init: function (grid, parentElement) {
		TextCellEditor.prototype.init.apply(this, [grid, parentElement]);
		this._list = new MultiCheckList(grid._container, this._options && (this._options._useCssStyle || this._options._useCssStyleMultiCheck));
		this._list.addListener(this);
		this._items = null; // listing items
		this._values = [];
		this._labeling = false;
		this._lookup = false;
		this._domain = null;
		this._closing = false;
		this._value = undefined;
		this._selectedIndices = [];
		this._saveIndices = [];
		this._borderable = false;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._list._element) {
					return;
				}
				p = p.parentNode;
			}
			this.closeUp(true);
		}.bind(this);
	},
	destroy: function() {
		this._destroying = true;
		this._globalMouseHandler = null;
		this._saveText = null;
		return this._super();
	},
	showButtons: true,
	acceptText: window.RG_CONST && window.RG_CONST.MULTICHECKACCEPT ? window.RG_CONST.MULTICHECKACCEPT : "accept",
	cancelText: window.RG_CONST && window.RG_CONST.MULTICHECKCANCEL ? window.RG_CONST.MULTICHECKCANCEL : "cancel",
	allCheckText: window.RG_CONST && window.RG_CONST.MULTICHECKALLCHECK ? window.RG_CONST.MULTICHECKALLCHECK : "all",
	showAllCheck: false,
	setMask: function(options) {
		this._mask = null;
	},
	dropDown: function (force) {
		if (!this.isReadOnly() && !this.isListing() && !this._closing) {
            this._refreshItems();
            if (force || this._items && this._items.length > 0) {
				this._list.setViewGridInside(this._options && this._options._viewGridInside);
				this._list.setDisplayLabels(this.displayLabels());
				this._list.setSeparator(this.separator());
				this._list.setItemColumned(this.isItemColumned());
                this._list.setItems(this._items);
                var r = Dom.getBounds(this._container);
				this._saveIndices = this._selectedIndices.slice();
				this._saveText = this._editor.value;
                this._list.setCaseSensitive(this._caseSensitive);
                this._list.setDropDownCount(this._dropDownCount);
				this._list.setDropDownWidth(this._dropDownWidth);
				this._list.setDropDownPosition(this._dropDownPosition);
				this._list.setButtonOptions(this._acceptText, this._cancelText, this._showButtons, this._showAllCheck, this._allCheckText);
				this._list.setSortStyle(this._itemSortStyle);
                this._list.setValueIndices(this._selectedIndices);
                this._list.setTrimLabelText(this._trimLabelText);
                this._list.setListZIndex(this.getListZIndex());
                this._list.show(_doc.documentElement, r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
                $_evl ? _win.addEventListener("mousedown", this._globalMouseHandler) : _win.attachEvent("onmousedown", this._globalMouseHandler);
                return true;
            }
		}
		return false;
	},
	getCheckValues: function (indices, items) {
		var ret = [];
		for (var i = 0, len =indices.length; i < len ; i++) {
			if (indices[i] >= 0 && indices[i] < items.length) {
				ret.push(this._labeling ? items[indices[i]].label : items[indices[i]].value);
			}
		}
		return ret;
	},
	closeUp: function (accept) {
		if (this.isListing()) {
			this._closing = true;
			try {
				var idx;
				var column = this.editIndex && this.editIndex().dataColumn();
				$_evl ? _win.removeEventListener("mousedown", this._globalMouseHandler) : _win.detachEvent("onmousedown", this._globalMouseHandler);
				this._list.hide();
				if (accept && this._list.isSelected()) {
					this._selectedIndices = this._list.valueIndices();
					this._editor.value = this.getCheckValues(this._selectedIndices, this._items).join(column.valueSeparator());
					if (!equalArrays(this._saveIndices,this._selectedIndices) || this._editor.value != this._saveText) {
						this._dispatchChange();
					}
                    if (this._commitOnSelect) {
                        this._dispatchCommit();
                    }
				} else {
					this._selectedIndices = this._saveIndices.slice();
				}
			} finally {
				this._closing = false;
			}
			return true;
		}
		return false;
	},	
	initOptions: function () {
		this._super();
		this._showButtons = true;
		this._showAllCheck = false;
		this._acceptText = window.RG_CONST && window.RG_CONST.MULTICHECKACCEPT ? window.RG_CONST.MULTICHECKACCEPT : "accept";
		this._cancelText = window.RG_CONST && window.RG_CONST.MULTICHECKCANCEL ? window.RG_CONST.MULTICHECKCANCEL : "cancel";
		this._allCheckText = window.RG_CONST && window.RG_CONST.MULTICHECKALLCHECK ? window.RG_CONST.MULTICHECKALLCHECK : "all";
	},
	setEditValue: function (value) {
		var v;
		var indices = [];
		var labels = [];
		var idx = -1;
		var values = _isArray(value) ? value : (value ? value.split(this._editIndex.dataColumn().valueSeparator()) : []);
		this._value = value;
		if (this._lookup) {
			var domain = this._domain;
			if (domain) {
				for (var i = 0, cnt = values.length ; i < cnt ; i++) {
					idx = domain.keys.indexOf(values[i]);
					if ( idx >= 0) {
						indices.push(idx);
						labels.push(idx < domain.values.length ? domain.values[idx] : values[i])
					}
				}
			} else {
				indices = this._editIndex.dataColumn().getLookupIndices(value);
			}
			if (this._labeling) {
				if (domain) {
					v = labels.join(this._editIndex.dataColumn().valueSeparator());
				} else {
					v = indices.length > 0 ? this._editIndex.dataColumn().getLookupLabel(value) : value;
				}
				this._super(v);
			} else {
				this._super(value);
			}
		} else if (this._values) {
			for (var i = 0, cnt = values.length; i < cnt; i++) {
				idx = this._values.indexOf(values[i]);
				if (idx >= 0) {
					indices.push(idx);
				 	labels.push(this._labels && idx >= 0 && this._labels.length > idx ? this._labels[idx] : values[i]);
				}
			}
			if (this._labeling && this._labels) {
				v = labels.join(this._editIndex.dataColumn().valueSeparator());
				this._super(v);
			} else {
				this._super(value);
			}
		} else {
			this._super(value);
		}
		this._selectedIndices = indices;
	},
	setCellEditValue: function(value, dropdown) {
		this._super(value, dropdown);
	},
	getEditValue: function (throwError, validateValue) {
		if (!this.isEdited() && !this._list.isSelected()) {
			return this._value;
		} else {
			return this.$_getEditValue(throwError, validateValue);
		}
	},
	_keyDownHandler: function (e) {
		var list = this._list;
		if (e.ctrlKey && e.keyCode == Keys.A && this.isListing()) {
			e.preventDefault();
			this._list._allCheck.checked = !this._list._allCheck.checked;		
			this._list.$_toggleAllCheck();
			return true;
		}
		switch (e.keyCode) {
			case Keys.SPACE:
				if (this.isListing()) {
					this._list.changeCheckIndex(list.itemIndex(), null, true);
					e.preventDefault();
					return true;
				}
				break;
		}
		return this._super(e);
	},
	$_getEditValue: function (throwError, validateValue) {
		function getValues(self, value, lookupValues, lookupLabels, col) {
			var ret = [];
			var labels = value && value.split(col.valueSeparator());
			if (labels && labels.length > 0) {
				for (i = 0 , cnt = labels.length; i < cnt ; i++) {
					if (lookupLabels.indexOf(labels[i]) >= 0 && lookupLabels.indexOf(labels[i]) < lookupValues.length) {
						ret.push(lookupValues[i])
					} else if (lookupValues.indexOf(labels[i]) >= 0) {
						ret.push(lookupValues[i])
					} else if (!self.isDomainOnly()){
						ret.push(labels[i]);
					}
				}
			}
			return ret;
		};
		var i, cnt;
		var t = this.text();
		var org = TextCellEditor.prototype.getEditValue.call(this, throwError, validateValue);
		var v = org;
		var col = this._editIndex.dataColumn();
		var indices = this._selectedIndices.slice();
		var values = [];
		var selected = this._list._selected;
		if (this._lookup) {
			if (this._domain) {
				if (this._labeling) {
					if (selected) {
						for (i = 0, cnt = indices.length; i < cnt ; i++) {
							indices[i] < this._domain.keys.length ? values.push(this._domain.keys[indices[i]]) : null;
						}
					} else {
						if (t) {
							values = getValues(this, t, this._domain.keys, this._domain.values, col);
						}
					}
					v = values.join(col.valueSeparator());
				}
			} else {
				if (this._labeling) {
					if (selected) {
						v = col.getLookupValues(indices);
					} else {
						v = col.getSourceValues(t);
					}
					if (v === undefined) {
						v = org;
					}
				}
				if (this.isDomainOnly()) {
					if (!col.lookupValues()) {
						return CellEditor.Unselected;
					}
					v = _isArray(v) ? v : v && v.split ? v.split(col.valueSeparator()) : [v];
					for (var i = v.length-1; i >= 0; i--) {
						if (col.lookupValues().indexOf(v[i]) < 0) {
							v.splice(i,1);
						}
					}
					// if (!col.lookupValues() || col.lookupValues().indexOf(v) < 0) {
					// 	return CellEditor.Unselected;
					// }
				}
			}
		} else {
			if (this._labeling) {
				if (selected) {
					for (i = 0, cnt = indices.length; i < cnt ; i++) {
						indices[i] < this._values.length ? values.push(this._values[indices[i]]) : null;
					}
				} else {
					if (t) {
						values = getValues(this, t, this._values, this._labels, col);
					}
				}
				v = values.join(col.valueSeparator());
			}
			if (this.isDomainOnly()) {
				if (!col.lookupValues()) {
					return CellEditor.Unselected;
				}
				v = _isArray(v) ? v : v && v.split ? v.split(col.valueSeparator()) : [v];
				for (var i = v.length-1; i >= 0; i--) {
					if (col.lookupValues().indexOf(v[i]) < 0) {
						v.splice(i,1);
					}
				}
				// if (!this._values || this._values.indexOf(v) < 0) {
				// 	return CellEditor.Unselected;;
				// }
			}
		}
		return v;
	},
	onMultiCheckListCloseUp: function (list, accept) {
		this.closeUp(accept);
		this.setFocus();
	},
	onMultiCheckListCheckClick: function(list) {
		this._editor.value = this.getCheckValues(this._list._selectItemIndices, this._items).join(this.editIndex().dataColumn().valueSeparator());
		this._selectedIndices = this._list._selectItemIndices.slice();
		this._saveIndices = this._list._selectItemIndices.slice();
		this._modified = true;
		this._dispatchChange();
		this._editor.focus({preventScroll:true});
	},
	onMultiCheckListCancel: function() {
		this._controller.cancelEditor();
	}
});
var /* internal */ MultiCheckList = defineClass("MultiCheckList", DropDownList, {
	init: function (container, useCssStyle) {
		this._super(container, useCssStyle);
		// this._element = this.$_createList();
		this._dom = new Dom(this._listElement);
		this._firstChild = null;
		this._selected = false;
		this._selectItemIndices = [];
		this._acceptText = null;
		this._cancelText = null;
		this._showButtons = null;
		this._showAllCheck = false;
		this._acceptClickHandler = function(e) {
			this.fireEvent(MultiCheckList.CLOSE_UP, true);
		}.bind(this);
		this._cancelClickHandler = function(e) {
			this.fireEvent(MultiCheckList.CANCEL, false);
		}.bind(this);
		this._acceptMouseoverHandler = function(e) {
			var label = e.currentTarget;
			label.style.background = "rgba(9, 211, 140, 0.5)";
		}.bind(this);
		this._acceptMouseoutHander = function(e) {
			var label = e.currentTarget;
			label.style.background = "";
		}.bind(this);
		this._cancelMouseoverHandler = function(e) {
			var label = e.currentTarget;
			label.style.background = "#888";
		}.bind(this);
		this._cancelMouseoutHandler = function(e) {
			var label = e.currentTarget;
			label.style.background = "";
		}.bind(this);
		this._mouseoverHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
			var idx = Dom.getChildIndex(div);
			var index = idx >= 0 && idx < this._items.length ? this._items[idx].index : idx;
			if (this._selectItemIndices.indexOf(index) < 0) {
				div.style.background = "rgba(0, 255, 0, 0.2)";
				div.style.color = ""
			}
		}.bind(this);
		this._mouseoutHandler = function (e) {
			var div = this._currDiv = e.currentTarget;
			var idx = Dom.getChildIndex(div);
			var index = idx >= 0 && idx < this._items.length ? this._items[idx].index : idx;
			if (this._selectItemIndices.indexOf(index) < 0) {
				div.style.background = idx == this._itemIndex ? "#888" : "";
				div.style.color = idx == this._itemIndex ? "#fff" : "";
			}
		}.bind(this);
		this._clickHandler = function (e) {
			var div = e.currentTarget;
			if (e.eventPhase == 2) {// target
				var idx = Dom.getChildIndex(div);
				var check;
				var inputs = div.getElementsByTagName("input");
				for (var i = 0, cnt = inputs.length; i < cnt; i++) {
					if (inputs[i].type == "checkbox") {
						check = inputs[i];
						break;
					}
				}
				if (check) {
					check.checked = !check.checked;
				}
				this.$_changeCheckIndex(div, idx, check.checked, true);
			}
		}.bind(this);
		this._checkClickHandler = function(e) {
			e.stopImmediatePropagation();
			var div = e.currentTarget.parentNode;
			if (div) {
				var idx = Dom.getChildIndex(div);
				var checked = e.currentTarget.checked;
				this.$_changeCheckIndex(div, idx, checked, true);
			}
		}.bind(this);
		this._allCheckMouseoverHandler = function(e) {
			var div = e.currentTarget;
			div.style.background = "rgba(0, 255, 0, 0.2)";
			div.style.color = ""
		}.bind(this);
		this._allCheckMouseoutHandler = function(e) {
			var div = this._currDiv = e.currentTarget;
			div.style.background = "";
			div.style.color = "";

		}.bind(this);
		this._allCheckClickHandler = function(e) {
			e.stopImmediatePropagation();
			if (e.eventPhase == 2 && e.currentTarget == this._allCheckElement) {
				this._allCheck.checked = !this._allCheck.checked;		
				this.$_toggleAllCheck();
			} else if (e.eventPhase == 2 && e.currentTarget == this._allCheck) {
				this.$_toggleAllCheck();
				return;
			}
		}.bind(this);	
	},
	$_toggleAllCheck: function() {
		var listElt = this._listElement;
		var i, cnt = listElt.childElementCount;
		var div;
		var checked = this._allCheck.checked;
		for (i=0; i< cnt ; i++) {
			this.changeCheckIndex(i, checked, false);
		}
		this.fireEvent(MultiCheckList.CHECK_CLICK, false);
	},
	valueIndices: function() {
		return this._selectItemIndices.slice();
	},
	setValueIndices: function (value) {
		this._selectItemIndices = [];
		if (value == null) {
			return;
		}
		value = _isArray(value) ? value : [value];
		this._selectItemIndices = value.slice();
		this.isListing() && this.$_refreshItems();
		this._selected = false;
	},	
	show: function (containerElement, x, y, cellWidth, editBounds) {
		this._containerElement = this._viewGridInside ? this._container._container : containerElement;
        (this._sortStyle != ItemSortStyle.NONE) && this.$_sortItems();
        this._itemIndex = -1;
		this.$_show(x, y, cellWidth, editBounds);
	},
	hide: function () {
		this._element.parentNode && this._element.parentNode.removeChild(this._element);		
		this._containerElement = null;
	},
	changeCheckIndex:function(idx, checked, fireEvent) {
		var item;
		var items = this._listElement.childNodes;
		if (idx >= 0 && idx < items.length) {
			var item = items[idx]; // div
			var inputs = item.getElementsByTagName("input");
			for (var i = 0, cnt = inputs.length; i < cnt; i++) {
				if (inputs[i].type == "checkbox") {
					check = inputs[i];
					break;
				}
			}
			if (check) {
				check.checked = checked != null ? checked : !check.checked;
				this.$_changeCheckIndex(item, idx, check.checked, fireEvent);
			}
		}
	},
	$_changeCheckIndex: function (div, idx, checked, fireEvent) {
		var indices = this._selectItemIndices;
		if (idx < 0 || idx >= this._items.length) {
			return;
		}
		var index = this._items[idx].index;
		if (checked) {
			indices.indexOf(index) < 0 ? indices.push(index) : null;
		} else {
			indices.indexOf(index) >= 0 ? indices.splice(indices.indexOf(index), 1): null;
		}
		!this._useCssStyle && (div.style.background = checked ? "#aaa" : this._itemIndex == idx ? "#888": "");
		!this._useCssStyle && (div.style.color = (checked || this._itemIndex == idx) ? "#fff" : "");
		this._useCssStyle && (div.className = checked ? "rg-multicheck-select" : "rg-multicheck-item");
		this._selected = true;
		fireEvent && this.fireEvent(MultiCheckList.CHECK_CLICK, false)
	},
	$_createList: function () {
		var element = document.createElement("div");
		if (this._useCssStyle) {
			element.className = "rg-multicheck";	
		}

		var allCheckDiv = document.createElement("div");
		this._useCssStyle ? (allCheckDiv.className = "rg-multicheck-allcheck") : null;
		this._allCheckElement = allCheckDiv;
		Dom.setStyles(allCheckDiv,{
			paddingLeft:"2px",
		})
		Dom.disableSelection(allCheckDiv);
		element.appendChild(allCheckDiv);

		var listDiv = document.createElement("div");
		this._useCssStyle ? (listDiv.className = "rg-multicheck-list") : null;
		this._listElement = listDiv;
		element.appendChild(listDiv);

		var buttonDiv = document.createElement("div");
		!this._useCssStyle && Dom.setStyles(buttonDiv, {
			textAlign :"center",
		});
		this._useCssStyle ? (buttonDiv.className = "rg-multicheck-button") : null;
		this._buttonElement = buttonDiv;
		Dom.setStyles(buttonDiv,{
			margin:"2px",
			paddingLeft:"2px",
		})
		Dom.disableSelection(buttonDiv);		
		element.appendChild(buttonDiv);

		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.fireEvent(MultiCheckList.CLOSE_UP, false);
			}
		}.bind(this);
		return element;
	},
	$_show: function (x, y, cellWidth, editBounds) {
		var elt = this._element;
		if (!elt) {
			return;
		}
		// var elt = this._dom.element();
		Dom.setStyles(elt,{
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			minWidth: "20px",
			minHeight: "10px",
			overflow: "visible",
			zIndex: this._listZIndex
		});
		!this._useCssStyle && Dom.setStyles(elt, {
			background: "#fff",// "rgb(233, 233, 233)",
			border: "1px solid rgb(50, 50, 50)", //"1px solid rgb(200, 200, 200)",
			boxShadow: "rgba(0, 0, 0, 0.8) 1px 2px 5px",
			fontFamily: "Tahoma",
			fontStyle: "normal",
			fontVariant: "normal",
			fontWeight: "normal",
			fontSize: "10pt",
			padding: "0px",
			margin: "0px"
		});

		this._dom.setStyles({
			position: "relative",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			minWidth: "20px",
			minHeight: "10px",
			overflow: "auto"
		});
		!this._useCssStyle && this._dom.setStyles({
			background: "#fff",// "rgb(233, 233, 233)",
			fontSize: "10pt",
			padding: "0px",
			margin: "0px"
		});
		Dom.setStyles(this._buttonElement,{
			position: "relative",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			marginLeft: "0px",
			marginRight: "0px",
		});
        this._firstChild = null;
		this._dom.clearChildren();
		this._dom.disableSelection();
		this._containerElement.appendChild(this._element);
        this.$_buildItems();
        this.$_buildButtons();
		this.$_resetHeight();
        this.$_resetWidth(cellWidth);
		this.$_resetPosition(x, y, cellWidth, editBounds);
		if (this._selectItemIndices.length > 0 && this._itemIndex < 0) {
			this.setItemIndex(this._selectItemIndices[0]);
		}
		this._selected = false;
	},
    $_resetWidth: function (cellWidth) {
        var elt = this._dom.element();
		var r = Dom.getBounds(elt);
        var dw = this._dropDownWidth, w = this._dropDownWidth;
		if (w < 0) {
			w = cellWidth;
		} else if (w == 0) {
			w = 10; // Dom Size가 큰 상태에서는 줄어들지 않으므로 최소 크기(10)으로 설정 후 계산
		}
		elt.style.width = w + "px";
		var cw = 0;
		if (this._firstChild) {
			var style = this._firstChild.currentStyle || window.getComputedStyle(this._firstChild);
			var marginLeft = parseInt(style.marginLeft.replace("px",""));
			marginLeft = isNaN(marginLeft) ? 0 : marginLeft;
			var marginRight = parseInt(style.marginRight.replace("px",""));
			marginRight = isNaN(marginRight) ? 0 : marginRight;

			var childs = elt.childNodes;
			for (var i = 0; i < childs.length; i++) {
				cw = Math.max(cw, childs[i].scrollWidth);
			}
			cw += elt.offsetWidth - elt.clientWidth + marginLeft + marginRight;// + 4;
		}
		//r = Dom.getBounds(elt);
		//cw = Math.max(cw, r.width);
		if (dw < 0)
			cw = Math.max(cw,w);
		r = _getBrowserSize();// Dom.getBounds(this._containerElement);
		cw = Math.min(cw, r.width);
		w = cw;

		if (_ieOld && (dw >= 0 || cw > w)) // boxSizing: "border-box"일 때 IE 9에서 width가 text보다 작아지는 현상
			w += 20;
		if (w < r.width)
			elt.style.overflowX = "hidden";
		else 
			elt.style.overflowX = "auto";

		cw = parseInt(this._buttonElement.getBoundingClientRect().width);
		if (!isNaN(cw)) {
			w = Math.max(w, cw);
		}
		elt.style.width = w + "px";
    },
	$_resetPosition: function (x, y, cellWidth, editBounds) {
        var br = _getBrowserSize();
        var pr = Dom.getBounds(this._containerElement);
		var cr = Dom.getBounds(this._container._container);
		var w = br.width; // this._container.width(); // _container: grid container
		var h = br.height; //this._container.height();
		// var r = this._dom.getBounds();
		var r = Dom.getBounds(this._element);
        var sx = window.pageXOffset || document.documentElement.scrollLeft;
        var sy = window.pageYOffset || document.documentElement.scrollTop;
        if (document.documentElement.scrollWidth > document.documentElement.clientWidth) {
            h -= 18;
        }
        if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
            w -= 18;
        }
        x += cr.left - pr.left;
        y += cr.top - pr.top;
		if (_ieTen || _ieOld || _ieLeg) {
			x += document.documentElement.scrollLeft;
			y += document.documentElement.scrollTop;
		}
		if (y + r.height > h + sy) {
			y = y - editBounds.height - r.height;
			if (y < 0) {
				y = h - r.height - 2;
			}
		}
		if (this._dropDownPosition != DropDownPosition.EDITOR) { // BUTTON 이거나 잘못된 값.
			x = Math.max(0, x + cellWidth - r.width);
		} else {
			if (x + r.width > w + sx) {
				x = w - r.width;
			}
		}
		if (this._viewGridInside) {
			y = editBounds.bottom - pr.top + 2;
			if ( (pr.bottom < editBounds.bottom+r.height) || (h+sy < editBounds.bottom+r.height)) {
				y = editBounds.top - r.height - pr.top - 2;
			}
		}
		// this._dom.move(Math.max(0, x), Math.max(0, y));
		Dom.move(this._element, Math.max(0, x), Math.max(0, y));
	},
	$_resetItems: function (x, y, cellWidth, editBounds) {
		this._dom.clearChildren();
		this._firstChild = null;
		this.$_buildItems();
		this.$_buildButtons();
		this.$_resetHeight();
        this.$_resetWidth(cellWidth);
		this.$_resetPosition(x, y, cellWidth, editBounds);
	},
	$_buildItems: function () {
		var itemWidth = 0;
		var g = this._container._defContext._graphics;
		var font;
		var span;
		addValue = function (div, item, check) {
			var s = (item ? item.value.toString() : "");
			var span = Dom.createElement("label");
			span.style.whiteSpace = "pre";
			span.innerHTML = s ? Dom.htmlEncode(s) : "&nbsp;";
			span.htmlFor = check && check.id;
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
			return span;
		}.bind(this);
		addLabel = function (div, item, check) {
			var s = (item ? item.label.toString() : "");
			s = this._trimLabelText ? s.trim() : s;
			var span = Dom.createElement("label");
			!this._trimLabelText && (span.style.whiteSpace = "pre");
			span.innerHTML = s ? Dom.htmlEncode(s) : "&nbsp;";
			span.htmlFor = check && check.id;
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
			return span;
		}.bind(this);
		addSeparator = function (div, separator) {
			var span = Dom.createElement("span");
			span.style.whiteSpace = "pre";
			span.innerHTML = separator ? Dom.htmlEncode(separator) : "&nbsp;";
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
		}.bind(this);
		calcWidth = function(span) {
			if (!font) {
				var style = window.getComputedStyle(span);
				font = {
					font: style.fontSize+" "+style.fontFamily,
					size: parseInt(style.fontSize)
				}
			};
			return Math.max(itemWidth, g.getTextWidth(font, span.innerText));
		}.bind(this);

		var items = this._items;
		if (!items || items.length < 1) {
			return;
		}
		for (var i = 0, cnt = items.length; i < cnt; i++) {
			var item = items[i];
			var div = Dom.createElement("div", {
				position: "relative",
				float: "none",
				paddingTop: "1px",
				paddingBottom: "1px",
				paddingLeft: "2px",
				paddingRight: "2px",
				whiteSpace: "nowrap",
				cursor: "default",
			});
			var isChecked = this._selectItemIndices.indexOf(items[i].index) >= 0;
			!this._useCssStyle && (div.style.background = isChecked ? "#aaa" : "");
			!this._useCssStyle && (div.style.color = isChecked ? "#fff" : "");
			this._useCssStyle && (div.className = isChecked ? "rg-multicheck-select" : "rg-multicheck-item");
			Dom.disableSelection(div);
			this._listElement.appendChild(div);
			if (i == 0) this._firstChild = div;
			div.onmouseover = !this._useCssStyle ? this._mouseoverHandler : null;
			div.onmouseout = !this._useCssStyle ? this._mouseoutHandler : null;
			div.onclick = this._clickHandler;
			var check = Dom.createElement("input");
			check.id = "$multiCheck_item_" + MultiCheckList.$_checkId++;
			check.type="checkBox";
			check.onclick = this._checkClickHandler;
			check.checked = isChecked;
			div.appendChild(check);

			span = null;

			// var s = (item ? item.label.toString() : "");
			// s = this._trimLabelText && s ? s.trim() : s;
			// var span = Dom.createElement("label");
			// !this._trimLabelText && (span.style.whiteSpace = "pre");
			// span.innerHTML = s ? Dom.htmlEncode(s) : "&nbsp;";
			// span.htmlFor = check.id;
			// span.tabIndex = -1;
			// Dom.disableSelection(span);
			// div.appendChild(span);
			switch(this.displayLabels()) {
				case true:
				case DropDownValueLabel.LABEL:
					addLabel(div, item, check);
					break;
				case false:
				case DropDownValueLabel.VALUE:
					addValue(div, item, check);
					break;
				case DropDownValueLabel.LABEL_VALUE:
					span = addLabel(div, item, check);
					addSeparator(div, this._separator);
					addValue(div, item, check);
					break;
				case DropDownValueLabel.VALUE_LABEL:
					span = addValue(div, item, check);
					addSeparator(div, this._separator);
					addLabel(div, item, check);
					break;
			};
			if (span && this._itemColumned) {
				itemWidth = Math.max(itemWidth, calcWidth(span));
				div._firstItem = span;
			}
		};
		if (this._itemColumned && itemWidth) {
			for (var i = 0, cnt = this._listElement.childNodes.length; i < cnt ; i++) {
				span = this._listElement.childNodes[i]._firstItem;
				span && (span.style.display = "inline-block");
				span && (span.style.width = itemWidth+"px");
			}
		}
	},
	setButtonOptions: function(acceptText, cancelText, showButtons, showAllCheck, allCheckText) {
		this._acceptText = acceptText;
		this._cancelText = cancelText;
		this._showButtons = showButtons;
		this._showAllCheck = showAllCheck;
		this._allCheckText = allCheckText;
		this.$_buildButtons();
	},
	$_buildButtons: function() {
		if (!this._buttonElement) {
			return;
		}
		this._buttonElement.style.display = this._showButtons ? "" : "none";
		Dom.clearChildren(this._buttonElement);

		var button = document.createElement("label");
		button.innerHTML = this._acceptText;
		button.onclick = this._acceptClickHandler;
		button.onmouseover = !this._useCssStyle ? this._acceptMouseoverHandler : null;
		button.onmouseout = !this._useCssStyle ? this._acceptMouseoutHander : null;
		this._useCssStyle && (button.className = "rg-multicheck-accept");
		Dom.setStyles(button,{
			padding: "0px 3px",
			marginRight: "0px",
			marginLeft: "2px",
			cursor: "pointer",
		});
		!this._useCssStyle && Dom.setStyles(button,{
			border: "1px solid #0a3c59",
			borderRadius: "3px",
			color: "#06426c",
			borderWidth: "1px", 
		});
		Dom.disableSelection(button);		
		this._buttonElement.appendChild(button);
		var button = document.createElement("label");
		button.innerHTML = this._cancelText;
		button.onclick = this._cancelClickHandler;
		button.onmouseover = !this._useCssStyle ? this._cancelMouseoverHandler : null;
		button.onmouseout = !this._useCssStyle ? this._cancelMouseoutHandler : null;
		this._useCssStyle && (button.className = "rg-multicheck-cancel");
		Dom.setStyles(button,{
			padding: "0px 1px",
			marginRight: "0px",
			marginLeft: "2px",
			cursor: "pointer",
		});
		!this._useCssStyle && Dom.setStyles(button,{
			border: "1px solid #0a3c59",
			borderRadius: "3px",
			color: "#06426c",
			borderWidth: "1px", 
		});
		Dom.disableSelection(button);		
		this._buttonElement.appendChild(button);

		var allCheckDiv = this._allCheckElement;
		allCheckDiv.onmouseover = !this._useCssStyle ? this._allCheckMouseoverHandler : null;
		allCheckDiv.onmouseout = !this._useCssStyle ? this._allCheckMouseoutHandler : null;
		allCheckDiv.onclick = this._allCheckClickHandler;
		Dom.clearChildren(allCheckDiv);
		if (this._showAllCheck) {
			allCheckDiv.style.display = "";
			var allCheck = document.createElement("input");
			allCheck.type = "checkbox";
			allCheck.id = "$multiCheck_item_" + MultiCheckList.$_checkId++;
			allCheck.onclick = this._allCheckClickHandler;
			this._allCheck = allCheck;
			allCheckDiv.appendChild(allCheck);
			var span = Dom.createElement("label");
			span.innerHTML = this._allCheckText;
			span.htmlFor = allCheck.id;
			span.tabIndex = -1;
			Dom.disableSelection(span);
			allCheckDiv.appendChild(span);
		} else {
			allCheckDiv.style.display = "none"
		}
	},
	$_refreshItems: function () {
		var item;
		var items = this._listElement.childNodes;
		var idx = -1;
		for (var i = 0; i < items.length; i++) {
			idx = i < this._items.length ? this._items[i].index : -1;
			item = items[i];
			if (i == this._itemIndex) {
				if (this._useCssStyle) {
					item.classList.add("rg-multicheck-selectitem")
				} else {
					item.style.background = "#888";
					item.style.color = "#fff";
				}
			} else {
				if (this._useCssStyle) {
					item.className = this._selectItemIndices.indexOf(idx) >= 0 ? "rg-multicheck-select" : "rg-multicheck-item";
				} else {
					item.style.background = this._selectItemIndices.indexOf(idx) >= 0 ? "#aaa" : "";
					item.style.color = this._selectItemIndices.indexOf(idx) >= 0 ? "#fff" : "";
				}
			}
		};
		var idx = this._itemIndex;
		if (idx >= 0 && idx < items.length) {
			item = items[idx];
			if (item.offsetTop < this._listElement.scrollTop) {
				this._listElement.scrollTop = item.offsetTop;
			} else {
				var y = item.offsetTop + Dom.getSize(item).height;
				if (y >= this._listElement.scrollTop + this._listElement.clientHeight) {
					this._listElement.scrollTop = y - this._listElement.clientHeight;
				}
			}
		}
	},
},{
	$_checkId:0
});
MultiCheckList.CLOSE_UP = "onMultiCheckListCloseUp";
MultiCheckList.CANCEL = "onMultiCheckListCancel";
MultiCheckList.CHECK_CLICK = "onMultiCheckListCheckClick";
var SearchCellEditor = defineClass("SearchCellEditor", DropDownCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._searchKey = null;
		this._timer = undefined;
	},
	searchLength: 1,
	searchDelay: 1000,
    useCtrlEnterKey: false,
    useEnterKey: false,
    initCount: 0,
    moreItemCount: 25,
    moreText: null,
    reInquery:true,
	fillItems: function (key/*String*/, values/*[]*/, labels/*[]*/) {
		if (this.isListing() && key == this.getEditText()) {
			this.setValues(values);
			this.setLabels(labels);
			this._refreshItems(true, true);
			this._list.$_search(this._editor.value, true);
			return true;
		}
		return false;
	},
    _keyDownHandler: function (e) {
        var key = e.keyCode == Keys.ENTER;
        if (key) {
            if (e.ctrlKey) {
                key = this.isUseCtrlEnterKey();
            } else {
                key = this.isUseEnterKey() && (!this._items || this._items.length < 1);
            }
        }
        if (key && this.isEditing()) {
            e.preventDefault();
            e.stopImmediatePropagation();
            this.$_stopTimer();
            var s = this.getEditText();
            if (s && (s != this._searchKey)) {
                this._searchKey = s;
                this._dispatchSearch(s);
            }
            return true;
        }
        return this._super(e);
    },
    _keyUpHandler: function (e) {
        this._super(e);
        /**
         * 크롬에서 한글 입력 시, composing이 완료되는 시점에
         * editor.value값이 새로 추가된 문자를 제외시키고 있다.
         */
        if (_isChrome) {
            this.$_search();
        }
    },
	_inputHandler: function (e) {
		this._super(e);
        if (!_isChrome) {
            this.$_search();
        }
	},
	_doEndEdit: function () {
		this._super();
		this.$_stopTimer();
		this._searchKey = null;
	},
	dropDown: function () {
		var list = this._list;
		if (list) {
			list.setInitCount(this.initCount());
			list.setMoreItemCount(this.moreItemCount());
			list.setMoreText(this.moreText());
		}
		this._super(true);
	},
	buttonClicked: function (index) {
		if (this.isListing()) {
			this.closeUp(false);
		} else {
			this.dropDown();
			var searchKey = this.getEditText();
			var ret = this._dispatchSearchCellButtonClick(searchKey);
			if (ret) {
				if ((typeof ret === "object") && ret.values) {
					this.fillItems(searchKey, ret.values, ret.labels);
				}
			}
		}
	},	
    $_search: function () {
        var s = this.getEditText();
        if (s && s !== $$_EMPTY_TEXT_VALUE && s.length >= this._searchLength) {
            this.$_startTimer();
        } else {
            this.$_stopTimer();
        }
    },
	$_startTimer: function () {
		this.$_stopTimer();
		if (!this.isReInquery() && this.isListing() && this._list._items.length > 0) {
			return;
		}
		this._timer = setInterval(function () {
			var s = this.getEditText();
			if (s && s !== $$_EMPTY_TEXT_VALUE && (s != this._searchKey)) {
				this._searchKey = s;
				this.$_stopTimer();
				this._dispatchSearch(s, true);
			}
		}.bind(this), this._searchDelay)
	},
	$_stopTimer: function () {
		this._timer && clearInterval(this._timer);
	}
});
SearchCellEditor.SEARCH = "onSearchCellEditorSearch";
var $$_HANGUL_REG = /[ㄱ-ㅎㅏ-ㅣ가-힝]/g;
var NumberCellEditor = defineClass("NumberCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
		this._regxAll = /[0-9]|,|\.|\-|\+|e|E/;
		this._regxPos = /[0-9]|,|\.|\+|e|E/;
		this._regxInt = /[0-9]|,|\+|\-/;
		this._regxPosInt = /[0-9]|,|\+/;
		this._regx = this._regxAll;
		this._editor.style.imeMode = "disabled";
		this._editor.style["-webkit-ime-mode"] = "disabled";
		this._editor.style["-moz-ime-mode"] = "disabled";
		this._editor.style["-ms-ime-mode"] = "disabled";
		this._decSep = $$$_DEC_SEP;
		this._groupSep = $$$_GRP_SEP;
		this._editFormat = undefined;
		this._decLen = undefined;
		this._decimalFormatter = undefined;
		this._numValue = undefined;
		this._multipleChar = null;
		this._addString = "000";
		this._isMultiple = false;
		this._maxIntegerLength = 0;
	},
	setMask: function(options) {
		this._mask = null;
	},
	positiveOnly: false,
	integerOnly: false,
	decSep:undefined,
	groupSep:undefined,
	editFormat:undefined,
	multipleChar:undefined,
	addString:undefined,
	maxLengthExceptComma : false,
	maxIntegerLength:undefined,
	blankWhenSpace: false,
	setEditFormat: function (value) {
		if (this._editFormat != value) {
			this._editFormat = value;
			if (value) {
				var decFormatter = this._decimalFormatter = new DecimalFormatter(value);
				if (decFormatter) {
					this._decSep = decFormatter._seperator ? decFormatter._seperator : $$$_DEC_SEP;
					this._groupSep = decFormatter._groupSep ? decFormatter._groupSep : $$$_GRP_SEP;
					this._decLen = Math.max(decFormatter._minDigits, decFormatter._maxDigits);
				}
			} else {
				this._decimalFormatter = undefined;
				this._decSep = $$$_DEC_SEP;
				this._groupSep = $$$_GRP_SEP;
				this._decLen = undefined;
			}
		}
	},
	setPositiveOnly: function (value) {
		if (value != this._positiveOnly) {
			this._positiveOnly = value;
			this.$_resetRistrict();
		}
	},
	setIntegerOnly: function (value) {
		if (value != this._integerOnly) {
			this._integerOnly = value;
			this.$_resetRistrict();
		}
	},
	initOptions: function () {
		this._super();
		this._decSep = $$$_DEC_SEP;
		this._groupSep = $$$_GRP_SEP;
		this.setEditFormat(undefined);
		this.setPositiveOnly(false);
		this.setIntegerOnly(false);
		this.setBlankWhenSpace(false);
	},
	setEditIndex: function (index) {	
		this._super(index);
		this._editor.maxLength = (this.isMaxLengthExceptComma() || this._maxLength <= 0) ? this._defMaxLength : this._maxLength;
	},
	_pasteHandler: function (e) {
		return this._super(e);
	},
	$_strToNum: function(numStr) {
		numStr = ""+numStr;
		var dpReg = new RegExp("\\"+this._decSep,"g");
		var tsReg = new RegExp("\\"+this._groupSep,"g");
		var sign = numStr[0] === "-";
		numStr = numStr.replace(tsReg,"").replace(dpReg,".");
		return isNaN(numStr) ? NaN : sign ? -Math.abs(parseFloat(numStr)):parseFloat(numStr);
	},

	// 편집을 위함 문자열 생성.
	$_formatNum: function(value,minDigits, maxDigits){
		var n = value, 
	    	s = n < 0 ? "-" : n == 0 && 1/n === -Infinity ? "-" : ""; // -0을 표시.

	    var c = isNaN(c = Math.max(minDigits, maxDigits)) ? 2 : c;
    	var i = parseInt(n = Math.abs(+n || 0).toFixed(c)) + "";
	    var j = (j = i.length) > 3 ? j % 3 : 0;

	    if (n.indexOf(".") >= 0) {
	    	var e = n.split(".")[1].split("");
	    	while(e.length > 0 && e[e.length-1] === "0" && e.length > minDigits) {
	    		e.splice(e.length-1, 1);
	    	}
	    	n = e.join("");
	    	c = e.length;
	    }

	   	return s + (j ? i.substr(0, j) + this._groupSep : "") + i.substr(j).replace(/(\d{3})(?=\d)/g, "$1" + this._groupSep) + (c ? this._decSep + n : "");
	 },	

	 $_editFormatting: function(e) {
		var value = e.target.value;
		var isDecSep = value && value[value.length-1] == this._decSep;
		var selStart = e.target.selectionStart;
		var selEnd = e.target.selectionEnd;
		value = this._isMultiple && this._addString ? value.replace(/\+/g,this._addString) : value;
		this._isMultiple && this._addString && (selStart += this._addString.length, selEnd += this._addString.length);
		var ary = value.split(this._decSep);
		var fLen = 0;
		if (ary.length > 1) {
			ary.length = 2;
			ary[1] = ary[1].substr(0,this._decimalFormatter._maxDigits);
			fLen = ary[1].length;
			value = ary.join(this._decSep);
		};
		fLen = ary.length == 2 ? Math.min(ary[1].length, this._decLen != null ? this._decLen : 99 ) : 0;
		var num = this.$_strToNum(value);
		if (!isNaN(num)) {
			if (this.maxLength() > 0 || this.maxIntegerLength() > 0) {
				var s = String(num).split(".");
				if (this.maxIntegerLength() > 0) {
					s[0] = s[0].substr(0, this.maxIntegerLength());
				};
				s = s.join(".");
				if (this.maxLength() > 0) {
					s = s.substr(0,this.maxLength());
				};
				num = parseFloat(s);
			}
			value = this.$_formatNum(num, fLen, this._decimalFormatter._maxDigits);
			value = isDecSep && this._decLen && value.indexOf(this._decSep) < 0 ? value+this._decSep : value;
			var l1 = value.length, l2 = e.target.value.length;
			Math.abs(l1-l2) == 1 && (l1 > l2 ? (selStart++, selEnd++) : (value.indexOf(this._decSep) >= selStart && (selStart--, selEnd--)));
			e.target.value = value;
			e.target.setSelectionRange(selStart, selEnd);
		}
	 },
	_inputHandler: function(e) {
		if (this._editFormat) {
			var target = e.target;
			this.$_editFormatting(e);
		}
		this._super(e);
	},
	_keyPressHandler: function (e) {
        if (_isFirefox) {
            if (e.ctrlKey || e.charCode === 0) {
                this._super(e);
                return;
            }
        };
        var chkLen = true;
        var c = String.fromCharCode(e.keyCode || e.charCode);
		if (!this._regx.test(c) || (e.target.value && e.target.value.indexOf(this._decSep) >= 0 && c == this._decSep)) {
			if (!this._multipleChar || c !== this._multipleChar) {
				chkLen = false;
				!(this.isBlankWhenSpace() && c === " ") && e.preventDefault();
			}
		};
		var ss = e.target.selectionStart,
			se = e.target.selectionEnd,
			value = e.target.value,
			tsReg = new RegExp("\\"+this._groupSep,"g");
		var s = value ? value.split("") : [];
		s.splice(ss,se-ss,c === this._multipleChar ? this._addString : c);
		s = s.join("").replace(tsReg,"");

		if (this._maxLength > 0 && chkLen && this.isMaxLengthExceptComma() && value && value !== $$_EMPTY_TEXT_VALUE) {
			s.length > this._maxLength && e.preventDefault();
		};
		if (this._maxIntegerLength > 0 && c !== this._decSep) {
			var int = parseInt(this.$_strToNum(s));
			if (!isNaN(int)) {
				chkLen = Math.abs(int).toString().length;
				this._maxIntegerLength < chkLen && e.preventDefault();
			}
		}
		this._isMultiple = c == this._multipleChar;
		this._super(e);
	},
	_keyDownHandler: function (e) {
		var key = e.keyCode || e.charCode;
		this._isMultiple = false;
		if ((key === 8 || key === 46) && this.isEditing() && this._editFormat) {
			var elt = e.target;
			var value = elt.value;
			var len = value.length,
				aLen;
			var ary = value && value.split("");
			var ss = elt.selectionStart,
				se = elt.selectionEnd;
			if (ss !== se) {
				this._super(e);
				return;
			};
			var c = value[key === 8 ? ss-1 : ss];
			if (c === this._groupSep || c === this._decSep) {
				if (c === this._decSep && ss === ( key === 8 ? value.length : value.length-1)) {

				} else {
					ary.splice(key === 8 ? ss-2 : ss+1, 1);
					elt.value = ary.join("");
					this.$_editFormatting(e);
					value = elt.value;
					aLen = len - (key === 8 ? value.length : len);
					elt.setSelectionRange(ss-aLen,se-aLen);
					this._doChanged();
					e.preventDefault();
				}
			}
		};
		this._super(e);
	},
	$_resetValue: function () {
		if (this.isVisible()) {
			var s = this._editor.selectionStart;
			var p = this._editor.selectionEnd;
			var plen = this._editor.value ? this._editor.value.length : 0;
			this._editor.value = this._editor.value.replace($$_HANGUL_REG, '').trim();
			var alen = this._editor.value ? this._editor.value.length : 0;
			alen == plen ? this._editor.setSelectionRange(s, p) : this._editor.setSelectionRange(p, p); 
		}
	},
	_dispatchChange: function () {
        if (this.isVisible()) {
            this.$_resetValue(); 
            this._super();
        }
	},
	setEditValue: function (value) {
		var v = parseFloat(value);
		if (isNaN(v)) {
			this._editor.value = "";
		} else if (this._editFormat && (typeof v == "number")) {
			// var len = Math.max(0, v.toString().length - Math.floor(v).toFixed().length - 1, this._decimalFormatter._minDigits);
			this._editor.value = this.$_formatNum(v,this._decimalFormatter._minDigits, this._decimalFormatter._maxDigits );
		} else {
			this._editor.value = v;
		}
	},
	getEditValue: function (throwError, validateValue) {
		this.$_resetValue();
		var fld = this._editField();
		var v = fld.nullValue;
		try {
			var s = this._editor.value;
			s = s && s.trim();
			if (s) {
				var tsReg = new RegExp("\\"+this._groupSep,"g");
				var dpReg = new RegExp("[\\"+this._decSep+"]+","g");
				s = s.replace(tsReg, "");
				s = s.replace(dpReg, ".");
				s = s.replace(/\++/g, "+");
				s = s.replace(/\-+/g, "-");
				s = s.replace(/\+\-/g, "+");
				s = s.replace(/\-\+/g, "-");
			}
			v = s ? parseFloat(s) : undefined;
		} catch (e) {
			if (throwError) throw e;
		}
		return v;
	},
	setCellEditValue: function(value) {
		if (!this.isReadOnly() && this._requestStart()) {
			if (typeof value === "string" || typeof value === "number") {
				value = this.$_strToNum(value);
			} else {
				return;
			};
			this.setEditValue(value);
			this._doChanged();
		}
	},
	$_resetRistrict: function () {
		if (this._positiveOnly && this._integerOnly) {
			this._regx = this._regxPosInt;
		} else if (this._positiveOnly) {
			this._regx = this._regxPos;
		} else if (this._integerOnly) {
			this._regx = this._regxInt;
		} else {
			this._regx = this._regxAll;
		}
	}
}); 
// 입력된 년주차에 해당하는 기준 목요일을 구해온다.
var $_getWeekThurs = function(weeks) {
	if (!weeks) {
		return null;
	}
	(weeks = String(weeks)) && (weeks = weeks.replace(/[^0-9]/g,""));
	var year = parseInt(weeks.substr(0,4));
	var week = parseInt(weeks.substr(4,2));
	if ( isNaN(year) || year <= 0 || isNaN(week) || week < 0) {
		return null;  // 뭔가 잘못되었으면 null;
	}
	var d = new Date(year,0,1);
	var day = 4 - d.getDay()+1;
	d.setDate(day);
	// 해당년도부터 시작하면 -1 전년도부터 시작하면 0
	if (d.getFullYear() == year) {week--};
	day = week*7;
	d.setDate(d.getDate()+day);
	return d;
};
// ISO기준은 월요일이 시작요일이다.
// 2017-01-01의 경우 ISO기준으로는 2016-52주이고 일반적인 달력으로는 2017-01주이다.
// 1월 1일의 기준 목요일과 입력된 날짜의 기준 목요일을 구한다.
// 1월 1일의 기준 목요일이 전 년도라면 1일 더해준다. 1월 첫 주의 경우 전년도 주차도 구해주어야 한다.
var $_getYearWeeks = function(dt, startWeek, includeSeparator) {
	thursDay = function (dt, startWeek) {
		var d = new Date(dt);
		var day = d.getDay();
		day = day < startWeek ? -3 -day : 4 - day;
		var date = d.getDate();
		d.setDate(date+day);  // 기준 목요일이 된다.
		return d;
	};
	var year = dt.getFullYear();
	var firstThurs = thursDay(new Date(year, 0, 1), startWeek);
	var thurs = thursDay(new Date(year, dt.getMonth(), dt.getDate()), startWeek);
	var firstYear = firstThurs.getFullYear();
	var thursYear = thurs.getFullYear();
	var weeks;

	// thurs 입력된 일자의 기준 목요일이 현재년도면 주차 return;
	// 전년도면 
	// 다음년도면 1주차가 된다.
	if (thursYear < year) {  // 기준 목요일의 년도가 입력된 일자의 년도보다 작다면 (1월1~3일정도) 전년도의 마지막 주차를 구해야 한다.
		firstThurs = thursDay(new Date(firstYear,0,1));
		weeks = Math.ceil((thurs.valueOf() - firstThurs.valueOf()) / (24*60*60*1000*7)) + (firstThurs.getFullYear() === thursYear ? 1 : 0);
	} else if (thursYear > year) {  // 기준목요일의 년도가 다음년도이다. 이건 다음년도의 1주차로 처리한다.
		weeks = 1;
	} else {
		weeks = Math.ceil((thurs.valueOf() - firstThurs.valueOf()) / (24*60*60*1000*7)) + (firstYear === thursYear ? 1 : 0); // 처음 목요일이 해당 년도면 1을 더한다.
	}
	return String(thursYear) + (includeSeparator ? '-' : "") + ( weeks < 10 ? "0"+weeks : String(weeks) );
};
var Holiday = defineClass("Holiday", null, {
	init: function (owner) {
		this._super();
		this._owner = owner;
		this._tooltips = [];
		this._items = [];
		this._styles = new VisualStyles(this, "holidayStyles");
		this._styles.setSysDefault(Holiday.$_defaultStyle, false);
	},
	destroy: function () {
		this._owner = null;
		this._tooltips = [];
		this._items = [];
		this._styles = null;
		this._super();
	},
	tooltips: null,
	items: null,
	styles: null,
	enabled: true,
	load: function (value) {
		this.clear();
		if (value) {
			value.styles === null ? this._styles.clearValues() : this._styles.extend(value.styles)
		}
	},
	clear: function () {
		this._items = [];
		this._tooltips = [];
	},
	count: function () {
		return this._items && this._items.length;
	},
	contains: function (date) {
		return false;
	},
	getTooltip: function (date) {
		return null;
	}
}, null, function(f) {
	f.$_defaultStyle = new VisualStyles(null, "default HolidayStyles",{background:"#f5f5f5", foreground:"#333"});
});
var DateHoliday = defineClass("DateHoliday", Holiday, {
	init: function (owner, value) {
		this._super(owner);
		value && this.load(value);
	},
	destroy: function () {
		this._super();
	},
	load: function (value) {
		this._super(value);
		if (value) {
			var dates = _isArray(value.dates) ? value.dates : value.dates ? [value.dates] : [];
			value.tooltips = _isArray(value.tooltips) ? value.tooltips : value.tooltips ? [value.tooltips] : [];
			for (var i = 0, cnt = dates.length; i < cnt; i++) {
				var date = dates[i];
				var dt;
				if (date instanceof Date) {
					dt = new Date(date);
					dt.setHours(0,0,0,0)
				} else if (typeof date === "number") {
					dt = new Date(date);
					dt.setHours(0,0,0,0)
				} else if (typeof date === "string") {
					if ((date.length === 4 || date.length === 8) && /^[0-9]*$/.test(date)) {
						date = date.length === 4 ? date.replace(/(\d{2})(\d{2})/,"$1/$2") : date.replace(/(\d{4})(\d{2})(\d{2})/,"$1/$2/$3");
					};
					var arr = date.split(/[.//-]/);
					if (arr.length == 2) {
						try {
							dt = parseInt(arr[0]).toString() + "/" + parseInt(arr[1]).toString();
						} catch (e) {}
					} else if (arr.length == 3) {
						// editorFormat에 따라서 변경해야 할 필요가 있다. 다국어 인경우.
						dt = DatetimeConverter.getSimpleDateNull(date)
					}
				}
				if (dt) {
					this._items.push(dt);
					value.tooltips[i] && this._tooltips.push(value.tooltips[i]);
				}
			};
			this._enabled = !!value.enabled;
		}
	},
	getItemIndex: function (date) {
		var item;
		for (var i = 0, cnt = this._items.length; i < cnt ; i++) {
			item = this._items[i];
			if (item instanceof Date && item.getFullYear() === date.getFullYear() && item.getMonth() === date.getMonth() && item.getDate() === date.getDate()) {
				return i;
			} else if (item === (date.getMonth()+1) + "/" + date.getDate()) {
				return i;
			}
		};
		return -1;
	},
	contains: function (date) {
		return this.getItemIndex(date) >= 0;
	},
	getTooltip: function (date) {
		var idx = this.getItemIndex(date);
		return idx >= 0 ? this._tooltips[idx] : null;
	}
});
var DayHoliday = defineClass("DayHoliday", Holiday, {
	init: function (owner, value) {
		this._super(owner);
		value && this.load(value);
	},
	destroy: function () {
		this._super();
	},
	load: function (value) {
		this._super(value);
		if (value) {
			this._items = _isArray(value.days) ? value.days : value.days ? [value.days] : [];
			this._tooltips = _isArray(value.tooltips) ? value.tooltips : value.tooltips ? [value.tooltips] : [];
			this._enabled = !!value.enabled;
		};
	},
	contains: function (date) {
		if (date instanceof Date) {
			return this._items.indexOf(date.getDay()) >= 0;
		} else if (typeof date == "number") {
			return this._items.indexOf(date) >= 0;
		}
	},
	getTooltip: function (date) {
		var idx = date instanceof Date ? this._items.indexOf(date.getDay()) : this._items.indexOf(date);
		return idx >= 0 ? this._tooltips[idx] : null;
	}
});
var HolidayCollection = defineClass("HolidayCollection", null, {
	init: function () {
		this._super();
		this._items = [];
		this._count = -1;
	},
	destroy: function () {
		this._editor = null;
		this._items = [];
		this._super();
	},
	items: null,
	setEditor: function(editor) {
		this._editor = editor;
	},
	isNull: function() {
		return this._count == -1;
	},
	setNull: function() {
		this._count = -1;
	},
	getDateConvert: function() {
		return this._editor && this._editor._dateConverter;
	},
	count: function() {
		return this._count;
	},
	clear: function() {
		for (var i = 0, cnt = this._items.length; i < cnt ; i++) {
			this._items[i].clear();
		}
		this._items = [];
		this._count = -1;
	},
	load: function(values) {
		this.clear();
		if (!values) {
			this._count = -1;
			return;
		}
		values = _isArray(values) ? values : [values];
		var value, item;
		for (var i = 0, cnt = values.length ; i < cnt ; i++) {
			value = values[i];
			switch(value.type) {
				case "day" :
					item = new DayHoliday(this, value);
					break;
				case "date" :
					item = new DateHoliday(this, value);
					break;
			}
			if (item.count() > 0) {
				this._items.push(item);
			};

		};
		this._count = this._items.length;
	},
	contains: function(date) {
		for (var i = 0, cnt = this._items.length; i < cnt ; i++) {
			if (this._items[i].contains(date)) {
				return this._items[i];
			}
		}
		return null;
	}
});

var DateCellEditor = defineClass("DateCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
	    this._yearDisplayFormat = this._options.yearDisplayFormat();
	    this._monthDisplayFormat = this._options.monthDisplayFormat();
	    this._months = this._options.months();
	    this._weekDays = this._options.weekDays();
		this._list = new DatePicker(grid._container, this, this._options && (this._options._useCssStyle || this._options._useCssStyleDatePicker));
		this._list.addListener(this);
		this._closing = false;
		this._date = undefined;
		this._borderable = false;
        this._regx = /[0-9]|\.|\-|\/|a|A|p|P|m/;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p === this._list._element) {
					this._list._monthPicker.hide();
					return;
				}
				if (p === this._list._monthPicker._dom._element) {
					return;
				}
				p = p.parentNode;
			}
			this.closeUp(true);
		}.bind(this);
		this._holidayCollection = new HolidayCollection();
	},
	destroy: function() {
		this._destroying = true;
		this._globalMouseHandler = null;
		return this._super();
	},
	editFormat: null,
	minDate: new Date(1970, 0, 1),
	maxDate: new Date(2100, 11, 31),
	yearNavigation: false,
	textReadOnly: false,
	dropDownPosition: DropDownPosition.BUTTON,
	dropDownWhenClick: false,
    showToday: true,
    yearDisplayFormat: "{Y}년",
    monthDisplayFormat: "{M}월",
    months: null,
    weekDays: null,
    showWeeks: false,
    startWeek: 0,
    weekSelectable: false,
    weekSeparator:"",
    commitOnSelect:false,
    defaultShowDate: null,// normal(value가 있으면 value 없으면 현재일자 또는 직전에 보여진 일자), today(무조건 현재일자), todayWhenNull(null이면), date // null인경우 보여질 날짜.
    holidays: null,
    setMinDate: function(value) {
    	this._minDate = !value ? null : value instanceof Date ? value : typeof value == "string" ? this._dateConverter.getDateNull(value) : null;
    	this._minDate && this._minDate.setHours(0,0,0,0);
    },
    setMaxDate: function(value) {
    	this._maxDate = !value ? null : value instanceof Date ? value : typeof value == "string" ? this._dateConverter.getDateNull(value) : null;
    	this._maxDate && this._maxDate.setHours(23,59,59);
    },
    setStartWeek: function(value) {
    	value = value == null ? 0 : (isNaN(value = parseInt(value)) ? 0 : value);
    	if (value !== this._startWeek) {
    		this._startWeek = value;
    	}
    },
    setDefaultShowDate: function(value) {
    	if (value != this._defaultShowDate) {
    		switch (value) {
    			case DefaultShowDate.TODAY :
    			case DefaultShowDate.NORMAL :
    			case DefaultShowDate.TODAY_WHEN_NULL :
    				break;
    			default :
    				var date = typeof value == "string" ? this._dateConverter.getDateNull(value) : value instanceof Date ? value : null;
    				value = date || "normal";
    		}
    		this._defaultShowDate = value;
    	}
    },
    setHolidays: function(value) {
		this._holidays = value;
		if (value) {
			this._holidayCollection = this._holidayCollection || new HolidayCollection();
			this._holidayCollection.setEditor(this);
			this._holidayCollection.load(value);
		} else {
			this._holidayCollection.setNull();
		}
    },
	editFormat_: function () {
		return this._datetimeFormat;
	},
	setEditFormat: function (value) {
		this.setDatetimeFormat(value);
	},
	isListing: function () {
		return this._list.isListing();
	},
	isMonthListing: function () {
		return this._list.isMonthListing();
	},
	dropDown: function () {
		if (!this.isReadOnly() && !this._controller._readOnly && !this.isListing() && !this._closing) {
			var list = this._list;
            var r = Dom.getBounds(this._container);
            list.setViewGridInside(this._options && this._options._viewGridInside);
			list.setYearNavigation(this._yearNavigation);
			list.setDropDownPosition(this._dropDownPosition);
            list.setShowToday(this._showToday);
            list.setYearDisplayFormat(this._yearDisplayFormat);
            list.setMonthDisplayFormat(this._monthDisplayFormat);
            list.setMonths(this._months);
            list.setMinDate(this._minDate);
            list.setMaxDate(this._maxDate);
            list.setShowWeeks(this._showWeeks);
            list.setStartWeek(this._startWeek || 0);
            list.setWeekSelectable(this.isWeekSelectable());
            list.setWeekSeparator(this._weekSeparator);
            list.setListZIndex(this.getListZIndex());
            list.setHolidays(this._holidayCollection.isNull() ? this._options._holidayCollection : this._holidayCollection);
            if (this._weekDays && this._weekDays.length > 0)
            	list.setWeekDays(this._weekDays);
			this.$_setListDate();
			// list.show(this._parentElement, r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
            list.show(_doc.documentElement, r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
			$_evl ? _win.addEventListener("mousedown", this._globalMouseHandler) : _win.attachEvent("onmousedown", this._globalMouseHandler);
			return true;
		}
		return false;
	},
	closeUp: function (accept) {
		if (this.isListing()) {
			this._closing = true;
			try {
				$_evl ? _win.removeEventListener("mousedown", this._globalMouseHandler) : _win.detachEvent("onmousedown", this._globalMouseHandler);				
				this._list.hide();
				if (accept && this._list.isSelected()) {
					this.$_selectDate(this._list.date());
	                this._commitOnSelect && this._dispatchCommit();
				}
			} finally {
				this._closing = false;
			}
			return true;
		}
		return false;
	},
	initOptions: function () {
		this._super();
		this._dropDownWhenClick = false;
		this._yearNavigation = false;
		this._textReadOnly = false;
        this._showToday = true;
		this._minDate = new Date(1970, 0, 1);
		this._maxDate = new Date(2100, 11, 31);
		this._showWeeks = false;
		this._startWeek = 0;
		this._weekSelectable = false;
		this._weekSeparator = "";
		this._commitOnSelect = false;
		this._defaultShowDate = "normal";
		this._holidayCollection && this._holidayCollection.setNull();
	},
    _isDateEditor: function () {
    	var valueType = this._editField().dataType();
        return valueType == ValueType.DATE || valueType == ValueType.DATETIME || !this.isWeekSelectable();// 
    },
	hasButton: function () {
		return true;
	},
	setEditIndex: function (index) {
		this._super(index);
		var dataType = this._editField().dataType();
		this._weekSelectable = this._weekSelectable && dataType !== ValueType.DATE && dataType !== ValueType.DATETIME;
		// if (this._textReadOnly) {
		// 	this._editor.readOnly = true;
		// }
	},
	setEditValue: function (value) {
		this._super(value);
		if (this.isWeekSelectable()) {
			this._date = $_getWeekThurs(value)
		} else {
			this._date = typeof value === "string" ? this._dateConverter.getDateNull(value) : value;
		}
		this._editor.value = this.$_valToStr(value);
	},
	setCellEditValue: function(value, dropdown) {
		this._super(value, dropdown);
	},
	getEditValue: function (throwError, validateValue) {
		var v = this._super(throwError);
		var valueType = this._editField().dataType();
		if (v && validateValue && ( valueType == ValueType.DATE || valueType == ValueType.DATETIME )) {
			v = this._minDate ? Math.max(this._minDate, v) : v;
			v = this._maxDate ? Math.min(this._maxDate, v) : v;
			v && (v = new Date(v));
		}
		return v;
	},
	_createContainer: function () {
		var elt = this._super();
		elt.style.border = "none";
		elt.style.boxShadow = "none";
		return elt;
	},
	_createEditor: function (parent) {
		var editor = this._super(parent);
		return editor;
	},
	_textHandler: function () {
		this._requestStart();
	},
	_compositionstartHandler: function (e) {
		this._requestStart(e);
	},
	_keyDownHandler: function (e) {
		var list = this._list;
		if (list.isMonthListing()) {
			if (e.keyCode == Keys.ESCAPE) {
				this.closeMonthList();
				e.preventDefault();
				e.stopImmediatePropagation();
				return true;
			}
			return false;
		}
		var listing = this.isListing();
		var focused = listing && list.isFocused();
		switch (e.keyCode) {
			case Keys.ENTER:
				if (this.closeUp(true)) {
					e.preventDefault();
					e.stopImmediatePropagation();
					return !this._sendToParent(e);
				}
				break;
			case Keys.ESCAPE:
				if (this.closeUp(false)) {
					e.preventDefault();
					e.stopImmediatePropagation();
					return true;
				}
				break;
			case Keys.HOME:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.firstDay());
					return true;
				}
				break;
			case Keys.END:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.lastDay());
					return true;
				}
				break;
			case Keys.LEFT:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.incDay(-1));
					return true;
				}
				break;
			case Keys.RIGHT:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.incDay(1));
					return true;
				}
				break;
			case Keys.PAGEUP:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.incMonth(-1));
					return true;
				}
				break;
			case Keys.PAGEDOWN:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.incMonth(1));
					return true;
				}
				break;
			case Keys.DOWN:
				if (e.altKey && !this.isListing()) {
					this._requestStart();
					e.preventDefault();
					e.stopImmediatePropagation();
					return true;
				} else if (this.isListing()) {
					e.preventDefault();
					e.stopImmediatePropagation();
					if (focused) {
						this.$_selectDate(list.incDay(7));
					} else {
						this._list.setFocused(true);
						this.$_setListDate();
					}
					return true;
				}
				break;
			case Keys.UP:
				if (e.altKey && this.isListing()) {
					this.closeUp(false);
					e.preventDefault();
					e.stopImmediatePropagation();
					return true;
				} else if (this.isListing()) {
					e.preventDefault();
					e.stopImmediatePropagation();
					if (focused) {
						var d = list.date();
						if (d.getDate() <= 7) {//} && d.getDay() + 1 >= d.getDate()) {
							this._list.setFocused(false);
						} else {
							this.$_selectDate(list.incDay(-7));
						}
					} else {
						this._list.setFocused(false);
					}
					return true;
				}
				break;
            case Keys.T:
                if ((e.altKey || e.altKey && e.ctrlKey) && this.isListing()) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    this._list.setDate(new Date());
					this.$_selectDate(this._list._date);
                }
                break;
		}
		return this._super(e);
	},
	_keyPressHandler: function (e) {
        var list = this._list;
        var c = String.fromCharCode(e.keyCode || e.charCode);
        if (c.toLocaleLowerCase() == this.todayChar()) {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (this.isListing()) {
                list.setFocused(true);
                this.$_selectDate(list.today());
                return true;
            }
        } else {
	        if (_isFirefox && (e.ctrlKey || e.charCode === 0)) {
	                this._super(e);
	                return;
	        }
        	if (!this._regx.test(c)) {
                e.preventDefault();
                return;
            }
        }
		this._super(e);
		e.keyCode && /* e.keyCode === Keys.SPACE &&*/ this.isTextReadOnly && this.isTextReadOnly() && e.preventDefault();
	},
    $_resetValue: function () {
		if (this.isVisible()) {
			var s = this._editor.selectionStart;
			var p = this._editor.selectionEnd;
			var plen = this._editor.value ? this._editor.value.length : 0;
			this._editor.value = this._editor.value.replace($$_HANGUL_REG, '');
			var alen = this._editor.value ? this._editor.value.length : 0;
			alen == plen ? this._editor.setSelectionRange(s, p) : this._editor.setSelectionRange(p, p); 
		}
    },
    _dispatchChange: function () {
        if (this.isVisible()) {
            this.$_resetValue();
            this._super();
        }
    },
	_changeHandler: function (e) {
		return this._super(e);
	},
	_pasteHandler: function (e) {
		return this._super(e);
	},
	_copyHandler: function (e) {
		return this._super(e);
	},
	_requestStart: function (dropdown) {
		if (this._super()) {
			dropdown !== false && this.dropDown();
			return true;
		}
		return false;
	},
	setBounds: function (x, y, w, h) {
		x += 2;
		y += 2;
		w -= 4;
		h -= 4;
		this._super(x, y, w, h);
	},
	_doChanged: function () {
		!this._started && this._requestStart();
		// date Editor에서 this._readOnly=false// this._controller._readOnly를 이용해서 처리해야 한다.
		// input element의 readOnly는 textReadOnly를 따라간다.
		if (this._started && !this._controller._readOnly && this._controller._editable) {
			this._modified = true;
			this._dispatchChange();
		}
	},
	dropDownList: function (force) {
		this.dropDown(force);
	},
	closeList: function (accept) {
		this.closeUp(accept);
	},
	closeMonthList: function () {
		this._list.closeMonth();
	},
	buttonClicked: function (index) {
		this.isListing() ? this.closeUp(false) : this.dropDown();
	},
	$_selectDate: function (d) {
		if (d && d != this._date) {
			this._date = d;
			if (this.containsRange(d)) {
				var s;
				if (this.isWeekSelectable()) {
					s = $_getYearWeeks(d, this._startWeek, this._weekSeparator);
				} else {
					s = this._dateConverter.getText(this._date);	
				}
				if (this._mask) 
					s = this._mask.writeBuffer(s);
				this._editor.value = s;
				// this._dispatchChange();
				this._doChanged();
			} else {

			}
		}
	},
	$_setListDate: function () {
		var d;
		var s = this._editor.value;
		s && this._mask && (s = this._mask.getStripValue(s));
		if (this.isWeekSelectable()) {
			d = $_getWeekThurs(s);
		} else {
			d = this._dateConverter.getDateNull(s);
		}
		switch (this._defaultShowDate) {
			case DefaultShowDate.TODAY :
				d = new Date();
				break;
			case DefaultShowDate.NORMAL :
				break;
			case DefaultShowDate.TODAY_WHEN_NULL :
				d = d || new Date();
				break;
			default :
				d = d || (typeof this._defaultShowDate === "string" ? this._dateConverter.getDateNull(s) : this._defaultShowDate instanceof Date ? this._defaultShowDate : null);
		}
		if (d) {
			this._list.setDate(d);
		}
	},
	onDatePickerCloseUp: function (list, accept) {
		this.closeUp(accept);
		!_isMobile() && this.setFocus();
	},
	containsRange: function(value) {
		return (!this._minDate || value >= this._minDate) && (!this._maxDate || value <= this._maxDate)
	}
},{

});
var /* internal */ DatePicker = defineClass("DatePicker", EventAware, {
	init: function (container, editor, useCssStyle) {
		this._super();
		this._useCssStyle = useCssStyle;
		this._editor = editor;
		this._container = container;
		this._containerElement = null;
		this._headerElement = null;
		this._headElement = null;
        this._todayElement = null;

	    this._yearDisplayFormat = editor.yearDisplayFormat();
	    this._monthDisplayFormat = editor.monthDisplayFormat();
	    this._months = editor.months();
	    this._weekDays = $$_week_days;
		this._date = new Date();
		this._currDate = null;
		this._today = null;
		this._selected = false;
		
		this._cellBackground = "#f5f5f5";
		this._todayBackground = "#d5d5d5";
		this._focusedBackground = "rgba(255, 255, 0, 0.3)";
		this._hoveredBackground = "";// "rgba(0, 255, 0, 0.2)";
		this._prevBackground = "";

		this._cellBorder = "1px solid #eee";
		this._nullBorder = "1px solid #fff";
		this._focusedBorder = "1px solid #aaa";
		this._todayBorder = "1px solid #aaa";
		this._hoveredBorder = "1px solid #000";

		this._cellColor = "#333";
		this._nullColor = "#ccc";
		this._prevColor = "#565656";

        this._focused = true;
		this._mouseoverHandler = function (e) {
			var td = e.currentTarget;
			var date2 = this.$_getCellDate(this._currDate, td.$_day+1);
			var innerDate = this._editor.containsRange(date2);
			var holiday = this._holidays && this._holidays.contains(date2);
			td.style.background = holiday && innerDate ? holiday.styles().background().css() : innerDate ? this._hoveredBackground : "";
			innerDate && holiday && (td.style.color = holiday.styles().foreground().css());
			td.style.border = innerDate ? this._hoveredBorder : this._nullBorder;
			if (innerDate && holiday && holiday.getTooltip(date2)) {
				td.title = holiday.getTooltip(date2);
			}
		}.bind(this);
		this._mouseoutHandler = function (e) {
			var date = this._currDate;
			var y = date.getFullYear();
			var m = date.getMonth();
			var mdays = $$_month_days[_isLeapYear(y) ? 1 : 0][m];
			var td = e.currentTarget;
			var d = td.$_day;
			var date2 = this.$_getCellDate(this._currDate, td.$_day+1);
			var innerDate = this._editor.containsRange(date2);
			var holiday = this._holidays && this._holidays.contains(date2);
			var tooltip;
			if (d < 0 || d >= mdays) {
				td.style.background = "";
				td.style.border = this._nullBorder;
				td.style.color = innerDate ? this._prevColor : this._nullColor;
			} else if (this.$_isFocusedDay(this._currDate, d + 1)) {
				td.style.background = this._focusedBackground;
				td.style.border = this._focusedBorder;
				td.style.color = innerDate ? this._cellColor : this._nullColor;
			} else if (this.$_isToday(this._currDate, d + 1)) {
				td.style.background = this._todayBackground;
				td.style.border = this._todayBorder;
				td.style.color = innerDate ? this._cellColor : this._nullColor;
			} else {
				td.style.background = innerDate && holiday ? holiday.styles().background().css() : this._cellBackground;
				td.style.border = this._cellBorder;
				td.style.color = innerDate ? (holiday ? holiday.styles().foreground().css() : this._cellColor) : this._nullColor;
			}
		}.bind(this);
		this._yearWeekmouseoverHandler = function(e) {
			var td = e.currentTarget;
			var innerDate = this._editor.containsRange($_getWeekThurs(e.currentTarget.$_yearWeek));
			td.style.background = innerDate ? this._hoveredBackground : "";
			td.style.border = innerDate ? this._hoveredBorder : this._nullBorder;
			td.style.color = innerDate ? this._cellColor : this._nullColor;
		}.bind(this);
		this._yearWeekmouseoutHandler = function(e) {
			var td = e.currentTarget;
			var innerDate = this._editor.containsRange($_getWeekThurs(e.currentTarget.$_yearWeek));
			var isFocusedWeek = this.$_isFocusedWeek(this._currDate, e.currentTarget.$_yearWeek)
			td.style.background = isFocusedWeek ? this._focusedBackground : this._cellBackground;
			td.style.border = isFocusedWeek ? this._focusedBorder : innerDate ? this._cellBorder : this._nullBorder;
			td.style.color = innerDate ? this._cellColor : this._nullColor;
		}.bind(this);
		this._clickHandler = function (e) {
			var d = this.$_getCellDate(this._currDate, e.currentTarget.$_day+1);
			if (!this._editor.containsRange(d)) {
				// 선택할수 없다.
				return;
			}
			var holiday = this._holidays && this._holidays.contains(d);
			if (holiday && !holiday.isEnabled()) {
				return;
			}
			this._date = new Date(d);
			this._selected = true;
			this.fireEvent(DatePicker.CLOSE_UP, true);
		}.bind(this);
		this._yearWeekClickHandler = function(e) {
			var week = e.currentTarget.$_yearWeek;
			var d;
			week && ( d = $_getWeekThurs(week) );
			if (!d || !this._editor.containsRange(d)) {
				return;
			};
			this._date = new Date(d);
			this._selected = true;
			this.fireEvent(DatePicker.CLOSE_UP, true);
		}.bind(this);
		this._dom = new Dom(this._element = this.$_createPicker());
		this._monthPicker = new MonthPicker(editor, this._element, this._useCssStyle);
		this._monthPicker.addListener(this);
	},
	minWidth: 0,
	maxWidth: 0,
	minDate: null,
	maxDate: null,
	yearNavigation: false,
	dropDownPosition: DropDownPosition.BUTTON,
    showToday: true,
    yearDisplayFormat: null,
    monthDisplayFormat: null,
    months: null,
    viewGridInside: false,
    showWeeks: false,
    startWeek: 0,
    weekSelectable: false,
    weekSeparator:"",
    holidays: null,
    listZIndex: 3000,
	date: function () {
		return this._date;
	},
	$_getCellDate: function (value, date) {
		var ret = new Date(value);
		ret.setDate(date);
		return ret;
	},
	setDate: function (value) {
		if (value.getTime() != this._date.getTime()) {
			this._currDate = new Date(value);
			this._date = new Date(value);
			if (this.isListing()) {
                this.$_buildCalendar();
			}
		}
		return this._date;
	},
	setWeekDays: function (value) {
		if (value != this._weekDays) {
			if (_isArray(value) && value.length >= 7) {
				this._weekDays = value;
			} else {
				this._weekDays = $$_week_days;
			}
		}
	},
	setHolidays: function (holidays) {
		this._holidays = holidays;
	},
	isListing: function () {
		return this._containerElement && this._containerElement.contains(this._element);
	},
	isMonthListing: function () {
		return this._monthPicker.isListing();
	},
	closeMonth: function () {
		this._monthPicker.hide(0);
	},
	isSelected: function () {
		return this._selected;
	},
	isFocused: function () {
		return this._focused;
	},
    setFocused: function (value) {
        if (value != this._focused) {
			this._focused = value;
			this._element.style.border = value ? "1px solid rgba(50, 50, 50, 1)" : "1px solid rgba(50, 50, 50, 0.3)";
			this._element.style.boxShadow = value ? "rgba(0, 0, 0, 0.8) 1px 2px 5px" : "rgba(0, 0, 0, 0.5) 1px 2px 5px";
			this._headerElement.style.backgroundColor = value ? "rgba(0, 200, 200, 0.1)" : "#e8e8e8";
			this._headElement.style.opacity = value ? "1.0" : "0.5";
			if (this._useCssStyle) {

			} else {
				this._headerElement.style.backgroundColor = value ? "rgba(0, 200, 200, 0.1)" : "#e8e8e8";
			}
        }
    },
	show: function (containerElement, x, y, cellWidth, editBounds) {
		this._containerElement = this._viewGridInside ? this._container._container : containerElement;
		this.$_show(x, y, cellWidth, editBounds);
	},
	hide: function () {
		this.setFocused(false);
		this._monthPicker.hide();
		this._dom.detach();
		this._containerElement = null;
	},
    today: function () {
        return this.setDate(new Date());
    },
	incDay: function (delta) {
		var d;
		if (this._date.getMonth() == this._currDate.getMonth()) {
			d = new Date(this._date);
			this._date && d.setDate(this._date.getDate() + delta);
		} else {
			d = this._currDate;
			d = new Date(d.getFullYear(), d.getMonth(), 1);
		}
		return this.setDate(d);
	},
	incMonth: function (delta) {
		var d;
		if (this._date.getMonth() == this._currDate.getMonth()) {
			d = new Date(this._date);
			this._date && _incMonth(d, delta);
		} else {
			d = this._currDate;
			d = new Date(d.getFullYear(), d.getMonth(), 1);
		}
		return this.setDate(d);
	},
	firstDay: function () {
		var d = new Date(this._currDate);
        this._date && d.setDate(1);//this._date.getDate() - this._date.getDay());
		return this.setDate(d);
	},
	lastDay: function () {
		var d = new Date(this._currDate);
		if (this._date) {
            var y = d.getFullYear();
            var m = d.getMonth();
            var mdays = $$_month_days[_isLeapYear(y) ? 1 : 0][m];
            d.setDate(mdays);//this._date.getDate() + 6 - this._date.getDay());
        }
		return this.setDate(d);
	},
	$_createPicker: function () {
		var element = Dom.createElement("div", {
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			margin: "0px",
			overflow: "auto",
			zIndex: 3000
		});
		if (this._useCssStyle) {
			element.className = "rg-calendar";
		} else {
			Dom.setStyles(element,{
				cursor: "default",
				fontFamily: "Verdana",
				fontSize: "11px",
				fontStyle: "normal",
				fontVariant: "normal",
				fontWeight: "normal",
				background: "#fff",// "rgb(233, 233, 233)",
				border: "1px solid rgba(50, 50, 50, 0.5)",
				boxShadow: "rgba(0, 0, 0, 0.5) 1px 2px 5px",
				padding: "0px"
			});
		}
		this._header = this.$_createHeader();
		element.appendChild(this._header);
		this._calendar = this.$_createCalendar();
		element.appendChild(this._calendar);
		element.addEventListener("keydown", function (e) {
			if (e.keyCode == 27) {
				if (this.isMonthLisiting()) {
					this.closeMonth();
				} else {
					this.fireEvent(DropDownList.CLOSE_UP, false);
				}
			}
		}.bind(this));
		element.addEventListener("mouseup", function (e) {
			this._editor.setFocus();
		}.bind(this));
		return element;
	},
	$_createHeader: function () {
        var list = this;
		var elt = this._headerElement = Dom.createElement("div", {
			position: "relative",
		});
		if (this._useCssStyle) {
			elt.className = "rg-cal-header"
		} else {
			Dom.setStyles(elt, {
				paddingLeft: "4px",
				paddingRight: "4px",
				paddingTop: "4px",
				paddingBottom: "0px",
				fontSize: "12px",
				backgroundColor: "#e8e8e8",
				margin: "0px"
			});
		}
		var prev = Dom.createElement("span", {
			position: "absolute",
			left: "4px",
			minWidth: "17px",
			minHeight: "17px",
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		if (this._useCssStyle) {
			prev.className = "rg-cal-prev-month";
		} else {
			Dom.setStyles(prev, {
				top: "3px",
				backgroundImage: _getAsset("cal_prev.png") }
			);
		}
		elt.appendChild(elt.$_prev = prev);
		prev.onclick = function (e) {
			!this._useCssStyle && Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev_hover.png")
			});
            _incMonth(this._currDate, -1);
			this.$_buildCalendar();
		}.bind(this);
		prev.onmouseover = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev_hover.png")
			});
		};
		prev.onmousedown =  this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev_active.png")
			});
		};
		prev.onmouseout =  this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_prev.png")
			});
		};
		var next = Dom.createElement("span", {
			position: "absolute",
			right: "4px",
			minWidth: "17px",
			minHeight: "17px",
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		if (this._useCssStyle) {
			next.className = "rg-cal-next-month";
		} else {
			Dom.setStyles(next,{
				top: "3px",
				backgroundImage: _getAsset("cal_next.png"),
			})
		}
		elt.appendChild(elt.$_next = next);
		next.onclick = function (e) {
			!this._useCssStyle && Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next_hover.png")
			});
            _incMonth(this._currDate, 1);
			this.$_buildCalendar();
		}.bind(this);
		next.onmouseover = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next_hover.png")
			});
		};
		next.onmousedown = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next_active.png")
			});
		};
		next.onmouseout = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_next.png")
			});
		};
        var today = this._todayElement = Dom.createElement("span", {
            position: "absolute",
            right: "18px",
            top: "2px",
        });
        if (this._useCssStyle) {
        	today.className = "rg-cal-today-button";
        } else {
        	Dom.setStyles(today,{
	            padding: "2px",
	            fontSize: "10px",
	            border: "1px solid transparent",
	            borderRadius: "3px"
        	})
        }
        elt.appendChild(today);
        today.innerHTML = "Today";
        today.onclick = function (e) {
        	var date = new Date();
        	// if (!list._editor.containsRange(date)) {
        	// 	return;
        	// }
            list.setFocused(true);
            list.setDate(new Date());
			list._editor.$_selectDate(list._currDate);
        };
        today.onmouseover = this._useCssStyle ? null : function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "#00f",
                border: "1px solid #aaa",
                backgroundColor: "#fff",
                textDecoration: "underline"
            });
        };
        today.onmouseup = this._useCssStyle ? null : function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "#00f",
                border: "1px solid #aaa",
                backgroundColor: "#fff"
            });
        };
        today.onmousedown = this._useCssStyle ? null : function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "#800",
                backgroundColor: "#eee"
            });
        };
        today.onmouseout = this._useCssStyle ? null : function (e) {
            Dom.setStyles(e.currentTarget, {
                color: "",
                border: "1px solid transparent",
                backgroundColor: "",
                textDecoration: ""
            });
        };
		var title = Dom.createElement("div", {
			position: "relative",
			textAlign: "center",
			marginLeft: "20px",
			marginRight: "50px"
		});
		elt.appendChild(elt.$_title = title);
		if (this._useCssStyle) {
			title.className = "rg-cal-yearmonth";
		}
		var year = Dom.createElement("span", {
			position: "relative",
			verticalAlign: "top",
			height: "16px"
		});
		if (this._useCssStyle) {
			year.className = "rg-cal-year";
		}
		title.appendChild(title.$_year = year);
		year.innerHTML = "2015년";
		year.onclick = function (e) {
		};
		var yearSpin = this.$_createYearSpin();
		title.appendChild(title.$_yearSpin = yearSpin);
		var month = Dom.createElement("span", {
			position: "relative",
			verticalAlign: "top"
		});
		if (this._useCssStyle) {
			month.className = "rg-cal-month";
		}
		title.appendChild(title.$_month = month);
		month.innerHTML = "1월";
		month.onmousedown = function (e) {
			e.preventDefault();
			e.stopImmediatePropagation();
			/*
			var r = Dom.getBounds(this._headerElement.$_title.$_month);
			var x = r.left + (window.pageXOffset || document.documentElement.scrollLeft);
			var y = r.top + (window.pageXOffset || document.documentElement.scrollLeft);
			this._monthPicker.show(this._containerElement, x, y);
			*/
			var p = Dom.getOffset(this._headerElement.$_title.$_month);
			this._monthPicker.show(this._containerElement, p.x, p.y, this._viewGridInside);
		}.bind(this);
		return elt;
	},
	$_createYearSpin: function () {
		var div = Dom.createElement("div", {
			display: "inline-block",
			visibility: "hidden",
			position: "relative",
			width: "15px",
			height: "16px",
			marginLeft: "-4px",
			marginRight: "2px"
		});
		var upper = Dom.createElement("span", {
			position: "absolute",
			top: "0px",
			left: "0px",
			width: "15px",
			height: "9px",
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		if (this._useCssStyle) {
			upper.className = "rg-cal-next-year"
		} else {
			Dom.setStyles(upper, {
				backgroundImage: _getAsset("cal_up.png")
			});
		}
		div.appendChild(upper);
		upper.onclick = function (e) {
			!this._useCssStyle && Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up_hover.png")
			});
			this._currDate.setFullYear(this._currDate.getFullYear() + 1);
			this.$_buildCalendar();
		}.bind(this);
		upper.onmouseover = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up_hover.png")
			});
		};
		upper.onmousedown = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up_active.png")
			});
		};
		upper.onmouseout = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_up.png")
			});
		};
		var lower = Dom.createElement("span", {
			position: "absolute",
			top: "7px",
			left: "0px",
			width: "15px",
			height: "9px",
			backgroundRepeat: "no-repeat",
			backgroundPosition: "center center"
		});
		if (this._useCssStyle) {
			lower.className = "rg-cal-prev-year"
		} else {
			Dom.setStyles(lower, {
				backgroundImage: _getAsset("cal_down.png")
			});
		}
		div.appendChild(lower);
		lower.onclick = function (e) {
			!this._useCssStyle && Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down_hover.png")
			});
			this._currDate.setFullYear(this._currDate.getFullYear() - 1);
			this.$_buildCalendar();
		}.bind(this);
		lower.onmouseover = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down_hover.png")
			});
		};
		lower.onmousedown = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down_active.png")
			});
		};
		lower.onmouseout = this._useCssStyle ? null : function (e) {
			Dom.setStyles(e.currentTarget, {
				backgroundImage: _getAsset("cal_down.png")
			});
		};
		return div;
	},
	$_createCalendar: function () {
		var weeks = ["sun","mon","tue","wed","thu","fri","sat"];
		var elt = Dom.createElement("table", {
			margin: "2px"
		});
		elt.cellSpacing = 3;
		if (this._useCssStyle) {
			elt.className = "rg-cal-days-table";
		}
		var head = this._headElement = Dom.createElement("thead", {
		});
		if (this._useCssStyle) {
			head.className = "rg-cal-weeks";
		}
		elt.appendChild(elt.$_head = head);
		var i, cells, span;
		var tr = Dom.createElement("tr");
		head.appendChild(tr);
		cells = [];
		var th = Dom.createElement("th",{
			minWidth: "20px",
			textAlign: "center"
		});
		if (this._useCssStyle) {
			th.className = "rg-cal-week-year-week";
		} else {

		}
		tr.appendChild(th);
		var span = Dom.createElement("span", {
		});
		th.appendChild(span);
		head.$_weeks = th;
		for (i = 0; i < 7; i++) {
			var th = Dom.createElement("th", {
				minWidth: "20px",
				textAlign: "center"
			});
			if (this._useCssStyle) {
				th.className = "rg-cal-week-"+weeks[i];
			}
			tr.appendChild(th);
			var span = Dom.createElement("span", {
			});
			span.innerHTML = Dom.htmlEncode(this._weekDays[i]);
			th.appendChild(span);
			cells.push(span);
		}
		head.$_cells = cells;
		var body = Dom.createElement("tbody", {
		});
		if (this._useCssStyle) {
			body.className = "rg-cal-days";
		} else {
			Dom.setStyles(body,{
				fontSize:"10px"
			})
		}
		elt.appendChild(elt.$_body = body);

		var rows = body.$_rows = [];
		var yearweeks = body.$_yearweeks = [];
		for (var r = 0; r < 6; r++) {
			var tr = Dom.createElement("tr", {
			});
			body.appendChild(tr);
			rows.push(tr);
			tr.$_cells = cells = [];
			// 년주차를 표시.
			var td = Dom.createElement("td",{
				padding:"1px"
			});
			if (this._useCssStyle) {
				td.className = "rg-cal-day rg-cal-year-weeks";
			} else {
				Dom.setStyles(td,{
					textAlign: "center",
					color: this._cellColor,
					background: "#f0f0f0",
					borderRadius: "1px",
					fontSize:"8px"
				})
			}
			tr.appendChild(td);
			td.onmouseover = this._useCssStyle ? null : this._yearWeekmouseoverHandler;
			td.onmouseout = this._useCssStyle ? null : this._yearWeekmouseoutHandler;
			// td.onclick = this._yearWeekClickHandler;
			span = Dom.createElement("span", {
			});
			td.appendChild(td.$_span = span);
			yearweeks.push(td);
			// 여기까지.
			for (i = 0; i < 7; i++) {
				var td = Dom.createElement("td", {
					padding: "1px",
				});
				if (this._useCssStyle) {
					td.className = "rg-cal-day rg-cal-week-"+weeks[(i + this._startWeek) % 7];
				} else {
					Dom.setStyles(td,{
						textAlign: "right",
						color: this._cellColor,
						background: "#f0f0f0",
						borderRadius: "1px"
					})
				}
				tr.appendChild(td);
				td.onmouseover = this._useCssStyle ? null : this._mouseoverHandler;
				td.onmouseout = this._useCssStyle ? null : this._mouseoutHandler;
				td.onclick = this._clickHandler;
				span = Dom.createElement("span", {
				});
				td.appendChild(td.$_span = span);
				cells.push(td);
			}
		}
		return elt;
	},
	$_show: function (x, y, cellWidth, editBounds) {
		this.setFocused(false);
		this._selected = false;
		this._header.$_title.$_yearSpin.style.visibility = this._yearNavigation ? "visible" : "hidden";
        this._todayElement.style.display = this._showToday ? "initial" : "none";
        this._header.$_title.style.marginRight = this._showToday ? "50px" : "20px";
		var d = this._date;
		if (!(d instanceof Date) || d == "Invalid Date") {
			d = null;
		}
		this._currDate = d ? new Date(d) : new Date();
		this._today = new Date();
		this.$_buildCalendar();
		this._dom.disableSelection();
		this._dom.setStyles({zIndex:this._listZIndex});

		this._containerElement.appendChild(this._dom.element());
        var br = _getBrowserSize();
        var pr = Dom.getBounds(this._containerElement);
		var cr = Dom.getBounds(this._container._container);
        var w = br.width; // this._container.width(); // _container: grid container
        var h = br.height; //this._container.height();
		var r = this._dom.getBounds();
        var sx = window.pageXOffset || document.documentElement.scrollLeft;
        var sy = window.pageYOffset || document.documentElement.scrollTop;
        if (document.documentElement.scrollWidth > document.documentElement.clientWidth) {
            h -= 18;
        }
        if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
            w -= 18;
        }
        x += cr.left - pr.left;
        y += cr.top - pr.top;
		if (_ieTen || _ieOld || _ieLeg) {
			x += document.documentElement.scrollLeft;
			y += document.documentElement.scrollTop;
		}
		if (y + r.height > h + sy) {
			y = y - editBounds.height - r.height;
			if (y < 0) {
				y = h - r.height - 2;
			}
		}
		if (this._dropDownPosition != DropDownPosition.EDITOR) { // BUTTON 이거나 잘못된 값.
			x = Math.max(0, x + cellWidth - r.width);
		} else {
			if (x + r.width > w + sx) {
				x = w - r.width;
			}
		}
		if (this._viewGridInside) {
			y = editBounds.bottom - pr.top + 2;
			if ( (pr.bottom < editBounds.bottom+r.height) || (h+sy < editBounds.bottom+r.height)) {
				y = editBounds.top - r.height - pr.top - 2;
			}
		}
		this._dom.move(Math.max(0, x), Math.max(0, y));
	},
	$_checkFocusedWeek: function(date, weekElt, innerDate) {
		var focused = this.$_isFocusedWeek(date, weekElt.$_yearWeek);
		if (this._useCssStyle) {
			weekElt.className = "rg-cal-week-year-week " + focused ? "rg-cal-week-year-focusweek" : null;
		} else {
			Dom.setStyles(weekElt, {
				background: focused ? this._focusedBackground : this._cellBackground,
				border: focused ? this._focusedBorder : this._cellBorder,
				color: innerDate ? this._cellColor : this._nullColor
			})
		}
	},
	$_isFocusedWeek: function(date, yearWeek) {
		return date && yearWeek && $_getYearWeeks(date, this._startWeek) == yearWeek;
	},
	$_isFocusedDay: function (date, day) {
		var t = _asDate(this._date);
		return t && date.getFullYear() == t.getFullYear() &&
				date.getMonth() == t.getMonth() &&
				day == t.getDate();
	},
	$_isToday: function (date, day) {
		var t = _asDate(this._today);
		return t && date.getFullYear() == t.getFullYear() &&
			date.getMonth() == t.getMonth() &&
			day == t.getDate();
	},
	$_buildCalendar: function () {
		var weeks = ["sun","mon","tue","wed","thu","fri","sat"];
		var i, cnt, cells;
		var header = this._header;
		var date = this._currDate;
		var prev = header.$_prev;
		var next = header.$_next;
		var title = header.$_title;
		var y = date.getFullYear();
		var m = date.getMonth();
		var holiday;
		title.$_year.innerHTML = (this._yearDisplayFormat ? this._yearDisplayFormat.replace("{Y}", y) : y + "년") + "&nbsp;";
		if (this._months && this._months.length > 0)
			title.$_month.innerHTML = this._months[m];
		else
			title.$_month.innerHTML = this._monthDisplayFormat ? this._monthDisplayFormat.replace("{M}", m + 1) : (m + 1) + "월";

		if (m == 0) {
			prev.title = (y - 1) + "/12";
		} else {
			prev.title = y + "/" + _pad(m);
		}
		if (m == 11) {
			next.title = (y + 1) + "/01";
		} else {
			next.title = y + "/" + _pad(m + 2);
		}
		cells = this._calendar.$_head.$_cells;
		for (i = 0; i < 7; i++) {
			var elt = cells[(i + 7 - this._startWeek) % 7];
			elt.innerHTML = Dom.htmlEncode(this._weekDays[i]);
			if (this._useCssStyle) {
				var th = elt.parentElement;
				th.className = "rg-cal-week-"+weeks[i];
			}
		}
		this._calendar.$_head.$_weeks.style.display = this.isShowWeeks() ? "" : "none";
		var body = this._calendar.$_body;
		var yearWeeks = body.$_yearweeks;  // td array
		for (i = 0, cnt = yearWeeks.length; i < cnt ; i++) {
			yearWeeks[i].style.display = this.isShowWeeks() ? "" : "none";
			yearWeeks[i].onclick = this.isWeekSelectable() ? this._yearWeekClickHandler : null;
		}
		var rows = body.$_rows;
		var mdays = $$_month_days[_isLeapYear(y) ? 1 : 0][m];
		var d = new Date(date);
		d.setDate(1);
		var dow = (d.getDay() + 7 - this._startWeek) % 7;
		if (mdays == 30 && dow == 6 || mdays == 31 && dow >= 5) {
			Dom.addChild(body, rows[5]);
		} else {
			Dom.removeChild(body, rows[5]);
		}
		if (mdays == 28 && dow == 0) {
			Dom.removeChild(body, rows[4]);
		} else {
			Dom.addChild(body, rows[4]);
		}
		var c;
		var md = 0;
		var innerDate;
		cells = rows[0].$_cells;
		var weekElt = yearWeeks[0];
		if (dow > 0) {
			var y2 = y;
			var m2 = m - 1;
			if (m2 < 0) {
				y2--;
				m2 = 11;
			}
			var mdays2 = $$_month_days[_isLeapYear(y2) ? 1 : 0][m2];
			for (i = 0; i < dow; i++) {
				c = cells[i];
				c.removeAttribute("title");
				d = new Date(this._currDate);
				c.$_day = i - dow;
				d.setDate(c.$_day+1);
				innerDate = this._editor.containsRange(d);
				if (i === 0) {
					weekElt.$_yearWeek = $_getYearWeeks(d, this._startWeek);
					weekElt.$_span.innerText = weekElt.$_yearWeek.substr(4,2);
					this.$_checkFocusedWeek(this._currDate, weekElt, innerDate);
				}
				c.$_span.innerHTML = (mdays2 - dow + i + 1);
				if (this._useCssStyle) {
					c.className = "rg-cal-day rg-cal-prev-day "+(innerDate ? "" : "rg-cal-disable-day ")+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
				} else {
					Dom.setStyles(c, {
						background: this._prevBackground,
						border: this._nullBorder,
						color: innerDate ? this._prevColor : this._nullColor
					});
				}
			}
		}
		for (i = dow; i < 7; i++) {
			c = cells[i];
			c.removeAttribute("title");
			c.$_day = md++;
			c.$_span.innerHTML = md;
			(d = new Date(this._currDate)).setDate(md);
			innerDate = this._editor.containsRange(d);
			if (i === 0) {
				weekElt.$_yearWeek = $_getYearWeeks(d, this._startWeek);
				weekElt.$_span.innerText = weekElt.$_yearWeek.substr(4,2);
				this.$_checkFocusedWeek(this._currDate, weekElt, innerDate);
			}
			if (this.$_isFocusedDay(date, md)) {
				if (this._useCssStyle) {
					c.className = "rg-cal-day rg-cal-focusday "+(innerDate ? "" : "rg-cal-disable-day ")+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
				} else {
					Dom.setStyles(c, {
						background: this._focusedBackground,
						border: this._focusedBorder,
						color: innerDate ? this._cellColor : this._nullColor
					});
				}
			} else if (this.$_isToday(date, md)) {
				if (this.useCssStyle) {
					c.className = "rg-cal-day rg-cal-today "+(innerDate ? "" : "rg-cal-disable-day ")+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
				} else {
					Dom.setStyles(c, {
						background: this._todayBackground,
						border: this._todayBorder,
						color: innerDate ? this._cellColor : this._nullColor
					});
				}
			} else {
				holiday = this._holidays && this._holidays.contains(d);
				if (this._useCssStyle) {
					c.className = "rg-cal-day "+(innerDate ? "" : "rg-cal-disable-day ")+(holiday ? "rg-cal-holiday " : "" )+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
				} else {
					if (holiday && innerDate) {
						Dom.setStyles(c, {
							background: holiday.styles().background().css(),
							border: this._cellBorder,
							color: holiday.styles().foreground().css()
						});
					} else {
						Dom.setStyles(c, {
							background: this._cellBackground,
							border: this._cellBorder,
							color: innerDate ? this._cellColor : this._nullColor
						});
					}
				}
			}
		}
		for (var r = 1; r < 6 && md < mdays; r++) {
			cells = rows[r].$_cells;
			weekElt = yearWeeks[r];
			for (i = 0; i < 7; i++) {
				if (md < mdays) {
					c = cells[i];
					c.removeAttribute("title");
					c.$_day = md++;
					(d = new Date(this._currDate)).setDate(md);
					innerDate = this._editor.containsRange(d);
					if (i === 0) {
						weekElt.$_yearWeek = $_getYearWeeks(d, this._startWeek);
						weekElt.$_span.innerText = weekElt.$_yearWeek.substr(4,2);
						this.$_checkFocusedWeek(this._currDate, weekElt, innerDate);
					}
					c.$_span.innerHTML = md;
					if (this.$_isFocusedDay(date, md)) {
						if (this._useCssStyle) {
							c.className = "rg-cal-day rg-cal-focusday "+(innerDate ? "" : "rg-cal-disable-day ")+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
						} else {
							Dom.setStyles(c, {
								background: this._focusedBackground,
								border: this._focusedBorder,
								color: innerDate ? this._cellColor : this._nullColor
							});
						}
					} else if (this.$_isToday(date, md)) {
						if (this._useCssStyle) {
							c.className = "rg-cal-day rg-cal-today "+(innerDate ? "" : "rg-cal-disable-day ")+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
						} else {
							Dom.setStyles(c, {
								background: this._todayBackground,
								border: this._todayBorder,
								color: innerDate ? this._cellColor : this._nullColor
							});

						}
					} else {
						holiday = this._holidays && this._holidays.contains(d);
						if (this._useCssStyle) {
							c.className = "rg-cal-day "+(innerDate ? "" : "rg-cal-disable-day ")+(holiday ? "rg-cal-holiday " : "" )+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
						} else if (holiday && innerDate) {
							Dom.setStyles(c, {
								background: holiday.styles().background().css(),
								border: this._cellBorder,
								color: holiday.styles().foreground().css()
							});
						} else {
							Dom.setStyles(c, {
								background: this._cellBackground,
								border: this._cellBorder,
								color: innerDate ? this._cellColor : this._nullColor
							});
						}
					}
				} else {
					var j = 1;
					for (; i < 7; i++) {
						c = cells[i];
						c.removeAttribute("title");
						c.$_day = md++;
						(d = new Date(this._currDate)).setDate(md);
						innerDate = this._editor.containsRange(d);
						c.$_span.innerHTML = j++;
						if (this._useCssStyle) {
							c.className = "rg-cal-day rg-cal-next-day "+(innerDate ? "" : "rg-cal-disable-day ")+"rg-cal-week-"+weeks[(i+this._startWeek)% 7];
						} else {
							Dom.setStyles(c, {
								background: this._prevBackground,
								border: this._nullBorder,
								color: innerDate ? this._prevColor : this._nullColor
							});
						}
					}
				}
			}
		}
	},
	$_refreshItems: function () {
	},
	$_search: function (text) {
	},
	onMonthPickerCloseUp: function (picker, month) {
		var delta = month - this._currDate.getMonth();
		if (delta) {
			_incMonth(this._currDate, delta);
			this.$_buildCalendar();
		}
		this._editor.setFocus();
	}
});
DatePicker.CLOSE_UP = "onDatePickerCloseUp";
var MonthPicker = defineClass("MonthPicker", EventAware, {
	init: function (editor,list, useCssStyle) {
		this._super();
		this._useCssStyle = useCssStyle;
		this._mouseoverHandler = function (e) {
			var div = e.currentTarget;
			div.style.background = "rgba(0, 0, 0, 0.9)";
			div.style.color = "#fff";
		}.bind(this);
		this._mouseoutHandler = function (e) {
			var div = e.currentTarget;
			div.style.background = "";
			div.style.color = "";
		}.bind(this);
		this._clickHandler = function (e) {
			e.preventDefault();
			e.stopImmediatePropagation();
			var div = e.currentTarget;
			var idx = Dom.getChildIndex(div);
			if (idx >= 0) {
				this._month = idx;
				this.fireEvent(MonthPicker.CLOSE_UP, this._month);
			}
			this.hide();
		}.bind(this);
		this._months = editor._months;
		this._dom = new Dom(this.$_createPicker());
		this._container = null;
		this._listElement = list;
	},
	month: -1,
	listElement:null,
	show: function (containerElement, x, y, innerDropDown) {
		this._container = containerElement;
		if (containerElement) {
			containerElement.appendChild(this._dom._element);
			var r = this._dom.getBounds();
			var s = Dom.getScrolled();
			if (innerDropDown && this._listElement) {
				var width = this._listElement.getBoundingClientRect().width;
				x = _int(this._listElement.style.left.replace("px","")) + width / 2;
				y = _int(this._listElement.style.top.replace("px",""));
			}
			x = Math.max(s.sx, x - r.width - 2);
			y = Math.max(s.sy, y - r.height / 2 + 13);
			this._dom.move(x, y);
		}
	},
	hide: function () {
		this._dom.detach();
		this._container = null;
	},
	isListing: function () {
		return this._container && this._container.contains(this._dom._element);
	},
	$_createPicker: function () {
		var element = Dom.createElement("div", {
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			zIndex: 3001,
		});
		if (this._useCssStyle) {
			element.className = "rg-cal-month-picker"
		} else {
			Dom.setStyles(element,{
				margin: "0px",
				cursor: "default",
				background: "#fff",
				border: "1px solid rgba(50, 50, 50, 0.5)",
				boxShadow: "rgba(0, 0, 0, 0.5) 1px 2px 5px",
				fontFamily: "Verdana",
				fontSize: "11px",
				fontStyle: "normal",
				fontVariant: "normal",
				fontWeight: "normal"
			});
		}
		element.onkeydown = function (e) {
			if (e.keyCode == 27) {
				this.hide();
			}
		}.bind(this);
		for (var i = 1; i <= 12; i++) {
			var div = Dom.createElement("div", {
				position: "relative",
				float: "none",
			});
			if (this._useCssStyle) {
				div.className = "rg-cal-month-picker-item";
			} else {
				Dom.setStyles(div,{
					paddingTop: "1px",
					paddingBottom: "1px",
					paddingLeft: "4px",
					paddingRight: "4px",
					fontFamily: "Verdana",
					fontSize: "11px",
					textAlign: "center",
					cursor: "default"
				})
			}
			Dom.disableSelection(div);
			element.appendChild(div);
			div.onclick = this._clickHandler;
			div.onmouseup = this._clickHandler;
			div.onmouseover = this._useCssStyle ? null : this._mouseoverHandler;
			div.onmouseout = this._useCssStyle ? null : this._mouseoutHandler;
			var span = Dom.createElement("span");
			span.innerHTML = Dom.htmlEncode((this._months ? this._months[i-1] : i) + " ");
			span.tabIndex = -1;
			Dom.disableSelection(span);
			div.appendChild(span);
		}
		return element;
	}
});
MonthPicker.CLOSE_UP = "onMonthPickerCloseUp";

var BTDateCellEditor = defineClass("BTDateCellEditor", TextCellEditor, {
	init: function (grid, parentElement) {
		this._super(grid, parentElement);
        this._regx = /[0-9]|\.|\-|\/|a|A|p|P|m/;
        this._date = null;
        this._closing = false;
		this._borderable = false;
		this._globalMouseHandler = function (e) {
			var p = e.target;
			while (p) {
				if (p == this._list._element) {
					return;
				}
				p = p.parentNode;
			}
			this.closeUp(true);
		}.bind(this);
	},
	destroy: function() {
		this._destroying = true;
		this._globalMouseHandler = null;
		return this._super();	
	},
	list: null,
	btOptions:null,
	textReadOnly: false,
	editFormat: null,
	minDate: new Date(1970, 0, 1),
	maxDate: new Date(2100, 11, 31),
	dropDownPosition: DropDownPosition.BUTTON,
	dropDownWhenClick: false,
	commitOnSelect: false,
    setMinDate: function(value) {
    	this._minDate = !value ? null : value instanceof Date ? value : typeof value == "string" ? this._dateConverter.getDateNull(value) : null;
    	this._minDate && this._minDate.setHours(0,0,0,0);
    },
    setMaxDate: function(value) {
    	this._maxDate = !value ? null : value instanceof Date ? value : typeof value == "string" ? this._dateConverter.getDateNull(value) : null;
    	this._maxDate && this._maxDate.setHours(23,59,59);
    },
	editFormat_: function () {
		return this._datetimeFormat;
	},
	setEditFormat: function (value) {
		this.setDatetimeFormat(value);
	},
	$_listDestroy: function() {
		var parent = this._list && this._list._element.parentElement;
		if (this._list) {
			this._list.$_destroy();
			parent.removeChild(this._list._element);
			this._list.destroy();
			delete this._list;
		}
	},
	initOptions: function () {
		this._super();
		this._dropDownWhenClick = false;
		this._textReadOnly = false;
		this._viewGridInside = false;
		this._minDate = new Date(1970, 0, 1);
		this._maxDate = new Date(2100, 11, 31);
		this._commitOnSelect = false;
	},
    _isDateEditor: function () {
        return true;
    },
	setEditValue: function (value) {
		this._super(value);
		this._date = typeof value === "string" ? this._dateConverter.getDateNull(value) : value;
		this._editor.value = this.$_valToStr(value);
	},
	setCellEditValue: function(value, dropdown) {
		this._super(value, dropdown);
	},
	getEditValue: function (throwError, validateValue) {
		var v = this._super(throwError);
		var valueType = this._editField().dataType();
		if (v && validateValue && ( valueType == ValueType.DATE || valueType == ValueType.DATETIME )) {
			v = this._minDate ? Math.max(this._minDate, v) : v;
			v = this._maxDate ? Math.min(this._maxDate, v) : v;
			v && (v = new Date(v));
		}
		return v;
	},
	isListing: function () {
		return !!this._list && this._list.isListing();
	},
	hasButton: function () {
		return true;
	},
	dropDown: function () {
		if (!this.isReadOnly() && !this._controller._readOnly && !this.isListing() && !this._closing) {
			var grid = this._grid;
			var useCssStyle = this._options._useCssStyle || this._options._useCssStyleDatePicker;
			var list = this._list = new BTCalendarList(grid._container, this, useCssStyle, this._btOptions);
			list.addListener(this);
            var r = Dom.getBounds(this._container); // input 의 div
			list.setViewGridInside(this._options && this._options._viewGridInside);
			list.setDropDownPosition(this._dropDownPosition);
            list.setMinDate(this._minDate);
            list.setMaxDate(this._maxDate);
            if (this._weekDays && this._weekDays.length > 0)
            	list.setWeekDays(this._weekDays);
			this.$_setListDate();
			list.setListZIndex(this.getListZIndex());
			list.show(_doc.documentElement, r.cx - 1, r.cy + r.height, this._cellBounds.width, Dom.getBounds(this._editor));
			$_evl ? _win.addEventListener("mousedown", this._globalMouseHandler) : _win.attachEvent("onmousedown", this._globalMouseHandler);
			return true;
		}
		return false;
	},
	closeUp: function (accept) {
		if (this.isListing()) {
			this._closing = true;
			try {
				$_evl ? _win.removeEventListener("mousedown", this._globalMouseHandler) : _win.detachEvent("onmousedown", this._globalMouseHandler);				
				if (accept && this._list.isSelected()) {
					this.$_selectDate(this._list.date());
	                this._commitOnSelect && this._dispatchCommit();
				}
			} finally {
				this.$_listDestroy();
				this._closing = false;
			}
			return true;
		}
		return false;
	},
	buttonClicked: function (index) {
		this.isListing() ? this.closeUp(false) : this.dropDown();
	},	
	dropDownList: function (force) {
		this.dropDown(force);
	},
	closeList: function (accept) {
		this.closeUp(accept);
	},
	$_setListDate: function () {
		var d;
		var s = this._editor.value;
		s && this._mask && (s = this._mask.getStripValue(s));
		d = this._dateConverter.getDateNull(s);
		if (d) {
			this._list.setDate(d);
		}
	},
	selectDate: function(d) {
		this.$_selectDate(d);
	},
	$_selectDate: function (d) {
		if (d && d != this._date) {
			this._date = d;
			if (this.containsRange(d)) {
				var s = this._dateConverter.getText(this._date);
				if (this._mask) 
					s = this._mask.writeBuffer(s);
				this._editor.value = s;
				// this._dispatchChange();
				this._doChanged();
			} else {

			}
		} else if (d === undefined) {
			this._editor.value = this._mask ? (this._mask.clearBuffer(), this._mask.writeBuffer()) : "";
			this._doChanged();
		}
	},
	containsRange: function(value) {
		return (!this._minDate || value >= this._minDate) && (!this._maxDate || value <= this._maxDate)
	},
	_requestStart: function (dropdown) {
		if (this._super()) {
			dropdown !== false && this.dropDown();
			return true;
		}
		return false;
	},
	_textHandler: function () {
		this._requestStart();
	},
	_compositionstartHandler: function (e) {
		this._requestStart(e);
	},
	_keyDownHandler: function (e) {
		var list = this._list;
		var listing = this.isListing();
		var focused = listing && list.isFocused();
		switch (e.keyCode) {
			case Keys.ENTER:
				if (this.closeUp(true)) {
					e.preventDefault();
					e.stopImmediatePropagation();
					return !this._sendToParent(e);
				}
				break;
			case Keys.ESCAPE:
				if (this.closeUp(false)) {
					e.preventDefault();
					e.stopImmediatePropagation();
					return true;
				}
				break;
			case Keys.HOME:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.firstDay());
					return true;
				}
				break;
			case Keys.END:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.lastDay());
					return true;
				}
				break;
			case Keys.LEFT:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this._list && this._list.keydown(e);
					// this.$_selectDate(list.incDay(-1));
					return true;
				}
				break;
			case Keys.RIGHT:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this._list && this._list.keydown(e);
					// this.$_selectDate(list.incDay(1));
					return true;
				}
				break;
			case Keys.PAGEUP:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.incMonth(-1));
					return true;
				}
				break;
			case Keys.PAGEDOWN:
				if (focused) {
					e.preventDefault();
					e.stopImmediatePropagation();
					this.$_selectDate(list.incMonth(1));
					return true;
				}
				break;
			case Keys.DOWN:
				if (e.altKey && !this.isListing()) {
					this._requestStart();
					e.preventDefault();
					e.stopImmediatePropagation();
					return true;
				} else if (this.isListing()) {
					e.preventDefault();
					e.stopImmediatePropagation();
					if (focused) {
						this._list && this._list.keydown(e);
						// this.$_selectDate(list.incDay(7));
					} else {
						this._list.setFocused(true);
						this.$_setListDate();
					}
					return true;
				}
				break;
			case Keys.UP:
				if (e.altKey && this.isListing()) {
					this.closeUp(false);
					e.preventDefault();
					e.stopImmediatePropagation();
					return true;
				} else if (this.isListing()) {
					e.preventDefault();
					e.stopImmediatePropagation();
					if (focused) {
						var d = list.date();
						if (d.getDate() <= 7) {//} && d.getDay() + 1 >= d.getDate()) {
							this._list.setFocused(false);
						} else {
							this._list && this._list.keydown(e);
							// this.$_selectDate(list.incDay(-7));
						}
					} else {
						this._list.setFocused(false);
					}
					return true;
				}
				break;
            case Keys.T:
                if ((e.altKey || e.altKey && e.ctrlKey) && this.isListing()) {
                    e.preventDefault();
                    e.stopImmediatePropagation();
                    this._list.setDate(new Date());
					this.$_selectDate(this._list._date);
                }
                break;
		}
		return this._super(e);
	},
	_keyPressHandler: function (e) {
        var list = this._list;
        var c = String.fromCharCode(e.keyCode || e.charCode);
        if (c.toLocaleLowerCase() == this.todayChar()) {
            e.preventDefault();
            e.stopImmediatePropagation();
            if (this.isListing()) {
                list.setFocused(true);
                this.$_selectDate(list.today());
                return true;
            }
        } else {
	        if (_isFirefox && (e.ctrlKey || e.charCode === 0)) {
	                this._super(e);
	                return;
	        }
        	if (!this._regx.test(c)) {
                e.preventDefault();
                return;
            }
        }
		this._super(e);
		e.keyCode && /* e.keyCode === Keys.SPACE &&*/ this.isTextReadOnly && this.isTextReadOnly() && e.preventDefault();
	},
	// 한글을 제거하기 위해서 사용한다.
    $_resetValue: function () {
		if (this.isVisible()) {
			var s = this._editor.selectionStart;
			var p = this._editor.selectionEnd;
			var plen = this._editor.value ? this._editor.value.length : 0;
			this._editor.value = this._editor.value.replace($$_HANGUL_REG, '');
			var alen = this._editor.value ? this._editor.value.length : 0;
			alen == plen ? this._editor.setSelectionRange(s, p) : this._editor.setSelectionRange(p, p); 
		}
    },
	setBounds: function (x, y, w, h) {
		x += 2;
		y += 2;
		w -= 4;
		h -= 4;
		this._super(x, y, w, h);
	},
    _doChanged: function() {
		this._started && this._requestStart();
		// date Editor에서 this._readOnly=false// this._controller._readOnly를 이용해서 처리해야 한다.
		// input element의 readOnly는 textReadOnly를 따라간다.
		if (this._started && !this._controller._readOnly && this._controller._editable) {
			this._modified = true;
			this._dispatchChange();
		}
    },
    _dispatchChange: function () {
        if (this.isVisible()) {
            this.$_resetValue();
            this._super();
        }
    },	
	onDatePickerCloseUp: function (list, accept) {
		this.closeUp(accept);
		this.setFocus();
	}
});

var BTCalendarList = defineClass("BTCalendarList", EventAware, {
	init: function(container, editor, useCssStyle, btOptions) {
		if (!window.jQuery) {

		}
		this._super();
		this._editor = editor;
		this._container = container;
		this._containerElement = null;
		this._useCssStyle = useCssStyle;
		this._date = new Date();
		this._btOptions = btOptions;
		var element;
		this._dom = new Dom(element = this._element = this.$_createList());
	},
	// 공통.
	destroy: function() {
		this._editor = null;
		this._container = null;
		this._containerElement = null;
		this._super();
	},
	dropDownPosition: DropDownPosition.BUTTON,
	date:null,
	minDate: null,
	maxDate: null,
    viewGridInside:false,
    listZIndex: 3000,
	setDate: function(value) {
		if (value.getTime() !== this._date.getTime()) {
			this._currDate = new Date(value);
			this._date = new Date(value);
			if (this.isListing()) {
				var dt;
				if (value instanceof Date) {
					dt = new Date(value.getFullYear(), value.getMonth(), value.getDate());
				} else {
					dt = value;
				};
				if (dt) {
					window.jQuery && jQuery(this._dom._element).datepicker("update", dt);
				}
			}
		}
		return this._date;
	},
	// 내부에서 생성된 BootStrap Datepicker삭제.
	$_destroy: function(){
		window.jQuery && jQuery(this._dom._element).datepicker("destroy");
	},
	isSelected: function () {
		return this._selected;
	},
	isFocused: function () {
		return this._focused;
	},
    setFocused: function (value) {
        if (value != this._focused) {
			this._focused = value;
			this._element.style.border = value ? "1px solid rgba(50, 50, 50, 1)" : "1px solid rgba(50, 50, 50, 0.3)";
			this._element.style.boxShadow = value ? "rgba(0, 0, 0, 0.8) 1px 2px 5px" : "rgba(0, 0, 0, 0.5) 1px 2px 5px";
			if (this._useCssStyle) {
			} else {
			}
        }
    },
    keydown:function(e) {
    	if (window.jQuery) {
	    	jQuery(this._dom._element).datepicker("keydown",e);
	    	var dt = jQuery(this._dom._element).data("datepicker").viewDate;
	    	if (dt instanceof Date) {
	    		this.setDate(dt);
	    		this._editor && this._editor.selectDate(this._date);
	    	}
	    }
    },
	$_createList: function() {
		var element = Dom.createElement("div", {
			position: "absolute",
			float: "none",
			clear: "both",
			boxSizing: "border-box",
			margin: "0px",
			overflow: "auto",
			zIndex: 3000,
		});
		if (this._useCssStyle) {
			element.className = "rg-calendar";
		} else {
			Dom.setStyles(element,{
				cursor: "default",
				// fontFamily: "Verdana",
				// fontSize: "11px",
				// fontStyle: "normal",
				// fontVariant: "normal",
				// fontWeight: "normal",
				background: "#fff",// "rgb(233, 233, 233)",
				border: "1px solid rgba(50, 50, 50, 0.5)",
				boxShadow: "rgba(0, 0, 0, 0.5) 1px 2px 5px",
				padding: "0px"
			});
		}

		return element;
	},
    isListing: function() {
		return window.jQuery && jQuery(this._dom._element).data("datepicker");
	},
	show: function (containerElement, x, y, cellWidth, editBounds) {
		this._containerElement = this._viewGridInside ? this._container._container : containerElement;
		if (!this.$_createCalendar()) {
			alert("BootStrap DatePicker Not Include");
			return false;
		}
		this.$_show(x, y, cellWidth, editBounds);
	},
	$_createCalendar: function() {
		var element = this._element;
		var dt;
		var options = this._btOptions;
		if (this._date) {
			dt = new Date(this._date.getFullYear(), this._date.getMonth(), this._date.getDate());
		}
		if (!window.jQuery) {
			return false;
		}
		jQuery(element).datepicker && jQuery(element).datepicker(options).datepicker("setDate", dt).on("changeDate", function(evt) {
			var d = evt.date;
			if (d && !this._editor.containsRange(d)) {
				// message창.
				return;
			}
			if (d) {
				this._date = new Date(d);
				// this._date.setDate(d + 1);
				this._selected = true;
			} else {
				this._date = undefined;
				this._selected = true;
			}
			this.fireEvent(DatePicker.CLOSE_UP, true);
		}.bind(this));
		return true;
	},
	$_show: function(x, y, cellWidth, editBounds) {
		this.setFocused(false);
		this._selected = false;
		this._dom.setStyles({zIndex:this._listZIndex});
		this._containerElement.appendChild(this._dom.element());
		var d = this._date;
		if (!(d instanceof Date) || d == "Invalid Date") {
			d = null;
		}
		this._currDate = d ? new Date(d) : new Date();

		var br = _getBrowserSize();
		var pr = Dom.getBounds(this._containerElement);
		var cr = Dom.getBounds(this._container._container);
        var w = br.width; // this._container.width(); // _container: grid container
        var h = br.height; //this._container.height();
		var r = this._dom.getBounds();
        var sx = window.pageXOffset || document.documentElement.scrollLeft;
        var sy = window.pageYOffset || document.documentElement.scrollTop;
        if (document.documentElement.scrollWidth > document.documentElement.clientWidth) {
            h -= 18;
        }
        if (document.documentElement.scrollHeight > document.documentElement.clientHeight) {
            w -= 18;
        }
        x += cr.left - pr.left;
        y += cr.top - pr.top;
		if (_ieTen || _ieOld || _ieLeg) {
			x += document.documentElement.scrollLeft;
			y += document.documentElement.scrollTop;
		}
		if (y + r.height > h + sy) {
			y = y - editBounds.height - r.height;
			if (y < 0) {
				y = h - r.height - 2;
			}
		}
		if (this._dropDownPosition != DropDownPosition.EDITOR) { // BUTTON 이거나 잘못된 값.
			x = Math.max(0, x + cellWidth - r.width);
		} else {
			if (x + r.width > w + sx) {
				x = w - r.width;
			}
		}
		if (this._viewGridInside) {
			y = editBounds.bottom - pr.top + 2;
			if ( (pr.bottom < editBounds.bottom+r.height) || (h+sy < editBounds.bottom+r.height)) {
				y = editBounds.top - r.height - pr.top - 2;
			}
		}
		this._dom.move(Math.max(0, x), Math.max(0, y));
	},
    today: function () {
        return this.setDate(new Date());
    },
	incDay: function (delta) {
		var d;
		if (this._date.getMonth() == this._currDate.getMonth()) {
			d = new Date(this._date);
			this._date && d.setDate(this._date.getDate() + delta);
		} else {
			d = this._currDate;
			d = new Date(d.getFullYear(), d.getMonth(), 1);
		}
		return this.setDate(d);
	},
	incMonth: function (delta) {
		var d;
		if (this._date.getMonth() == this._currDate.getMonth()) {
			d = new Date(this._date);
			this._date && _incMonth(d, delta);
		} else {
			d = this._currDate;
			d = new Date(d.getFullYear(), d.getMonth(), 1);
		}
		return this.setDate(d);
	},
	firstDay: function () {
		var d = new Date(this._currDate);
        this._date && d.setDate(1);//this._date.getDate() - this._date.getDay());
		return this.setDate(d);
	},
	lastDay: function () {
		var d = new Date(this._currDate);
		if (this._date) {
            var y = d.getFullYear();
            var m = d.getMonth();
            var mdays = $$_month_days[_isLeapYear(y) ? 1 : 0][m];
            d.setDate(mdays);//this._date.getDate() + 6 - this._date.getDay());
        }
		return this.setDate(d);
	},

});
var DefaultEditController = defineClass("DefaultEditController", null, {
	init: function (grid) {
		this._super();
		this._grid = grid;
		this._editIndex = new CellIndex();
		this._editors = [];
		this._starting = false;
		this._editRow = -1;
		this._editor = null;
		this._editState = UNDEFINED;
		this._modified = false;
		this._commiting = false;
		this._canceling = false;
		this._resetting = false;
		this._dirty = false;
		this._editable = false;
		this._readOnly = false;
        this.$_editFocused = false;
		this._defaultEditor = grid.delegate().createDefaultCellEditor();
		this._defaultEditor.setController(this);
		this._internalHideEditor(this._defaultEditor);
		this._showEditorTimer = null;
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		this._defaultEditor = null;
		this._editor = null;
		this._editors = null;// 사용하는지 확인 필요.
		this._super();
	},
	editIndex: function () {
		return this._editIndex.clone();
	},
	isEditing: function () {
		return this._editor && this._editor.isEditing();
	},
	setFocus: function (force) {
		this.$_focusToEditor(force);
	},
	resetEditor: function (resetValue) {
		if (this.isEditing()) {
			if (!this._grid.isValid(this._editIndex)) {
				this.hideEditor();
			} else {
				this._resetBounds(false);
				if (resetValue && this.isEditing()) {
					var v = this.getData(this._editIndex);
					this._resetting = true;
					try {
						this._editor.setEditValue(v);
						this._editor.beginEdit(false, true);
					} finally {
						this._resetting = false;
					}
				}
			}
		}
	},
	reprepareEditor: function (index) {
		if (CellIndex.areEquals(index, this._editIndex)) {
			if (this.isEditing()) {
				this._editor.selectAll();
			} else {
				this._prepareEditor(index);
			}
		}
	},
	invalidateEditor: function () {
		this._dirty = true;
	},
	closeList: function (accept) {
		if (this._editor) {
			this._editor.closeList(accept);
		}
	},
	focusedIndexChanging: function () {
		if (this.isEditing()) {
			this.closeList(true);
			return this.commitEditor(true);
		}
		return true;
	},
	focusedIndexChanged: function (oldIndex, newIndex) {
		this._hideEditor();
		if (this._grid.isValid(newIndex)) {
			this._prepareEditor(newIndex);
		}
	},
	dataColumnChanged: function (column) {
		if (column && this._editor && this._editIndex && this._editIndex.dataColumn() === column) {
			var readOnly = !column.isEditable() || column.isReadOnly();
			if (readOnly != (!this._editable || this._readOnly)) {
				if (this.isEditing()) {
					this._editor.setReadOnly(readOnly);
				} else {
					this._prepareEditor(this._editIndex);
				}
			}
		}
	},
	showEditor: function (index, dropdown) {
		var grid = this._grid;
		if (grid && grid.isValid(index)) {
            if (this._editor && this._editor.isEditing()) {
                grid.makeCellVisible(index);
                return true;
            }
			var canShow = /*(grid.isItemEditing(item) || grid.canUpdate(item, index.dataField())) &&*/
							/* grid.canEdit(index) &&*/ this._editor && !this._editor.isEditing();
			if (canShow) {
				!this._showEditorTimer && this._prepareEditor(index);
				// if (this._editor) {
				// 	if (!this._editor.isTextReadOnly || !this._editor.isTextReadOnly()) {
				// 		this._editor.setReadOnly(this._readOnly);
				// 	} else if (this._editor.isTextReadOnly && this._editor.isTextReadOnly()){
				// 		this._editor._editor && (this._editor._editor.readOnly = this._editor.isTextReadOnly()); 
				// 	}
				// }
				grid.makeCellVisible(index);
				return this._activateEditor(false, true, dropdown);
			}
		}
        return false;
	},
    caretToLast: function () {
        this._editor && this._editor.caretToLast();
    },
	hideEditor: function () {
		if (this.isEditing()) {
			this._modified = false;
			this._resetting = true;
			try {
				this._internalHideEditor(this._editor);
				this._prepareEditor(this._editIndex);
			} finally {
				this._resetting = false;
			}
		}
	},
	commitEditor: function (hideEditor, throwError) {
		if (!this.isEditing() || this._commiting) {
			return true;
		}
		var grid = this._grid;
		var editOptions = grid.editOptions();
		var index = this._editIndex;
		var column = index.dataColumn();
		var commit = true;
        var v, err;
        var editor = this._editor;
        var mask = editor && editor._mask;
		this._commiting = true;
		try {
			editor.commit();
			if (this._modified || editor.isEdited()) {
				if (column && column.dataIndex() >= 0) {
					try {
						try {
							v = mask && !mask.checkValid() ? CellEditor.InvalidFormat : editor.getEditValue(true,true);
							if (v === CellEditor.InvalidFormat) {
								commit = false;
								editOptions.isShowInvalidFormatMessage() && mask && mask.isShowInvalidFormatMessage() && alert((mask && mask.invalidFormatMessage()) || editOptions.invalidFormatMessage());
							} else if (v === CellEditor.Unselected) {
								commit = false;
							} else {
                                var editResult = { text: editor.getEditText(), value: v };
                                this._grid.getEditValue(editor, index, editResult);
                                v = editResult.value;
                                commit = this._grid.editorCommit(editor, index, this._getData(index), v);
                            }
						} catch (e) {
							// err = e;
							_trace(e.message || e);
							commit = false;
						}
                        if (!this._grid.isItemEditing()) {
                            this._modified = false;
                        } else if (commit) {
							this._setData(index, v);
							if (this._grid.isItemEditing(index.item())) {
								v = this._getData(index);
								this._grid.validateCellCommit(index, v);
							}
							this._modified = false;
						}
					} catch (e) {
						err = e;
						commit = false;
					}
				}
			}
			this._resetting = true;
			if (hideEditor) {
				try {
					this._internalHideEditor(editor);
					this._prepareEditor(index);
				} finally {
					this._resetting = false;
				}
			}
			if (err) {
				_trace(err.message || err);
				if (throwError) {
					throw err;
				} else {
					alert(err.message || err);
				}
			}
		} finally {
			this._commiting = false;
		}
		return commit;
	},
	cancelEditor: function (hideEditor) {
		if (!this.isEditing()) {
			return;
		}
		this._canceling = true;
		try {
			try {
				this._modified = false;
				this._grid.editorCancel(this._editor, this._editIndex);
			} catch (err) {
				throw err;
			}
			this._resetting = true;
			try {
				this._internalHideEditor(this._editor);
				this._prepareEditor(this._editIndex);
			} finally {
				this._resetting = false;
			}
		} finally {
			this._canceling = false;
			this._grid.editorCanceled();
		}
	},
	fillSearchItems: function (column, searchKey, values, labels) {
		if (this.isEditing() && this._editIndex.column() === column && this._editor instanceof SearchCellEditor) {
			this._editor.fillItems(searchKey, values, labels);
		}
	},
	buttonClicked: function (index) {
		if (this._editor && CellIndex.areEquals(this._editIndex, index) && this._editor.hasButton()) {
			this._editor.buttonClicked(this._editIndex);
		}
	},
	$_focusToEditor: function (force) {
		if (force || this._grid.$_editFocused) {
			this._grid._container._setFocusAndScroll(this._editor || this._defaultEditor);
            if (!this.isEditing()) {
                this._editor && this._editor.selectAll();
            }
		}
	},
	$_focusToContainer: function () {
	},
	_internalHideEditor: function (editor) {
		this.closeList(false);
		editor.setVisible(false);
		editor.endEdit();
		!this._grid._loading && this._grid._fireHideEditor(editor._editIndex);
	},
	$_hideEdit: function (index, editor) {
		if (editor) {
			//editor.setReadOnly(this._readOnly = true);
			editor.setEditIndex(index);
			editor.setVisible(false);
			this.$_focusToEditor();
		}
	},
	$_getCellEditor: function (index) {
		var editor = this._grid.delegate().getCellEditor(index);
		if (editor) {
			editor.setController(this);
		}
		return editor;
	},
	/* */
	getCellEditor2: function (index) {
		var grid = this._grid;
		var column = index.column();
		var editor = this._grid.delegate().getCellEditor(index);
		index.item() && grid.body().getCell(index); // dynamicStyle적용.
		var editorOptions = grid.getCellEditorOptions(index) || column.editorOptions();
		editor.initOptions();
		editorOptions && this._editor.applyOptions(editorOptions);		
		return editor;
	},
	_prepareEditor: function (index) {
		this._dirty = false;
		if (!this._grid.isValid(index)) {
			return;
		}
		this._hideEditor();
        this._editor = this.$_getCellEditor(index);
        if (!this._editor) {
            return;
        }
		this._editIndex.assign(index);
		this._editor.setReadOnly(false);
		var grid = this._grid;
		var options = grid.editOptions();
		var editorOpts = grid.editorOptions();
		var column = index.dataColumn();
		var item = index.item();
		var itemState = item.itemState();
		var row = ItemState.isInserting(itemState) ? -1 : index.dataRow();
		var style = grid.itemSource().getCellStyle(row, index.dataField());
		var editable = grid.canEdit(index);
		if (style) {
			editable = style.isEditable(editable);
		};
       	editorOpts._titleExprStatement && this._editor.setEditorTitle(index);
		// if (!grid.fixedOptions().isRowEditable() && index.itemIndex() < grid.layoutManager().fixedItemCount()) {
        //     this.$_hideEdit(index, this._editor);
        //     return;
        // }
		// var column = index.dataColumn();
		// var item = index.item();
		// var itemState = item.itemState();
		// var row = ItemState.isInserting(itemState) ? -1 : index.dataRow();
		// var style = grid.itemSource().getCellStyle(row, index.dataField());
		// var editable = style ? style.isEditable() : undefined;
        // if (editable === undefined) {
        //     editable = grid.canEdit(index);
        // }
		if (!editable) {
			this.$_hideEdit(index, this._editor);
			return;
		};
		var readOnly = style ? style.isReadOnly() : undefined;
		var editorOptions = _extend(null, column.editorOptions(), grid.getCellEditorOptions(index));// || column.editorOptions();
		if (readOnly === undefined && (readOnly = grid.getCellReadOnly(index)) === undefined) {
			readOnly = options.isReadOnly() || column.isReadOnly() || (!ItemState.isInserting(itemState) && !grid.canUpdate(item, index.dataField()));
		}
		this._editor.initOptions();
		editorOptions && this._editor.applyOptions(editorOptions);
        var ds = item.dataSource();
        var field = ds ? ds.getField(index.dataField()) : null;
		this._readOnly = readOnly || !field || !field.isUpdatable() || !index.dataColumn() || field.dataType() == ValueType.OBJECT;
		//this._editor.setReadOnly(this._readOnly);
		this._editor.setEditIndex(index);
		this._editable = true;
		this._editor.clear();
		var v = this._getData(index);
        this._editor.setEditValue(v);
        this._editor.selectAll();
		if (options.isEditWhenFocused() && !this._editor.isEditing()) {
			if (this._showEditorTimer) {
				clearTimeout(this._showEditorTimer);
			} 
			if (!this._canceling) {
				this._showEditorTimer = setTimeout(function() {
					grid.showEditor();
					this._showEditorTimer = null;
				}.bind(this),100);
			}
		} else {
			this._editor.setVisible(false);
		}
		this.$_focusToEditor();
	},
	_applyCellFont: function () {
		var grid = this._grid;
		var options = grid.editorOptions();
		if (options.isApplyCellFont()) {
			var cell = grid.body().getCell(this._editIndex);
			var style = cell.styles();
			this._editor.setFontFamily(style.fontFamily());
			this._editor.setFontSize(style.fontSize()+"px");
		} 
	},
	_hideEditor: function () {
		if (this._editor) {
			try {
				this._editor.clear();
				this._editor.setVisible(false);
			} finally {
				this._editor.endEdit();
				this._editor = null;
                this._editable = false;
				this.$_focusToEditor();
			}
		}
	},
	_initEditor: function (bClear, bSelect, bDropdown) {
		if (this._dirty) {
			this._dirty = false;
			if (!this._starting) {
				this._prepareEditor(this._editIndex);
			}
		}
        var editor = this._editor;
		if (editor) {
			editor.endEdit();
			this._applyCellFont();
			this._resetBounds();
			editor.setVisible(true);
			editor.beginEdit(bClear, bSelect);
            bClear && editor.clear();
            bSelect && editor.selectAll();
            bDropdown && editor.dropDownList && editor.dropDownList();
            this.$_focusToEditor(true)
		}
	},
	_setEditAttribute: function(attrs) {
		var editor = this._editor;
		if (editor) {
			for (var attr in attrs) {
				if (attr === "callback") continue;
				editor._editor.setAttribute(attr, attrs[attr])
			}
			if (attrs.callback && typeof attrs.callback == "function") {
				attrs.callback();
			}
		}
	},
	_editorActivated: function(editor) {
		this._grid.editorActivated(editor);
	},
	_activateEditor: function (bClear, bSelect, bDropdown) {
        var grid = this._grid;
        var editor = this._editor;
        var index = this._editIndex;
        var attrs = {};
		if (this._editable && editor && !editor.isEditing() && grid.canShowEditor(index, attrs)) {
			if (!editor.isTextReadOnly || !editor.isTextReadOnly()) {
				editor.setReadOnly(this._readOnly);
			} else if (editor.isTextReadOnly && editor.isTextReadOnly()){
				editor._editor && (editor._editor.readOnly = editor.isTextReadOnly()); 
			}
			this._initEditor(bClear, bSelect, bDropdown);
            this._modified = false;
            this._editorActivated(this._editor);
			this._setEditAttribute(attrs);
            return true;
		}
        return false;
	},
	_resetBounds: function () {
		if (this._editor) {
			var r = this._grid.getEditBounds(this._editIndex);
			r.x--;
			r.y--;
			r.width++;
			r.height++;
            /**
             * ie에서 편집기가 그리드 크기 밖에 있는 상태에서,
             * 편집기가 새로 focus를 받으면 편집기를 표시하기 위해 canvas를 강제 스크롤 시키고 있다.
             * 편집기 너비/높이를 0으로 하면 그렇게 동작하지 않는다.
             */
            if (_isIE && r.right() > this._grid.width() + 3) {
                this._editor.setBounds(r.x + 10000, r.y, 0, 0);
            } else {
                this._editor.setBounds(r.x, r.y, r.width, r.height);
            }
			r = this._grid.getEditCellBounds(this._editIndex);
			this._editor.setCellBounds(r.x, r. y, r.width, r.height);
			if (r.x < 0) {
				this._resetFocused = true;
			}
		}
	},
	_getData: function (index) {
		var item = index.item();
		if (item) {
			var idx = index.column().dataIndex();
			if (idx >= 0) {
				return item.getData(idx);
			}
		}
		return undefined;
	},
	_setData: function (index, value) {
		var item = index.item();
		if (item) {
			var idx = index.column().dataIndex();
			if (idx >= 0) {
				return item.setData(idx, value);
			}
		}
	},
	_isEditKey : function (key) {
		return (key == 8) || //backspace
		    (key >= 46 && key <= 90)   ||  // delete, 0-9a-z
			(key >= 96 && key <= 111)  ||  // numberpad 0-9, *+-./
			(key >= 186 && key <= 222) ||  // special char
			(key == Keys.ENTER && this._grid.editOptions().isEnterToEdit())
	},
	onEditorStart: function (editor) {
		if (!editor.isVisible() && !this._commiting && !this._canceling) {
			return this._activateEditor(false, false);
		}
	},
	onEditorKeyDown: function (editor, keyCode, ctrl, shift, alt) {
		if (this._editor) {
			if ((!this._editor.isTextReadOnly || !this._editor.isTextReadOnly()) && !ctrl && !alt && this._isEditKey(keyCode)) {
				this._editor.setReadOnly(this._readOnly);
			} else if (this._editor.isTextReadOnly && this._editor.isTextReadOnly()) {
				this._editor._editor.readOnly = this._editor.isTextReadOnly();
			} else if (keyCode == 229) {
				this._editor.setReadOnly(this._readOnly);
			}
		}
		return this._grid.activeTool().keyDown(keyCode, ctrl, shift, alt);
	},
	onEditorKeyUp: function (editor, keyCode, ctrl, shift, alt) {
		return this._grid.activeTool().keyUp(keyCode, ctrl, shift, alt);
	},
	onEditorKeyPress: function (editor, keyCode) {
		return this._grid.activeTool().keyPress(keyCode);
	},
	onEditorChange: function (editor) {
		if (!this._modified) {
			this._modified = true;
			this._grid._editorStarted(this._editor, this._editIndex);
		}
		if (this.isEditing()) {
			this._grid.makeCellVisible(this._editIndex);
			this._grid._editorChange(this._editor, this._editIndex, this._editor.getEditValue(false,false));//, this._editor.getEditText());
		}
	},
	onEditorSearch: function (editor, text) {
		this._grid._editorSearch(this._editor, this._editIndex, text);
	},
	onSearchCellButtonClick: function(editor, text) {
		return this._grid._searchCellButtonClick(this._editor, this._editIndex, text);
	},
    onEditorCommit: function (editor) {
        this.commitEditor(true);
    }
});
var GridTool = defineClass("GridTool", VisualTool, {
	init: function (owner, name) {
		this._super(owner, name);
		this._grid = owner.gridView();
		this._focusView = new FocusView(this.grid()._dom, this._grid.displayOptions());
		this._rowFocusView = new RowFocusView(this.grid()._dom, this._grid.displayOptions());
		this._innerFocusView = null;
		this._tipCell = null;
		this._tipIndex = null;
		this._tipButton = -1;
		this._tipOptions = new ToolTipOptions();

		// mobileSelectionTool에서 touch관련 이동.
		this._touchManager = new SingleTouchManager(owner);
		this._tapTracker = null;
		this._swipeTimer = null;
		this._swipeDistance = 0;
		this._swipeDuration = 0;
		this._swipeStarted = null;
		this._swipePrev = undefined;
		this._swipeAmount = 0;
		this._tapX = this._tapY = NaN;
		this._touchManager.setTouchHandler(function (event, x, y) {
			return this.onTouch(event, x, y);
		}.bind(this));
		this._touchManager.setTapHandler(function (x, y) {
			return this.onTap(x, y);
		}.bind(this));
		this._touchManager.setDoubleTapHandler(function (x, y) {
			return this.onDoubleTap(x, y);
		}.bind(this));
		this._touchManager.setLongTapHandler(function (x, y) {
			return this.onLongTap(x, y);
		}.bind(this));
		this._touchManager.setDragStartHandler(function (startX, startY, x, y) {
			return this.onDragStart(startX, startY, x, y);
		}.bind(this));
		this._touchManager.setDragHandler(function (prevX, prevY, x, y) {
			return this.onDrag(prevX, prevY, x, y);
		}.bind(this));
		this._touchManager.setSwipeHandler(function (duration, distance, dir) {
			return this.onSwipe(duration, distance, dir);
		}.bind(this));
	},
	destroy: function() {
		if (this._destroying) {
			return;
		};
		this._destroying = true;
		this._grid = null;
		this._focusView && this._focusView.destroy();
		this._focusView = null;
		this._rowFocusView && this._rowFocusView.destroy();
		this._rowFocusView = null;
		this._innerFocusView && this._innerFocusView.destroy();
		this._innerFocusView = null;
		this._tipCell = null;
		this._tipIndex = null;
		this._tipOptions && this._tipOptions.destroy();
		this._tipOptions = null;
		this._touchManager && this._touchManager.destroy();
		this._touchManager = null;
		this._super();
	},
    focused: null,
	grid: function () { return this._grid; },
	touchManager: function () {
		return this._touchManager;
	},
	focused_: function () {
		return this._grid.focusedIndex();
	},
	setFocused: function (value, select) {
		if (this._grid.isValid(value)) {
			var grid = this._grid;
			var item = grid.getItem(value.itemIndex());
			if (!grid.isEditing() && item instanceof DummyEditItem) {
				grid.append();
			}
			return this._grid.setFocusedIndex(value, select, true);
		}
		return false;
	},
// touch 관련 이동.
	_stopTapTracker: function (accept) {
		if (this._tapTracker) {
			try {
				accept ? this._tapTracker.drop(x, y) : this._tapTracker.cancel();
			} finally {
				this._tapTracker = null;
			}
		}
	},
	onTouch: function (event, x, y) {
		clearInterval(this._swipeTimer);
		this._stopTapTracker(false);
		this._hideTooltip();
		var grid = this._grid;

		if (_isMobile() && event.target === grid._container._canvas && !grid.$_editFocused) {
			grid._container._canvas.focus();
		}
		grid.closePopups();
		this._clickCell = this._clickHandle = null;
		var clickElement = this._clickElement = this.findElementAt(x, y, false);
		this._clickHandle = _cast(clickElement, HandleElement);
		this._clickCell = _cast(clickElement, CellElement);
		if (clickElement instanceof ScrollThumb) {
			return new TabScrollThumbTracker(grid, clickElement);
		} else if (clickElement instanceof ScrollButton) {
			return new ScrollButtonTimer(clickElement);
		} else if (clickElement instanceof ScrollBar) {
			/*
			if (clickElement.ptInTrack(x, y, true)) {
				return new ScrollTrackTimer(clickElement, true);
			} else if (clickElement.ptInTrack(x, y, false)) {
				return new ScrollTrackTimer(clickElement, false);
			}
			*/
		}
	},
	onTap: function (x, y) {
		if (_isiOS && this._touchManager) {
			var t = getTimer();
			if (this._touchManager._touchEndt + 50 > t) {
				return;// iOS에서는 touch event에서 preventDefault를 이용해서 이벤트를 막아도 마우스 관련 이벤트가 발생한다. 
			}
		}
		var grid = this._grid;
		var mode = grid.selectOptions().mode();
		var style = grid.selectOptions().style();
		var selections = grid._selections;
		var clickCell = this._clickCell;
		var clickElement = this._clickElement;
		var index = clickCell ? clickCell.index() : null;
		var col = clickCell ? index.column() : null;
		this._hideTooltip();
		selections.clear();
		grid.closeFilterSelector();

		if (clickCell instanceof DataCellElement) {
			index.normalize(grid);
			this.setFocused(index, true);
			
			var cx = clickCell.mouseX(),
				cy = clickCell.mouseY(),
				buttonIndex = -1,
				focused = clickCell.isFocused(),
				name, renderer = clickCell._renderer, clickFunc;
			if (focused) {
				if (clickCell.ptInButton(cx, cy)) {
					buttonIndex = clickCell.getPtInButtonIndex(cx,cy);
					clickFunc = this.cellButtonClicked.bind(this);
				} else if (clickCell.ptInDataButton(cx, cy)) {
					buttonIndex = clickCell.getPtInDataButtonIndex(cx, cy);
					name = renderer && renderer instanceof ImageButtonsCellRenderer && renderer._images[buttonIndex] ? renderer._images[buttonIndex].name : undefined;
					clickFunc = this.imageButtonClicked.bind(this);
				} else if (clickCell.ptInEditButton(cx, cy)) {
					clickFunc = this.editButtonClicked.bind(this);		
				} else if (renderer && (renderer instanceof LinkCellRenderer || renderer instanceof CheckCellRenderer)) {
					this._performRendererClick(index, clickCell, x, y, false, true);
				} 
			};
			// index.normalize(grid);
			// this.setFocused(index, true);
            if (focused && clickFunc) {
            	clickFunc(index, buttonIndex, name);
            }
            if (renderer.isShowTooltip() && this._grid.mobileOptions().isShowTooltip()) {
            	var tm = this._grid.toolTipManager();
            	if (tm) {
            		if (tm._hintDuration > 0) {
            			tm._showTimer && clearTimeout(tm._showTimer);
            			tm._showTimer = setTimeout(function () {this._showTooltip2(clickCell)}.bind(this), tm._hintDuration);
            		} else {
            			this._showTooltip2(clickCell);
            		}
            	}
            }
            this.dataCellClicked(index);
		} else if (clickElement instanceof HeaderPopupHandle) {
			var popupMenuManager = grid.popupMenuManager(),
				headerElement = this._clickElement.parent(),
				column = headerElement.column(),
				columnHeader = column.header(),
				popupMenuName = columnHeader._popupMenuName;
			if (popupMenuName) {
				popupMenuManager.show(popupMenuName, headerElement, x, y, 0, 0);
			}
		} else if (clickElement instanceof HeaderImageHandle) {
			this._columnHeaderImageClicked(clickElement.cellView().column());
		} else if (clickElement instanceof HeaderCheckHandle) {
            clickElement.cellView().column().setChecked(!clickElement.cellView().column().isChecked());
		} else if (clickCell instanceof HeaderCellElement && clickCell.isClickable()) {
			if (clickCell.parent() instanceof HeaderElement || clickCell.parent() instanceof HeaderGroupCellElement) {
				this._columnHeaderClicked(clickCell.index().column());
			} else if (clickCell.parent() instanceof GroupByView) {
				this._rowGroupPanelClicked(clickCell.index().column());
			}

			if (!grid.isEmpty() && col instanceof DataColumn && col.isSortable() && grid.sortingOptions().isEnabled()) {
				grid.sortColumn(col);
			} else {
	            if (this._grid.mobileOptions().isShowTooltip()) {
	            	var tm = this._grid.toolTipManager();
					if (tm) {
						if (tm._hintDuration > 0) {
							tm._showTimer && clearTimeout(tm._showTimer);
							tm._showTimer = setTimeout(function() {self._showHeaderTooltip2(clickCell)}.bind(self), tm._hintDuration);
						} else {
							this._showHeaderTooltip2(clickCell);
						}
					}
	            }	
			}
		} else if (clickElement instanceof MobileEditCommandView) {
			clickElement.model && clickElement.model().run(grid, index);
		} else if (clickElement instanceof IndicatorCellElement) {
			this._indicatorCellClicked(index.I());
			if (grid.indicator().isSelectable()) {
				var idx = CellIndex.temp(grid, index.I(), index.column());
				if (idx.C() == null && idx.item() instanceof GridRow) {
					var col = grid.focusedIndex() && grid.focusedIndex().C();
					idx.column(col ? col : grid.getFirstColumn());
				}
				index.assign(idx);
				this.setFocused(index, true);
				mode != SelectionMode.NONE && style != SelectionStyle.NONE && selections.add(index, index, SelectionStyle.ROWS);
			}
		} else if (clickElement instanceof IndicatorHeadElement) {
			this._indicatorCellClicked(-1);
		} else if (clickElement instanceof IndicatorFootElement) {
			this._indicatorCellClicked(-2);
        } else if (clickElement instanceof CheckBarCellElement) {
			this._checkCellClicked(clickElement);
		} else if (clickElement instanceof CheckBarHeadElement) {
			this._checkAllClicked(clickElement);
		} else if (clickElement instanceof CheckBarFootElement) {
			this._checkBarFootClicked(clickCell);
		} else if (clickElement instanceof StateBarCellElement) {
			this._stateBarCellClicked(clickCell.index().itemIndex());
		} else if (clickElement instanceof StateBarHeadElement) {
			this._stateBarCellClicked(-1);
		} else if (clickElement instanceof StateBarFootElement) {
			this._stateBarCellClicked(-2);
		} else if (clickElement instanceof RowGroupHeadCellElement) {
			this._rowGroupHeadClicked();
		} else if (clickElement instanceof RowGroupFootCellElement) {
			this._rowGroupFootClicked();
		} else if (clickElement instanceof RowGroupHeaderCellElement) {
			this._rowGroupHeaderFooterClicked(-1, clickElement.index());
		} else if (clickElement instanceof GroupFooterCellElement) {
			this._rowGroupHeaderFooterClicked(-2, clickElement.index());
		} else if (clickElement instanceof RowGroupBarCellElement) {
			this._rowGroupBarClicked(clickElement.level());
		} else if (clickElement instanceof RowGroupExpandHandle) {
			this._rowGroupBarClicked(-1);
		} else if (clickElement instanceof RowGroupExpanderElement) {
			this._rowGroupBarClicked(-2);
		} else if (clickElement instanceof GroupByView) {
			this._panelClicked(0);
		} else if (clickElement instanceof FooterCellElement) {
			this._footerCellClicked(clickElement.index().column());
		} else if (clickElement instanceof HeaderFilterHandle && grid.filteringOptions().isEnabled()) {
			var parent = clickElement.parent();
			col = parent.column();
			if (grid.isFilterSelecting(col)) {
				grid.closeFilterSelector();
			} else {
	 			grid.selectColumnFilters(clickElement.parent());
			}
		} else if (clickElement instanceof MobileSelectionHandle) {
		} else if (clickElement instanceof GroupRemoveButtonHandle) {
			grid.removeGroupBy(clickElement.cellView().column());
		} else if (clickElement == null) {
			this._bodyEmptyClicked();
		}

	},
	onLongTap: function (x, y) {
		var grid = this._grid;
		var clickCell = this._clickCell;
		var clickElement = this._clickElement;
		var index = clickCell ? clickCell.index() : null;
		var col = clickCell ? index.column() : null;
		var renderer;
		if (clickElement instanceof DataCellElement || clickElement instanceof MobileSelectionHandle) {
			if (clickElement instanceof MobileSelectionHandle) {
				clickCell = grid.getFocusedCellView();
				index = grid.focusedIndex();
				col = index.column();
			}
			if (col.button() != CellButton.NONE && clickCell._getButtonVisible(col.buttonVisibility())) {
				this.cellButtonClicked(index);
				return false;
			} else if ((renderer = col.rendererObj()) && (renderer instanceof LinkCellRenderer || renderer instanceof CheckCellRenderer)) {
				this._performRendererClick(index, clickCell, x, y, false, true);
			} 
        } else if (clickElement instanceof HeaderCellElement && clickElement.parent() instanceof GroupByView) {
        	if (grid.groupingOptions().isEnabled() && index.dataColumn() && index.dataColumn().isGroupable() && grid.panel().isVisible()) {
        		var panelView = grid.panelView();
        		if (panelView) {

	        		panelView.setState(GridPanelElement.UNGROUPING);
		        	if (grid.isGrouped(col)) {
						grid.removeGroupBy(col);
					}
					panelView.setState(GridPanelElement.NORMAL);
					return false;
				}
        	}
        }
		return true;
	},
	onDoubleTap: function (x, y) {
		var index = this.focused();
		if (this._clickElement instanceof DataCellElement) {
            this.dataCellDblClicked(this._clickElement.index());
            var clickIndex = this._clickElement.index();
            if (clickIndex.isValid() && !this._grid.isEditing() && this._clickCell instanceof DataCellElement) {
            	if (CellIndex.areEquals(clickIndex, index)) {
            		this._grid && this._grid.showEditor(clickIndex.clone());
            	}
            }
		} else if (this._clickElement instanceof RowGroupHeaderCellElement) {
			var groupItem = _cast(this._clickElement.item(), GroupItemImpl);
			if (groupItem) {
				groupItem.setExpanded(!groupItem.isExpanded());
			}
		} else if (this._clickElement instanceof HeaderCellElement) {
			if (this._clickElement.parent() instanceof HeaderElement) {
				this._grid._fireColumnHeaderDblClicked(this._clickElement.index().column());
			} else {
				this._grid._fireRowGroupPanelDblClicked(this._clickElement.index().column());
			}
		} else if (this._clickCell instanceof FooterCellElement) {
			if (this._clickCell.error()) {
				this._grid.alertCellError(this._clickCell, this._clickCell.errorDetail() || this._clickCell.error());
			} else {
				this._grid._fireFooterCellDblClicked(this._clickCell.index().column());
			}
		} else if (this._clickCell instanceof GroupFooterCellElement && this._clickCell.error()) {
			this._grid.alertCellError(this._clickCell, this._clickCell.errorDetail() || this._clickCell.error());
		} else if (this._clickCell instanceof IndicatorHeadElement) {
			this._grid._fireIndicatorCellDblClicked(-1);
		} else if (this._clickCell instanceof IndicatorFootElement) {
			this._grid._fireIndicatorCellDblClicked(-2);
		} else if (this._clickCell instanceof StateBarHeadElement) {
			this._grid._fireStateBarCellDblClicked(-1);
		} else if (this._clickCell instanceof StateBarFootElement) {
			this._grid._fireStateBarCellDblClicked(-2);
		} else if (this._clickCell instanceof StateBarCellElement) {
			this._grid._fireStateBarCellDblClicked(this._clickCell.index().itemIndex());
		} else if (this._clickCell instanceof CheckBarFootElement) {
			this._grid._fireCheckBarFootDblClicked(-2);
		} else if (this._clickCell instanceof RowGroupHeadCellElement) {
			this._grid._fireRowGroupHeadDblClicked();
		} else if (this._clickCell instanceof RowGroupFootCellElement) {
			this._grid._fireRowGroupFootDblClicked();
		} else if (this._clickCell instanceof RowGroupHeaderCellElement) {
			this._grid._fireRowGroupHeaderFooterDblClicked(-1, this._clickCell.index());
		} else if (this._clickCell instanceof GroupFooterCellElement) {
			this._grid._fireRowGroupHeaderFooterDblClicked(-2, this._clickCell.index());
		} else if (this._clickCell instanceof RowGroupBarCellElement) {
			this._grid._fireRowGroupBarDblClicked(this._clickCell.level());
		} else if (this._clickCell instanceof RowGroupExpandHandle) {
			this._grid._fireRowGroupBarDblClicked(-1);
		} else if (this._clickCell instanceof RowGroupExpanderElement) {
			this._grid._fireRowGroupBarDblClicked(-2);
		} else if (this._clickElement instanceof GroupByView) {
			this._grid._firePanelDblClicked(0);
		} else if (this._clickElement == null) {
			this._grid._fireBodyEmptyDblClicked();
		}
	},
	onDragStart: function (startX, startY, currX, currY) {
		var elt = this._clickElement;
		var tracker = null;
		var grid = this._grid;
		var mode = grid.selectOptions().mode();
		var style = grid.selectOptions().style();
		var headerScoll = grid.mobileOptions().isHeaderToScroll();

		if (elt instanceof DataCellElement || (elt instanceof HeaderCellElement && headerScoll)) {
			tracker = new MobileScrollTracker(this._grid);
		} else if (elt instanceof IndicatorCellElement && grid.indicator().isSelectable() && mode != SelectionMode.NONE && style != SelectionStyle.NONE && style != SelectionStyle.SINGLE_ROW) {
			var index = this._clickElement.index().clone();
			if (index.C() == null && index.item() instanceof GridRow) {
				var col = grid.focusedIndex() && grid.focusedIndex().C();
				index.column(col ? col : grid.getFirstColumn());
			}
			this.setFocused(index, true);
			tracker = new MobileRowSelectTracker(this._grid, elt);
		} else if (elt instanceof HeaderCellElement) {
			tracker = new MobileColumnSelectTracker(this._grid, elt);
		} else if (elt instanceof MobileSelectionHandle) {
			tracker = new MobileSelectHandleTracker(this._grid, elt);
		} else if (elt instanceof ScrollThumb) {
		}
		if (tracker && tracker.start(startX, startY, currX, currY)) {
			this._tapTracker = tracker;
		}
		return this._tapTracker;
	},
	onDrag: function (prevX, prevY, currX, currY) {
		var tracker = this._tapTracker;
		var drag;
		if (tracker) {
			if (!(drag = tracker.drag(prevX, prevY, currX, currY))) {
				tracker.cancel();
				this._tapTracker = null;
			}
		};
		return drag;
	},

	onSwipe: function (duration, distance, dir) {
		if (!(this._clickElement instanceof DataCellElement)) {
			return;
		}
		var grid = this._grid;
		var delta = 1;
		switch (dir) {
			case "right":
				grid.setLeftPos(grid.leftPos() - distance / 20);
				break;
			case "left":
				grid.setLeftPos(grid.leftPos() + distance / 20);
				break;
			case "bottom":
				delta = -1;
			case "top":
				this._swipeDistance = delta * distance / 20;
				this._swipeDuration = duration;
				this._swipePrev = this._swipeStarted = getTimer();
				this._swipeAmount = 0;
				this._swipeTimer = setInterval(this.$_scrollRow.bind(this), 50);
				break;
		}
	},
	$_scrollRow: function () {
		var t = getTimer();
		if (t - this._swipeStarted < this._swipeDuration) {
			var dt = getTimer() - this._swipePrev;
			var rows = (this._swipeDistance - this._swipeAmount) * dt / this._swipeDuration;
			this._swipeAmount -= rows;
			this._swipePrev = t;
			this._grid.setTopIndex(this._grid.topIndex() + rows);
		} else {
			clearInterval(this._swipeTimer);
		}
	},
//
	layoutChanged: function () {
		this._doLayoutChanged && this._doLayoutChanged();
	},
	resetFocused: function () {
		this._resetFocusedView();
	},
	focusedIndexChanging: function (newIndex) {
		this._doFocusedIndexChanging && this._doFocusedIndexChanging(newIndex); 
	},
	focusedIndexChanged: function (oldIndex, newIndex) {
		this._doFocusedIndexChanged && this._doFocusedIndexChanged(oldIndex, newIndex); 
	},
	columnHeaderDblClicked: function (column) {
		this._grid._fireColumnHeaderDblClicked(column);
	},
	footerCellDblClicked: function (column) {
		this._grid._fireFooterCellDblClicked(column);
	},
	headerSummaryCellDblClicked: function (column) {
		this._grid._fireHeaderSummaryCellDblClicked(column);
	},
	checkBarFootDblClicked: function () {
		this._grid._fireCheckBarFootDblClicked();
	},
	indicatorCellDblClicked: function (index) {
		this._grid._fireIndicatorCellDblClicked(index);
	},
	stateBarCellDblClicked: function (index) {
		this._grid._fireStateBarCellDblClicked(index);
	},
	rowGroupHeadDblClicked: function () {
		this.grid()._fireRowGroupHeadDblClicked();
	},
	rowGroupFootDblClicked: function () {
		this.grid()._fireRowGroupFootDblClicked();
	},
	rowGroupHeaderFooterDblClicked: function (kind, index) {
		this.grid()._fireRowGroupHeaderFooterDblClicked(kind, index);
	},
	rowGroupBarDblClicked: function (index) {
		this.grid()._fireRowGroupBarDblClicked(index);
	},
	panelDblClicked: function () {
		this.grid()._firePanelDblClicked();
	},
	rowGroupPanelDblClicked: function (column) {
		this.grid()._fireRowGroupPanelDblClicked(column);
	},
	bodyEmptyDblClicked: function() {
		this.grid()._fireBodyEmptyDblClicked();
	},
	dataCellClicked: function (index) {
		this._grid._fireDataCellClicked(index);
	},
	dataCellDblClicked: function (index) {
		this._grid._fireDataCellDblClicked(index);
	},
	cellButtonClicked: function (index, buttonIndex) {
		var column = index.dataColumn();
		var grid = this._grid;
		if (column) {
			var lm = grid.layoutManager();
			var room = lm.getMergedCell(index);
			var view;
			if (room) {
				view = grid.getCellView(grid._mergeView, index, index.isFixedCol());
			} else {
				view = _cast(grid.getCellView(null, index), CellElement);
			}
			index = index.clone();
			if (view instanceof MergedDataCellElement) {
				index.setItemIndex(index.I()+view.innerIndex());
			}
			switch (column.button()) {
				case CellButton.POPUP:
					var menu = column.menu();
					menu && view && grid.popupMenuManager().show(menu, view);
					break;
				case CellButton.ACTION:
					grid._fireCellButtonClicked(index);
					break;
				case CellButton.IMAGE:
					var renderer = column._imageButtonsRenderer;
					if (renderer && buttonIndex >= 0 && buttonIndex < renderer._count ) {
						var name = renderer._images[buttonIndex].name;
						grid._fireImageButtonClicked(index, buttonIndex, name);
					}
					break;
			}
		}
	},
	editButtonClicked: function (index) {
		this._grid._fireEditButtonClicked(index);
	},
	imageButtonClicked: function (index, buttonIndex, name) {
		this._grid._fireImageButtonClicked(index, buttonIndex, name);
	},
    _doSetFocus: function () {
        this.grid().editController().setFocus(true);
    },
	_resetFocusedView: function () {
		var grid = this._grid;
		var options = grid.displayOptions()
		var showInnerFocus = options.isShowInnerFocus();
		var index = this.focused();
		var vis = false;
		var rowVis = false;
		var inner = false;
		var lm = grid.layoutManager();
		if (options.isFocusVisible() && grid.isValid(index)) {
			var cell = grid.getFocusedCellView(index);
			if (cell) {
                var fixed = lm.fixedColCount();
				var editing = grid.isEditing();
                var r = cell.boundsBy(grid);
				if (cell instanceof RowGroupFooterElement) {
					var r2 = lm._rowGroupBounds;
					var aw = r2.x + cell._level * grid.rowGroup().levelIndent();
					r.setLeft(aw);
					r.width = r2.width - grid.leftPos() - cell._level * grid.rowGroup().levelIndent();
				}
                if (cell instanceof MergedFooterElement) {
                	// 해당 컬럼의 right
					var c = cell._level - 1;
                	var x = lm.getColumnBounds(c).right() + lm.fixedBounds().x;
                	var fixedWidth = lm.fixedWidth();
                	var leftPos = grid.leftPos();
                	var er = lm._editBarBounds;

					if (fixed > 0) {
						if (c >= fixed) {
							x = Math.max(x + fixedWidth - leftPos , fixedWidth+lm.fixedBounds().x);
						} else if (c == fixed - 1) {
							x = fixedWidth + lm.fixedBounds().x;
						}
					} else if (fixed == 0) {
						x -= leftPos;
					}
                	r.x = x;
                	r.width = er.width + er.x - x ;
                }
				if (r.width > 0 && r.height > 0) {
					if (grid._container.$_rich) {
						r.x++;
						r.y++;
					}
					this._focusView.setRect(r);
					vis = true;
					if (cell instanceof MergedDataCellElement) {
						if (!this._innerFocusView) {
							this._innerFocusView = new InnerFocusView(grid._dom, grid.displayOptions());
							grid.addFocusElement(this._innerFocusView);
						}
						var r1 = lm.itemBounds(cell._topIndex);
						var r2 = lm.itemBounds(index.I() - grid.topIndex());
						cell.setInnerIndex(index.I() - cell.mergeRoom().headItem());
						r.y += r2.y - r1.y;
						r.height = r2.height;
						if (!editing) {
							r.x += 2;
							r.y += 2;
							r.width -= 5;
							r.height -= 5;
						}
						if (showInnerFocus && this._innerFocusView) {
							this._innerFocusView.setRect(r);
							this._innerFocusView.setEditing(editing, cell.getButtonWidth ? cell.getButtonWidth() : 0, cell._isLeftImageButton);
							inner = true;
						}
					}
					if (inner) {
						this._focusView.setEditing(false, 0);
					} else {
						this._focusView.setEditing(editing, cell.getButtonWidth ? cell.getButtonWidth() : 0, cell._isLeftImageButton);
					}
				}
			}
		}
		if (lm._gridBounds && options.isRowFocusVisible() && grid.isValid(index)) {
			var idx = index.I();
			var t = grid.topIndex();
			var fixed = lm.fixedItemCount();
			var itemCount = lm.itemCount();
			var fr;
			if (rowVis = idx < fixed || (idx >= t && idx <= t+itemCount)) {
				var y = fixed > 0 ? lm.fixedHeight() + grid.fixedOptions().rowBarHeight() : 0;
				var gr = lm.gridBounds(); 
				if (idx < fixed) {
					fr = lm.itemBounds(Math.max(0, idx));
				} else {
					fr = lm.itemBounds(Math.max(0, idx - t));
					fr.y = Math.max(fr.y, y);
				}
				fr.y += gr.y;
				fr.x = 0;
				fr.width = gr.x+gr.width;
				grid._container.$_rich && (fr.x++, fr.y++);
				this._rowFocusView.setRect(fr)
			}
		}
		this._focusView.setVisible(vis);
		this._rowFocusView.setVisible(rowVis);
		this._innerFocusView && this._innerFocusView.setVisible(inner);
		if (this._focusView.isVisible()) {
			grid._resetFocusMask();
		}
		if (this._rowFocusView.isVisible()) {
			grid._resetRowFocusMask();
		}
		if (options._rowHoverMask.isVisible()) {
			var hView = this._rowHoverView;
			if (hView && this._rowFocusView.isVisible() && (!hView.$_hoverRow || hView.$_hoverRow.itemIndex() == index.I())){
				hView.setVisible(false);
			} else {
				this._resetRowHoverView();
			} 
		}
	},
	// supportTool에서 옮겨옴.
	$_checkAppending: function (index, cancel, clickCell) {
		var grid = this.grid();
		if (index.I() == grid.itemCount() - 1 && ItemState.isInserting(index.item().itemState())) {
			var idx = index.I();
			if (!clickCell || clickCell.index().I() != idx) {
                try {
                    if (grid.commit(grid.editOptions().isForceAppend(), true)) {
                        index = index.clone();
                        index.itemIndex(idx);
                        if (!grid.isValid(index)) {
                            index.itemIndex(grid.getItemIndexOfRow(grid.dataSource().rowCount() - 1));
                        }
                        this.setFocused(index, true);
                    } else if (cancel) {
                        grid.cancel(true);
                    }
                } catch (err) {
                    if (err instanceof ValidationError) {
                    	err = grid._fireValidationFail(idx, err.column, err);
						err ? alert(grid._editOptions.isShowOnlyValidationMessage() && err.userMessage ? err.userMessage : err.toString()) : null;
                        return true;
                    }
                    if (err instanceof AbortError) {
                        return true;
                    }
                    throw err;
                }
				return true;
			}
		}
		return false;
	},
	$_checkReadOnly: function (index) {
		var grid = this.grid();
		if (!grid.isValid(index)) {
			return true;
		}
		var column = index.dataColumn();
		var editable;
		var readOnly = grid.getCellWritable(index);
		if (typeof readOnly === "boolean") {
			return !readOnly;
		}
		var row = ItemState.isInserting(index.item().itemState()) ? -1 : index.dataRow();
		var style = _cast(grid.itemSource().getCellStyle(row, index.dataField()), DataCellStyle);
		if (style) {
			editable = style.isEditable();
			readOnly = style.isReadOnly();
			if (editable != null || readOnly != null) {
				return !((editable == null || editable) && !readOnly);
			}
		}
		return !column.isWritable();
	},
	checkReadOnly:function (index) {
		return this.$_checkReadOnly(index);
	},
	$_skipReadOnly: function (index, dx) {
		var moved = false;
		var grid = this.grid();
		if (grid.editOptions().isSkipReadOnly()) {
			var idx = this._skipIndex;
			idx.assign(index);
			moved = !this.$_checkReadOnly(idx);
			if (!moved) {
				if (dx > 0) {
					while (idx.next()) {
						if (!this.$_checkReadOnly(idx)) {
							index.assign(idx);
							moved = true;
							break;
						}
					}
				} else {
					while (idx.prev()) {
						if (!this.$_checkReadOnly(idx)) {
							index.assign(idx);
							moved = true;
							break;
						}
					}
				}
			}
		}
		return moved;
	},
	skipReadOnly: function(index, dx) {
		return this.$_skipReadOnly(index, dx);
	},
	$_skipReadOnlyCell : function (index, dx, limit) {
		var grid = this.grid();
		var col = index.column();
		var hasVertical = col.checkGroupExist(ColumnGroupOrientation.VERTICAL);
		var moved = !col.isWritable() && !hasVertical;
		if (!moved && grid.editOptions().isSkipReadOnlyCell()) {
			var idx = this._skipIndex;
			idx.assign(index);
			moved = !this.$_checkReadOnly(idx);
			if (!moved) {
				if (dx > 0) {
					while (idx.lower(grid.isItemEditing(idx.item()))) {
						if (idx.itemIndex == -1 || !this.$_checkReadOnly(idx)) {
							index.assign(idx);
							moved = true;
							break;
						}
						if (CellIndex.areEquals(idx, limit)) {
							moved = false;
							break;
						}
					}
				} else {
					while (idx.upper(grid.isItemEditing(idx.item()))) {
						if (idx.itemIndex == -1 || !this.$_checkReadOnly(idx)) {
							index.assign(idx);
							moved = true;
							break;
						}
						if (CellIndex.areEquals(idx, limit)) {
							moved = false;
							break;
						}
					}
				}
			}
		}
		return moved;
	},
	_doTab: function (grid, options, focused, ctrl, shift, event) {
		var index = focused.clone();
		if (!grid.isValid(index)) {
			index.normalize(grid);
			this.$_skipReadOnly(index, 1);
		} else if (options.isUseTabKey()) {
			var exitCond = options.exitGridWhenTab();
            if (shift) {
            	if (options.isCrossWhenExitLast() && (index.isFirst() || options.isSkipReadOnly() && index.isEditableFirst() ) && index.itemIndex() > 0) {
            		index.up();
            		index.end();
            	} else {
                	index.prev();
                }
                if (options.isSkipReadOnly() && !this.$_skipReadOnly(index, -1)) {
                    index.assign(focused);
                }
                if (CellIndex.areEquals(index, focused) && exitCond) {
                	switch (exitCond) {
                		case "row":
                			grid._exiting = true;
                			break;
                		case "grid": 
                			grid._exiting = index.itemIndex() <= 0;
                			break;
                	}
                	if (grid._exiting) {
                		!_isMobile() && grid._container._canvas.setAttribute("tabindex","-1");
                		return false;
                	}
                }
            } else {
                if (options.isCrossWhenExitLast() && (index.isLast() || options.isSkipReadOnly() && index.isEditableLast()) && index.I() < grid.itemCount() - 1) {
                    index.down(null, options.isSkipReadOnly() && index.isEditableLast() && options.isCrossWhenExitLast());
                    index.home();
                } else if (options.isCommitWhenExitLast() && index.isLast()) {
                	try {
                    	grid.commit(options.isCommitWhenNoEdit());
                    } catch (err) {
						if (err instanceof ValidationError) {
							err = grid._fireValidationFail(item._index, err.column, err);
							err ? alert(options.isShowOnlyValidationMessage() && err.userMessage ? err.userMessage : err.toString()) : null;
						}
						throw err;	
                    }
                    if (options.isAppendWhenExitLast()) {
                        grid.append();
                        if (grid.isItemEditing()) {
                            index.down();
                            index.home();
                        }
                    }
                } else {
                    index.next();
                }
                if (options.isSkipReadOnly() && !this.$_skipReadOnly(index,1)) {
                    index.assign(focused);
                }

                if (CellIndex.areEquals(index, focused) && exitCond) {
                	switch (exitCond) {
                		case "row":
                			grid._exiting = true;
                			break;
                		case "grid" :
                			grid._exiting = index.itemIndex() >= (grid.itemCount() - 1)
                			break;
                	}
                	if (grid._exiting) {
                		return false;
                	}
                }
            }
			if (!CellIndex.areEquals(index, focused)) {
				this.setFocused(index, true);
			}
			_isMobile() && event && event.preventDefault && event.preventDefault();
			return true;
		}
		grid._exiting = true;  // itemCount <= 0 || not UseTabKey GridExit;
		shift && !_isMobile() && grid._container._canvas.setAttribute("tabindex","-1"); 
		return false;
	},
	$_commitCancel: function(item, options) {
		var grid = this.grid();
		try {
			switch (item.itemState()) {
				case ItemState.INSERTING:
					if (!grid.commit(options.isForceInsert())) {
						grid.cancel(true);
					}
					return true;
				case ItemState.APPENDING:
					if (!grid.commit(options.isForceAppend())) {
						grid.cancel(true);
					}
					return true;
				case ItemState.UPDATING:
					if (!grid.commit(options.isCommitWhenNoEdit())) {
						grid.cancel(true);
					}
					return true;
			}
		} catch (err) {
			if (err instanceof ValidationError) {
				err = grid._fireValidationFail(item._index, err.column, err);
				err ? alert(options.isShowOnlyValidationMessage() && err.userMessage ? err.userMessage : err.toString()) : null;
				return false;
			}
			if (err instanceof AbortError) {
				return false;
			}
			throw err;
		}
		return false;
	},
	_doCancel: function (grid) {
		grid.closeFilterSelector();
		if (grid.isEditing()) {
			grid.cancelEditor(true);
		} else {
			if (grid.itemEditCancel()) {
				grid.cancel();
			}
		}
	},
	_doEnter: function (grid, options, focused) {
        var editing = grid.isEditing();
		if (editing && !options.isEnterToTab()) {
			grid.commitEditor(true);
		} else {
			var index = focused.clone();
			var skip = options.isSkipReadOnly();
			var skipCell = options.isSkipReadOnlyCell();
			if (!grid.isValid(index)) {
				index.normalize(grid);
			} else if (options.isEnterToNextRow() && index.I() < grid.itemCount() - 1) {
				index.down();
				if (skipCell && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnlyCell(index, 1)) {
						index.assign(focused);
					}
				}
            } else if ((!editing || options.isEnterToTab()) && options.isCrossWhenExitLast() && (index.isLast() || options.isSkipReadOnly() && index.isEditableLast()) && index.I() < grid.itemCount() - 1) {
                index.down();
                index.home();
                skip && this.$_skipReadOnly(index, 1);
            } else if ((!editing || options.isEnterToTab()) && options.isCommitWhenExitLast() && index.isLast()) {
            	try {
	                grid.commit(options.isCommitWhenNoEdit());
	            } catch (err) {
					if (err instanceof ValidationError) {
						err = grid._fireValidationFail(item._index, err.column, err);
						err ? alert(options.isShowOnlyValidationMessage() && err.userMessage ? err.userMessage : err.toString()) : null;
					}
					throw err;	
	            }
                if (options.isAppendWhenExitLast()) {
                    grid.append();
                    if (grid.isItemEditing()) {
                        index.down();
                        index.home();
                    }
                }
			} else if (options.isEnterToTab() && (grid.isEditing() || this.$_checkReadOnly(index))) {
				if (grid.isEditing()) {
					grid.commitEditor(true);
				}
				index.next();
				if (skip && !this.$_skipReadOnly(index, 1)) {
					index.assign(focused);
				}
			} else if (!options.isEnterToEdit()) {
				index.next();
				if (skip && !this.$_skipReadOnly(index, 1)) {
					index.assign(focused);
				}
			}
			if (!CellIndex.areEquals(index, focused)) {
				this.setFocused(index, true);
			} else if (grid.isValid(index) && options.isEnterToEdit()) {
				if (!grid.isEditing() && focused && focused.dataColumn() && !this.$_checkReadOnly(focused)){
					grid.showEditor(focused);
				}
			}
		}
		return true;
	},
	// supportTool에서 옮겨옴. // 여기까지
	// supportTool에서 tooltip관련 이동
	_showTooltip: function (cellView, options, buttonIndex) {
		var grid = this.grid();
		var tm = grid.toolTipManager();
		var lm = grid.layoutManager();
		var index = grid.pointToIndex(grid.mouseX(), grid.mouseY(),true);
		if (tm.isVisible() && this._tipCell == cellView && CellIndex.areEquals(index, this._tipIndex) && this._tipButton == buttonIndex) {
			return;
		}
		this._hideTooltip();
		if (cellView && options) {
			var bounds = cellView.boundsBy();
			var x = bounds.x, y =bounds.y;
			x = cellView._dataColumn && cellView._dataColumn.isFixed() ? x : Math.max(x, lm.nonfixedBounds().x);
			if (cellView instanceof MergedDataCellElement) {
				if (index) {
					var h = index.I() - Math.max(cellView.index().I(), grid.topIndex()) + 1;
					y += h * grid._layoutManager.$_calcItemHeight(grid, grid._delegate, index.I());
				} else {
					y = grid.mouseY()+8;
				}
			} else {
				y += cellView._height;
			}
			tm.show(options, x, y, cellView);
			this._tipCell = cellView;
			this._tipIndex = index.clone();
			this._tipButton = buttonIndex;
		}
	},
	_showTooltip2: function (cell) {
		var grid = this.grid();
		var index = cell.index();
		var dcol = index.dataColumn();
		var dataId = index.dataId();
		var buttonIndex = -1;
		var vCell = grid._validationManager._validateCellList[dataId] && grid._validationManager._validateCellList[dataId][dcol.dataIndex()];
        // dcol && dcol.cursor() && grid.setCursor(dcol.cursor());
		if (grid.editOptions().isHintOnError() && (dcol && grid.isItemEditing(index.item()) && dcol.error()) || (vCell)) {
			if (vCell) {
				this._tipOptions.setMessage(vCell.message);
			} else {
				this._tipOptions.setMessage(dcol.error().message || dcol.error());
			}
			this._tipOptions.setStyles({
				background: "#eeffcc99"
			});
			this._showTooltip(cell, this._tipOptions);
		} else {
			var renderer = cell.renderer();
			if (renderer && cell instanceof MergedDataCellElement) {
				index = grid.pointToIndex(grid.mouseX(), grid.mouseY(), true);
			}
			if (renderer instanceof ImageButtonsCellRenderer || renderer instanceof ImageButtonCellRenderer) {
				buttonIndex = renderer.ptInButtonIndex(cell, cell.mouseX(), cell.mouseY());
			}
			if (renderer && (!CellIndex.areEquals(index, this._tipIndex) || (this._tipButton != buttonIndex))) {
				var s = renderer.getTooltip(cell, index, buttonIndex);
				if (renderer.isShowTooltip() && (s || grid._displayOptions.isEmptyShowTooltip())) {
					if (renderer.isTooltipEllipseTextOnly()) {
						var txtWidth = renderer.measure(grid, cell, 0,0).width;
						var w = Math.min(renderer._rect.width, cell.width());
						if (txtWidth < w) {
							return;
						}
					}
					var opts = this._grid._fireShowTooltip(index, s);
					var defStyles = {
							background: "#eeffffff"
						};
					if (opts && typeof opts == "object") {
						this._tipOptions.setMessage(opts.message);
						this._tipOptions.setStyles(opts.styles ? opts.styles : defStyles);
					} else if (opts && typeof opts == "string") {
						this._tipOptions.setMessage(opts);
						this._tipOptions.setStyles(defStyles);
					} else {
						return;
					}
					this._showTooltip(cell, this._tipOptions, buttonIndex);
				}
			}
		}
	},
	_showHeaderTooltip: function (headerCell, options) {
		var grid = this.grid();
		var tm = grid.toolTipManager();
		var lm = grid.layoutManager();
		if (tm.isVisible() && this._tipCell == headerCell) {
			return;
		}
		this._hideTooltip();
		if (headerCell && options) {
			var elt = headerCell;
			var grid = this.grid();
			if (headerCell instanceof ColumnView) {
				var x = grid.mouseX()+8, y = grid.mouseY();
			} else {
				var br = headerCell.boundsBy();
				var x = headerCell._column.isFixed() ? br.x : Math.max(br.x, lm.nonfixedBounds().x)
				var y = br.y + br.height;
			}
			tm.show(options, x, y, headerCell);
			this._tipCell = headerCell;
		}
	},
	_showHeaderTooltip2:function(cell) {
		var grid = this.grid();
		if (grid.header().isShowTooltip() && this._tipCell != cell) {
			var headerCell = _cast(cell, HeaderCellElement);
			if (headerCell.isShowTooltip()) {
				var s = headerCell._tooltip || headerCell._text;
				if (grid.header().isTooltipEllipseTextOnly()) {
						var txtWidth = headerCell.tooltipWidth(grid, headerCell.width(), headerCell.height()).width;
						var w = Math.min(headerCell._calcWidth ? headerCell._calcWidth : headerCell.width(), headerCell.width());
						if (txtWidth <= w) {
							return;
						}					
				}
				if (s) {
					var opts = grid._fireShowHeaderTooltip(headerCell._column, s);
					var defStyles = {
							background: "#eeffffff"
						};
					if (opts && typeof opts == "object") {
						this._tipOptions.setMessage(opts.message);
						this._tipOptions.setStyles(opts.styles ? opts.styles : defStyles);
					} else if (opts && typeof opts == "string") {
						this._tipOptions.setMessage(opts);
						this._tipOptions.setStyles(defStyles);
					} else {
						return;
					}
					this._showHeaderTooltip(headerCell, opts);
				}
			}
		}
	},
	_hideTooltip: function (x, y) {
		this.grid().toolTipManager().close(x, y);
		this._tipCell = null;
		this._tipIndex = null;
		this._tipButton = -1;
	}
	// supportTool에서 tooltip관련 이동 // 여기까지.
});
var GridScrollTool = defineClass("GridScrollTool", null, {
    init: function (owner) {
        this._super(owner, "gridScrollTool");
        this._scrollTimer = null;
    },
    isScrolling: function () {
        return this._scrollTimer != null;
    },
    stop: function (x, y) {
        if (this._scrollTimer) {
            this._scrollTimer.stop(x, y);
            this._scrollTimer = null;
        }
    },
    start: function (element, x, y) {
        if (element instanceof ScrollButton) {
            if (element.isEnabled()) {
                this._scrollTimer = new ScrollButtonTimer(element);
                this._scrollTimer.start();
            }
            return true;
        }
        if (element instanceof ScrollBar) {
            if (element.ptInTrack(x, y, true)) {
                this._scrollTimer = new ScrollTrackTimer(element, true);
            } else if (element.ptInTrack(x, y, false)) {
                this._scrollTimer = new ScrollTrackTimer(element, false);
            }
            if (this._scrollTimer) {
                this._scrollTimer.start();
                return true;
            }
        }
        return false;
    },
    move: function (x, y) {
        this._scrollTimer.move(x, y);
    }
});
var GridSelectionTool = defineClass("GridSelectionTool", GridTool, {
	init: function (owner) {
		this._super(owner, "selectionTool");
		this._clickPos = Point.empty();
		this._clickElement = null;
		this._clickHandle = null;
		this._clickCell = null;
		this._reclickCell = null;
		this._tmpIndex = this._grid.getIndex();
		this._skipIndex = this._grid.getIndex();
        this._scrollTool = new GridScrollTool();
		this._rightClicked = null;
		this._prevElt = null;
		this._rowHoverView = new RowHoverView(false, this._grid && this._grid._displayOptions);
		this._rowBlockView = new RowBlockView(false, this._grid && this._grid._displayOptions);
		this._checkScroll = this._prevScroll = Date.now();
	},
	destroy: function() {
		this._destroying = true;
		this._clickPos = null;
		this._clickElement = null;
		this._clickHandle = null;
		this._clickCell = null;
		this._reclickCell = null;
		this._tmpIndex = null;
		this._skipIndex = null;
        this._scrollTool = null;
		this._rightClicked = null;
		this._prevElt = null;
		this._rowHoverView = null;
		this._rowBlockView = null;
		this._super();
	},
	hoveredCell: null,
	setHoveredCell: function (value, x, y) {
		if (value != this._hoveredCell) {
			this._hideTooltip();
			if (this._hoveredCell) {
				this._hoveredCell.setMouseEntered(false);
			}
			this._hoveredCell = value;
			if (this._hoveredCell) {
				this._hoveredCell.setMouseEntered(true);
			}
		} else if (value instanceof DataCellElement && value.renderer() instanceof ImageButtonsCellRenderer){
			// value : DataCellElement
			var idx = value.getPtInDataButtonIndex(value.mouseX(),value.mouseY());
			this._tipButton !== idx && this._hideTooltip();
			// ImageButtonsCellRenderer의 경우 버튼마다 tooltip을 둘수 있다.
		}
		var grid = this.grid();
		var cell = value;
		var self = this;
		var tm = grid.toolTipManager();
		var cursor;
		if (cell instanceof DataCellElement && grid.canHovering()) {
			if (tm) {
				if (tm._hintDuration > 0) {
					tm._showTimer && clearTimeout(tm._showTimer);
					tm._showTimer = setTimeout(function() {self._showTooltip2(cell)}.bind(self), tm._hintDuration);
				} else {
					this._showTooltip2(cell);
				}
			}
			cursor = cell.cursor && cell.cursor(cell.mouseX(), cell.mouseY());
			cursor = cursor || grid.getCellCursor(cell._index);
			cursor && grid.setCursor(cursor);
		} else if (cell instanceof HeaderCellElement && grid.canHovering()) {
			if (tm) {
				if (tm._hintDuration > 0) {
					tm._showTimer && clearTimeout(tm._showTimer);
					tm._showTimer = setTimeout(function() {self._showHeaderTooltip2(cell)}.bind(self), tm._hintDuration);
				} else {
					this._showHeaderTooltip2(cell);
				}
			}
		}
	},
    isEditing: function () {
        return this._grid.isEditing();
    },
	_doActivate: function () {
		this._super();
		this._grid.addFocusElement(this._focusView);
        this._innerFocusView && this._grid.addFocusElement(this._innerFocusView);
        this._grid.addRowFocusElement(this._rowFocusView);
        this._grid.addFeedbackElement(this._rowHoverView);
        this._grid.addFeedbackElement(this._rowBlockView);
	},
	_doDeactivate: function () {
		this._grid.removeFocusElement(this._focusView);
        this._innerFocusView && this._grid.removeFocusElement(this._innerFocusView);
        this._grid.removeRowFocusElement(this._rowFocusView);
        this._grid.removeFeedbackElement(this._rowHoverView);
        this._grid.removeFeedbackElement(this._rowBlockView);
		this._super();
	},

	/**
	 * true를 리턴하면 editor에서 key 입력이 무시된다.
	 */
	_doKeyDown: function (key, ctrl, shift, alt) {
		trace("selectionTool K E Y: " + key);
		var item;
		var grid = this.grid();
		var lm = grid.layoutManager();
		var options = grid.editOptions();
		var skip = options.isSkipReadOnly();
		var skipCell = options.isSkipReadOnlyCell();
		var focused = this.focused();
		var verticalStep = options.verticalMovingStep()
		focused._verticalStep = verticalStep;
		var index = focused.clone();
		var isMac = false;
        var appending = false;
        if (!grid._fireKeyDown(key, ctrl, shift, alt))
        	return true;
		if (!grid._focusedCheckIndex && DataCellRenderer.consumeKey(index, key, ctrl, shift)) {
			return true;
		}
        grid.closeFilterSelector();
        if (options && options.isCheckWhenSpace() && key == Keys.SPACE && grid._focusedCheckIndex) {
        	var cell = grid.checkBar().getCell(grid._focusedCheckIndex);
			if (cell) {
				this._checkCellClicked(cell);
				return true;
			}
		};
		if (grid._focusedCheckIndex) {
			grid._focusedCheckIndex = undefined;
			var cb = grid.checkBar();
			cb._dirty = true;
			cb.invalidate();
		};
		var pmManager = grid.popupMenuManager();
		if (pmManager.isShow() && _included(key, Keys.LEFT, Keys.UP, Keys.DOWN, Keys.RIGHT, Keys.ENTER, Keys.SPACE)) {
			pmManager.keyDown(key);
			return true;
		}
		if (key == Keys.ESCAPE) {
			grid.closePopups();
			this._doCancel(grid);
		} else if (key == Keys.ENTER) {
			return this._doEnter(grid, options, index);
		} else if (key == Keys.TAB) {
			return this._doTab(grid, options, index, ctrl, shift);
		} else if (key == Keys.F2) {
			if (!grid.isEditing() && index && index.dataColumn()) {
				grid.showEditor(index, shift);
			}
		} else if (key == Keys.INSERT) {
			if (options.isAppendWhenInsertKey() || grid.itemCount() == 0) {
				grid.append();
			} else {
				grid.insert(index.item(), shift, ctrl);
			}
		} else if (key == Keys.DELETE) {
            if (ctrl && shift) {
                grid.revertSelection();
                return true;
            } else if (ctrl) {
				grid.deleteSelection();
				return true;
			}
			return false;
		} else if (key == Keys.BACK) {
			return false;
		/*
		} else if (key == Keys.SPACE && grid.isReadMode()) {
			var cell = grid.checkBar().getCell(index);
			if (cell) {
				this._checkCellClicked(cell);
			}
		*/
		} else if (_included(key, Keys.HOME, Keys.END, Keys.RIGHT, Keys.LEFT, Keys.DOWN, Keys.UP, Keys.PAGEDOWN, Keys.PAGEUP)) {
			var itemCount = grid.itemCount();
			if (key == Keys.DOWN && itemCount == 0) {
				grid.append();
				return;
			}
			if (!grid.isValid(index)) {
				index.normalize(grid);
				this.setFocused(index, true);
				return true;
			}
			if ((_included(key, Keys.DOWN, Keys.PAGEDOWN) || (key == Keys.END && ctrl)) && index.isBottom() && this.$_checkAppending(index)) {
				return true;
			}
			if ((_included(key, Keys.UP, Keys.PAGEUP) || (key == Keys.HOME && ctrl)) && index.isTop() && this.$_checkAppending(index, true)) {
				return true;
			}
			switch (key) {
			case Keys.HOME:
				if (ctrl) {
					var orgIndex = index.clone();
					index.first();
					if (skip && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, 1, orgIndex)) {
							index.assign(focused);
							break;
						}
					}
				} else {
					index.home();
					this.$_skipReadOnly(index, 1);
				}
				break;
			case Keys.END:
				if (ctrl) {
					var orgIndex = index.clone();
					index.last();
					if (skip && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, -1, orgIndex)) {
							index.assign(focused);
							break;
						}
					}
				} else {
					index.end();
					this.$_skipReadOnly(index, -1);
				}
				break;
			case Keys.RIGHT:
				index.right();
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnly(index, 1)) {
						index.assign(focused);
						break;
					}
				}
				break;
			case Keys.LEFT:
				index.left();
				if (options && options.isCheckWhenSpace() && CellIndex.areEquals(index, focused)) {
					var cb = grid.checkBar();
					var ci = cb && cb.getCell(index);
					if (ci && ci.index().item().isCheckable()) {
						grid._focusedCheckIndex = ci ? ci._index.clone() : null;
						cb._dirty = true;
						cb.invalidate();
						break;
					}
				};
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnly(index, -1)) {
						index.assign(focused);
						break;
					}
				}
				break;
			case Keys.DOWN:
				try {
					if (index.I() == grid.itemCount() - 1 && (index.isBottom() || verticalStep == VerticalMovingStep.ROW)) {
						if (index.isBottom()) {
							if (this.$_commitCancel(index.item(), options))
								return true;
						}
						grid.append();
	                    appending = true;
						if (ctrl && isMac) {
							index.last();
						} else {
							index.down(grid.isItemEditing(index.item()));
						}
					} else {
						if (ctrl && isMac) {
							index.last();
						} else if (ctrl) {
							grid.setTopIndex(grid.topIndex()+1);
							return true;
						} else {
							index.down(grid.isItemEditing(index.item()));
						}
					}
				} finally {
					if (skipCell && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, 1)) {
							index.assign(focused);
						}
					}
				}
				break;
			case Keys.UP:
				try {
	                if (index.I() == 0 && index.isTop()) {
						if (this.$_commitCancel(index.item(), options))
							return true;

	                    if (ctrl && isMac) {
	                        index.first();
	                    } else {
	                        index.up();
	                    }
	                } else {
	                    if (ctrl && isMac) {
	                        index.first();
	                    } else if (ctrl) {
							grid.setTopIndex(grid.topIndex()-1);
							return true;
	                    } else {
	                        index.up(grid.isItemEditing(index.item()));
	                    }
	                }
				} finally {
					if (skipCell && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, -1)) {
							index.assign(focused);
						}
					}				
				}
				break;
			case Keys.PAGEUP:
				if (ctrl && !isMac) {
					grid.setTopIndex(grid.topIndex() - lm.fullItemCount());
					return true;
				}
				var orgIndex = index.clone();
				index.incRow(-lm.fullItemCount());
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnlyCell(index, 1, orgIndex)) {
						index.assign(focused);
						break;
					}
				}
				break;
			case Keys.PAGEDOWN:
				if (index.I() == grid.itemCount() - 1 && index.isBottom()) {
					if (ItemState.isInserting(index.item().itemState())) {
						if (grid.commit(options.isForceAppend())) {
						}
						return true;
					}
				}
				if (ctrl && !isMac) {
					grid.setTopIndex(grid.topIndex() + lm.fullItemCount());
					return true;
				}
				var orgIndex = index.clone();
				index.incRow(lm.fullItemCount());
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnlyCell(index, -1, orgIndex)) {
						index.assign(focused);
						break;
					}
				}
				break;
			}
            if (shift && grid.selections().count() > 0) {
                this.setFocused(index, false);
                grid.selections().getItem(0).resizeTo(index);
            } else {
                this.setFocused(index, true);
            }
			return true;
		} else if (index.item() instanceof DummyEditItem) {
			grid.append();
		}
		return false;
	},
	_doKeyUp: function (key, ctrl, shift, alt) {
		trace("selectionTool KeyUp KEY: " + key + ",ctrl="+ctrl+",shift="+shift+",alt="+alt);
		this.grid()._fireKeyUp(key, ctrl, shift, alt);
	},
	_doKeyPress: function (key) {
		trace("selectionTool KeyPress");
		this.grid()._fireKeyPress(key);
	},
	_doClick: function (x, y) {
		if (this.isDragging()) { // || isScrollBar(event)) {
			return;
		}
		var grid = this._grid;
		var index = this.focused().clone();
		if (index) {
			var elt = this.findElementAt(x, y, true);
			elt = !elt ? this._clickElement : elt; // 반쯤 걸쳐진 셀을 클릭해서 스크롤 되었는데 마지막 셀인경우 null이 나온다.
			if (elt == this._clickElement) {
				if (this._clickElement instanceof DataCellElement) {
					// var clickIndex = this._clickElement.index();
					// if (this._clickCell instanceof MergedDataCellElement) {
					// 	clickIndex = clickIndex.clone();
					// 	this.$_calcInnerCellIndex(this._clickCell, clickIndex, x, y);
					// }
					this.dataCellClicked(index); // element의 경우 위치는 변경되지 않고 내부 값만 변경된다. focus된 index로 처리해야 한다.
					if (!grid.isEditing()) {
						if (index.column() instanceof DataColumn) {
							var col = index.dataColumn();
							var editor = grid.editController()._editor;
							if (!col.isReadOnly() && editor && (editor instanceof DropDownCellEditor || editor instanceof DateCellEditor) && editor._dropDownWhenClick) {
								// this.editButtonClicked(index)
						        grid.makeCellVisible();
						        if (grid.showEditor(index)) {
						            grid.editorButtonClick(index);
						        }
							}
						}
						if (this._reclickCell) {
							this._performRendererClick(index, this._reclickCell, x, y, false, false);
						} else {
							this._performRendererClick(index, this._clickElement, x, y, false, true);
						}
					}
				} else if (this._clickElement instanceof IndicatorCellElement) {
					this._indicatorCellClicked(index.itemIndex());
				} else if (this._clickElement instanceof HeaderPopupHandle && true) {
					var grid = this.grid(),
						popupMenuManager = grid.popupMenuManager(),
						headerElement = this._clickElement.parent(),
						column = headerElement.column(),
						columnHeader = column.header(),
						popupMenuName = columnHeader._popupMenuName;
					if (popupMenuName) {
						popupMenuManager.show(popupMenuName, headerElement, x, y, 0, 0);
					}
				}	
			}
		}
	},
    $_calcInnerCellIndex: function (cell, index, x, y) {
        if (cell instanceof MergedDataCellElement) {
            var grid = this._grid;
            var lm = grid.layoutManager();
			var p = grid.containerToElement(x, y);
			y -= lm.bodyBounds().y;
            for (var k = cell._topIndex; k <= cell._bottomIndex; k++) {
				var r = lm.itemBounds(k);
				if (y >= r.y && y < r.bottom()) {
					index.itemIndex(k + grid.topIndex());
					break;
				}
            }
        }
    },
	_doDblClick: function (x, y) {
		if (this.isDragging()) {
			return;
		}
		var grid = this._grid;
		var index = this.focused();
		var elt = this.findElementAt(x, y, true);
		if (elt === this._clickElement) {
			var clickIndex;
			var request = this._getEditRequest(this._clickElement, x, y, false, false);
			if (request instanceof RowResizeRequest) {
				var itemIndex = request.itemIndex()+grid.topIndex();
				grid.layoutManager().fitRowHeight(itemIndex, 0, false, true);
			};
			if (this._clickElement instanceof DataCellElement) {
				clickIndex = this._clickCell.index();
				if (this._clickCell instanceof MergedDataCellElement) {
					clickIndex = clickIndex.clone();
					this.$_calcInnerCellIndex(this._clickCell, clickIndex, x, y);
				}				
				this.dataCellDblClicked(clickIndex);
			}
			if (this._clickElement instanceof RowGroupHeaderCellElement) {
				var clickItem = this._clickElement.item();
				if ((clickItem instanceof GroupItemImpl || clickItem instanceof MergedGroupHeader) && clickItem.isExpanded && clickItem.setExpanded) {
					var expanded = !clickItem.isExpanded();
					clickItem.setExpanded(expanded);
				}
				var idx = CellIndex.temp(grid, this._clickElement.index().itemIndex(), grid.columnByField(clickItem._groupField));
				this.rowGroupHeaderFooterDblClicked(-1, idx);
			} else if (this._clickCell instanceof GroupFooterCellElement) {
				// var item = this._clickElement.item();
				// var groupItem = item && item.parent();
				// if (groupItem && !groupItem.isVisible()) {
				// 	var expanded = !groupItem.isExpanded();
				// 	groupItem.setExpanded(expanded);
				// }
				this.rowGroupHeaderFooterDblClicked(-2, this._clickCell.index());
			} else if (this._clickElement instanceof HeaderCellElement) {
				var request = this._getEditRequest(this._clickElement, x, y, false, false);
				if (request instanceof ColumnResizeRequest) {
					var col = this._clickElement.index().column();
					var minWidth = Math.max(col.minWidth(), Column.MIN_WIDTH);
					var maxWidth = col.maxWidth();
					grid.layoutManager().fitColumnWidth(col, false, minWidth, maxWidth);
					grid._fireColumnPropertyChanged(col, "width", col.width());
				} else {
					if (this._clickElement.parent() instanceof HeaderElement || this._clickElement.parent() instanceof HeaderGroupCellElement) {
						this.columnHeaderDblClicked(this._clickElement.index().column());
					} else if (elt.parent() instanceof GroupByView) {
						this.rowGroupPanelDblClicked(this._clickElement.index().column());
					}
				}
			} else if (index.isValid() && !grid.isEditing() && this._clickCell instanceof DataCellElement) {
				if (CellIndex.areEquals(clickIndex, index)) {
					grid.showEditor(clickIndex);
				}
			} else if (this._clickCell instanceof FooterCellElement) {
				if (this._clickCell.error()) {
					grid.alertCellError(this._clickCell, this._clickCell.errorDetail() || this._clickCell.error());
				} else {
					this.footerCellDblClicked(this._clickCell.index().column());
				}
			} else if (this._clickCell instanceof HeaderSummaryCellElement) {
				if (this._clickCell.error()) {
					grid.alertCellError(this._clickCell, this._clickCell.errorDetail() || this._clickCell.error());
				} else {
					this.headerSummaryCellDblClicked(this._clickCell.index().column());
				}

			} else if (this._clickCell instanceof GroupFooterCellElement && this._clickCell.error()) {
				grid.alertCellError(this._clickCell, this._clickCell.errorDetail() || this._clickCell.error());
			} else if (this._clickCell instanceof IndicatorHeadElement) {
				this.indicatorCellDblClicked(-1);
			} else if (this._clickCell instanceof IndicatorFootElement) {
				this.indicatorCellDblClicked(-2);
			} else if (this._clickCell instanceof IndicatorCellElement) {
				this.indicatorCellDblClicked(elt.index().itemIndex());
			} else if (this._clickCell instanceof StateBarHeadElement) {
				this.stateBarCellDblClicked(-1);
			} else if (this._clickCell instanceof StateBarFootElement) {
				this.stateBarCellDblClicked(-2);
			} else if (this._clickCell instanceof StateBarCellElement) {
				this.stateBarCellDblClicked(elt.index().itemIndex());
			} else if (this._clickCell instanceof CheckBarFootElement) {
				this.checkBarFootDblClicked();
			} else if (this._clickCell instanceof RowGroupHeadCellElement) {
				this.rowGroupHeadDblClicked();
			} else if (this._clickCell instanceof RowGroupFootCellElement) {
				this.rowGroupFootDblClicked();
			} else if (this._clickCell instanceof RowGroupBarCellElement) {
				this.rowGroupBarDblClicked(this._clickCell.level());
			} else if (this._clickCell instanceof RowGroupExpandHandle) {
				this.rowGroupBarDblClicked(-1);
			} else if (this._clickCell instanceof RowGroupExpanderElement) {
				this.rowGroupBarDblClicked(-2);
			} else if (this._clickElement instanceof GroupByView) {
				this.panelDblClicked();
			} else if (this._clickElement == null) {
				this.bodyEmptyDblClicked();
			}
		}
	},
	_doMouseDown: function (x, y, ctrlKey, shiftKey, button, event) {
		var grid = this._grid;
		this._hideTooltip();
		grid.closePopups();
		grid._buttonClicked = false;		
		// grid.setFocus();
        this._scrollTool.stop();
		var clickElement = this._clickElement = null;
		var clickCell = this._clickCell = null;
		this._reclickCell = null;
		this._clickHandle = null;
		var preEditor,
		    curEditor;
		this._rightClicked = button > 1 ? true : false;
		if (grid._focusedCheckIndex) {
			grid._focusedCheckIndex = null;
			grid._checkBar && (grid._checkBar._dirty = true);			
		}		    
        if (button == 0 || grid.displayOptions().isRightClickable()) {
            clickElement = this._clickElement = this.findElementAt(x, y, false);
            if (this._scrollTool.start(clickElement, x, y)) return;
            this._clickHandle = _cast(clickElement, HandleElement);
            clickCell = this._clickCell = _cast(clickElement, CellElement);
            this._clickPos.set(x, y);
            if (this._clickHandle) {
                if (this._clickHandle.isClickable()) {
                    this.$_handleClicked(this._clickHandle);
                    return;
                }
            }
        }
		if (clickCell instanceof DataCellElement && this.$_checkAppending(grid.focusedIndex(), true, clickCell)) {
			this._clickElement = null;
			this._clickCell = null;
			return;
		}
        var request, tracker;
		if (clickCell) {
			var idx, tracker;
			var selected = false;
			var footerView = null;
			var mergedFooter = null;
			var index = clickCell.index().clone();
            if (clickCell instanceof MergedDataCellElement) {
                this.$_calcInnerCellIndex(clickCell, index, x, y);
            }
            request = this._getEditRequest(clickCell, x, y, ctrlKey, shiftKey);
			if (!request || request.isSelectable()) {
				if (!shiftKey) {
					if (!this._rightClicked || !grid._selections.contains(index)) {
						// if (clickCell instanceof DataCellElement) {
							// grid._selections.clear();
						// } else 
						if (clickCell instanceof IndicatorCellElement && grid.indicator().isSelectable()) {
							grid._selections.clear();
						} else if (clickCell instanceof RowGroupHeaderCellElement) {
							grid._selections.clear();
						} else if ((footerView = this.$_getGroupFooterView(clickCell)) != null) {
							grid._selections.clear();
						} else if ((mergedFooter = this.$_getMergedFooterView(clickCell)) != null) {
							grid._selections.clear();
						}
					}
				}
				if (clickCell instanceof DataCellElement) {
					if (CellIndex.areEquals(index, this.focused())) {
						this._reclickCell = this._clickCell;
					}
                    if(!(request instanceof CellButtonRequest) && this._reclickCell && grid.editOptions().isEditWhenClickFocused()) {
						grid.showEditor(index);
						setTimeout(function(){
							grid._editController._editor.selectAll(); 
							grid._editController._editor.setFocus();
						},100);
                    } else {
                        selected = true;
                    }
				} else if (clickCell instanceof IndicatorCellElement) {
					if (grid.indicator().isSelectable()) {
						idx = this._tmpIndex;
						idx.assign(grid.focusedIndex());
						idx.itemIndex(index.I());
						if (idx.C() == null && idx.item() instanceof GridRow) {
							idx.column(grid.getFirstColumn());
						}
						index = idx;
						selected = true;
					}
				} else if (clickCell instanceof RowGroupHeaderCellElement) {
					index.setColumn(grid.getVisibleColumn(index.item().level()));
					selected = true;
				} else if (footerView) {
					idx = this.focused().clone();
					idx.itemIndex(footerView.item().index());
					index = idx;
					selected = true;
				} else if (mergedFooter) {
					selected = true;
				}
				if (selected && !shiftKey) {
					index.normalize(grid);
					// right Click이면서 영역밖인 경우. selected True
					var hasSelect = !this._rightClicked || !grid._selections.contains(index);
					preEditor = grid._editController._editor;
					if (this.setFocused(index, hasSelect)) { // 아래 selectionTracker에서 clear할 것이다.
						if (SelectionStyle.isSingle(grid._selectOptions.style()) && grid._selections.count() < 1) {
							grid.clearSelection();
						} 
					} else {
						return;
					}
					curEditor = grid._editController._editor;
				}
			}
            if (button == 0) {
                tracker = this._getDragTracker(request, x, y);
                this.setDragTracker(tracker);
                if (grid._selections.count() < 1) {
                    if (grid._selectOptions.style() == SelectionStyle.ROWS && !(tracker instanceof RowsSelectTracker) ||
                        grid._selectOptions.style() == SelectionStyle.COLUMNS && !(tracker instanceof ColumnsSelectTracker)) {
                        grid.clearSelection();
                    }
                }
            }
		} else if (clickElement) { // for scrollbar
			request = this._getEditRequest(clickElement, x, y, false, false);
			if (request) {
				this.setDragTracker(this._getDragTracker(request, x, y));
			}
		}
		tracker = this.dragTracker();
		if (tracker && tracker.isStartWhenCreated()) {
			if (tracker instanceof SelectTracker && shiftKey) {
				this._startDragTracker(x, y, shiftKey);
				var sIndex = clickCell.index().clone()
				clickCell instanceof MergedDataCellElement && this.$_calcInnerCellIndex(clickCell, sIndex, x, y);
				tracker._item && tracker._item.resizeTo(sIndex);
			} else {
				this._startDragTracker(x, y);
			}
		}
		if (preEditor && curEditor && preEditor != curEditor && curEditor instanceof MultiLineCellEditor) {
			if (event && event.preventDefault) {
				!_isFirefox && event.preventDefault();
			}
		}
	},
	_doMouseMove: function (x, y, ctrlKey, shiftKey) {
		var grid = this._grid;
		if (!grid || grid._destroying) {
			return;
		}
		var i, cnt, rowElt, rowElts, hoverY;
		if (this._scrollTool.isScrolling()) {
			this._scrollTool.move(x, y);
		} else if (this.dragTracker()) {
			this._hideTooltip();
		} else {
			var elt = null;
			grid.setCursor(Cursor.DEFAULT);
			elt = this.findElementAt(x, y, true);
			if (grid.canHovering()) {
				this.setHoveredCell(_cast(elt, CellElement), x, y);
			} else {
				this._hideTooltip();
			}
			if (this._prevElt) {
				this._prevElt.setButtonState(false, false);
				this._prevElt = null;
			}
			var rowElt;
			var hMask = grid.displayOptions().rowHoverMask();
			var hView = this._rowHoverView;
			if (elt && (elt instanceof DataCellElement || elt.paretnAs && elt.parentAs(RowElement)) && hMask && hMask.isVisible()) {
				rowElts = grid._bodyView._elements;
				hoverY = parseInt(y) - grid._bodyView.bounds().y;
				cnt = rowElts ? rowElts.length : 0;
				for (i = 0; i < cnt ; i++) {
					if (rowElts[i].y() <= hoverY && rowElts[i].bottom() >= hoverY) {
						rowElt = rowElts[i];
						break;
					};
					if (rowElts[i].y() > hoverY) {
						break;
					}
				}
				if (rowElt instanceof RowElement && (hView._rowHoverPos != rowElt.y() || (hMask.hoverMask() == "cell" && hView.$_hoverCell != elt))) {
					if (this._rowFocusView && this._rowFocusView.isVisible() && this.focused() && this.focused().itemIndex() == rowElt.itemIndex()) {
						hView._rowHoverPos = -1;
						hView.$_hoverCell = null;
						hView.$_hoverRow = null;
						hView.setVisible(false);
					} else {
						hView.setVisible(true);
						this.$_updateRowHoverView(grid, rowElt, elt)
						hView._hoverMouseY = Math.max(0,hoverY-1);
					}
				} else {
					!(rowElt instanceof RowElement) && (hView._rowHoverPos = -1, hView.$_hoverCell = null, hView.$_hoverRow = null, hView.setVisible(false));
				}
			} else {
				hView._rowHoverPos = -1;
				hView.$_hoverCell = null;
				hView.$_hoverRow = null;
				hView.setVisible(false);
			}
			var request = this._getEditRequest(elt, x, y, ctrlKey, shiftKey);
			if (request && request.cursor()) {
                grid.setCursor(request.cursor());
			} else if (elt instanceof DataCellElement) {
				x = elt.mouseX();
				y = elt.mouseY();
				if (elt.ptInDataButton(x, y)) {
					var button = elt.getPtInDataButtonIndex(x, y);
					elt.setButtonState(true, false, button);
				} else if (elt.ptInButton(x, y)) {
					var button = elt.getPtInButtonIndex(x,y);
					elt.setButtonState(true, false, button);
					this._prevElt = elt;
				} else {
					elt.setButtonState(false, false);
				}
			}
		}
	},
	_doMouseUp: function (x, y, event) {
		var grid = this._grid;
		var elt = this.findElementAt(x, y, true);
		elt && !_included(elt.$name, "CheckBarCellElement", "ScrollBar", "ScrollButton", "ScrollThumb") && (delete this._prevCheckIndex);
		// !(elt instanceof CheckBarCellElement || elt instanceof ScrollBar) && (delete this._prevCheckIndex);
        if (this._scrollTool.isScrolling()) {
            this._scrollTool.stop(x, y);
		} else if ((!this.dragTracker() || !this.dragTracker().isCompleted()) && elt == this._clickElement) {
			if (elt instanceof HeaderCellElement && elt.isClickable()) {
				var request = this._getEditRequest(this._clickElement, x, y, false, false);
				if (!request || !request.isDblClickable()) {
					if (elt.parent() instanceof HeaderElement || elt.parent() instanceof HeaderGroupCellElement) {
						this.$_columnHeaderClicked(elt.index().column(), this._rightClicked, event);
					} else if (elt.parent() instanceof GroupByView) {
						this._rowGroupPanelClicked(elt.index().column());
					}
				}
			} else if (elt instanceof HeaderImageHandle) {
				this.$_columnHeaderImageClicked(elt.cellView().column());
			} else if (elt instanceof HeaderCheckHandle) {
                elt.cellView().column().setChecked(!elt.cellView().column().isChecked());
            } else if (elt instanceof GroupRemoveButtonHandle) {
            	grid.removeGroupBy(elt.cellView().column());
            } else if (elt instanceof CheckBarCellElement) {
				this._checkCellClicked(elt, event);
				this._prevCheckIndex = elt.index().clone();
			} else if (elt instanceof CheckBarHeadElement) {
				this._checkAllClicked(elt);
			} else if (elt instanceof CheckBarFootElement) {
				this._checkBarFootClicked();
			} else if (elt instanceof IndicatorCellElement) {
				this._indicatorCellClicked(elt.index().itemIndex());
			} else if (elt instanceof IndicatorHeadElement) {
				if (grid.filteringOptions().isEnabled()) {
				}
				this._indicatorCellClicked(-1);
			} else if (elt instanceof IndicatorFootElement) {
				this._indicatorCellClicked(-2);
			} else if (elt instanceof StateBarCellElement) {
				this._stateBarCellClicked(elt.index().itemIndex());
			} else if (elt instanceof StateBarHeadElement) {
				this._stateBarCellClicked(-1);
			} else if (elt instanceof StateBarFootElement) {
				this._stateBarCellClicked(-2);
			} else if (elt instanceof RowGroupHeadCellElement) {
				this._rowGroupHeadClicked();
			} else if (elt instanceof RowGroupFootCellElement) {
				this._rowGroupFootClicked();
			} else if (elt instanceof RowGroupHeaderCellElement) {
				var column = grid.columnByField(elt.item()._groupField);
				var index = CellIndex.temp(grid, elt.index().itemIndex(), column);
				this._rowGroupHeaderFooterClicked(-1, index);
			} else if (elt instanceof GroupFooterCellElement) {
				this._rowGroupHeaderFooterClicked(-2, elt.index());
			} else if (elt instanceof RowGroupBarCellElement) {
				this._rowGroupBarClicked(elt.level());
			} else if (elt instanceof RowGroupExpandHandle) {
				this._rowGroupBarClicked(-1);
			} else if (elt instanceof RowGroupExpanderElement) {
				this._rowGroupBarClicked(-2);
			} else if (elt instanceof GroupByView) {
				this._panelClicked(0);
			} else if (elt instanceof FooterCellElement) {
				this._footerCellClicked(elt.index().column());
			} else if (elt instanceof HeaderSummaryCellElement) {
				this._headerSummaryCellClicked(elt.index().column());
			} else if (elt && elt.isClickable()) {
				this.$_elementClicked(elt);
			} else if (elt == null) {
				this._bodyEmptyClicked();
			}
		}
		this.setDragTracker(null);
	},
	_doMouseOutside: function () {
		if (this._hoveredCell) {
			this._hoveredCell.setMouseEntered(false);
			this._hoveredCell = null;
		}
		this._grid._validateScrollBars();
		this._grid._toolTipManager && this._grid._toolTipManager._active && this._grid._toolTipManager.close();
	},
	_doMouseWheel: function (event /*x, y, deltaX, deltaY*/) {
		// var x = event.mouseX, y = event.mouseY, deltaX = event.wheelDelta, deltaY = event.wheelDelta;
		var options = this._grid.displayOptions();
		if (options.isWheelEnabled()) {
			this._super(event /*x, y, deltaX, deltaY*/);

			var isHorz = (event.shift || (Math.abs(event.deltaX) > Math.abs(event.deltaY)));
			isHorz = isHorz && options.wheelScrollHorz() !== 0;
			if (!isHorz) {
	            var top = this._grid.topIndex();
	            var wheelScrollLines = Math.abs(options.wheelScrollLines());
				var curScroll = Date.now();
	            wheelScrollLines = !!wheelScrollLines ? wheelScrollLines : 3;
	            if (options.wheelAccelDelay() > 0) {
					if (curScroll > this._prevScroll+300) {
						this._checkScroll = curScroll;
					} else {
						if (this._checkScroll+options.wheelAccelDelay() < curScroll) {
							var cnt = this._grid.itemCount();
							var wheelAccelScroll = options.wheelAccelScroll();
							if (wheelAccelScroll && !isNaN(wheelAccelScroll)) {
								wheelScrollLines = parseInt(wheelAccelScroll);
							} else if (typeof wheelAccelScroll === "string") {
								wheelAccelScroll = wheelAccelScroll.trim();
								if (wheelAccelScroll.indexOf("%") > 0) {
									var cnt = this._grid.itemCount();
									wheelScrollLines = parseInt(wheelAccelScroll.substr(0, wheelAccelScroll.length-1))/100 * cnt;
								}
							}
						}
					}
	            }
				this._prevScroll = curScroll;
	            this._grid.setTopIndex(this._grid.topIndex() + (event.wheelDelta > 0 ? -wheelScrollLines : wheelScrollLines));
	            return !options.isWheelEventPropagate() || (top != this._grid.topIndex()); 
	        } else {
	        	var left = this._grid.leftPos();
	        	var wheelScrollPos = Math.abs(options.wheelScrollHorz() || 16) * (event.wheelDelta > 0 ? -1 : 1);
	        	this._grid.setLeftPos(left+wheelScrollPos);
	        	// IE, Edge의 경우 forword, backword가 실행되는 경우가 있다. return true로 막아준다.
	        	return (_isIE || _isEdge) ? true : (!options.isWheelEventPropagate() || left != this._grid.leftPos());
	        }
		}
		return false;
	},
	_doMouseEnter: function (x, y) {
	},
	_doMouseLeave: function (x, y) {
		this._hideTooltip(x, y);
	},
	_doMouseOver: function (x, y) {
	},
	_doLayoutChanged: function (x, y) {
		this._resetFocusedView();
		this.$_resetRowBlockView();
	},
	_doFocusedIndexChanging: function (newIndex) {
	},
	_doFocusedIndexChanged: function (oldIndex, newIndex) {
		this._resetFocusedView();
	},
	editButtonClicked: function (index) {
		var grid = this.grid();
        grid.makeCellVisible();
        if (grid.showEditor(index)) {
            grid.editorButtonClick(index);
        }
		this._super(index);
	},
	$_getGroupFooterView: function (element)/* RowGroupFooterElement */ {
		var p = element.parent();
		while (p) {
			if (p instanceof RowGroupFooterElement) {
				return p;
			}
			p = p.parent();
		}
		return null;
	},
	$_getMergedFooterView: function (element)/* MergedFooterElement */ {
		var p = element.parent();
		while (p) {
			if (p instanceof MergedFooterElement) {
				return p;
			}
			p = p.parent();
		}
		return null;
	},
	_getEditRequest: function (source, x, y, ctrlKey, shiftKey) {
		var request;
		var cell;
		var grid = this._grid;
		if (source instanceof ScrollThumb) {
			return new ScrollThumbRequest(source);
		}
		if (grid.visibleColumnCount() < 1) {
			return null;
		}
		if (!(source instanceof CellElement)) { 
			return null;
		}
		cell = source;
		request = this.$_getRowResizeRequest(cell, x, y);
		if (request) {
			return request;
		}
		if (grid.header().isResizable()) {
			request = this.$_getHeaderResizeRequest(x, y);
			if (request) {
				return request;
			}
		}
        if (grid.header().summary().isResizable()) {
            request = this.$_getHeaderSummaryResizeRequest(x, y);
            if (request) {
                return request;
            }
        }
		if (grid.footer().isResizable()) {
			request = this.$_getFooterResizeRequest(x, y);
			if (request) {
				return request;
			}
		}	
		var index;
		var column;
		var lm = grid.layoutManager();
		var mode = grid.selectOptions().mode();
		var style = grid.selectOptions().style();
		var p = cell.localToContainer(Point.EMPTY);
		var displayOptions = grid.displayOptions();
		var editOptions = grid.editOptions();
		p.x += cell.width();
		if (cell instanceof IndicatorCellElement) {
			if (grid.indicator().isSelectable() && mode != SelectionMode.NONE && style != SelectionStyle.NONE && style != SelectionStyle.SINGLE_ROW) {
				return new SelectRequest(grid.selections(), cell, SelectionStyle.ROWS);
			}
		} else if (cell instanceof HeaderCellElement) {
			if (ctrlKey) {
				if (mode != SelectionMode.NONE && style != SelectionStyle.NONE && style != SelectionStyle.SINGLE_COLUMN) {
					return new SelectRequest(grid.selections(), cell, SelectionStyle.COLUMNS);
				}
			} else {
				index = cell.index();
				column = index.column();
				if (displayOptions.isColumnResizable() && column.isResizable() &&
					(grid.fixedOptions().isResizable() || (column.root().displayIndex() >= lm.fixedColCount() && column.root().displayIndex() < lm.rfixedStartCol()) )) {
					if (x >= p.x - 3 && x <= p.x + 3) {
						return new ColumnResizeRequest(cell);
					}
				}
				if (displayOptions.isColumnMovable() && column.isMovable() &&
					(!column.isRoot() || grid.canMoveIndex(column.root().displayIndex()))) {
					return new ColumnMoveRequest(cell);
				}
			}
		} else if (cell instanceof RowGroupHeaderCellElement || this.$_getGroupFooterView(cell) || this.$_getMergedFooterView(cell)) {
			if (mode != SelectionMode.NONE && style != SelectionStyle.NONE && !SelectionStyle.isSingle(style)) {
				if (grid.selections().count() > 0 && shiftKey) {
					return new SelectRequest(grid.selections(), cell, grid.selections().itemStyle());
				} else if (style != SelectionStyle.NONE) {
					return new SelectRequest(grid.selections(), cell,  style);
				}
			}
		} else if (cell instanceof DataCellElement) {
			if (editOptions.isInnerDraggable()) {
	            var r;
	            var dragCells;
	            if (grid.selectOptions().style() == SelectionStyle.NONE) {
	            	r = CellIndex.areEquals(grid._focusedIndex, cell.index()) && cell.boundsByContainer();
	            	dragCells = new BlockSelection(grid._selections, cell.index(), cell.index());
	            	// dragCells = cell;
	            } else {
	            	var tr = new Rectangle();
	            	var sItem = grid.selections().getItem(0);
	            	sItem && grid.$_getSelectionRangeRect(lm, sItem, tr);
	            	r = tr && tr.clone();
	            	dragCells = grid.selections().getItem(0)
	            }
	            if (r instanceof Rectangle) {
	            	var rx = r.x, rw = r.x+r.width, ry = r.y , rh = r.y+r.height;
	            	if (r && ( ((x >= rx -3 && x <= rx +3) || (x > rw -3 && x < rw +3 )) && y > ry && y < rh ) || 
	            		     ( ((y >= ry -3 && y <= ry +3) || (y > rh -3 && y < rh +3 )) && x > rx && x < rw ) || ( ctrlKey && r.contains(x,y) ) ) {
	            		var cursor = grid._fireShowInnerDragCursor(dragCells);
	            		if (cursor) {
	            			return new DragNDropRequest(dragCells, cursor);
	            		}
	            	}
	            }
			}
			x = cell.mouseX();
			y = cell.mouseY();
            if (!shiftKey && cell.ptInDataButton(x, y)) {
            	var button = cell.getPtInDataButtonIndex(x,y);
                return new DataButtonRequest(cell, button);
            }
			if (!shiftKey && cell.ptInButton(x, y)) {
				var button = cell.getPtInButtonIndex(x,y);
				return new CellButtonRequest(cell, button);	
			}
			if (!shiftKey && cell.ptInEditButton(x, y)) {
				return new EditButtonRequest(cell);
			}
            // 
			// grid.$_getSelectionRangeRect(lm, sItem, aa); 현재 selectView의 영역
			// grid._selections.contains(cell.index()) 선택된 셀이 selectionView의 영역안에 있는 가?
			if (mode != SelectionMode.NONE && style != SelectionStyle.NONE && !SelectionStyle.isSingle(style)) {
				if (grid.selections().count() > 0 && shiftKey) {
					return new SelectRequest(grid.selections(), cell,  grid.selections().itemStyle());
				} else if (style != SelectionStyle.NONE) {
					return new SelectRequest(grid.selections(), cell,  style);
				}
			}
		}
		return this._super(source, x, y, ctrlKey, shiftKey);
	},
	$_getHeaderResizeRequest: function (x, y) {
		var lm = this._grid.layoutManager();
		var w = lm.indicatorBounds().width;
		if (w <= 0) {
			w = lm.stateBarBounds().width;
		}
		if (w <= 0) {
			w = lm.checkBarBounds().width;
		}
		if (w <= 0 && (lm.fixedColCount() > 0 || lm.columnCount() > 0)) {
			w = 20;
		}
		if (w <= 0 || x >= w)
			return null;
		var r = lm.headerBounds();
		if (y > r.bottom() - 3 && y <= r.bottom()) {
			return new HeaderResizeRequest();
		}
		return null;
	},
    $_getHeaderSummaryResizeRequest: function (x, y) {
        var lm = this._grid.layoutManager();
        var w = lm.indicatorBounds().width;
        if (w <= 0) {
            w = lm.stateBarBounds().width;
        }
        if (w <= 0) {
            w = lm.checkBarBounds().width;
        }
        if (w <= 0 && (lm.fixedColCount() > 0 || lm.columnCount() > 0)) {
            w = 20;
        }
        if (w <= 0 || x >= w)
            return null;
        var r = lm.summaryBounds();
        if (y > r.bottom() - 3 && y <= r.bottom()) {
            return new HeaderSummaryResizeRequest();
        }
        return null;
    },
	$_getFooterResizeRequest: function (x, y) {
		var lm = this._grid.layoutManager();
		var w = lm.indicatorBounds().width;
		if (w <= 0) {
			w = lm.stateBarBounds().width;
		}
		if (w <= 0) {
			w = lm.checkBarBounds().width;
		}
		if (w <= 0 && (lm.fixedColCount() > 0 || lm.columnCount() > 0)) {
			w = 20;
		}
		if (w <= 0 || x >= w) {
			return null;
		}
		var r = lm.footerBounds();
		if (y >= r.y && y <= r.y + 3) {
			return new FooterResizeRequest();
		}
		return null;
	},
	$_getRowResizeRequest: function (cell, x, y) {
		var p, w, i, r, r2;
		var grid = this._grid;
		var lm = grid.layoutManager();
		var fixedItems = lm.fixedItemCount();
		var idx = -1;
		var eachRowResizable = grid.displayOptions().isEachRowResizable() && grid._rootColumn._dataLevel == 1;
		if (cell instanceof IndicatorCellElement) {
			idx = cell.index().I();
		} else if (cell instanceof  StateBarCellElement) {
			if (!grid.indicator().isVisible()) {
				idx = cell.index().I();
			}
		} else if (cell instanceof  CheckBarCellElement) {
			if (!grid.indicator().isVisible() && !grid.stateBar().isVisible()) {
				idx = cell.index().I();
			}
		} else if (cell instanceof DataCellElement) {
			if (!grid.indicator().isVisible() && !grid.stateBar().isVisible() && !grid.checkBar().isVisible() && x < 50) {
				idx = cell.index().I();
			}
		}
		if (idx < 0) {
			return null;
		}
		p = cell.localToContainer(Point.EMPTY);
		w = cell.width();
		if (w <= 0 || x < p.x || x >= p.x + w) {
			return null;
		}
		w = -1;
		if (grid.fixedOptions().isRowResizable()) {
			for (i = 0; i < fixedItems; i++) {
				if (grid.getItem(i).isResizable()) {
					if (idx == i || eachRowResizable) {
						r = lm.getItemRect(i);
						if (y >= r.bottom() - 2 && y <= r.bottom() + 2) {
							return new RowResizeRequest(i);
						} else {
							r2 = lm.footerBounds();
							if (r.bottom() >= r2.y && y >= r2.y - 2 && y <= r2.y + 2) {
								return new RowResizeRequest(i);
							}
						}
					} else {
						break;
					}
				}
			}
		}
		if (w >= 0) {
			return null;
		}
		if (grid.displayOptions().isRowResizable() || eachRowResizable) {
			if (lm.itemCount() == 0 && lm.fixedItemCount() > 0 || lm.itemCount() == 1 && lm.fullItemCount() == 0) {
				r = lm.getItemRect(0);
				r2 = lm.footerBounds();
				if (r.bottom() >= r2.y && y >= r2.y - 4 && y <= r2.y + 2) {
					return new RowResizeRequest(0);
				}
			}
			var itemCount = lm.itemCount();
			var topIndex = grid.topIndex();
			for (i = 0; i < itemCount; i++) {
				if (grid.getItem(i+fixedItems+topIndex).isResizable()) {
					if (idx - topIndex == i + fixedItems || eachRowResizable) {

						r = lm.getItemRect(i + fixedItems);
						if (y >= r.bottom() - 2 && y <= r.bottom() + 2) {
							return new RowResizeRequest(i + fixedItems);
						} else {
							r2 = lm.footerBounds();
							if (r.bottom() >= r2.y && y >= r2.y - 2 && y <= r2.y + 2) {
								return new RowResizeRequest(i + fixedItems);
							}
						}
					} else {
						break;
					}
				}
			}
		}
		return null;
	},
	$_updateRowHoverView: function(grid, rowElt, cell) {
		var view = this._rowHoverView;
		var lm = grid._layoutManager;
		var r = rowElt.boundsBy(grid._rootElement).clone();
		var gr = lm._gridBounds;
		var hoverMask = grid._displayOptions._rowHoverMask && grid._displayOptions._rowHoverMask.hoverMask();
		var mask;
		var styles = view._rowHoverMask._styles;
		var borderWidth = styles && styles.border() ? styles.border()._width : 0;
		view._rowHoverPos = rowElt.y();
		view.$_hoverCell = null;
		switch(hoverMask) {
			case RowFocusMask.CELL:
				if (!cell) {
					return;
				}
				r = cell.boundsBy(grid._rootElement);
				view.$_hoverCell = cell;
				break;
			case RowFocusMask.DATA : 
				r.x = gr.x;
				r.width = lm.rfixedBounds().right()-gr.x;
				break;
			case RowFocusMask.FILL :
				r.x = 0;
				r.width = gr.right();
				break;
			default :
				r.x = 0;
				r.width = lm.rfixedBounds().right();
				break;
		}
		view.$_hoverRow = rowElt;
		styles.border() && (r.y--, r.x--);
		view.setRectI(r);
		mask = r.clone();
		mask.x = mask.y = 0;
		hoverMask == RowFocusMask.CELL && (mask.setLeft(Math.max(0, lm.fixedBounds().right() - r.x )), mask.width = mask.width - Math.max(0, r.right() - lm.rfixedBounds().left())); 
		mask.height = Math.min(r.height, lm.gridBounds().bottom() - r.y);
		styles.border() && (mask.y--, mask.x--, mask.width+=2, mask.height+=2);
		view._mask = mask;
		view.invalidate();
	},
	_resetRowHoverView: function(x,y) {
		if (this._scrollTool.isScrolling()) {
			return;
		}
		var grid = this.grid();
		var lm = grid._layoutManager;
		var hView = this._rowHoverView;
		if (!grid._displayOptions._rowHoverMask._visible || lm._bodyBounds.bottom() < grid.container().mouseY()) {
			hView && hView.setVisible(false);
			return;
		}
		var elt;
		var rowElts = grid._bodyView._elements;
		var hoverY = parseInt(grid._container.mouseY()) - grid._bodyView.bounds().y;
		var cnt = rowElts ? rowElts.length : 0;
		for (i = 0; i < cnt ; i++) {
			if (rowElts[i].y() <= hoverY && rowElts[i].bottom() >= hoverY) {
				elt = rowElts[i];
				break;
			};
			if (rowElts[i].y() > hoverY) {
				break;
			}
		}
		if (elt && elt instanceof RowElement) {
			hView.setVisible(true);
			this.$_updateRowHoverView(grid, elt, hView.$_hoverCell)	;
		} else {
			hView.setVisible(false);
		}
	},
	$_resetRowBlockView: function() {
		var view = this._rowBlockView;
		var grid = this.grid();
		if (grid._loading) {
			return;
		}
		var options = grid.displayOptions().rowBlockMask();
		var lm = grid._layoutManager;
		var gr = lm._gridBounds;		
		if (!view || !options.isVisible()) {
			view && view.setVisible(false);
			return;
		}
		var sIdx = Math.max(0,view._startIndex - grid.topIndex()), eIdx = Math.min(lm.itemCount()+lm.fixedRowCount()-1,view._endIndex - grid.topIndex());
		var r1 = lm.itemBounds(sIdx), r2 = lm.itemBounds(eIdx);
		var blockMask = options.blockMask();
		r1 = r1.union(r2);
		switch(blockMask) {
			case RowFocusMask.DATA : 
				r1.x = gr.x;
				r1.width = lm.rfixedBounds().right()-gr.x;
				break;
			case RowFocusMask.FILL :
				r1.x = 0;
				r1.width = gr.right();
				break;
			default :
				r1.x = 0;
				r1.width = lm.rfixedBounds().right();
				break;
		}
		r1.offset(0, lm.bodyBounds().y);
		view.setRectI(r1);
		var mask = r1.clone();
		mask.x = mask.y = 0;
		mask.height = Math.min(r1.height, lm.gridBounds().bottom() - r1.y);
		view._mask = mask;
		view.setVisible(true);
		view.invalidate();
	},
	setRowBlockView: function(startIndex, endIndex) {
		var bView = this._rowBlockView;
		bView._startIndex = startIndex;
		bView._endIndex = endIndex;
		this.$_resetRowBlockView();
	},	
	_getDragTracker: function (request, x, y) {
		if (request instanceof ColumnResizeRequest) {
			return new ColumnResizeTracker(request, x, y);
		} else if (request instanceof ColumnMoveRequest) {
			if (this._grid.displayOptions().isParentChangable()) {
				return new ColumnMoveTracker3(request, x, y);
			} else {
				return new ColumnMoveTracker2(request, x, y);
			}
		} else if (request instanceof HeaderResizeRequest) {
			return new HeaderResizeTracker(this._grid, request, x, y);
        } else if (request instanceof HeaderSummaryResizeRequest) {
            return new HeaderSummaryResizeTracker(this._grid, request, x, y);
		} else if (request instanceof FooterResizeRequest) {
			return new FooterResizeTracker(this._grid, request, x, y);
		} else if (request instanceof RowResizeRequest) {
			return new RowResizeTracker(this._grid, request, x, y);
		} else if (request instanceof SelectRequest) {
            switch (request.selectStyle()) {
                case SelectionStyle.ROWS:
                    return new RowsSelectTracker(request, x, y);
                case SelectionStyle.COLUMNS:
                    return new ColumnsSelectTracker(request, x, y);
                case SelectionStyle.BLOCK:
                    return new BlockSelectTracker(request, x, y);
            }
        } else if (request instanceof DataButtonRequest) {
            return new DataButtonTracker(request);
		} else if (request instanceof EditButtonRequest) {
			return new EditButtonTracker(request);
		} else if (request instanceof CellButtonRequest) {
			return new CellButtonTracker(request);
		} else if (request instanceof ScrollThumbRequest) {
			return new ScrollThumbTracker(request, x, y);
		} else if (request instanceof DragNDropRequest) {
			return new DragNDropTracker(request, x, y);
		}
		return null;
	},
	editorActivated: function (editor) {
		this._resetFocusedView();
	},
	$_columnHeaderClicked: function (column, rightClicked, event) {
		rightClicked = arguments.length > 1 ? rightClicked : false;
		this.grid()._fireColumnHeaderClicked(column, rightClicked, event);
		this._doColumnHeaderClicked(column, rightClicked, event);
	},
	$_columnHeaderImageClicked: function (column, right, event) {
		rightClicked = arguments.length > 1 ? rightClicked : false;
		this.grid()._fireColumnHeaderImageClicked(column, rightClicked, event);
		// this._doColumnHeaderClicked(column, rightClicked, event);
	},
	_doColumnHeaderClicked: function (column) {
	},
	_checkCellClicked: function (cell, event) {
		var grid = this.grid();
		if (grid.editOptions().isCheckable()) {
			var checkBar = grid.checkBar();
			var item = cell.item();
			if (event && event.shiftKey && this._prevCheckIndex && !checkBar.isExclusive()) {
				var prevItem = this._prevCheckIndex.item();
				var idx1 = Math.min(prevItem._index, item._index),
					idx2 = Math.max(prevItem._index, item._index),
					itemIndicies = [];
				for (var idx = idx1; idx <= idx2; idx++) {
					item = grid.getItem(idx);
					item.isCheckable() && item.dataRow() >= 0 && itemIndicies.push(item);
				};
				itemIndicies.length > 0 && grid.itemSource().checkItems(itemIndicies, prevItem.isChecked(), true);
			} else {
				if (item.isCheckable() && (checkBar.isShowGroup() || item.dataRow() >= 0)) {
	                grid.makeItemVisible(item.index());
					grid.itemSource().checkItem(item, !item.isChecked(), checkBar.isExclusive(), true);
				}
			}
		}
	},
	_checkAllClicked: function (cell) {
		var grid = this.grid();
		var checkBar = grid.checkBar();
		if (!grid.isEmpty() && grid.editOptions().isCheckable()) {
			if (checkBar.isShowAll() && !checkBar.isExclusive()) {
				cell.setChecked(!cell.isChecked());
				grid.itemSource().checkAll(cell.isChecked(), checkBar.isVisibleOnly(), checkBar.isCheckableOnly(), true, checkBar.isShowGroup());
			} else {
				this._checkBarHeadClicked();
			}
		}
	},
	_footerCellClicked: function (cell) {
		this.grid()._fireFooterCellClicked(cell);
	},
	_headerSummaryCellClicked: function (cell) {
		this.grid()._fireHeaderSummaryCellClicked(cell);
	},
	_checkBarHeadClicked: function () {
		this.grid()._fireCheckBarHeadClicked();
	},
	_checkBarFootClicked: function () {
		this.grid()._fireCheckBarFootClicked();
	},
	_indicatorCellClicked: function (index) {
		this.grid()._fireIndicatorCellClicked(index);
	},
	_stateBarCellClicked: function (index) {
		this.grid()._fireStateBarCellClicked(index);
	},
	_rowGroupHeadClicked: function () {
		this.grid()._fireRowGroupHeadClicked();
	},
	_rowGroupFootClicked: function () {
		this.grid()._fireRowGroupFootClicked();
	},
	_rowGroupHeaderFooterClicked: function (kind, index) {
		this.grid()._fireRowGroupHeaderFooterClicked(kind, index);
	},
	_rowGroupBarClicked: function (index) {
		this.grid()._fireRowGroupBarClicked(index);
	},
	_panelClicked: function () {
		this.grid()._firePanelClicked();
	},
	_rowGroupPanelClicked: function (cell) {
		this.grid()._fireRowGroupPanelClicked(cell);
	},
	$_elementClicked: function (element) {
		this._doElementClicked(element);
	},
	_bodyEmptyClicked: function() {
		this.grid()._fireBodyEmptyClicked();
	},
	_doElementClicked: function (element) {
	},
	$_handleClicked: function (handle) {
		this._doHandleClicked(handle);
	},
	_doHandleClicked: function (handle) {
		var grid = this.grid();
		if (handle instanceof HeaderFilterHandle && grid.filteringOptions().isEnabled()) {
			grid.selectColumnFilters(handle.parent());
		}
	},
	_performRendererClick: function (index, cell, x, y, dblClick, immediate) {
		var grid = this.grid();
		var cellIdx = cell instanceof MergedDataCellElement ? cell.index().I()+cell.innerIndex() : cell.index().I();
		if (!grid.isEditing() && index.isValid() && cell && index.I() == cellIdx && index.column() == cell.index().column()) {
			var column = index.dataColumn();
			if (column) {
				var renderer = cell.renderer(); // column.renderer;
				if (cell.ptInCell(cell.mouseX(), cell.mouseY())) {
					if (!grid.isReadOnly(index) && 
						(!dblClick && renderer.isEditable() || dblClick && renderer.isDblClickEditable()) && 
						(!immediate || renderer.isStartEditOnClick())) {
						var item = index.item();
						if ((grid.isItemEditing(item) || grid.canUpdate(item, index.dataField())) && grid.canWrite(index)) {
							if (grid.edit(index)) {
								renderer.performEdit(index);
							}
						}
					} else if (!dblClick && (index.I() == (cell instanceof MergedDataCellElement ? cell.index().I()+cell.innerIndex() : cell.index().I())) && renderer.isClickable(index)) {
						renderer.performClick(cell, x, y);
					}
				}
			}
		}
	}
});
var FocusView = defineClass("FocusView", LayerElement, {
	init: function (dom, options) {
		this._super(dom, "focusView");
		this._options = options;
		this._editing = false;
	},
    setEditing: function (editing, buttonWidth, isLeftImageButton) {
        if (editing != this._editing) {
            this._editing = editing;
            this._buttonWidth = buttonWidth;
            this._isLeftImageButton = isLeftImageButton;
            this.invalidate();
        }
    },
	_doDraw: function (g) {
		var w = this.width() - (this._editing ? this._buttonWidth : 0);
        var d = this._editing ? 0 : 1;
        var x = -1 + (this._editing && this._isLeftImageButton ? this._buttonWidth : 0);
		g.drawBoundsI(this._options._focusBackgroundBrush, this._editing ? this._options._focusActivePen : this._options._focusPen, x, -1, w - d, this.height() - 1);
	}
});

var RowFocusView = defineClass("RowFocusView", LayerElement, {
	init: function (dom, options) {
		this._super(dom, "rowFocusView");
		this._options = options;
		this._editing = false;
	},
	_doDraw: function (g) {
		var styles = this._options._rowFocusOption.styles();
		var border = styles.border();
		var bw = border && border.width();
		bw = bw ? Math.round(bw / 2) : 0;
		g.drawBoundsI(styles.background(), border, -1 - bw, -1 - bw , this.width() , this.height()-1 + bw);
	},
});

var InnerFocusView = defineClass("InnerFocusView", LayerElement, {
    init: function (dom, options) {
        this._super(dom, "innerFocusView");
        this._options = options;
        this._editing = false;
    },
    setEditing: function (editing, buttonWidth, isLeftImageButton) {
        if (editing != this._editing) {
            this._editing = editing;
            this._buttonWidth = buttonWidth;
            this._isLeftImageButton = isLeftImageButton;
            this.invalidate();
        }
    },
    _doDraw: function (g) {
        var w = this.width() - (this._editing ? this._buttonWidth : 0);
        var d = this._editing ? 0 : 1;
        var x = -1 + (this._editing && this._isLeftImageButton ? this._buttonWidth : 0);
		g.drawBoundsI(null, this._editing ? this._options._focusActivePen : this._options._innerFocusPen, x, -1, w - d, this.height() - 1);
    }
});
var RowHoverView = defineClass("RowHoverView", LayerElement, {
	init: function(dom, options) {
		this._super(dom , "rowHoverView");
		this._rowHoverMask = options && options.rowHoverMask();
		this._visible = false;
		this.$_hoverCell = null;
		this.$_hoverRow = null;
	},
	visible:false,
	_doDraw: function(g) {
		var styles = this._rowHoverMask && this._rowHoverMask.styles();
		var border = styles && styles.border();
		g.drawBoundsI(styles.background(), border, 0, 0, this.width(), this.height());		
	}
});
var RowBlockView = defineClass("RowBlockView", LayerElement, {
	init: function(dom, options) {
		this._super(dom , "rowBlockView");
		this._rowBlockMask = options && options.rowBlockMask();
		this._visible = false;
		this._startIndex = -1;
		this._endIndex = -1;
	},
	visible:false,
	_doDraw: function(g) {
		var styles = this._rowBlockMask && this._rowBlockMask.styles();
		var border = styles && styles.border();
		g.drawBoundsI(styles.background(), border, 0, 0, this.width(), this.height());		
	}
});
var GridDragTracker = defineClass("GridDragTracker", DragTracker, {
	init: function(grid, name) {
		this._super(grid.container(), name);
		this._grid = grid;
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		this._super();
	},
	grid: function () {
		return this._grid;
	},
	isStartWhenCreated: function () {
		return false;
	},
	checkScrolling: function () {
		return this._grid.checkScrolling();
	},
	checkHScrolling: function () {
		return this._grid.checkHSCrolling();
	}
});
var CellRequest = defineClass("CellRequest", EditRequest, {
	init : function(cell) {
		this._super();
		this._cell = cell;
	},
	cell: function () {
		return this._cell;
	},
	cursor : function() {
		return null;
	},
	source : function() {
		return this._cell;
	},
	isSelectable : function() {
		return true;
	},
	isDblClickable : function() {
		return false;
	}
});
var ColumnResizeRequest = defineClass("ColumnResizeRequest", CellRequest, {
	init: function(headerCell) {
		this._super(headerCell);
	},
	delta: 0,
	headerCell: function () {
		return this._cell;
	},
	cursor: function() {
		return Cursor.HORZ_RESIZE;
	},
	isSelectable : function() {
		return false;
	},
	isDblClickable : function() {
		return true;
	}
});
var ColumnMoveRequest = defineClass("ColumnMoveRequest", CellRequest, {
	init: function(cell) {
		this._super(cell);
	}
});
var DataCellRequest = defineClass("DataCellRequest", EditRequest, {
	init: function (index) {
		this._super();
		this._index = index;
	},
	cursor: function () {
		return null;
	},
	source: function () {
		return null;
	},
	isSelectable: function () {
		return true;
	},
	isDblClickable: function () {
		return false;
	}
});
var CellButtonRequest = defineClass("CellButtonRequest", DataCellRequest, {
	init : function(dataCell, buttonIndex) {
		this._super(dataCell.index());
		this._cell = dataCell;
		this._buttonIndex = buttonIndex;
	},
	cell : function() {
		return this._cell;
	},
	buttonIndex: function() {
		return this._buttonIndex;
	}
});
var EditButtonRequest = defineClass("EditButtonRequest", CellButtonRequest, {
	init: function(dataCellView) {
		this._super(dataCellView);
	}
});
var DataButtonRequest = defineClass("DataButtonRequest", CellButtonRequest, {
    init: function(dataCellView, buttonIndex) {
        this._super(dataCellView, buttonIndex);
    }
});
var GridEditRequest = defineClass("GridEditRequest", EditRequest, {
	init: function(index) {
		this._super();
	},
	cursor: function() {
		return null;
	},
	source: function() {
		return null;
	},
	isSelectable: function() {
		return true;
	},
	isDblClickable: function() {
		return false;
	}
});
var HeaderResizeRequest = defineClass("HeaderResizeRequest", GridEditRequest, {
	init: function(dataCell) {
		this._super(dataCell);
	},
	cursor: function() {
		return Cursor.VERT_RESIZE;
	}
});
var HeaderSummaryResizeRequest = defineClass("HeaderSummaryResizeRequest", GridEditRequest, {
    init: function(dataCell) {
        this._super(dataCell);
    },
    cursor: function() {
        return Cursor.VERT_RESIZE;
    }
});
var FooterResizeRequest = defineClass("FooterResizeRequest", GridEditRequest, {
	init: function(dataCell) {
		this._super(dataCell);
	},
	cursor: function() {
		return Cursor.VERT_RESIZE;
	}
});
var RowResizeRequest = defineClass("RowResizeRequest", GridEditRequest, {
	init: function(itemIndex) {
		this._super();
		this._itemIndex = itemIndex;
	},
	itemIndex: function () {
		return this._itemIndex;
	},
	cursor: function() {
		return Cursor.VERT_RESIZE;
	},
	isSelectable: function() {
		return false;
	}
});
var DragNDropRequest = defineClass("DragNDropRequest", CellRequest, {
	init: function(selectCells, cursor) {
		this._super(selectCells);
		this._selectCells = selectCells;
		if (typeof cursor === "boolean") {
			this._cursor = Cursor.move;
		} else if (typeof cursor === "string") {
			this._cursor = cursor;
		} else {
			this._cursor = Cursor.MOVE;
		}
	}, 
	selectCells: function() {
		return this._selectCells;
	},
	cursor: function() {
		return this._cursor ? this._cursor : Cursor.MOVE;
	},
	isSelectable : function() {
		return false;
	},
});
var ColumnResizeTracker = defineClass("ColumnResizeTracker", GridDragTracker, {
	init: function(request) {
		this._super(request.cell().grid(), "columnResizeTracker");
		this._request = request;
		var cell = request.headerCell();
		var column = cell.index().column();
		if (column.group()) {
			this._cell = GroupCellElement.getRootOf(cell);
		} else {
			this._cell = cell;
		}
		// this._startWidth = this._cell.width();
		this._startWidth = column.displayWidth();
		this._offset = this.container().mouseX() - this._startWidth;
	},
	_doStart: function (x, y) {
		return true;
	},
	_doDrag: function (x, y) {
		var cell = this._request.headerCell();
		var column = cell.index().column();
		var minWidth = Math.max(column._minWidth, Column.MIN_WIDTH);
		var maxWidth = column.maxWidth();
		var curWidth = column.displayWidth();
		var x = this.container().mouseX() - this._offset;
		var d = curWidth - x;
		if (d < 0 && maxWidth > -1 && x > maxWidth || d > 0 && minWidth >= Column.MIN_WIDTH && x <= minWidth) {
			if (d < 0) {
				if (curWidth < maxWidth) {
					x = maxWidth;
				} else {
					return;
				}
			} else {
				if (curWidth > minWidth) {
					x = minWidth;
				} else {
					return;
				}
			}
		}
		if (x >= 2) {
			var columnFitted = this.grid() && this.grid().layoutManager()._columnFitted;
			ColumnGroup.changeWidth(column, x - this._startWidth, false, Column.MIN_WIDTH, columnFitted);
			this._startWidth = x;
		}
		return true;
	},
	_doEnded: function() {
		var cell = this._request.headerCell();
		var grid = this.grid();
		var column = cell.index().column();
		grid._fireColumnPropertyChanged(column, "width", column.width());
	}
});
var RowResizeTracker = defineClass("RowResizeTracker", GridDragTracker, {
	init: function(grid, request, x, y) {
		this._super(grid, "rowResizeTracker");
		this._request = request;
		var r = grid.layoutManager().getItemBounds(request.itemIndex());
		r.x += grid.x();
		r.y += grid.y();
		this._rowTop = r.y;
		this._rowBottom = r.bottom();
		this._offset = y - r.bottom();
	},
	_doStart: function(x, y) {
		return true;
	},
	_doDrag: function(x, y) {
		var h = y - this._offset - this._rowTop;
		if (h >= 2) {
			var request = this._request;
			var grid = this.grid();
			var opts = grid.displayOptions();
			if (opts.isEachRowResizable() && grid._rootColumn._dataLevel == 1) {
				if (request && request.itemIndex() >= 0) {
					var lm = grid.layoutManager();
					var itemIndex = request._itemIndex >= lm._fixedItemCount ? request._itemIndex + grid._topIndex : request._itemIndex;
					var item = lm._items.getItem(itemIndex);
					var dMaxHeight = opts.maxRowHeight();
					h = dMaxHeight && dMaxHeight < h ? dMaxHeight : h;
					var dataId = item.dataId();
					lm._itemHeights[dataId] = h;
					grid.refreshView();
				}
			} else {
				grid.displayOptions().setRowHeight(h);
			}
		}
		return true;
	}
});
var HeaderResizeTracker = defineClass("HeaderResizeTracker", GridDragTracker, {
	init : function(grid, request, x, y) {
		this._super(grid, "headerResizeTracker");
		this._request = request;
		var r = grid.layoutManager().headerBounds();
		this._headerTop = r.y;
		this._headerBottom = r.bottom();
		this._offset = y - r.bottom();
	},
	_doStart : function(x, y) {
		return true;
	},
	_doDrag : function(x, y) {
		if (this._grid.footer().isVisible() && y >= this._grid.layoutManager().footerBounds().y) {
			return false;
		}
		if (y >= this._grid.layoutManager().gridBounds().bottom()) {
			return false;
		}
		var h = y - this._offset - this._headerTop;
		if (h >= 2) {
			this._grid.header().setHeight(h);
		}
		return true;
	}
});
var HeaderSummaryResizeTracker = defineClass("HeaderSummaryResizeTracker", GridDragTracker, {
    init : function(grid, request, x, y) {
        this._super(grid, "headerResizeTracker");
        this._request = request;
        var r = grid.layoutManager().summaryBounds();
        this._summaryTop = r.y;
        this._summaryBottom = r.bottom();
        this._offset = y - r.bottom();
    },
    _doStart : function(x, y) {
        return true;
    },
    _doDrag : function(x, y) {
        if (this._grid.footer().isVisible() && y >= this._grid.layoutManager().footerBounds().y) {
            return false;
        }
        if (y >= this._grid.layoutManager().gridBounds().bottom()) {
            return false;
        }
        var h = y - this._offset - this._summaryTop;
        if (h >= 2) {
            this._grid.header().summary().setHeight(h);
        }
        return true;
    }
});
var FooterResizeTracker = defineClass("FooterResizeTracker", GridDragTracker, {
	init : function(grid, request, x, y) {
		this._super(grid, "footerResizeTracker");
		this._request = request;
		var r = grid.layoutManager().footerBounds();
		this._footerTop = r.y;
		this._footerBottom = r.bottom();
		this._offset = y - r.y;
	},
	_doStart : function(x, y) {
		return true;
	},
	_doDrag : function(x, y) {
		if (this._grid.header().isVisible() && y < this._grid.layoutManager().headerBounds().bottom()) {
			return false;
		}
		if (this._grid.panel() && this._grid.panel().isVisible() && y < this._grid.layoutManager().panelBounds().bottom()) {
			return false;
		}
		if (y < 0) {
			return false;
		}
		var h = this._footerBottom - y + this._offset;
		if (h >= 2) {
			this._grid.footer().setHeight(h);
		}
		return true;
	}
});
var ColumnMoveTracker2 = defineClass("ColumnMoveTracker2", GridDragTracker, {
	init: function(request, x, y) {
		this._super(request.cell().grid(), "columnMoveTracker2");
		this._request = request;
		this._sourceFeedback = new HeaderCellElement(this._grid, this._grid._dom, "columnMoveFeedback");
		this._sourceFeedback.setAlpha(0.7);
		this._targetFeedback = new ColumnMoveFeedback(this._grid._dom, "columnMoveTargetFeedback");
		this._targetFeedback.setAlpha(0.5);
		this._timer = null;
		var p = request.cell().index().column().parent();
		if (p.isHorizontal()) {
			this._startPos = x;
			this._orgPos = request.cell().boundsByContainer().x;
		} else {
			this._startPos = y;
			this._orgPos = request.cell().boundsByContainer().y;
		}
	},
	_canAccept: function (x, y) {
		var cell = _cast(this._request.cell(), HeaderCellElement);
		return cell != this._target;
	},
	_doStart: function (x, y) {
		var cell = this._request.cell();
		var grid = this.grid();
		var r = cell.boundsBy(grid);
		grid.addFeedbackElement(this._sourceFeedback);
		grid.addFeedbackElement(this._targetFeedback);
		this._sourceFeedback.setBounds(r.x, r.y, cell.width(), cell.height());
		this._sourceFeedback.updateCell(grid.header().getCell(cell.index()));
		this.$_setTarget(null);
		return true;
	},
	_doDrag: function (x, y) {
		var grid = this.grid();
		var lm = grid.layoutManager();
		if (grid.panel().isVisible() && y >= lm.panelBounds().y && y < lm.panelBounds().bottom()) {
			return false;
		}
		this._currx = x = grid.containerToGridX(x);
		if (x < lm.gridBounds().x || x > lm.clientRect().right()) {
			this._startTimer();
			return true;
		} else {
			this._stopTimer();
			var column = this._request.cell().index().column();
			var target = null;
			var group;
			var r;
			var headerView;
			var view;
			if (column.group()) {
				target = this._request.cell();
				if (column instanceof ColumnGroup) {
					target = target.parent();
				}
				if (column.parent().isHorizontal()) {
					this._sourceFeedback.setX(this._orgPos + (this._currentX - this._startPos));
				} else {
					this._sourceFeedback.setY(this._orgPos + (this._currentY - this._startPos));
				}
				group = _cast(target.parent(), HeaderGroupCellElement);
				r = group.boundsByContainer();
				x -= r.x;
				y -= r.y;
				target = group.getCellAt(x, y);
			} else { // 최상위 셀들.
				if (column.parent().isHorizontal()) {
					this._sourceFeedback.setX(this._orgPos + (x - this._startPos));
				} else {
					this._sourceFeedback.setY(this._orgPos + (y - this._startPos));
				}
				if ((view = grid.rfixedHeaderView()) && view.isVisible() && view.containsInBounds(x,y)) {
					headerView = view;
				} else if ((view = grid.fixedHeaderView()) && view.isVisible() && view.containsInBounds(x,y)) {
					headerView = view;
				} else if ((view = grid.headerView()) && view.containsInBounds(x,y)) {
					headerView = view;
				}
				if (headerView) {
					r = headerView.boundsByContainer();
					x -= r.x;
					y -= r.y;
					target = headerView.getCellAt(x, y);
				}
			}
			var column2 = target ? target.index().column() : null;
			if (target && column2.isRoot() && !grid.canMoveToIndex(column2.root().displayIndex())) {
				target = null;
			}
			if (!target || column2.group() == column.group()) {
				this.$_setTarget(target);
			}
			return true;
		}
	},
	_doCanceled: function () {
		this._stopTimer();
	},
	_doCompleted: function () {
		this._stopTimer();
		if (this._target) {
			var source = _cast(this._request.cell(), HeaderCellElement);
			var column = source.index().column();
			column.setDisplayIndex(this._target.index().column().displayIndex());
		}
	},
	_doEnded: function () {
		this._stopTimer();
		var grid = this.grid();
		grid.removeFeedbackElement(this._targetFeedback);
		grid.removeFeedbackElement(this._sourceFeedback);
		if (this._completed) {
			var cell = this._request.cell();
			var column = cell && cell.index && cell.index().column();
			grid._fireColumnPropertyChanged(column, "displayIndex", column.displayIndex());
		}
	},
	_startTimer: function() {
		if (!this._timer) {
			this._colLoop = this._colPrevLoop = 0;
			this._timer = setInterval(this._timerHandler.bind(this), 60);
		}
	},
	_stopTimer: function() {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
		}	
	},
	_timerHandler: function() {
		var grid = this._grid;
		var x = this._currx;
		var lm = grid.layoutManager();
		var cx = 0;
		if (x > lm.clientRect().right()) {
			cx = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		} else if (x < lm.gridBounds().x) {
			cx = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		}
		if (cx > 0) {
			this._interval = 4 - cx;
		}
		if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
			this._colPrevLoop = this._colLoop;
			if (x > lm.clientRect().right()) {
				grid.setLeftCol(grid.leftCol() + 1);
			} else if (x < lm.gridBounds().left() && grid.leftPos() > 0) {
				grid.setLeftCol(grid.leftCol() - 1);
			}
		}
		this.$_setTarget(null);
	},
	getNextRequest: function (x, y) {
		this._stopTimer();
		var grid = this.grid();
		var index = this._request.cell().index();
		if (grid.groupingOptions().isEnabled() && index.dataColumn() && index.dataColumn().isGroupable() && grid.panel().isVisible()) { 
			y -= grid.y();
			if (y < grid.layoutManager().headerBounds().y && y >= 0) {
				return new RowGroupingRequest(this._request.cell());
			}
		}
		return null;
	},
	$_setTarget: function (cell) {
		if (cell == this._target) {
			return;
		}
		var source = this._request.cell();
		var column = source.index().column();
		var group = _cast(column, ColumnGroup);
		var target = this._target = cell;
		if (target) {
			var grid = this.grid();
			var oldPos = grid.leftPos();
			grid.makeCellVisible(target.index());
			if (grid.leftPos() != oldPos) {
				grid.refreshView();
				grid.container().updateNow();
			}
			var r = target.boundsBy(grid);
			if (target === source) {
				this._targetFeedback._direction = "none";
			} else if (group && group === target.index().column()) {
				this._targetFeedback.direction = "none";
			} else if (!column.group() || column.group().isHorizontal()) {
				var x1 = target.boundsByContainer().x;// target.x();
				var x2 = group ? source.parent().boundsByContainer().x : source.boundsByContainer().x;
				this._targetFeedback._direction = "horz";
				this._targetFeedback._reversed = x1 > x2;
			} else {
				var y1 = target.y();
				var y2 = group ? source.parent().y() : source.y();
				this._targetFeedback._direction = "vert";
				this._targetFeedback._reversed = y1 > y2;
			}
			this._targetFeedback.setBounds(r.x, r.y, target.width(), target.height());
			this._targetFeedback.setVisible(true);
			this._targetFeedback.invalidate();
		} else {
			this._targetFeedback.setVisible(false);
		}
	}
});
var ColumnMoveTracker3 = defineClass("ColumnMoveTracker3", GridDragTracker, {
	init: function(request, x, y) {
		this._super(request.cell().grid(), "columnMoveTracker3");
		this._request = request;
		this._sourceFeedback = new HeaderCellElement(this._grid, this._grid._dom, "columnMoveFeedback");
		this._sourceFeedback.setAlpha(0.7);
		this._targetFeedback = new ColumnMoveFeedback(this._grid._dom, "columnMoveTargetFeedback");
		this._targetFeedback.setAlpha(0.5);
		this._startX = y;
		this._startY = y;
		var r = request.cell().boundsByContainer();
		this._orgX = r.x;
		this._orgY = r.y;
		this._target = null;
		this._dir = null;
		this._timer = null;
	},
	_canAccept: function (x, y) {
		var cell = _cast(this._request.cell(), HeaderCellElement);
		return cell != this._target;
	},
	_doStart: function(x, y) {
		var cell = this._request.cell();
		var grid = this.grid();
		var r = cell.boundsBy(grid);
		grid.addFeedbackElement(this._sourceFeedback);
		grid.addFeedbackElement(this._targetFeedback);
		this._sourceFeedback.setBounds(r.x, r.y, cell.width(), cell.height());
		this._sourceFeedback.updateCell(grid.header().getCell(cell.index()));
		this.$_setTarget(null);
		return true;
	},
	_doDrag: function(x, y) {
		var grid = this.grid();
		var lm = grid.layoutManager();
		if (grid.panel().isVisible() && y >= lm.panelBounds().y && y < lm.panelBounds().bottom()) {
			return false;
		}
		if (this._request.cell().index().column().parent().count() < 2) {
			return true;
		}
		this._currx = x = grid.containerToGridX(x);
		if (x < lm.gridBounds().x || x > lm.clientRect().right()) {
			this._startTimer();
			return true;
		} else {
			this._stopTimer();
			this._sourceFeedback.setX(x);
			this._sourceFeedback.setY(y);
			var view, headerView;
			if ( (view = grid.rfixedHeaderView()) && view.isVisible() && view.containsInBounds(x,y)) {
				headerView = view;
			} else if ((view = grid.fixedHeaderView()) && view.isVisible() && view.containsInBounds(x,y)) {
				headerView = view;
			} else if ((view = grid.headerView()) && view.containsInBounds(x,y)) {
				headerView = view;
			}
			if (headerView) {
				var r = headerView.boundsByContainer();
				x -= r.x;
				y -= r.y;
				var target = headerView.getCellAt(x, y, true);
			}
			var column = target ? target.index().column() : null;
			if (target && column.isRoot() && !grid.canMoveToIndex(column.root().displayIndex())) {
				target = null;
			}
			this.$_setTarget(target);
			return true;
		}
	},
	_doCanceled: function() {
		this._stopTimer();
	},
	_doCompleted: function() {
		this._stopTimer();
		if (this._target) {
			var source = _cast(this._request.cell(), CellElement);
			var colSource = source.index().column();
			var colTarget = this._target.index().column();
			if (colTarget.parent() === colSource.parent()) {
				colSource.setDisplayIndex(colTarget.displayIndex());
			} else {
				colSource.setParent(colTarget.parent());
				colSource.setDisplayIndex(colTarget.displayIndex() + (this._dir == "r" ? 1 : 0));
			}
		}
	},
	_doEnded: function() {
		this._stopTimer();
		var grid = this.grid();
		grid.removeFeedbackElement(this._targetFeedback);
		grid.removeFeedbackElement(this._sourceFeedback);
		if (this._completed) {
			var cell = this._request.cell();
			var column = cell && cell.index && cell.index().column();
			grid._fireColumnPropertyChanged(column, "displayIndex", column.displayIndex());
		}
	},
	getNextRequest: function(x, y) {
		var grid = this.grid();
		var index = this._request.cell().index();
		this._stopTimer();
		if (grid.groupingOptions().isEnabled() && index.dataColumn() && index.dataColumn().isGroupable()
				&& grid.panel().isVisible()) {
			y -= grid.y();
			if (y < grid.layoutManager().headerBounds().y && y >= 0) {
				return new RowGroupingRequest(this._request.cell());
			}
		}
		return null;
	},
	_startTimer: function() {
		if (!this._timer) {
			this._colLoop = this._colPrevLoop = 0;
			this._timer = setInterval(this._timerHandler.bind(this), 60);
		}
	},
	_stopTimer: function() {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
		}	
	},
	_timerHandler: function() {
		var grid = this._grid;
		var x = this._currx;
		var lm = grid.layoutManager();
		var cx = 0;
		if (x > lm.clientRect().right()) {
			cx = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		} else if (x < lm.gridBounds().x) {
			cx = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		}
		if (cx > 0) {
			this._interval = 4 - cx;
		}
		if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
			this._colPrevLoop = this._colLoop;
			if (x > lm.clientRect().right()) {
				grid.setLeftCol(grid.leftCol() + 1);
			} else if (x < lm.gridBounds().left() && grid.leftPos() > 0) {
				grid.setLeftCol(grid.leftCol() - 1);
			}
			this.$_setTarget(null);
		}
	},
	$_setTarget: function(cell) {
		var x = this.currentX();
		var y = this.currentY();
		var source = this._request.cell();
		var sourceColumn = source.index().column();
		var column = cell ? cell.index().column() : null;
		if (sourceColumn instanceof ColumnGroup && sourceColumn.isAncestorOf(column)) {
			return;
		}
		var equals = cell == this._target;
		var target = this._target = cell;
		if (target) {
			var grid = this.grid();
			var oldPos = grid.leftPos();
			if (!equals) {
				grid.makeCellVisible(target.index());
				if (grid.leftPos != oldPos) {
					grid.refreshView();
					grid.updateNow();
				}
			}
			var dir;
			var r = target.boundsBy(grid);
			if (target === source) {
				this._targetFeedback._direction = "none";
			} else if (!column.group() || column.group().isHorizontal()) {
				var x1, x2;
				this._targetFeedback._direction = "horz";
				if (column.parent() == sourceColumn.parent() && !(column instanceof ColumnGroup)) {
					if (!equals) {
						x1 = target.boundsByContainer().x;
						x2 = (sourceColumn instanceof ColumnGroup) ? source.parent().boundsByContainer().x : source.boundsByContainer().x;
						this._targetFeedback._reversed = x1 > x2;
					} 
				} else {
					x1 = target.width() / 2;
					x2 = x - r.x;
					dir = x2 > x1 ? "r" : "n";
					if (!equals || dir != this._dir) {
						this._dir = dir;
						if (column instanceof ColumnGroup) {
							r.height = target.parent().height();
						}
						this._targetFeedback._reversed = dir == "r";
					}
				}
			} else {
				var y1, y2;
				this._targetFeedback._direction = "vert";
				if (column.parent() == sourceColumn.parent() && !(column instanceof ColumnGroup)) {
					y1 = target.y();
					y2 = (sourceColumn instanceof ColumnGroup) ? source.parent().y() : source.y();
					this._targetFeedback._reversed = y1 > y2;
				} else {
					y1 = target.height() / 2;
					y2 = y - r.y;
					dir = y2 > y1 ? "r" : "n";
					if (!equals || dir != this._dir) {
						this._dir = dir;
						if (column instanceof ColumnGroup) {
							r.width = target.parent().width();
							r.height = target.parent().height();
						}
						this._targetFeedback._reversed = dir == "r";
					}
				}
			}
			this._targetFeedback.setRect(r);
			this._targetFeedback.setVisible(true);
		} else {
			this._targetFeedback.setVisible(false);
		}
	}
});
var ColumnMoveFeedback = defineClass("ColumnMoveFeedback", VisualElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._direction = "none";	// "horz", "vert"
		this._reversed = false;
		this._lineNone = new SolidPen("rgba(0, 0, 0, 0.7)", 2);
		this._fillNone = new SolidBrush("rgba(0, 0, 0, 0.2)");
		this._line = new SolidPen("rgba(0, 0, 0, 1)", 2);
		this._fill = new SolidBrush(0xff000000);
	},
	_doDraw: function(g) {
		var x;
		var y;
		var r = this.clientRect();
		switch (this._direction) {
		case "horz":
			if (!this._reversed) {
				y = r.height - 2;
				g.drawBoundsI(this._fill, null, 0, 1, 3, y);
				g.drawLineI(this._line, 1, 1, 7, 1);
				g.drawLineI(this._line, 1, y, 7, y);
			} else {
				x = r.width;
				y = r.height - 2;
				g.drawBoundsI(this._fill, null, x - 3, 1, 3, y);
				g.drawLineI(this._line, x - 1, 1, x - 7, 1);
				g.drawLineI(this._line, x - 1, y, x - 7, y);
			}
			break;
		case "vert":
			if (!this._reversed) {
				w = r.width - 2;
				g.drawBoundsI(this._fill, null, 1, 0, w, 3);
				g.drawLineI(this._line, 1, 1, 1, 7);
				g.drawLineI(this._line, w, 1, w, 7);
			} else {
				x = r.width - 2;
				y = r.height;
				g.drawBoundsI(this._fill, null, 1, y - 3, x, 3);
				g.drawLineI(this._line, 1, y - 1, 1, y - 7);
				g.drawLineI(this._line, x, y - 1, x, y - 7);
			}
			break;
		default:
			g.drawRectI(this._fillNone, this._lineNone, r);
			break;
		}
	}
});
var CellButtonTracker = defineClass("CellButtonTracker", GridDragTracker, {
	init: function (request) {
		this._super(request.cell().grid(), "cellButtonTracker");
		this._request = request;
		this._buttonIndex = request.buttonIndex();
		this._clickIndex = request.cell().index().clone();
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		this._request.cell().setButtonState(true, true, this._buttonIndex);
		return true;
	},
	_doDrag: function (x, y) {
		var cell = this._request.cell();
		var hit = cell.ptInButton(cell.mouseX(), cell.mouseY());
		cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : cell;
		cell.setButtonState(hit, hit);
		return true;
	},
	_canAccept: function (x, y) {
		var cell = this._request.cell();
		var p = cell.containerToElement(x, y);
		cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : cell;
		return cell.ptInButton(p.x, p.y);
	},
	_doCanceled: function () {
	},
	_doCompleted: function () {
		var grid = this.grid();
		var cell = this._clickIndex ? grid.getFocusedCellView(this._clickIndex) : this._request.cell();
		grid.activeTool().cellButtonClicked(cell.index(), this._buttonIndex);
	},
	_doEnded: function () {
		var cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : this._request.cell();
		cell && cell.setButtonState(false, false, this._buttonIndex);
	}
});
var EditButtonTracker = defineClass("EditButtonTracker", GridDragTracker, {
	init: function (request) {
		this._super(request.cell().grid(), "editButtonTracker");
		this._request = request;
		this._clickIndex = request.cell().index().clone();
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		this._request.cell().setEditButtonState(true, true);
		return true;
	},
	_doDrag: function (x, y) {
		var cell = this._request.cell();
		var hit = cell.ptInButton(cell.mouseX(), cell.mouseY());
		cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : cell;
		cell.setEditButtonState(hit, hit);
		return true;
	},
	_canAccept: function (x, y) {
		var cell = this._request.cell();
		var p = cell.containerToElement(x, y);
		cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : cell;
		return cell.ptInEditButton(p.x, p.y);
	},
	_doCanceled: function () {
	},
	_doCompleted: function () {
		var cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : this._request.cell();
		var index = cell.index().clone();
		if (cell instanceof MergedDataCellElement) {
			if (cell.innerIndex() >= 0) {
				index.setItemIndex(index.itemIndex() + cell.innerIndex());
			}
		}
		cell.grid().activeTool().editButtonClicked(index);
	},
	_doEnded: function () {
		var cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : this._request.cell();
		cell.setEditButtonState(false, false);
	}
});
var DataButtonTracker = defineClass("DataButtonTracker", GridDragTracker, {
    init: function (request) {
        this._super(request.cell().grid(), "dataButtonTracker");
        this._request = request;
        this._buttonIndex = request.buttonIndex();
        this._clickIndex = request.cell().index().clone();
    },
    isStartWhenCreated: function () {
        return true;
    },
    _doStart: function (x, y) {
        this._request.cell().setPressed(true);
        return true;
    },
    _doDrag: function (x, y) {
		var cell = this._request.cell();
		var hit = cell.ptInDataButton(cell.mouseX(), cell.mouseY());
        cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : cell;
        cell.setPressed(hit);
        return true;
    },
    _canAccept: function (x, y) {
        var cell = this._request.cell();
        var p = cell.containerToElement(x, y);
        cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) : cell;
        return cell.ptInDataButton(p.x, p.y);
    },
    _doCanceled: function () {
    },
    _doCompleted: function (x, y) {
    	var grid = this.grid();
        var cell = this._clickIndex ? grid.getFocusedCellView(this._clickIndex) :this._request.cell();
		var renderer = cell._renderer;
		var buttonIndex = this._buttonIndex == undefined ? cell._buttonIndex : this._buttonIndex;
		var name;
		var index = cell.index().clone();
		if (cell instanceof MergedDataCellElement) {
			index.setItemIndex(index.itemIndex() + cell.innerIndex())
		}
		name = renderer && renderer instanceof ImageButtonsCellRenderer && renderer._images[buttonIndex] ? renderer._images[buttonIndex].name : undefined;
		cell.grid().activeTool().imageButtonClicked(index, buttonIndex, name);
    },
    _doEnded: function () {
        var cell = this._clickIndex ? this.grid().getFocusedCellView(this._clickIndex) :this._request.cell();
        cell && cell.setPressed(false);
    }
});

var DragNDropTracker = defineClass("DragNDropTracker", GridDragTracker, {
	init: function(request) {
		this._super(request.selectCells()._grid, "DragNDropTracker");
		this._request = request;
		this._dragCells = request.selectCells();
		this._targetFeedback = new DragMoveFeedback(this._grid._dom, "DragMoveTargetFeedback");
		this._targetFeedback.setAlpha(0.5);
		this._timer = null;
	},
	_doStart: function (x, y) {
		var grid = this.grid();
		if (!grid._fireInnerDragStart(this._dragCells)) {
			return;
		};
		grid.addFeedbackElement(this._targetFeedback);
		this.$_setTarget(null);
		return true;
	},
	_doDrag: function (x, y) {
		if (this._dragCells) {
			var grid = this.grid();
			var lm = grid.layoutManager();
			var targetCell = null;
			// var body =  grid.bodyView();
			this._currx = x = grid.containerToGridX(x);
			this._curry = y = grid.containerToGridY(y);
			if (y > lm.footerBounds().y || y < lm.gridBounds().y ||	x < lm.gridBounds().x || x > lm.clientRect().right()) {
				this._startTimer();
			} else {
				this._stopTimer();
				targetCell = grid.findChildAt(x, y, true);
				if (targetCell instanceof DataCellElement) {
					var style = grid._fireInnerDragOver(targetCell.index(), this._dragCells)
					if (style === false) {
						this.$_setTarget(null);
						return;
					}
					this.$_setTarget(targetCell, style);
				}
			}
			return true;
		}
		return true;
	},
    _canAccept: function (x, y) {
    	return !!this._target;
    },
    _doCanceled: function () {
    	this.$_setTarget(null);
    },
    _doCompleted: function (x, y) {
    	if (this._target) {
    		var index = this._target && this._target instanceof DataCellElement && this._target.index();
    		var grid = this._target && this._target._grid;
    		if (grid && index) {
    			grid._fireInnerDrop(index,this._dragCells);
    		}	
    	}
    },
	_doEnded: function() {
		var grid = this.grid();
		this._stopTimer();
		grid.removeFeedbackElement(this._targetFeedback);
		grid.setCursor(Cursor.DEFALUT);
	},
	_startTimer: function () {
		if (!this._timer) {
			this._rowLoop = this._rowPrevLoop = this._colLoop = this._colPrevLoop = 0;
			this._timer = setInterval(this._timerHandler.bind(this), 30);
		}
	},
	_stopTimer: function () {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
		}
	},
	_timerHandler: function () {
		var grid = this._grid;
		var x = this._currx;
		var y = this._curry;
		var lm = grid.layoutManager();
		var cx = 0;
		var cy = 0;
		if (y > lm.footerBounds().y) {
			cy = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
			this._interval = 4 - cy;
			this._rowLoop++;
		} else if (y < lm.gridBounds().y) {
			cy = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
			this._interval = 4 - cy;
			this._rowLoop++;
		}
		if (x > lm.clientRect().right()) {
			cx = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		} else if (x < lm.gridBounds().x) {
			cx = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		}
		var scrolled = false;
		var cnt = Math.max(cx, cy);
		if (cnt > 0) {
			this._interval = 4 - Math.max(cx, cy);
		}
		if (this._rowLoop - this._rowPrevLoop >= this._interval) {
			this._rowPrevLoop = this._rowLoop;
			if (y > lm.footerBounds().y) {
				if (grid.topItem() + lm.fullItemCount() < grid.itemCount()) {
					grid.setTopIndex(grid.topIndex() + 1);
					scrolled = true;
				}
			} else if (y < lm.gridBounds().y) {
				if (grid.topItem() > lm.fixedItemCount()) {
					grid.setTopIndex(grid.topIndex() - 1);
					scrolled = true;
				}
			}
		}
		if (!scrolled) {
			if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
				this._colPrevLoop = this._colLoop;
				if (x > lm.clientRect().right()) {
					grid.setLeftCol(grid.leftCol() + 1);
					scrolled = true;
				} else if (x < lm.gridBounds().left() && grid.leftPos() > 0) {
					grid.setLeftCol(grid.leftCol() - 1);
					scrolled = true;
				}
			}
		}
	},
	$_setTarget: function (cell, style) {
		if (cell == this._target) {
			return;
		}
		var target = this._target = cell;
		if (target) {
			var grid = this.grid();
			var body = grid.body();
			var lm = grid._layoutManager;
			var r = target.boundsBy(grid);
			this._targetFeedback.setBounds(r.x, r.y, target.width(), target.height());
			if (style) {
				style.background && this._targetFeedback.setBackground(style.background);
				style.line && this._targetFeedback.setLine(style.line);
			}
			var mask = r.clone();
			mask.x = mask.y = 0;
			mask.setLeft(Math.max(0, lm.fixedBounds().right() - r.x ));
			mask.width = mask.width - Math.max(0, r.right() - lm.rfixedBounds().left())
			mask.height = Math.min(r.height, lm.gridBounds().bottom() - r.y);
			this._targetFeedback._mask = mask;
			this._targetFeedback.setVisible(true);
		} else {
			this._targetFeedback.setVisible(false);
		}
		this._targetFeedback.invalidate();
	}
});
var DragMoveFeedback = defineClass("DragMoveFeedback", VisualElement, {
	init: function (dom, name) {
		this._super(dom, name);
		this._line = new SolidPen("rgba(0, 0, 0, 1.0)", 2,[1,1]);
		this._fill = new SolidBrush("rgba(0, 0, 0, 0.2)");
	},
	setBackground: function (value) {
		if (value != this._fill.toText()) {
			this._fill = new SolidBrush(value);
		}
	},
	setLine: function (value) {
		if (value != this._line.toText()) {
			var arr = value.trim().split(",");
			this._line = new SolidPen(arr[0], arr[1]);
		}
	},
	_doDraw: function(g) {
		var r = this.clientRect();
		// var width = this._line.width() ? _int((this._line.width() + 1) / 2) : 0;
		// width > 1 && r.inflate(-width, -width);
		g.drawRectI(this._fill, this._line, r);
	}
});

var SelectRequest = defineClass("SelectRequest", CellRequest, {
	init: function(manager, cell, style) {
		this._super(cell);
		this._manager = manager;
		this._style = style;
	},
	manager: function () {
		return this._manager;
	},
	selectStyle: function () {
		return this._style;
	}
});

var SelectTracker = defineClass("SelectTracker", GridDragTracker, {
	init: function(request, name) {
		this._super(request.cell().grid(), name);
		this._request = request;
	},
	isStartWhenCreated: function () {
		if (this._request.cell() instanceof GroupFooterCellElement ||
			this._request.cell() instanceof RowGroupHeaderCellElement) {
			return false;
		} else {
			return true;
		}
	},
	_doEnded: function() {
		var item = this._getItem();
		if (item) {
			this.grid()._fireSelectionEnded(item);
		}
	},
	_getItem: function () {
		return null;
	}
});
var BlockSelectTracker = defineClass("BlockSelectTracker", SelectTracker, {
	init : function(request) {
		this._super(request, "blockSelectTracker");
		this._item = null;
		this._timer = null;
		this._currx = NaN;
		this._curry = NaN;
		this._rowPrevLoop = 0;
		this._rowLoop = 0;
		this._colPrevLoop = 0;
		this._colLoop = 0;
		this._interval = 0;
	},
	_getItem: function () {
		return this._item;
	},
	_doStart: function (x, y, shift) {
		var activeTool = this.container().activeTool();
		var manager = this._request.manager();
		var lm = manager && manager._grid && manager._grid.layoutManager();		
		var idx = activeTool && activeTool instanceof GridViewSelectionTool ? activeTool.findElementAt(x,y,false).index() : this.grid().pointToIndex(_int(x), _int(y), true);
		if (lm.isMergedCell(idx)) {
			idx = this.grid().pointToIndex(_int(x), _int(y), true);
		}
		manager.setItemStyle(SelectionStyle.BLOCK);
		if (shift) {
			this._item = manager.count() > 0 && manager.getItem(0);
		} else {
			manager.clear();
			this._item = manager.add(idx, idx, SelectionStyle.BLOCK);
		}
		return Boolean(this._item);
	},
	_doDrag: function (x, y) {
		if (this._item) {
			var elt;
			var index;
			var grid = this.grid();
			var lm = grid.layoutManager();
			this._currx = x = grid.containerToGridX(x);
			this._curry = y = grid.containerToGridY(y);
			if (y > lm.footerBounds().y || y < lm.gridBounds().y ||	x < lm.gridBounds().x || x > lm.clientRect().right()) {
				this._startTimer();
			} else {
				this._stopTimer();
				index = this.grid().pointToIndex(x, y, true);
				if (index.column() && index.I() >= 0) {
					this._item.resizeTo(index);
				}
			}
			return true;
		}
		return false;
	},
	_doEnded: function () {
		this._stopTimer();
		this._super();
	},
	_startTimer: function () {
		if (!this._timer) {
			this._rowLoop = this._rowPrevLoop = this._colLoop = this._colPrevLoop = 0;
			this._timer = setInterval(this._timerHandler.bind(this), 30);
			this._grid.selections().lock();
		}
	},
	_stopTimer: function () {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
			this._grid.selections().unlock();
		}
	},
	_timerHandler: function () {
		var grid = this._grid;
		var x = this._currx;
		var y = this._curry;
		var lm = grid.layoutManager();
		var cx = 0;
		var cy = 0;
		if (y > lm.footerBounds().y) {
			cy = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
			this._interval = 4 - cy;
			this._rowLoop++;
		} else if (y < lm.gridBounds().y) {
			cy = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
			this._interval = 4 - cy;
			this._rowLoop++;
		}
		if (x > lm.clientRect().right()) {
			cx = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		} else if (x < lm.gridBounds().x) {
			cx = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
			this._interval = 4 - cx;
			this._colLoop++;
		}
		var scrolled = false;
		var cnt = Math.max(cx, cy);
		if (cnt > 0) {
			this._interval = 4 - Math.max(cx, cy);
		}
		if (this._rowLoop - this._rowPrevLoop >= this._interval) {
			this._rowPrevLoop = this._rowLoop;
			if (y > lm.footerBounds().y) {
				if (grid.topItem() + lm.fullItemCount() < grid.itemCount()) {
					grid.setTopIndex(grid.topIndex() + 1);
					scrolled = true;
				}
			} else if (y < lm.gridBounds().y) {
				if (grid.topItem() > lm.fixedItemCount()) {
					grid.setTopIndex(grid.topIndex() - 1);
					scrolled = true;
				}
			}
		}
		if (!scrolled) {
			if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
				this._colPrevLoop = this._colLoop;
				if (x > lm.clientRect().right()) {
					grid.setLeftCol(grid.leftCol() + 1);
					scrolled = true;
				} else if (x < lm.gridBounds().left() && grid.leftPos() > 0) {
					grid.setLeftCol(grid.leftCol() - 1);
					scrolled = true;
				}
			}
		}
		if (scrolled) {
			var index = grid.pointToIndex(this._currx, this._curry, false);
			if (index.column()) {
				index.itemIndex(Math.min(Math.max(0, index.I(), grid.topIndex()), grid.itemCount() - 1));
				this._item.resizeTo(index);
			}
		}
	}
});
var RowsSelectTracker = defineClass("RowsSelectTracker", SelectTracker, {
	init: function (request) {
		this._super(request, "rowsSelectTracker");
		this._item = null;
		this._timer = null;
		this._currx = NaN;
		this._curry = NaN;
		this._prevLoop = 0;
		this._loop = 0;
		this._colPrevLoop = 0;
		this._colLoop = 0;
		this._interval = 0;
	},
	_getItem: function () {
		return this._item;
	},
	_doStart: function (x, y, shift) {
		var activeTool = this.container().activeTool();
		var manager = this._request.manager();
		var lm = manager && manager._grid && manager._grid.layoutManager();		
		var idx = activeTool && activeTool instanceof GridSelectionTool ? activeTool.findElementAt(x,y,false).index() : idx = this.grid().pointToIndex(_int(x), _int(y), true);
		if (lm.isMergedCell(idx)) {
			idx = this.grid().pointToIndex(_int(x), _int(y), true);
		}
		manager.setItemStyle(SelectionStyle.ROWS);
		if (shift) {
			this._item = manager.count() > 0 && manager.getItem(0);
		} else {
			manager.clear();
			this._item = manager.add(idx, idx, SelectionStyle.ROWS);
		}
		return Boolean(this._item);
	},
	_doDrag: function (x, y) {
		if (this._item) {
			var index;
			var grid = this.grid();
			var lm = grid.layoutManager();
			this._currx = x = grid.containerToGridX(x);
			this._curry = y = grid.containerToGridY(y);
			if (y > lm.footerBounds().y || y < lm.gridBounds().y || x < 0 || x > lm.clientRect().right()) {
				this._startTimer();
			} else {
				this._stopTimer();
				index = grid.pointToIndex(x, y, false);
				if (index.I() >= 0) {
					this._item.resizeTo(index);
				}
			}
			return true;
		}
		return false;
	},
	_doEnded: function () {
		this._stopTimer();
		this._super();
	},
	_startTimer: function () {
		if (!this._timer) {
			this._loop = this._prevLoop = this._colLoop = this._colPrevLoop = 0;
			this._interval = 1;
			this._timer = setInterval(this._timerHandler.bind(this), 30);
			this._grid.selections().lock();
		}
	},
	_stopTimer: function () {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
			this._grid.selections().unlock();
		}
	},
	_timerHandler: function () {
		var grid = this._grid;
		var x = this._currx;
		var y = this._curry;
		var lm = grid.layoutManager();
		var index;
		var cnt;
		if (y > lm.footerBounds().y) {
			cnt = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		} else if (y < lm.gridBounds().y) {
			cnt = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		}
		if (this._loop - this._prevLoop >= this._interval) {
			this._prevLoop = this._loop;
			if (y > lm.footerBounds().y) {
				grid.setTopIndex(grid.topIndex() + 1);
			} else if (y < lm.gridBounds().y) {
				grid.setTopIndex(grid.topIndex() - 1);
			}
			index = grid.pointToIndex(this._currx, this._curry, false); // 이 함수가 한 칸씩 밀어준다.
				index.itemIndex(Math.min(Math.max(0, index.I(), grid.topIndex()), grid.itemCount() - 1));
				this._item.resizeTo(index);
		} else {
			if (x > lm.clientRect().right()) {
				cnt = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
				this._interval = 4 - cnt;
				this._colLoop++;
			} else if (x < 0) {
				cnt = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
				this._interval = 4 - cnt;
				this._colLoop++;
			}
			if (this._colLoop - this._colPrevLoop >= this._interval * 2) {
				this._colPrevLoop = this._colLoop;
				if (x > lm.clientRect().right()) {
					grid.setLeftCol(grid.leftCol() + 1);
				} else if (x < lm.gridBounds().x && grid.leftPos() > 0) {
					grid.setLeftCol(grid.leftCol() - 1);
				}
				index = grid.pointToIndex(this._currx, this._curry, false);
				if (index.I() >= 0) {
					index.itemIndex(Math.min(Math.max(0, index.I(), grid.topIndex()), grid.itemCount() - 1));
					this._item.resizeTo(index);
				}
			}
		}
	}
});
var ColumnsSelectTracker = defineClass("ColumnsSelectTracker", SelectTracker, {
	init: function (request) {
		this._super(request, "columnsSelectTracker");
		this._item = null;
		this._timer = null;
		this._currx = NaN;
		this._curry = NaN;
		this._prevLoop = 0;
		this._loop = 0;
		this._rowPrevLoop = 0;
		this._rowLoop = 0;
		this._interval = 0;
	},
	_getItem: function () {
		return this._item;
	},
	_doStart: function (x, y, shift) {
		var activeTool = this.container().activeTool();
		var idx = activeTool && activeTool instanceof GridViewSelectionTool ? activeTool.findElementAt(x,y,false).index() : this.grid().pointToIndex(_int(x), _int(y), true);
		var manager = this._request.manager();
		manager.setItemStyle(SelectionStyle.COLUMNS);
		if (shift) {
			this._item = manager.count() > 0 && manager.getItem(0);
		} else {
			manager.clear();
			this._item = manager.add(idx, idx, SelectionStyle.COLUMNS);
		}
		return Boolean(this._item);
	},
	_doDrag: function (x, y) {
		if (this._item) {
			var grid = this.grid();
			var lm = grid.layoutManager();
			this._currx = x = grid.containerToGridX(x);
			this._curry = y = grid.containerToGridY(y);
			if (x < lm.gridBounds().x || x > lm.clientRect().right() || y > lm.footerBounds().y || y < 0) {
				this._startTimer();
			} else {
				this._stopTimer();
				var index = grid.pointToIndex(x, y, false);
				if (index.column()) {
					this._item.resizeTo(index);
				}
			}
			return true;
		}
		return false;
	},
	_doEnded: function () {
		this._stopTimer();
		this._super();
	},
	_startTimer: function () {
		if (!this._timer) {
			this._loop = this._prevLoop = this._rowLoop = this._rowPrevLoop = 0;
			this._interval = 1;
			this._timer = setInterval(this._timerHandler.bind(this), 30);
			this._grid.selections().lock();
		}
	},
	_stopTimer: function () {
		if (this._timer) {
			clearInterval(this._timer);
			this._timer = null;
			this._grid.selections().unlock();
		}
	},
	_timerHandler: function () {
		var grid = this._grid;
		var x = this._currx;
		var y = this._curry;
		var lm = grid.layoutManager();
		var index;
		var cnt;
		if (x > lm.clientRect().right()) {
			cnt = Math.max(0, Math.min(3, (x - lm.clientRect().right()) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		} else if (x < lm.gridBounds().x) {
			cnt = Math.max(0, Math.min(3, (lm.gridBounds().x - x) / 40));
			this._interval = 4 - cnt;
			this._loop++;
		}
		if (this._loop - this._prevLoop >= this._interval * 2) {
			this._prevLoop = this._loop;
			if (x > lm.clientRect().right()) {
				grid.setLeftCol(grid.leftCol() + 1);
			} else if (x < lm.gridBounds().x && grid.leftPos() > 0) {
				grid.setLeftCol(grid.leftCol() - 1);
			}
			index = grid.pointToIndex(this._currx, this._curry, false);
			if (index.column) {
				this._item.resizeTo(index);
			}
		} else {
			if (y > lm.footerBounds().y) {
				cnt = Math.max(0, Math.min(3, (y - lm.footerBounds().y) / 40));
				this._interval = 4 - cnt;
				this._rowLoop++;
			} else if (y < 0) {
				cnt = Math.max(0, Math.min(3, (lm.gridBounds().y - y) / 40));
				this._interval = 4 - cnt;
				this._rowLoop++;
			}
			if (this._rowLoop - this._rowPrevLoop >= this._interval) {
				this._rowPrevLoop = this._rowLoop;
				if (y > lm.footerBounds().y) {
					grid.setTopIndex(grid.topIndex() + 1);
				} else if (y < lm.gridBounds().y) {
					grid.setTopIndex(grid.topIndex() - 1);
				}
				index = grid.pointToIndex(this._currx, this._curry, false);
				if (index.column()) {
					this._item.resizeTo(index);
				}
			}
		}
	}
});
var SelectionItem = defineClass("SelectionItem", null, {
	init: function(manager) {
		this._super();
		this._manager = manager;
	},
	style: function () {
		throwAbstractError();
	},
	isSingleCell: function () {
		return false;
	},
	getBounds: function () {
		return null;
	},
	contains: function (index) {
		return false;
	},
	inflate: function (dir, newIndex) {
		switch (dir) {
			case "left": return this._inflateLeft(newIndex);
			case "right": return this._inflateRight(newIndex);
			case "top": return this._inflateTop(newIndex);
			case "bottom": return this._inflateBottom(newIndex);
		}
		return false;
	},
	resizeTo: function (endIndex) {
	},
	intersectsWith: function (item) {
		throwAbstractError();
	},
	mergeWith: function (item) {
		throwAbstractError();
	},
	getData: function (maxRows) {
		throwAbstractError();
	},
	_resized: function () {
		this._manager && this._manager._itemResized(this);
	},
	_inflateLeft: function (newLeft) {
	},
	_inflateRight: function (newRight) {
	},
	_inflateTop: function (newTop) {
	},
	_inflateBottom: function (newBottom) {
	},
	proxy: function() {
		var grid = this._grid;
		var range = this.getBounds();
		var item1 = grid.getItem(range.R1());
		var item2 = grid.getItem(range.R2());
		return {
			style: this.style(),
			startItem: range.R1(),
			startRow: item1 ? item1.dataRow() : -1,
			startColumn: range.C1().name(),
			endItem: range.R2(),
			endRow: item2 ? item2.dataRow() : -1,
			endColumn: range.C2().name()
		}
	}

});
var SelectionManager = defineClass("SelectionManager", EventAware, {
	init: function(grid) {
		this._super();
		this._grid = grid;
		this._items = [];
		this._locked = false;
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		this._items = null;
		this._super();
	},
	exclusiveMode: true,
	itemStyle: SelectionStyle.BLOCK,
	setExclusiveMode: function (value) {
		if (value != this._exclusive) {
			this._exclusive = value;
			this.clear();
		}
	},
	setItemStyle: function (value) {
		if (value != this._itemStyle) {
			this._itemStyle = value;
			this.clear();
		}
	},
	count: function () {
		return this._items.length;
	},
	isSingleCell: function () {
		return this._items.length == 1 && this._items[0].isSingleCell();
	},
	lock: function () {
		this._locked = true;
	},
	unlock: function () {
		this._locked = false;
	},
	getItem: function (index) {
		return this._items[index];
	},
	add: function (start, end, style) {
		if (this._locked) {
			return null;
		}
		if (style == SelectionStyle.NONE) {
			this.clear();
			return null;
		}
		if (this._exclusiveMode && style != this._style) {
			this.clear();
		}
		var item = null;
		switch (style) {
		case SelectionStyle.COLUMNS:
			item = new ColumnSelection(this, start.column(), end.column());
			break;
		case SelectionStyle.SINGLE_COLUMN:
			item = new ColumnSelection(this, start.column(), start.column());
			break;
		case SelectionStyle.ROWS:
			item = new RowSelection(this._grid, start.I(), end.I());
			break;
		case SelectionStyle.SINGLE_ROW:
			item = new RowSelection(this._grid, start.I(), start.I());
			break;
		case SelectionStyle.BLOCK:
			item = new BlockSelection(this, start, end);
			break;
		case SelectionStyle.SINGLE:
			item = new BlockSelection(this, start, start);
			break;
		}
		return this._addItem(item);
	},
	remove: function (item) {
		if (this._locked) {
			return;
		}
		var index = this._items.indexOf(item);
		if (index >= 0) {
			this._items.splice(index, 1);
			this.fireEvent(SelectionManager.REMOVED, item);
		}
	},
	clear: function () {
		if (this._locked) {
			return;
		}
		if (this._items.length > 0) {
			this._items.length = 0;
			this.fireEvent(SelectionManager.CLEARED);
		}
	},
	containsItem: function (itemIndex) {
		return false;
	},
	containsColumn: function (column) {
		return false;
	},
	contains: function(index) {
		for (var i = 0, cnt = this._items.length; i < cnt; i++) {
			if (this._items[i].contains(index))
				return true;
		}
		return false;
	},
	normalize: function () {
	},
	_addItem: function (item) {
		if (!item)
			throw new Error("item is null");
		if (this._items.indexOf(item) < 0) {
			this._items.push(item);
			this.fireEvent(SelectionManager.ADDED, item);
		}
		return item;
	},
	_itemResized: function (item) {
		this.fireEvent(SelectionManager.RESIZED, item);
	}
});
SelectionManager.CHANGED = "onSelectionChanged";
SelectionManager.ADDED = "onSelectionAdded";
SelectionManager.REMOVED = "onSelectionRemoved";
SelectionManager.CLEARED = "onSelectionCleared";
SelectionManager.RESIZED = "onSelectionResized";
SelectionManager.ENDED = "onSelectionEnded";
var BlockSelection = defineClass("BlockSelection", SelectionItem, {
	init: function(manager, startIndex, endIndex) {
		this._super(manager);
		this._grid = startIndex.grid();
		this._startIndex = startIndex.clone();
		this._endIndex = endIndex.clone();
	},
	startIndex: function () {
		return this._startIndex;
	},
	endIndex: function () {
		return this._endIndex;
	},
	style: function () {
		return SelectionStyle.BLOCK;
	},
	isSingleCell: function () {
		return CellIndex.areEquals(this._startIndex, this._endIndex);
	},
	getBounds: function () {
		this._startIndex.normalize(this._grid);
		this._endIndex.normalize(this._grid);
		if (CellIndex.areEquals(this._startIndex, this._endIndex)) {
			return GridRange.create(this._startIndex);
		} else {
			var c1 = this._startIndex.C() ? this._startIndex.C().dataRoot() : null;
			var c2 = this._endIndex.C() ? this._endIndex.C().dataRoot() : null;
			return GridRange.createRange(this._startIndex.I(), c1, this._endIndex.I(), c2);
		}
	},
	contains: function (index) {
		return this.getBounds().containsIndex(index);
	},
	_inflateLeft: function (newLeft) {
		if (this._startIndex.C().distance() <= this._endIndex.C().distance()) {
			if (newLeft.C() !== this._startIndex.C()) {
				this._startIndex.column(newLeft.C());
				this._resized();
			}
		} else {
			if (newLeft.C() !== this._endIndex.C()) {
				this._endIndex.column(newLeft.C());
				this._resized();
			}
		}
	},
	_inflateRight: function (newRight) {
		if (this._startIndex.C().distance() > this._endIndex.C().distance()) {
			if (newRight.C() !== this._startIndex.C()) {
				this._startIndex.column(newRight.C());
				this._resized();
			}
		} else {
			if (newRight.C() !== this._endIndex.C()) {
				this._endIndex.column(newRight.C());
				this._resized();
			}
		}
	},
	_inflateTop: function (newTop) {
		var i = Math.max(0, Math.min(this._grid.itemCount() - 1, newTop.I()));
		if (this._startIndex.I() <= this._endIndex.I()) {
			if (i !== this._startIndex.I()) {
				this._startIndex.itemIndex(i);
				this._resized();
			}
		} else {
			if (i !== this._endIndex.I()) {
				this._endIndex.itemIndex(i);
				this._resized();
			}
		}
	},
	_inflateBottom: function (newBottom) {
		var i = Math.max(0, Math.min(this._grid.itemCount() - 1, newBottom.I()));
		if (this._startIndex.I() > this._endIndex.I()) {
			if (i !== this._startIndex.I()) {
				this._startIndex.itemIndex(i);
				this._resized();
			}
		} else {
			if (i !== this._endIndex.I()) {
				this._endIndex.itemIndex(i);
				this._resized();
			}
		}
	},
	resizeTo: function (newEnd) {
		if (this._grid.isValid(newEnd) && !CellIndex.areEquals(newEnd, this._endIndex)) {
			this._endIndex.assign(newEnd);
			this._resized();
		}
	},
	intersectsWith: function (item) {
		return this.getBounds().intersectsWith(item.getBounds());
	},
	mergeWith: function (item) {
	},
	getData: function (maxRows) {
		maxRows = arguments.length > 0 ? maxRows : -1;
		if (maxRows == 0) {
			return null;
		}
		var cnt;
        var grid = this._grid;
		var columns = grid.collectDataColumns(this._startIndex.C(), this._endIndex.C());
		if (!columns || (cnt = columns.length) < 1) {
			return null;
		}
		var r, row, item, c, col,
			r1 = Math.min(this._startIndex.I(), this._endIndex.I()),
			r2 = Math.max(this._startIndex.I(), this._endIndex.I()),
			rows = [];
		for (r = r1; r <= r2; r++) {
			item = grid instanceof GridView ? _cast(grid.getItem(r), GridRow) : ( grid instanceof TreeView ? _cast(grid.getItem(r), TreeItem) : null);
			if (item) {
				row = {};
				for (c = 0; c < cnt; c++) {
					col = columns[c];
					row[col.fieldName()] = item.getData(col.dataIndex());
				}
				rows.push(row);
				if (maxRows > 0 && rows.length == maxRows) {
					break;
				}
			}
		}
		return rows;
	}
});
var RowSelection = defineClass("RowSelection", SelectionItem, {
	init : function(grid, startRow, endRow) {
		this._super(grid.selections());
		this._grid = grid;
		this._startRow = Math.min(startRow, endRow);
		this._endRow = Math.max(startRow, endRow);
	},
	startRow: function() {
		return this._startRow;
	},
	endRow: function() {
		return this._endRow;
	},
	topRow: function () {
		return Math.min(this._startRow, this._endRow);
	},
	bottomRow: function () {
		return Math.max(this._startRow, this._endRow);
	},
	style : function() {
		return SelectionStyle.ROWS;
	},
	getBounds: function () {
		var itemCount = this._grid.itemCount();
		this._startRow = Math.max(0, Math.min(itemCount - 1, this._startRow));
		this._endRow = Math.max(0, Math.min(itemCount - 1, this._endRow));
		if (this._startRow <= this._endRow) {
			return GridRange.createRange(this._startRow, this._grid.getVisibleColumn(0), this._endRow, this._grid.getVisibleColumn(this._grid.visibleColumnCount() - 1));
		} else {
			return GridRange.createRange(this._endRow, this._grid.getVisibleColumn(0), this._startRow, this._grid.getVisibleColumn(this._grid.visibleColumnCount() - 1));
		}
	},
	contains: function (index) {
		return (index.I() >= this.topRow()) && (index.I() <= this.bottomRow());
	},
	_inflateTop: function (newTop) {
		var i = newTop.I();
		if (i != this.topRow()) {
			if (this._startRow <= this._endRow) {
				this._startRow = Math.max(0, Math.min(this._grid.itemCount() - 1, i));
			} else {
				this._endRow = Math.max(0, Math.min(this._grid.itemCount() - 1, i));
			}
			this._resized();
		}
	},
	_inflateBottom: function (newBottom) {
		var i = newBottom.I();
		if (i != this.bottomRow()) {
			if (this._startRow > this._endRow) {
				this._startRow = Math.max(0, Math.min(this._grid.itemCount() - 1, i));
			} else {
				this._endRow = Math.max(0, Math.min(this._grid.itemCount() - 1, i));
			}
			this._resized();
		}
	},
	resizeTo: function (endIndex) {
		var row = Math.max(0, endIndex.I());
		if (row != this._endRow) {
			this._endRow = Math.max(0, Math.min(this._grid.itemCount() - 1, row));
			this._resized();
		}
	},
	intersectsWith: function (item) {
		return this.getBounds().intersectsWith(item.getBounds());
	},
	mergeWith: function (item) {
	},
	getData: function (maxRows) {
		maxRows = arguments.length > 0 ? maxRows : -1;
		if (maxRows == 0) {
			return null;
		}
		var grid = this._grid;
		var columns = grid.collectDataColumns(grid.getVisibleColumn(0), grid.getVisibleColumn(grid.visibleColumnCount() - 1));
		if (!columns) {
			return null;
		}
		var cnt = columns.length; 
		if (cnt < 1) {
			return null;
		}
		var item;
		var row;
		var c;
		var col;
		var r;
		var r1 = Math.max(0, Math.min(this._startRow, this._endRow));
		var r2 = Math.min(this._grid.itemCount() - 1, Math.max(this._startRow, this._endRow));
		var rows = [];
		for (r = r1; r <= r2; r++) {
			item = grid instanceof GridView ? _cast(grid.getItem(r), GridRow) : ( grid instanceof TreeView ? _cast(grid.getItem(r), TreeItem) : null);
			if (item) {
				row = {};
				for (c = 0; c < cnt; c++) {
					col = columns[c];
					row[col.fieldName()] = item.getData(col.dataIndex()); 
				}
				rows.push(row);
				if (maxRows > 0 && rows.length == maxRows) {
					break;
				}
			}
		}
		return rows;
	}
});
var ColumnSelection = defineClass("ColumnSelection", SelectionItem, {
	init: function(manager, startColumn, endColumn) {
		this._super(manager);
		if (Column.compareLoc(startColumn, endColumn) <= 0) {
			this._startColumn = startColumn;
			this._endColumn = endColumn;
		} else {
			this._startColumn = endColumn;
			this._endColumn = startColumn;
		}
	},
	startColumn: function() {
		return this._startColumn;
	},
	endColumn: function() {
		return this._endColumn;
	},
	leftColumn: function () {
		return this._startColumn.distance() <= this._endColumn.distance() ? this._startColumn : this._endColumn;
	},
	rightColumn: function () {
		return this._startColumn.distance() > this._endColumn.distance() ? this._startColumn : this._endColumn;
	},
	style: function() {
		return SelectionStyle.COLUMNS;
	},
	getBounds: function() {
		if (this._startColumn.distance() <= this._endColumn.distance()) {
			return GridRange.createRange(0, this._startColumn, this._startColumn.grid().itemCount() - 1, this._endColumn);
		} else {
			return GridRange.createRange(0, this._endColumn, this._endColumn.grid().itemCount() - 1, this._startColumn);
		}
	},
	contains: function(index) {
		var column = index.column();
		return Column.compareLoc(column, this._startColumn) >= 0 && Column.compareLoc(column, this._endColumn) <= 0;
	},
	_inflateLeft: function (newLeft) {
		var c = newLeft.column();
		if (c !== this.leftColumn()) {
			if (this._startColumn.distance() <= this._endColumn.distance()) {
				this._startColumn = c;
			} else {
				this._endColumn = c;
			}
			this._resized();
		}
	},
	_inflateRight: function (newRight) {
		var c = newRight.column();
		if (c !== this.rightColumn()) {
			if (this._startColumn.distance() > this._endColumn.distance()) {
				this._startColumn = c;
			} else {
				this._endColumn = c;
			}
			this._resized();
		}
	},
	resizeTo: function(newEnd) {
		if (newEnd.column() !== this._endColumn) {
			this._endColumn = newEnd.column();
			this._resized();
		}
	},
	intersectsWith: function(item) {
		return this.getBounds().intersectsWith(item.getBounds());
	},
	mergeWith: function(item) {
	},
	getData: function(maxRows) {
		maxRows = arguments.length > 0 ? maxRows : -1;
		if (maxRows == 0) {
			return null;
		}
		var grid = this._startColumn.grid();
		var columns = grid.collectDataColumns(this._startColumn, this._endColumn);
		if (!columns) {
			return null;
		}
		var r, item, row, c, cols;
		var cnt = grid.itemCount();
		var rows = [];
		for (r = 0; r < cnt; r++) {
			item = grid instanceof GridView ? _cast(grid.getItem(r), GridRow) : ( grid instanceof TreeView ? _cast(grid.getItem(r), TreeItem) : null);
			if (item) {
				row = {};
				for (c = 0, cols = columns.length; c < cols; c++) {
					row[columns[c].fieldName()] = item.getData(columns[c].dataIndex());
				}
				rows.push(row);
				if (maxRows > 0 && rows.length == maxRows) {
					break;
				}
			}
		}
		return rows;
	}
});
var SelectionView = defineClass("SelectionView", LayerElement, {
	init : function(dom) {
		this._super(dom, "selectionView");
		this._item = null;
		this._background = SelectionView.$$_defBackground;
		this._border = SelectionView.$$_defBorder;
	},
	background: null,
    border: null,
	setBackground: function (value) {
		if (value !== this._background) {
			this._background = value;
			this.invalidate();
		}
	},
	setBorder: function (value) {
		if (value != this._border) {
			this._border = value;
			this.invalidate();
		}
	},
	updateElement: function (item, styles) {
		this._item = item;
		this.setBackground(styles.background());
		this.setBorder(styles.border());
	},
	_doDraw: function (g) {
		var grid = this.container().gridView();
		var lm = grid.layoutManager();
		var r = lm.gridBounds();
		r = grid.translateBy(this, r);
		g.clipRectEx(r);
		g.drawBoundsI(this._background, this._border, 0, 0, this.width(), this.height());
	}
});
SelectionView.$$_defBackground = new SolidBrush(0x2F1E90FF);
SelectionView.$$_defBorder = new SolidPen(0xaa1E90FF, 1);
var /* abstract */ ClipboardData = defineClass("ClipboardData", null, {
	init: function() {
		this._super();
	},
	lastColumn: function () {
		throwAbstractError();
	},
	getText: function (scope, range, format) {
		throwAbstractError();
	},
	getCellText: function (scope, index, format) {
		throwAbstractError();
	},
	getRows: function (scope, data, index) {
		throwAbstractError();
	},
	getCell: function (scope, data, index) {
		throwAbstractError();
	}
});
var ClipboardSource = defineClass("ClipboardSource", null, {
	init: function(data, selection) {
		this._super();
		this._lines = [];
		this._colCount = 0;
		this._blockPaste = false;
		this.$_parseQuoted(data, selection);
	},
	rowCount: function () {
		return this._lines.length;
	},
	colCount: function () {
		return this._colCount;
	},
	isEmpty: function () {
		return this._lines.length == 0 || this._colCount == 0;
	},
	isSingle: function () {
		return this._lines.length == 1 && this._colCount == 1;
	},
	isBlockPaste:function() {
		return this._blockPaste;
	},
	get: function (row) {
		return this._lines[row];
	},
	/*
	$_parse: function (data) {
		var c, quoted, escaped, s;
		var lines = this._lines;
		var line = [];
		var len = data.length;
		var p = 0;
		var i = 0;
		var quoting = false;
		while (i < len) {
			c = data.charAt(i);
			if (quoting) {
				if (c == '"') {
					quoting = false;
				}
			} else if (c == '"') {
				quoting = true;
			} else if (c == "\t") {
				s = data.substring(p, i);
				if (escaped) {
					if (i > 0 && data.charAt(i - 1) == '"') {
						s = s.substring(1, s.length - 1);
					}
					escaped  = false;
				}
				line.push(s);
				p = i + 1;
			} else if (c == "\n") {
				s = data.substring(p, i);
				if (escaped) {
					if (i > 0 && data.charAt(i - 1) == '"') {
						s = s.substring(1, s.length - 1);
					}
					escaped  = false;
				}
				line.push(s);
				lines.push(line);
				line = [];
				p = i + 1;
			} else if (c == "\r" && (i + 1) < len && data.charAt(i + 1) == "\n") {
				s = data.substring(p, i);
				if (escaped) {
					if (i > 0 && data.charAt(i - 1) == '"') {
						s = s.substring(1, s.length - 1);
					}
					escaped  = false;
				}
				line.push(s);
				lines.push(line);
				line = [];
				i++;
				p = i + 1;
			}
			i++;
		}
		if (p < len) {
			s = data.substring(p, len);
			line.push(s);
			lines.push(line);
		}
		for (i = lines.length - 1; i >= 0; i--) {
			line = lines[i];
			this._colCount = Math.max(this._colCount, line.length);
			for (p = line.length - 1; p >= 0; p--) {
				s = line[p];
				if (s && (len = s.length) > 1 && s.charAt(0) == '"' && s.charAt(len - 1) == '"') {
					line[p] = s.substring(1, len - 1);
				}
			}
		}
	}
	*/
	$_parseQuoted: function (data, selection) {
		var c, next;
		var lines = this._lines;
		var line = [];
		var len = data.length;
		var p = 0;
		var i = 0;
		var quoting, started;
		var s = "";
		var nextData;
		if (data === "") {
			line.push(data);
			lines.push(line);
			this._colCount = 1;
		} else {
			while (i < len) {
				nextData = false;
				c = data.charAt(i);
				next = i < len -1 ? data.charAt(i+1) : '';
				
				if (c == '"') {
					if (!started) { // 시작 
						started = true;
						quoting = true;
					} else if (quoting && next == '"') { //quoting 시 따옴표 두개
						s += c;
						i++;
					} else if (quoting) { //quoting 시 따옴표 한개 
						quoting = false;
					} else { //quoting 바깥쪽의 따옴표 
						s += c;
					}
				} else if (!quoting && (c == '\r' || c == '\n' || c == '\t')) {
					if (c == '\t') {
						line.push(s);
						nextData = true;
					}
					if (c == '\r' || c == '\n') {
						// if (s.length > 0)
							line.push(s);
						this._colCount = Math.max(this._colCount, line.length);
						lines.push(line);
						line = [];
						if (next == '\n')
							i++;
					}
					s = "";
					started = false;
				} else {
					started = true;
					s += c;
				}
				i++;
			}
			// 개행문자로 끝나지 않은 경우 처리
			if (quoting)
				s = '"' + s;
			if (s.length > 0||nextData)  // \t로 끝나는 경우 다음 cell의 값이 공백...
				line.push(s);
			if (line.length > 0) {
				this._colCount = Math.max(this._colCount, line.length);
				lines.push(line);
			}
		}
		if (selection && selection instanceof BlockSelection && !selection.isSingleCell()) {
			var startIndex = selection._startIndex;
			var endIndex = selection._endIndex;
			if (startIndex && endIndex) {
				var grid = selection._grid;
				var dRoot = grid._dataRoots._dataRoots;
				var startColumn = startIndex.C();
				var endColumn = endIndex.C();
				startColumn = startColumn instanceof ColumnGroup ? startColumn.first().dataRoot() : startColumn.dataRoot();
				endColumn = endColumn instanceof ColumnGroup ? endColumn.last().dataRoot() : endColumn.dataRoot();
				var c1 = Math.min(dRoot.indexOf(startColumn), dRoot.indexOf(endColumn)),
					c2 = Math.max(dRoot.indexOf(startColumn), dRoot.indexOf(endColumn));
				var r = 0;
					r1 = Math.min(startIndex.I(), endIndex.I()),
					r2 = Math.max(startIndex.I(), endIndex.I());

				var cCnt = 0;
				for (var c = c1; c <= c2; c++) {
					cCnt += dRoot[c] instanceof DataColumn ? 1 : dRoot[c] instanceof ColumnGroup ? dRoot[c].calcHorz() : 1;
					r = Math.max(r, dRoot[c] instanceof DataColumn ? 1 : dRoot[c] instanceof ColumnGroup ? dRoot[c].dataLevel() : 1);
				}
				r = (r2 - r1 + 1) * r;
				var i = 0,
				    lcnt = lines.length;
				for (var j = 0 ; j < lcnt ; j++) {
					var datas = lines[j].slice();
					for (var k = datas.length; k < cCnt; k++) {
						lines[j].push(datas[i]);
						i = i >= datas.length ? 0 : i;
					}
					this._colCount = Math.max(this._colCount, lines[j].length);
				}
				i = 0;
				for (var j = lines.length; j < r;j++ ) {
					lines.push(lines[i++]);
					i = i >= lines.length ? 0 : i;
				}
			}
			this._blockPaste = true;
			this._startIndex = CellIndex.temp(selection._grid, r1, dRoot[c1] instanceof DataColumn ? dRoot[c1] : dRoot[c1].first());
		}
	}
});
var DefaultClipboardData = defineClass("DefaultClipboardData", ClipboardData, {
	init: function() {
		this._super();
		this._columns = null;
	},
	lastColumn: function () {
		return this._columns ? this._columns[this._columns.length - 1] : null;
	},
	getText: function (scope, range, format) {
        var grid = scope.grid();
		var cells = this.$_rangeToCells(scope, null, range);
		var rows = [];
		if (grid.copyOptions().isIncludeHeaderText()) {
			for (var i = 0, cnt = cells.length; i < cnt ; i++) {
				var cols = cells[i];
				var row = [];
				for (var j = 0, jCnt = cols.length; j <jCnt; j++) {
					var col = _cast(cols[j], DataColumn); 
						if (col) {
							var v = col.header().displayText();
							row.push(v);
						} else {
							row.push("");
						}
				}
				rows.push(row.join("\t"));
			}
		}		
		for (var r = range.R1(); r <= range.R2(); r++) {
            var item = grid.getItem(r);
			if (item.dataRow() >= 0 || ItemState.isInserting(item.itemState())) {
				for (var f = 0; f < cells.length; f++) {
					var cols = cells[f];
					var row = [];
					for (var c = 0; c < cols.length; c++) {
						var col = _cast(cols[c], DataColumn);
						if (col && !col._blankWhenCopy) {
							var v = scope.getData(r, col, format);
							row.push(v);
						} else {
							row.push("");
						}
					}
					var s = row.join("\t");
					rows.push(s);
				}
			}
		}
		var data = rows.join("\r\n");
		return data+"\r\n";
	},
	getCellText: function (scope, index, format) {
		var data = "";
		var grid = scope.grid();
		if (grid.copyOptions().isIncludeHeaderText()) {
			data = index.dataColumn().header().displayText()+'\r\n'
		}
		data = data + scope.getData(index.itemIndex(), index.dataColumn(), format);
		return (data == null ? "" : data)+"";
	},
	getRows: function (scope, data, index) {
		if (data == null) {
			return null;
		}
		var grid = index.grid();
		var selection = grid.pasteOptions().isSelectBlockPaste() && grid.getSelection();
		var source = new ClipboardSource(data, selection);
		if (source.isEmpty()) {
			return null;
		}
		if (source.isSingle()) {
			return source.get(0)[0];
		} else {
			if (source.isBlockPaste() && source._startIndex) {
				index.assign(source._startIndex);
			}
			var roots = scope.getDataRoots();
			var idx1 = new CellIndex(grid, index.itemIndex(), index.column().dataRoot());
			var idx2 = new CellIndex(grid, index.itemIndex(), roots[roots.length - 1]);
			var range = GridRange.create(idx1, idx2);
			var cells = this.$_rangeToCells(scope, source, range);
			var row, j, c, line, cols, cnt, r;
			var rows = [];
			var i = 0;
			var len = source.rowCount();
			while (i < len) {
				row = {};
                row.columns = [];
                row.values = [];
				for (j = 0; j < cells.length && i < len; j++, i++) {
					cols = cells[j];
                    line = source.get(i);
					row.columns.push(cols);
					row.values.push(r = []);
					cnt = Math.min(line.length, cols.length);// colCount);
					for (c = 0; c < cnt; c++) {
						if (cols[c]) {
							r.push(line[c]);
						} else {
                            r.push("");
                        }
					}
				}
                rows.push(row);
			}
			return rows;
		}
	},
	getCell: function (scope, data, index) {
		if (!data) {
			return null;
		}
		var source = new ClipboardSource(data);
		return source.isEmpty() ? null : source.get(0)[0];
	},
	$_rangeToCells: function (scope/*ClipboardManager*/, source/*ClipboardSource*/, range) {
		range.normalizeData();
		var fld, r, c, g, col, i, colCount, width, height, w;
		var col1 = range.C1();
		var col2 = range.C2();
		if (col1 != col1.dataRoot()) {
			col1 = col1.dataRoot();
		}
		if (col2 != col2.dataRoot()) {
			col2 = col2.dataRoot();
		}
		var cells = [];
		var roots = scope.getDataRoots();
		var columns = this._columns = [];
		var c1 = roots.indexOf(col1);
		var c2 = roots.indexOf(col2);
		if (c1 < 0) {
			throw col1.name + " is not data root column.";
		}
		if (c2 < 0) {
			throw col2.name + " is not data root column.";
		}
		for (c = c1; c <= c2; c++) {
			columns.push(roots[c]);
		}
		colCount = columns.length;
		for (width = 0, c = 0; c < columns.length; c++) {
			width += this.$_calcWidth(columns[c]);
			if (source && width >= source.colCount()) {
				width = Math.min(width, source.colCount());
				colCount = c + 1;
				columns.length = colCount;
				break;
			}
		}
		w = 0;
		for (height = 1, c = 0; c < colCount; c++) {
			col = columns[c];
			height = Math.max(height, this.$_calcHeight(col, width - w));
			w += col instanceof ColumnGroup ? col.$_dataWidth : 1;
		}
		for (r = 0; r < height; r++) {
			cells.push([]);
		}
		for (r = 0; r < height; r++) {
			for (i = 0; i < width; i++) {
				cells[r].push(null);
			}
		}
		w = 0;
		for (c = 0; c < colCount; c++) {
			col = columns[c];
			this.$_setFields(col, cells, w, 0);
			w += col instanceof ColumnGroup ? col.$_dataWidth : 1;
		}
		return cells;
	},
	$_calcHeight: function (column, maxWidth) {
		if (maxWidth < 1) {
			return 0;
		}
		var i, cnt, c;
		var h = 1;
		var g = _cast(column, ColumnGroup);
		if (g && (cnt = g.visibleCount()) > 0) {
			if (g.isVertical()) {
				h = 0;
				for (i = 0; i < cnt; i++) {
					h += this.$_calcHeight(g.getVisibleItem(i), maxWidth);
				}
			} else {
				for (i = 0; i < cnt && maxWidth > 0; i++) {
					c = g.getVisibleItem(i);
					h = Math.max(h, this.$_calcHeight(c, maxWidth));
					maxWidth -= c instanceof ColumnGroup ? c.$_dataWidth : 1;
				}
			}
			g.$_dataHeight = h;
		} else if (g) {
			g.$_dataHeight = 1;
		}
		return h;
	},
	$_calcWidth: function (column) {
		var i, cnt;
		var w = 1;
		var g = _cast(column, ColumnGroup);
		if (g && (cnt = g.visibleCount()) > 0) {
			if (g.isHorizontal()) {
				w = 0;
				for (i = 0; i < cnt; i++) {
					w += this.$_calcWidth(g.getVisibleItem(i));
				}
			} else {
				for (i = 0; i < cnt; i++) {
					w = Math.max(w, this.$_calcWidth(g.getVisibleItem(i)));
				}
			}
			g.$_dataWidth = w;
		} else if (g) {
			g.$_dataWidth = 1;
		}
		return w;
	},
	$_setFields: function (column, cells, x, y) {
		var r, c, i, fld, col;
		var g = _cast(column, ColumnGroup);
		if (!g) {
			if (cells[y].length > x) {
				cells[y][x] = _cast(column, DataColumn);
			}
		} else if (g.isVertical()) {
			r = y;
			for (i = 0; i < g.visibleCount(); i++) {
				col = g.getVisibleItem(i);
				this.$_setFields(col, cells, x, r);
				r += (col instanceof ColumnGroup) ? col.$_dataHeight : 1;
			}
		} else {
			c = x;
			for (i = 0; i < g.visibleCount(); i++) {
				col = g.getVisibleItem(i);
				this.$_setFields(col, cells, c, y);
				c += (col instanceof ColumnGroup) ? col.$_dataWidth : 1;
			}
		}
	}
});

var ClipboardItem = defineClass("ClipboardItem", GridItem, {
	init: function() {
		this._super();
		this._dataSource = null;
		this._values = null;
		this._dataRow = -1;
	},
	setValues: function (values) {
		this._values = values;
	},
	id: function () {
		return NaN;
	},
	parent: function () {
		return null;
	},
	root: function () {
		return this;
	},
	childIndex: function () {
		return -1;
	},
	level: function () {
		return 1;
	},
	isLeaf: function () {
		return true;
	},
	isVisible: function () {
		return true;
	},
	provider: function () {
		return null;
	},
	dataSource: function () {
		return this._dataSource;
	},
	setDataSource: function (value) {
		this._dataSource = value;
	},
	dataRow: function () {
		return this._dataRow;
	},
	dataId:function() {
		return this.dataSource().getRowId(this._dataRow);		
	},
	setDataRow: function(dataRow) {
		this._dataRow = dataRow;
	},
	rowState: function () {
		return RowState.NONE;
	},
	itemState: function () {
		return ItemState.NORMAL;
	},
	isChecked: function () {
		return false;
	},
	setChecked: function (value) {
	},
	isCheckable: function () {
		return true;
	},
	setCheckable: function (value) {
	},
	isEditable: function () {
		return false;
	},
	isReadOnly: function () {
		return false;
	},
	setReadOnly: function (value) {
	},
	isResizable: function () {
		return false;
	},
	getRowData: function () {
		return null;
	},
	getRowObject: function () {
		var i,
			fld,
			v,
			dataSource = this.dataSource(),
			cnt = dataSource.fieldCount(),
			vals = {};
		for (i = 0; i < cnt; i++) {
			fld = dataSource.getOrgFieldName(i);
			v = this._values[i];
			vals[fld] = v;
		}
		return vals;
	},
	canEdit: function () {
		return false;
	},
	makeVisible: function () {
	},
	getData: function (field) {
		return this._values[field];
	}
});

var ClipboardIndex = defineClass("ClipboardIndex", CellIndex, {
	init: function (grid, item) {
		this._super();
		this._item = item;
	},
	item: function () {
		return this._item;
	}
});

var ClipboardManager = defineClass("ClipboardManager", null, {
	init: function(grid) {
		this._super();
		this._grid = grid;
		this._data = new DefaultClipboardData();
		this._appendingItem = new ClipboardItem();
		this._appendingIndex = new ClipboardIndex(grid, this._appendingItem);
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		this._data = null;
		this._appendingItem = null;
		this._appendingIndex = null;
		this._super();
	},
	grid: function () { 
		return this._grid;
	},
	dataSource: function () {
		return this._dataSource;
	},
	copyEmptyToClipboard: function () {
		return "";
	},
	copyToClipboard: function (range) {
		return this._data.getText(this, range, true);
	},
	copyCellToClipboard: function (index) {
		return this._data.getCellText(this, index, true);
	},
	pasteFromClipboard: function (index, data, noDataEvent) {
		var dataProvider = this._grid && this._grid.dataSource();
		this._appendingItem.setDataSource(dataProvider);
		var saveIndex = index.clone();
		index = this.$_checkIndex(index);
		if (!index || !this._grid.isValid(index)) {
			return;
		}
		if (data != null) {
			var rows = this._data.getRows(this, data, index);
			if (rows != null) {
				if (typeof rows == "string") {
					this.$_pasteSingleCell(index, rows, true);
				} else if (rows.length == 1) {
					this.$_pasteSingleLine(index, rows[0], true);
				} else if (rows.length > 1) {
					this.$_pasteMultiLines(index, rows, true, noDataEvent);
				}
			}
		}
		if (!CellIndex.areEquals(index, saveIndex)) {
			this._grid.setFocusedIndex(saveIndex, false, false);
		}
	},
	pasteCellFromClipboard: function (index, data) {
		index = this.$_checkIndex(index);
		if (!index || !this._grid.isValid(index)) {
			return;
		}
		/*
		var data = null;
		var inner = Clipboard.generalClipboard.hasFormat(DEFAULT_FORMAT);
		if (inner) {
			data = Clipboard.generalClipboard.getData(DEFAULT_FORMAT) as String;
		} else if (Clipboard.generalClipboard.hasFormat(ClipboardFormats.TEXT_FORMAT)) {
			data = Clipboard.generalClipboard.getData(ClipboardFormats.TEXT_FORMAT) as String;
		}
		*/
		if (data != null) {
			var s = this._data.getCell(this, data, index);
			this.$_pasteSingleCell(index, s, true);
		}
	},
	getDataRoots: function () {
		return this._grid.getDataRootColumns();
	},
	getData: function (itemIndex, column, format) {
		function _getTextData(cellValue) {
			if (options._lookupDisplay && (column.labelField() || column.isLookupDisplay())) {
				var index = CellIndex.temp(grid, itemIndex, column);
				var gCell = grid.body().getCellSimple(index);
				return gCell.getTextFromItem(item);
			} 
			return cellValue;
		}
        var grid = this._grid;
		var item = grid.getItem(itemIndex);
        var fld, s, v, options;
		if (!item || !(ItemState.isInserting(item.itemState()) || item.dataRow() >= 0)) {
			return "";
		}
		if (column && (fld = grid.dataSource().getField(column.dataIndex())) != null) {
			v = item.getData(column.dataIndex());
			options = this._grid.copyOptions();
			if (options.isCopyDisplayText()) {
		        var index = CellIndex.temp(grid, itemIndex, column);
		        var cell = grid._body.getCell(index);
		        var cellView = new DataCellElement(false);
		        cellView._parent = grid;
		        cellView.updateCell(cell);
		        if (cellView._renderer && cellView._renderer instanceof DataCellRenderer && cellView._renderer._getText) {
		        	return cellView._renderer._getText(cellView);
		        } else if (cellView.text()) { 
		        	return cellView.text();
		        }
			}
			if (format) {
				switch (fld.dataType()) {
					case ValueType.DATETIME:
						if (v) {
							if (options.dateWriter()) {
								s = options.dateWriter().getText(v);
							} else {
								s = v;
							}
						} else {
							s = "";
						}
						break;
					case ValueType.BOOLEAN:
						if (v !== undefined) {
							if (options.boolWriter()) {
								s = options.boolWriter().formatValue(v);
							} else {
								s = v;
							}
						} else {
							s = "";
						}
						break;
					case ValueType.NUMBER:
						if (v !== undefined && !isNaN(v)) {
							s = v;
						} else {
							s = "";
						}
						break;
					case ValueType.OBJECT:
						s = v && typeof v === "object" ? JSON.stringify(v) : v == null ? "" : v;
						break;
					default:
						s = _getTextData(v);
						break;
				}
			} else {
				switch (fld.dataType()) {
					case ValueType.DATETIME:
						s = v ? v : "";
						break;
					case ValueType.BOOLEAN:
						s = (v !== undefined) ? v : "";
						break;
					case ValueType.NUMBER:
						s = (v !== undefined && !isNaN(v)) ? v : "";
						break;
					case ValueType.OBJECT:
						s = v && typeof v === "object" ? JSON.stringify(v) : "";
						break;
					default:
						s = _getTextData(v);
						break;
				}
			}
			s = s ? String(s) : s;
			if (s && ((s.indexOf("\n") >= 0 || s.indexOf("\r\n") >= 0) || s.charAt(0) == '"')) {
				s = s.replace(/\"/g, '""');
				s = '"' + s + '"';
			}
			return s;
		} else {
			return "";
		}
	},
	$_checkIndex: function (index) {
		if (index) {
			index.normalize(this._grid);
			if (this._grid.isValid(index)) {
				if (this._grid.pasteOptions().isSelectionBase()) {
					if (this._grid.selections().count() > 0) {
						var range = this._grid.selections().getItem(0).getBounds();
						var idx = range.firstCell();
						index.setColumn(idx.column() instanceof ColumnGroup ? idx.column().first() : idx.column());
						index.setItemIndex(idx.itemIndex());
					}
				}
			}
		}
		return index;
	},
	$_createDate: function () {
		return new DefaultClipboardData();
	},
	$_readValue: function (ds, column, s) {
		var v = UNDEFINED;
		var fld = ds.getField(column.dataIndex());
		switch (fld.dataType) {
		case ValueType.NUMBER:
			v = Number(s);
			break;
		case ValueType.DATETIME:
			v = new Date(s);
			break;
		case ValueType.BOOLEAN:
			v = Boolean(s);
			break;
		default:
			v = s;
			break;
		}
		return v;
	},
	$_convertValue: function (ds, options, column, s, vals) {
		var i, readers;
		var v = UNDEFINED;
		var idx = column.dataIndex();
		var fld = ds.getField(idx);
		switch (fld.dataType()) {
		case ValueType.NUMBER:
			v = NaN;
			var f;
			if (s) {
				var colname = column.name();
				var editorOptions = column.editorOptions();
				if (options.isApplyNumberFormat()) {
					var format = editorOptions && editorOptions.editFormat || column.styles && column.styles().numberFormat();
					if (format) {
						f = new DecimalFormatter(format);
					}
				};
				var exp = options.numberCharExpOfCol(colname);
				if (exp) {
					s = s.replace(exp, "");
				}
				var sep = options.numberSeparatorOfCol(colname);
				if (sep) {
					s = s.replace(sep, ".");
				}
				v = f ? +parseFloat(s).toFixed(f._maxDigits) : parseFloat(s);
				if (options.isApplyMaxLength()) {
					s = String(v).split(".");
					if (editorOptions && editorOptions.maxIntegerLength > 0) {
						s[0] = s[0].substr(0, editorOptions.maxIntegerLength);
					};
					s = s.join(".");
					if (editorOptions && editorOptions.maxLength > 0) {
						s = s.substr(0,editorOptions.maxLength);
					};
					v = parseFloat(s);
				}
			} else if (s == "") {
				v = null;
			}
			break;
		case ValueType.DATETIME:
			v = null;
			readers = options.dateReaders();
			if (s && readers) {
				for (i = 0; i < readers.length; i++) {
					v = readers[i].toDate(s);
					if (v) {
						break;
					}
				}
			}
			if (v === null) {
				v = new Date(s);
				if (isNaN(v.getTime())) {
					v = null;
				}
			}
			if (v === null) {
				v = fld.readValue(s);
			}
			break;
		case ValueType.BOOLEAN:
			v = undefined;
			var boolReader = options.boolReader();
			if (s && boolReader) {
				v = boolReader.toBoolStrict(s);
			}
			if (v === undefined) {
				v = fld.readValue(s);
			}
			break;
		default:
			s = String(s);
			if (s) {
				var editorOptions = column.editorOptions && column.editorOptions();
				var editor = column.editor() && column.editor().toLowerCase();
				if (editor === "dropdown" || editor === "multicheck") {
					var checkDomainOnly = options._checkDomainOnly && editorOptions.domainOnly;
					var convertLabel = options._convertLookupLabel;
					var li = -1;
					var labels = [] , values = [];
					if (checkDomainOnly || convertLabel) {
						if (editorOptions.values && editorOptions.values.length > 0) {
							values = editorOptions.values;
							labels = editorOptions.labels;
						} else if (column.lookupSource()) {
							var lookupSource = column.lookupSource();
							var flds = column.lookupKeyFieldIds();
							var keys = [];
							for (var i = 0; i < flds.length -1; i++) {
								keys.push(vals[flds[i]]);
							}
							var domain = lookupSource.getTextDomain(keys);
							values = domain && domain.keys;
							labels = domain && domain.values;
						} else if (column._lookupValues && column._lookupValues.length > 0){
							values = column._lookupValues;
							labels = column._lookupLabels;
						}
					}
					if (editor === "dropdown") {
						s = convertLabel && values && labels && values.indexOf(s) < 0 && (li = labels.indexOf(s)) >= 0 ? values[li] : s;
						s = values && values.indexOf(s) >= 0 ? s : checkDomainOnly ? "" : s;
					} else if (editor === "multicheck") {
						var ret = [];
						v = _isArray(s) ? s : s && s.split ? s.split(column.valueSeparator()) : [s];
						for (var i = 0, cnt = v.length ; i < cnt; i++) {
							s = convertLabel && values && labels && values.indexOf(v[i]) < 0 && (li = labels.indexOf(v[i])) >= 0 ? values[li] : v[i];
							values && values.indexOf(s) >= 0 ? ret.push(s) : checkDomainOnly ? null : ret.push(v[i]);
						}
						s = ret.join(column.valueSeparator());
					}
				} else {
					if (options.isApplyMaxLength() && editor === "text" && editorOptions.maxLength > 0) {
						s = s.substr(0, editorOptions.maxLength);
					}
					if (column.textInputCase() == TextInputCase.LOWER) {
						s = s.toLocaleLowerCase();
					} else if (column.textInputCase() == TextInputCase.UPPER) {
						s = s.toLocaleUpperCase();
					}
				}
			}
			v = s;
		}
		return v;
	},
	$_removeChars: function (s, c) {
		if (c) {
			while (true) {
				var s2 = s.replace(c, "");
				if (s2.length == s.length)
					break;
				s = s2;
			}
		}
		return s;
	},
	$_fireRowsPasted: function (rows) {
		var grid = this._grid;
		var updatedItems = [];
		for (var i = 0; i < rows.length; i++)
			updatedItems.push(grid.getItemIndexOfRow(rows[i]));
		if (updatedItems.length > 0) {
			grid.$_rowsPasted(updatedItems);
		}
	},
	$_fireCellPasting: function (index, value) {
		var grid = this._grid;
		return grid.$_cellPasting(index, value);
	},
	$_cellWritable: function(index, state, value) {
		var grid = this._grid;
		var pasteFlag = this.$_fireCellPasting(index, value);
		// onCellpasting event에서 true,false를 return시 붙여넣기 또는 취소.
		if (typeof pasteFlag === "boolean") {
			return pasteFlag;
		}
		// checkReadOnly가 false이면 무조건 붙여넣기.
		if (!grid.pasteOptions().isCheckReadOnly()) {
			return true;
		}
		// 1. cellStyle이 있으면 editalbe, readOnly 체크.
		// 2. dynamicStyles이 있으면 editable, readOnly체크.
		// 3. fixed상태 체크.
		// 4. dataRow, column에 따라서 
		var editable = true;
		var fixedOptions = grid.fixedOptions();
		var editOptions = grid.editOptions();
		var cs = grid.getDataCellStyle(index.dataRow(), index.dataField());
		var cellWritable = grid.getCellWritable(index);
		if (cs) {
			if ((editable = cs.calcWritable()) !== undefined) {
				return editable;
			}
		} else if (cellWritable !== undefined) {
			return cellWritable;
		}
		if ((index.isFixedCol() && !fixedOptions.isEditable()) || (index.isFixedRow() && !fixedOptions.isRowEditable())) {
			return false;	// fixed인경우 return
		};
		var itemState = index.item() && index.item().itemState();
		switch (itemState || state) {
			case ItemState.NORMAL:
			case ItemState.FOCUSED:
			case ItemState.UPDATING:
				editable = grid.canUpdate(index.item(), index.dataField());
				break;
			case ItemState.INSERTING:
			case ItemState.APPENDING:
				editable = true;
				break;
		}
		return editable && index.dataColumn().isEditable() && !index.dataColumn().isReadOnly();
	},
	$_applyMaskValue: function(index, value) {
		var grid = this.grid();
		var ec = grid.editController();
		var editor = ec.getCellEditor2(index);
		if (mask = (editor.mask && editor.mask())) {
			mask.clearBuffer();
			mask.writeBuffer(value, true);
			if (mask.checkValid()) {
				return mask.getStripValue();
			} else {
				return null;
			};
		}
		return value;
	},
	$_pasteSingleCell: function (index, s, convert) {
		var v, item;
		var grid = this._grid;
		var ds = grid.dataSource();
		var col = index.dataColumn();
		var options = grid.pasteOptions();
		if (s == null || !ds || !col || !grid._editOptions.isEditable() || grid._editOptions.isReadOnly() || !index.item().canEdit() ) {
			return;
		}
		if (s.lastIndexOf("\r\n") == s.length - 1) {
			s = s.substr(0, s.length - 2);
		}
		if (s.lastIndexOf("\n") == s.length - 1) {
			s = s.substr(0, s.length - 1);
		}
		v = convert ? this.$_convertValue(ds, options, col, s, index.item() && index.item().getRowData()) : this.$_readValue(ds, col, s);
		v = options.isApplyEditMask() ? this.$_applyMaskValue(index, v) : v;
  		var pasteFlag = this.$_cellWritable(index, null, v);
		if (pasteFlag) {
			if (grid.isItemEditing() || options.isStartEdit() && grid.edit(index)) {
				item = index.item();
				var oldValue = item.getData(index.dataField());
				grid.setCellUpdateEventLock(options.isNoEditEvent());
				try {
					item.setData(col.dataIndex(), v);
				} finally {
					grid.setCellUpdateEventLock(false);
				}
				grid.validateCellCommit(index, index.item().getData(index.dataField()));
				grid.$_editRowPasted(item, [index.dataField()], [oldValue], [v]);
				grid.refreshView();
			} else {
				var vals;
				var validations = grid.validationManager();
				var rowValidation = options.isForceRowValidation();// && grid.validationManager().hasRowValidation();
				var colValidation = options.isForceColumnValidation();
				item = index.item();
				vals = rowValidation || colValidation ? item.getRowData() : [];
				vals[col.dataIndex()] = v;
				this._appendingItem.setValues(vals);
				var inserting = ItemState.isInserting(item.itemState());
				this._appendingItem.setDataRow(item.dataRow());
				this._appendingItem.setIndex(item.index());
				this._appendingIndex.setColumn(null);
				this._appendingIndex.setItemIndex(index.itemIndex());
				if (rowValidation) {
					grid.validationManager().hasRowValidation() && grid.validationManager().validateRow(this._appendingItem, false, true);
					grid._fireValidateRow(this._appendingItem, inserting, this._appendingItem.getRowObject());
				}
				if (colValidation) {
					this._appendingIndex.setColumn(col);
					validations.validateCell(this._appendingIndex, false);
					grid._fireValidateCell(this._appendingIndex, false, this._appendingItem.getData(col.dataIndex()));
				}
				grid.updatePastedRow(item, vals, !rowValidation);
			}
		}
	},
	$_pasteSingleLine: function (index, row, convert) {
		var grid = this._grid;
		var items = grid.itemSource();
		var ds = grid.dataSource();
		var rowUpdated = false;
		var options = grid.pasteOptions();
		var editOptions = grid.editOptions();
		var v, col, item, vals, cols, values, cnt, r, i;
		if (!ds || !editOptions.isEditable() || editOptions.isReadOnly()) {
			return;
		}
		if (ds) {
			if (grid.isItemEditing() || options.isStartEdit() && grid.edit(index)) {
				var fields = [];
				var oldValues = [];
				var saveCol = index.column();
                item = index.item();
                values = [];
                cnt = Math.min(row.columns.length, row.values.length);
                for (r = 0; r < cnt; r++) {
                    cols = row.columns[r];
                    vals = row.values[r];
                    for (i = 0; i < vals.length; i++) {
                        var col = cols[i];
                        var val = vals[i];
                        if (col) {
                            oldValues.push(item.getData(col.dataIndex()));

                            var idx = CellIndex.temp(grid, index.itemIndex(), col);
                            v = convert ? this.$_convertValue(ds, options, col, val, item && item.getRowData()) : this.$_readValue(ds, col, val);
                            v = options.isApplyEditMask() ? this.$_applyMaskValue(idx, v) : v;
                            grid.setCellUpdateEventLock(options.isNoEditEvent());
                            try {
                                var pasteFlag = this.$_cellWritable(idx, null, v);
                                if (pasteFlag) {
                                    item.setData(col.dataIndex(), v);
                                }
                            } finally {
                                grid.setCellUpdateEventLock(false);
                            }
                            if (pasteFlag) {
	                            index.column(col);
	                            grid.validateCellCommit(index, index.item().getData(col.dataIndex()));
	                            fields.push(col.dataIndex());
	                            values[col.dataIndex()] = v;
	                            rowUpdated = true;
	                        }
                        }
                    }
                }
                if (rowUpdated) {
					grid.$_editRowPasted(item, fields, oldValues, values);
					index.column(saveCol);
					grid.refreshView();
                }
			} else {
				var validations = grid.validationManager();
				var rowValidation = options.isForceRowValidation();// && validations.hasRowValidation();
				var colValidation = options.isForceColumnValidation();
				item = index.item();
				values = rowValidation || colValidation ? item.getRowData() : [];
                cnt = Math.min(row.columns.length, row.values.length);
                for (r = 0; r < cnt; r++) {
                    cols = row.columns[r];
                    vals = row.values[r];
                    for (i = 0; i < vals.length; i++) {
                        col = cols[i];
                        if (col) {
							var idx = CellIndex.temp(grid, index.itemIndex(), col);
                            v = convert ? this.$_convertValue(ds, options, col, vals[i], item, item.getRowData()) : this.$_readValue(ds, col, vals[i]);
                            v = options.isApplyEditMask() ? this.$_applyMaskValue(idx, v) : v;
							var pasteFlag = this.$_cellWritable(idx, null, v);//cs ? cs.calcWritable(editable, readOnly) : editable && !readOnly;
                            if (pasteFlag) {
	                            values[col.dataIndex()] = v;
	                            rowUpdated = true;
                            }
                                
                        }
                    }
                }
                if (rowUpdated) {
                	var inserting = ItemState.isInserting(item.itemState());
					this._appendingItem.setValues(values);
					this._appendingItem.setIndex(item.index());
					this._appendingItem.setDataRow(item.dataRow());
					this._appendingIndex.setColumn(null);
					this._appendingIndex.setItemIndex(index.itemIndex());
					if (rowValidation) {
						validations.hasRowValidation() && validations.validateRow(this._appendingItem, inserting, true);
						grid._fireValidateRow(this._appendingItem, inserting, this._appendingItem.getRowObject());
					}
					if (colValidation) {
						for (i = 0; i < vals.length; i++) {
							this._appendingIndex.setColumn(cols[i]);
							validations.validateCell(this._appendingIndex, inserting);
							grid._fireValidateCell(this._appendingIndex, inserting, this._appendingItem.getData(cols[i].dataIndex()));
						}
					}
					grid.updatePastedRow(item, values, !rowValidation);
                }
			}
			grid.selections().clear();
			grid.selections().add(index, new CellIndex(index.grid(), index.itemIndex(), this._data.lastColumn()), SelectionStyle.BLOCK);
		}
	},
	$_pasteMultiLines: function (index, rows, convert, noDataEvent) {
		var grid = this._grid;
		var ds = grid.dataSource();
		if (ds) {
			var items = grid.itemSource();
			var options = grid.pasteOptions();
			var checkReadOnly = options.isCheckReadOnly();
			if (checkReadOnly && (!grid._editOptions.isEditable() || grid._editOptions.isReadOnly())) {
				return;
			}
			var len = rows.length;
			var idx = index.itemIndex();
			var flds = ds.fieldCount();
			var allColumns = grid.getDataColumns(false);
			var cols = allColumns.length;
			var validations = grid.validationManager();
			var rowValidation = options.isForceRowValidation();// && validations.hasRowValidation();
			var colValidation = options.isForceColumnValidation();
			var appendingItem = this._appendingItem;
            var appendingIndex = this._appendingIndex;
			var r, r2, cnt, i, v, item, row, vals, fld, col, itemCount, values, columns, pasteFlag, cs;
			var eventEachRow = options.isEventEachRow();
			var updatedRows = [];
			if (options.isCommitEdit()) {
				if (!grid.commit(false)) {
					grid.cancel();
				}
			} else {
				grid.cancel();
			}
			itemCount = grid.itemCount();
			appendingItem.setDataSource(ds);
			noDataEvent ? ds.beginUpdate() : (!eventEachRow && grid.beginUpdate());
			try {
				for (r = 0; r < len && idx < itemCount; r++) {
					try {
						item = grid.getItem(idx);
						if (item.itemState() == ItemState.APPENDING) {
							break;
						}
						while (item && item.dataRow() < 0) {
							idx++;
							item = grid.getItem(idx);
						}
						if (item == null) {
							break;
						}
						row = rows[r];
	                    vals = rowValidation || colValidation ? item.getRowData() : [];
	                    var rowUpdated = false;
	                    var oldValues = [];
	                    var fields = [];
	                    cnt = Math.min(row.columns.length, row.values.length);
	                    for (r2 = 0; r2 < cnt; r2++) {
	                        columns = row.columns[r2];
	                        values = row.values[r2];
	                        for (i = 0; i < values.length; i++) {
	                            col = columns[i];
	                            if (col) {
	                            	oldValues.push(item.getData(col.dataIndex()));
									var tidx = CellIndex.temp(grid, item.index(), col);
                                    v = convert ? this.$_convertValue(ds, options, col, values[i],item && item.getRowData()) : this.$_readValue(ds, col, values[i]);
                                    v = options.isApplyEditMask() ? this.$_applyMaskValue(tidx, v) : v;
									var pasteFlag = this.$_cellWritable(tidx, null, v);
	                                if (pasteFlag) {
	                                	rowUpdated = rowUpdated || pasteFlag || !checkReadOnly;
	                                    vals[col.dataIndex()] = v;
	                                    fields.push(col.dataIndex());
	                                }
	                            }
	                        }
	                    }
	                    if (rowUpdated) {
							try {
								appendingItem.setValues(vals);
								appendingItem.setIndex(item.index());
								appendingItem.setDataRow(item.dataRow());
								appendingIndex.column(null);
								appendingIndex.setItemIndex(item.index());
								var inserting = ItemState.isInserting(item.itemState());								
								if (rowValidation) {
									validations.hasRowValidation() && validations.validateRow(appendingItem, inserting, true);
									grid._fireValidateRow(appendingItem, inserting, appendingItem.getRowObject());
								}
								if (colValidation) {
		                            for (r2 = 0; r2 < cnt; r2++) {
		                                columns = row.columns[r2];
		                            	for (i = 0; i < cols; i++) {
		                                    col = allColumns[i];
		                                    appendingIndex.column(col);
		                                    validations.validateCell(appendingIndex, inserting);
		                                    grid._fireValidateCell(appendingIndex, inserting, appendingItem.getData(col.dataIndex()));
	                              		}
		                            }
								}
								grid.updatePastedRow(item, vals, !rowValidation);
								if (eventEachRow)
									grid.$_editRowPasted(item, fields, oldValues, vals);
								updatedRows.push(item.dataRow());
							} catch (err) {
								if (options.isStopOnError()) {
									throw err;
								}
							}
						}
						idx++;
					} catch (err) {
						idx = Math.max(index.I(), idx - 1);
						grid.setFocusedIndex(index, false);
						grid.selections().clear();
						grid.selections().add(index, new CellIndex(index.grid(), idx, this._data.lastColumn()), SelectionStyle.BLOCK);
						throw err;
					}
				}
				if (r < len && options.isEnableAppend()) {
					for (; r < len; r++) {
	                    row = rows[r];
	                    vals = [];
	                    try {
	                    	var fields = [];
	                    	cnt = Math.min(row.columns.length, row.values.length);
	                        for (r2 = 0; r2 < cnt; r2++) {
	                            columns = row.columns[r2];
	                            values = row.values[r2];
	                            for (i = 0; i < values.length; i++) {
	                                col = columns[i];
	                            	if (col) {
										var tidx = CellIndex.temp(grid, -1, col);	                            		
	                                    v = convert ? this.$_convertValue(ds, options, col, values[i], vals) : this.$_readValue(ds, col, values[i]);
	                                    v = options.isApplyEditMask() ? this.$_applyMaskValue(tidx, v) : v;
										var pasteFlag = this.$_cellWritable(tidx, ItemState.APPENDING, v);
		                                if (pasteFlag) {
		                                    vals[col.dataIndex()] = v;
		                                    fields.push(col.dataIndex());
		                                }
		                            }
	                            }
	                            if (options.isFillColumnDefaults()) {
	                                for (i = 0; i < cols; i++) {
	                                    col = allColumns[i];
	                                    if (vals[col.dataIndex()] === undefined) {
	                                        vals[col.dataIndex()] = col.defaultValue();
	                                    }
	                                }
	                            }
	                            if (options.isFillFieldDefaults()) {
	                                for (i = 0; i < flds; i++) {
	                                    if (vals[i] === undefined) {
	                                        fld = ds.getField(i);
	                                        vals[i] = fld.defaultValue();
	                                    }
	                                }
	                            }
	                        }
	                        try {
	                            appendingItem.setValues(vals);
	                            appendingItem.setDataRow(-1);
	                            appendingItem.setIndex(-1);
								this._appendingIndex.column(null);
								this._appendingIndex.setItemIndex(-1);
	                            if (rowValidation) {
	                                validations.hasRowValidation() && validations.validateRow(appendingItem, true, true);
									grid._fireValidateRow(appendingItem, true, appendingItem.getRowObject());
	                            }
	                            if (options.isForceColumnValidation()) {
	                                for (i = 0; i < cols; i++) {
	                                    col = allColumns[i];
	                                    this._appendingIndex.column(col);
	                                    validations.validateCell(this._appendingIndex, true);
	                                    grid._fireValidateCell(appendingIndex, true, appendingItem.getData(col.dataIndex()));
	                                }
	                            }
	                            grid.appendPastedRow(vals);
	                            var drow = ds.rowCount()-1;
								if (eventEachRow) {
									item = grid.getItem(grid.getItemIndexOfRow(drow));
									grid.$_editRowPasted(item, fields, [], vals);
								}
	                            updatedRows.push(drow);
	                        } catch (err) {
	                            if (options.isStopOnError()) {
	                                throw err;
	                            }
	                        }
	                    } catch (err) {
	                        idx = Math.max(index.I(), grid.itemCount() - 1);
	                        grid.setFocusedIndex(index, false);
	                        grid.selections().clear();
	                        grid.selections().add(index, new CellIndex(index.grid(), idx, this._data.lastColumn()), SelectionStyle.BLOCK);
	                        throw err;
	                    }
	                }
					idx = noDataEvent ? -1 : grid.itemCount();
				}
				this.$_fireRowsPasted(updatedRows);
			} catch (err) {
				this.$_fireRowsPasted(updatedRows);
				throw err;
			} finally {
				if (noDataEvent) {
					ds.endUpdate();
					idx < 0 && (idx = ds.rowCount());
				} else {
				 	!eventEachRow && grid.endUpdate(true);	
				}
			}
			grid.setFocusedIndex(index, false);
			grid.selections().clear();
			grid.selections().add(index, new CellIndex(index.grid(), idx - 1, this._data.lastColumn()), SelectionStyle.BLOCK);
		}
	}
});

var MobileSelectionTool = defineClass("MobileSelectionTool", GridTool, {
	init: function (owner) {
		this._super(owner, "mobileSelectionTool");
		this._clickElement = null;
		this._clickCell = null;
		this._clickHandle = null;
/**** tablet의 경우 touchScreen을 가진다. touch관련 속성들 GridTool로 이동한다. ****/		
	},
	destroy: function () {
		this._super();
	},
	_doActivate: function () {
		this._super();
		this._grid.addFocusElement(this._focusView);
        this._grid.addRowFocusElement(this._rowFocusView);
	},
	_doDeactivate: function () {
		this._super();
		this._grid.removeFocusElement(this._focusView);
        this._grid.removeRowFocusElement(this._rowFocusView);
	},
	_doMouseDown: function (x, y, ctrlKey, shiftKey) {
		this.onTouch(x, y);
	},
	_doMouseMove: function (x, y) {
	},
	_doMouseUp: function (x, y) {
		this.onTap(x, y);
	},
	_doLayoutChanged: function (x, y) {
		this._resetFocusedView();
	},
	_doFocusedIndexChanging: function (newIndex) {
	},
	_doFocusedIndexChanged: function (oldIndex, newIndex) {
		this._resetFocusedView();
	},
	_doDblClick: function (x, y) {
		this.onDoubleTap(x, y);
	},
	_doKeyDown: function(key, ctrl, shift, alt, event) {
		trace("MobileSelectionTool K E Y D O W N: " + key);
		var item;
		var grid = this.grid();
		var lm = grid.layoutManager();
		var options = grid.editOptions();
		var skip = options.isSkipReadOnly();
		var skipCell = options.isSkipReadOnlyCell();
		var focused = this.focused();
		var verticalStep = options.verticalMovingStep()
		focused._verticalStep = verticalStep;
		var index = focused.clone();
		var isMac = false;
        var appending = false;
        if (!grid._fireKeyDown(key, ctrl, shift, alt))
        	return true;
		if (DataCellRenderer.consumeKey(index, key, ctrl, shift)) {
			return true;
		}
        grid.closeFilterSelector();
        if (options && options.isCheckWhenSpace() && key == Keys.SPACE && grid._focusedCheckIndex) {
        	var cell = grid.checkBar().getCell(grid._focusedCheckIndex);
			if (cell) {
				this._checkCellClicked(cell);
				return true;
			}
		};
		if (grid._focusedCheckIndex) {
			grid._focusedCheckIndex = undefined;
			var cb = grid.checkBar();
			cb._dirty = true;
			cb.invalidate();
		};
		if (key == Keys.ESCAPE) {
			grid.closePopups();
			this._doCancel(grid);
		} else if (key == Keys.ENTER) {
			return this._doEnter(grid, options, index);
		} else if (key == Keys.TAB) {
			return this._doTab(grid, options, index, ctrl, shift, event);
		} else if (key == Keys.F2) {
			if (!grid.isEditing() && index && index.dataColumn()) {
				grid.showEditor(index, shift);
			}
		} else if (key == Keys.INSERT) {
			if (options.isAppendWhenInsertKey() || grid.itemCount() == 0) {
				grid.append();
			} else {
				grid.insert(index.item(), shift, ctrl);
			}
		} else if (key == Keys.DELETE) {
            if (ctrl && shift) {
                grid.revertSelection();
                return true;
            } else if (ctrl) {
				grid.deleteSelection();
				return true;
			}
			return false;
		} else if (key == Keys.BACK) {
			return false;
		/*
		} else if (key == Keys.SPACE && grid.isReadMode()) {
			var cell = grid.checkBar().getCell(index);
			if (cell) {
				this._checkCellClicked(cell);
			}
		*/
		} else if (_included(key, Keys.HOME, Keys.END, Keys.RIGHT, Keys.LEFT, Keys.DOWN, Keys.UP, Keys.PAGEDOWN, Keys.PAGEUP)) {
			var itemCount = grid.itemCount();
			event && event.preventDefault && event.preventDefault();
			if (key == Keys.DOWN && itemCount == 0) {
				grid.append();
				return;
			}
			if (!grid.isValid(index)) {
				index.normalize(grid);
				this.setFocused(index, true);
				return true;
			}
			if ((_included(key, Keys.DOWN, Keys.PAGEDOWN) || (key == Keys.END && ctrl)) && index.isBottom() && this.$_checkAppending(index)) {
				return true;
			}
			if ((_included(key, Keys.UP, Keys.PAGEUP) || (key == Keys.HOME && ctrl)) && index.isTop() && this.$_checkAppending(index, true)) {
				return true;
			}
			switch (key) {
			case Keys.HOME:
				if (ctrl) {
					var orgIndex = index.clone();
					index.first();
					if (skip && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, 1, orgIndex)) {
							index.assign(focused);
							break;
						}
					}
				} else {
					index.home();
					this.$_skipReadOnly(index, 1);
				}
				break;
			case Keys.END:
				if (ctrl) {
					var orgIndex = index.clone();
					index.last();
					if (skip && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, -1, orgIndex)) {
							index.assign(focused);
							break;
						}
					}
				} else {
					index.end();
					this.$_skipReadOnly(index, -1);
				}
				break;
			case Keys.RIGHT:
				index.right();
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnly(index, 1)) {
						index.assign(focused);
						break;
					}
				}
				break;
			case Keys.LEFT:
				index.left();
				if (options && options.isCheckWhenSpace() && CellIndex.areEquals(index, focused)) {
					var cb = grid.checkBar();
					var ci = cb && cb.getCell(index);
					if (ci && ci.index().item().isCheckable()) {
						grid._focusedCheckIndex = ci ? ci._index.clone() : null;
						cb._dirty = true;
						cb.invalidate();
						break;
					}
				};
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnly(index, -1)) {
						index.assign(focused);
						break;
					}
				}
				break;
			case Keys.DOWN:
				try {
					if (index.I() == grid.itemCount() - 1 && (index.isBottom() || verticalStep == VerticalMovingStep.ROW)) {
						if (index.isBottom()) {
							if (this.$_commitCancel(index.item(), options))
								return true;
						}
						grid.append();
	                    appending = true;
						if (ctrl && isMac) {
							index.last();
						} else {
							index.down(grid.isItemEditing(index.item()));
						}
					} else {
						if (ctrl && isMac) {
							index.last();
						} else {
							index.down(grid.isItemEditing(index.item()));
						}
					}
				} finally {
					if (skipCell && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, 1)) {
							index.assign(focused);
						}
					}
				}
				break;
			case Keys.UP:
				try {
	                if (index.I() == 0 && index.isTop()) {
						if (this.$_commitCancel(index.item(), options))
							return true;

	                    if (ctrl && isMac) {
	                        index.first();
	                    } else {
	                        index.up();
	                    }
	                } else {
	                    if (ctrl && isMac) {
	                        index.first();
	                    } else {
	                        index.up(grid.isItemEditing(index.item()));
	                    }
	                }
				} finally {
					if (skipCell && this.$_checkReadOnly(index)) {
						if (!this.$_skipReadOnlyCell(index, -1)) {
							index.assign(focused);
						}
					}				
				}
				break;
			case Keys.PAGEUP:
				var orgIndex = index.clone();
				index.incRow(-lm.fullItemCount());
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnlyCell(index, 1, orgIndex)) {
						index.assign(focused);
						break;
					}
				}
				break;
			case Keys.PAGEDOWN:
				if (index.I() == grid.itemCount() - 1 && index.isBottom()) {
					if (ItemState.isInserting(index.item().itemState())) {
						if (grid.commit(options.isForceAppend())) {
						}
						return true;
					}
				}
				var orgIndex = index.clone();
				index.incRow(lm.fullItemCount());
				if (skip && this.$_checkReadOnly(index)) {
					if (!this.$_skipReadOnlyCell(index, -1, orgIndex)) {
						index.assign(focused);
						break;
					}
				}
				break;
			}
            if (shift && grid.selections().count() > 0) {
                this.setFocused(index, false);
                grid.selections().getItem(0).resizeTo(index);
            } else {
                this.setFocused(index, true);
            }
			return true;
		} else if (index.item() instanceof DummyEditItem) {
			grid.append();
		}
		return false;
	},
	_doKeyUp: function(key, ctrl, shift, alt, event) {
		trace("MobileSelectionTool KeyUp KEY: " + key + ",ctrl="+ctrl+",shift="+shift+",alt="+alt);
		this.grid()._fireKeyUp(key, ctrl, shift, alt);
	},
	_doKeyPress: function(key) {
		trace("MobileSelectionTool KeyPress");
		this.grid()._fireKeyPress(key);
	},
	_resetFocusedView: function () {
		var grid = this._grid;
		var index = this.focused();
		var lm = grid.layoutManager();
		var options = grid.displayOptions()
		var rowVis;		
		if (grid.displayOptions().isFocusVisible() && grid.isValid(index)) {
			var cell = this._grid.getFocusedCellView();
			if (cell) {
				var r = cell.boundsBy(grid);
				if (r.width > 0 && r.height > 0) {
					if (grid._container.$_rich) {
						r.x++;
						r.y++;
					}
					this._focusView.setRect(r);
					this._focusView.setEditing(grid.isEditing(), cell.getButtonWidth ? cell.getButtonWidth() : 0);
					this._focusView.setVisible(true);
				} else {
					this._focusView.setVisible(false);
				}
			} else {
				this._focusView.setVisible(false);
			}
		} else {
			this._focusView.setVisible(false);
		}
		if (lm._gridBounds && options.isRowFocusVisible() && grid.isValid(index)) {
			var idx = index.I();
			var t = grid.topIndex();
			var fixed = lm.fixedItemCount();
			var itemCount = lm.itemCount();
			var fr;
			if (rowVis = idx < fixed || (idx >= t && idx <= t+itemCount)) {
				var y = fixed > 0 ? lm.fixedHeight() + grid.fixedOptions().rowBarHeight() : 0;
				var gr = lm.gridBounds(); 
				if (idx < fixed) {
					fr = lm.itemBounds(Math.max(0, idx));
				} else {
					fr = lm.itemBounds(Math.max(0, idx - t));
					fr.y = Math.max(fr.y, y);
				}
				fr.y += gr.y;
				fr.x = 0;
				fr.width = gr.x+gr.width;
				grid._container.$_rich && (fr.x++, fr.y++);
				this._rowFocusView.setRect(fr)
			}
		}
		this._rowFocusView.setVisible(rowVis);
		if (this._focusView.isVisible()) {
			grid._resetFocusMask();
		}
		if (this._rowFocusView.isVisible()) {
			grid._resetRowFocusMask();
		}
	},
	_checkCellClicked: function (cell) {
		var grid = this.grid();
		if (grid.editOptions().isCheckable()) {
			var checkBar = grid.checkBar();
			var item = cell.item();
			if (item.isCheckable() && (checkBar.isShowGroup() || item.dataRow() >= 0)) {
                grid.makeItemVisible(item.index());
				grid.itemSource().checkItem(item, !item.isChecked(), checkBar.isExclusive(), true);
			}
		}
	},
	_checkAllClicked: function (cell) {
		var grid = this.grid();
		var checkBar = grid.checkBar();
		if (!grid.isEmpty() && grid.editOptions().isCheckable()) {
			if (checkBar.isShowAll() && !checkBar.isExclusive()) {
				cell.setChecked(!cell.isChecked());
				grid.itemSource().checkAll(cell.isChecked(), checkBar.isVisibleOnly(), checkBar.isCheckableOnly(), true, checkBar.isShowGroup());
			} else {
				this._checkBarHeadClicked();
			}
		}
	},
	_performRendererClick: function (index, cell, x, y) {
		var grid = this.grid();
		if (!grid.isEditing() && index.isValid() && cell) {
			var column = index.dataColumn();
			if (column) {
				var renderer = cell.renderer(); // column.renderer;

				if (!grid.isReadOnly(index) && renderer.isEditable()) {
					var item = index.item();
					if ((grid.isItemEditing(item) || grid.canUpdate(item, index.dataField())) && grid.canWrite(index)) {
						if (grid.edit(index)) {
							renderer.performEdit(index);
						}
					}
				} else if (renderer.isClickable(index)) {
					renderer.performClick(cell, x, y);
				}

			}
		}
	},
	_columnHeaderClicked: function(column) {
		this.grid()._fireColumnHeaderClicked(column);
	},
	_columnHeaderImageClicked: function(column) {
		this.grid()._fireColumnHeaderImageClicked(column);
	},
	_footerCellClicked: function (cell) {
		this.grid()._fireFooterCellClicked(cell);
	},
	_checkBarHeadClicked: function (cell) {
		this.grid()._fireCheckBarHeadClicked(cell);
	},
	_checkBarFootClicked: function (cell) {
		this.grid()._fireCheckBarFootClicked(cell);
	},
	_indicatorCellClicked: function (index) {
		this.grid()._fireIndicatorCellClicked(index);
	},
	_stateBarCellClicked: function (index) {
		this.grid()._fireStateBarCellClicked(index);
	},
	_rowGroupHeadFootClicked: function () {
		this.grid()._fireRowGroupHeadFootClicked();
	},
	_rowGroupHeaderFooterClicked: function (kind, index) {
		this.grid()._fireRowGroupHeaderFooterClicked(kind, index);
	},
	_rowGroupBarClicked: function (index) {
		this.grid()._fireRowGroupBarClicked(index);
	},
	_panelClicked: function (index) {
		this.grid()._firePanelClicked(index);
	},
	_rowGroupPanelClicked: function (column) {
		this.grid()._fireRowGroupPanelClicked(column);
	},
	_bodyEmptyClicked: function() {
		this.grid()._fireBodyEmptyClicked();
	},
	editorActivated: function (editor) {
 		this._resetFocusedView();
 	},
 	editButtonClicked: function(index) {
 		var grid = this.grid();
        grid.makeCellVisible();
        if (grid.showEditor(index)) {
            grid.editorButtonClick(index);
        }
		this._super(index);
	}
});

var MobileGridSelectionTool = defineClass("MobileGridSelectionTool", MobileSelectionTool, {

});

var MobileTreeSelectionTool = defineClass("MobileTreeSelectionTool", MobileSelectionTool, {
	onTap: function(x, y) {
		var clickCell = this._clickCell;
		var clickElement = this._clickElement;
		if (clickElement instanceof TreeExpandHandle) {
			var item = clickElement.cellView().item();
			if (item) {
				item.setExpanded(!item.isExpanded());
			}
		} else if (clickElement instanceof TreeCheckElement) {
			var tree = this.grid();
			if (tree.editOptions().isCheckable()) {
				var item = clickElement.item();
				item && item.isCheckable() && tree.itemSource().checkItem(item, !item.isChecked(), tree.checkBar().isExclusive(), true);
			}
		} else {
			this._super(x, y);
		}
	}
});
var MobileFocusView = defineClass("MobileFocusView", LayerElement, {
	init: function () {
		this._super("mobileFocusView");
		this._border = new SolidPen(0xff333333, 2);
		this._editBorder = new SolidPen(0xff000000 + (82 << 16) + (146 << 8) + 247, 2);
		this._editing = false;
	},
	setEditing: function (editing, buttonWidth) {
		if (editing != this._editing) {
			this._editing = editing;
			this._buttonWidth = buttonWidth;
			this.invalidate();
		}
	},
	_doDraw: function (g) {
		var w = this.width() - (this._editing ? this._buttonWidth : 0);
		g.drawBoundsI(null, this._editing ? this._editBorder : this._border, -1, -1, w - 1, this.height() - 1);
	}
});
var MobileContextMenu = defineClass("MobileContextMenu", LayerElement, {
	init: function () {
		this._super("focusView");
		this._border = new SolidPen(0xff333333, 2);
		this._editBorder = new SolidPen(0xff000000 + (82 << 16) + (146 << 8) + 247, 2);
		this._editing = false;
	},
	setMenu: function (menu) {
	},
	_doDraw: function (g) {
		var w = this.width() - (this._editing ? this._buttonWidth : 0);
		g.drawBoundsI(null, this._editing ? this._editBorder : this._border, -1, -1, w - 1, this.height() - 1);
	}
});
var MobileEditCommand = defineClass("MobileEditcommand", null, {
    init: function(grid, command, k) {
        this._super();
        this._owner = grid;
        this._name = command.name;
        this._label = command.label;
        this._styles = new VisualStyles(grid,'mobileEditCommand',{
        	line:SolidPen.WHITE,
        	figureBackground: SolidBrush.WHITE
        });
        if (command) {
            this._callback = command.callback;
            this._renderer = command.renderer;
            command.styles && this._styles.extend(command.styles);
        };
    },
    run: function(grid, name) {
        var callback = this._callback;
        if (callback) {
            callback(grid, name);
        } else {
            this._doRun(grid, name);
        }
    },
    _doRun: function(grid, name) {}
});
var MobileEditCommandView = defineClass("MobileEditCommandView", GridElement, {
    init: function(dom, model) {
        this._super(dom, 'mobileEditCommandView');
        this._model = model;
    },
    model: function() {
        return this._model;
    },
    _doRender: function(g, r) {
        var model = this._model,
			styles = model._styles,
			background = styles.background(),
			stroke = styles.line() || SolidPen.WHITE,
			fill = styles.figureBackground() || SolidBrush.WHITE,
          	renderer = model._renderer;
        g.drawRectI(background, stroke, r);
        if (renderer) {
            renderer(g, r, fill);
        }
    }
});
var MobileEditCommander = defineClass("MobileEditCommander", LayerElement, {
    init: function(owner, grid, commands) {
        this._super(grid._dom, 'mobileEditCommander');
        this._grid = grid;
        this._owner = owner;
        this._commands = [];
        this._views = {};
        commands && this.addCommands(commands);
    },
    destroy: function () {
    	this._grid = null;
    	this._owner = null;
    	this._commands = null;
    	this._views = null;
    },
    itemWidth: 30,
    itemHeight: 25,
    addCommands: function(source) {
        var len, i, command, obj;
        if (_isArray(source) && (len = source.length) > 0) {
            for (i = 0; i < len; i++) {
                command = source[i];
                if (command && command.name && (typeof command.callback == "function") && (typeof command.renderer == "function")) {
                    obj = new MobileEditCommand(this._grid,command);
                    this._commands.push(obj);
                }
            }
            this.updateElement();
        }
    },
    updateElement: function() {
        var i, command, view, width, height, totWidth, 
        	views = this._views, 
        	len = this._commands.length;
        this.setVisible(len > 0);
        if (this.isVisible()) {
            this.clear();
            width = this._itemWidth;
            height = this._itemHeight;
            totWidth = 0;
            for (i = 0; i < len; i++) {
                command = this._commands[i];
                view = views[command.$_hash];
                if (!view) {
                    view = new MobileEditCommandView(this._dom,command);
                    views[command.$_hash] = view;
                }
                this.addChild(view);
                view.setBounds(totWidth, 0, width, height);
                totWidth += width;
            }
            this.resize(totWidth, height);
        }
    }
});

var MobileEditController = defineClass("MobileEditController", DefaultEditController, {
	init: function (grid) {
		this._super(grid);
		this._grid = grid;
		this._editIndex = new CellIndex();
		this._editor = null;
        this._commander = new MobileEditCommander(this, grid,[{
            name: 'commit',
            callback: function(grid, o) {
                grid.commitEditor();
            },
            renderer: function(g, r, fill) {
            	$$_drawCheckMark(g,fill,r,17)
            },
            styles: {
                background: '#080'
            }
        }, {
            name: "cancel",
            callback: function(grid) {
                grid.cancelEditor();
            },
            renderer: function(g, r, fill) {
            	$$_drawCloseMark(g, fill, r, 19)
            },
            styles: {
                background: "#F00"
            }
        }]);		
	},
	_hideEditor: function () {
		if (this._editor) {
			try {
				this._editor.clear();
				this._editor.setVisible(false);
			} finally {
				var editor = this._editor;
				var activeElement = document.activeElement;
				this._editor.endEdit();
				this._editor = null;
                this._editable = false;
				// this.$_focusToEditor();  // mobile에서는 editor가 포커스를 가지면 가상키보드가 표시되는 현상 때문에 editor에 포커스를 주지 못한다.
				this._editorActivated(null);
				if (editor && editor._editor == activeElement) {
					this._grid._container._canvas.focus();
				}
			}
		}
	},

	_resetBounds: function () {
		this._super();
		this.$_setCommanderPostion(this._commander);
	},

	$_setCommanderPostion: function(commander) {
		var container = this._grid.container();
        var rect = this._grid.getEditCellBounds(this._editIndex);
        var width = commander.width();
        var height = commander.height();
        var left = rect.right() - width;
        var top = rect.y - height - 5;
        if (top < 0) {
            if (container.width() - width >= rect.right()) {
                left = Math.min(container.width() - width, rect.right() + 2);
                top = Math.max(0, rect.y - 2);
            } else if (rect.x >= width) {
                left = Math.max(0, rect.x - width - 2);
                top = Math.max(0, rect.y - 2);
            } else if (container.height() - height >= rect.bottom()) {
                top = Math.min(container.height() - height, rect.bottom() + 2);
            }
        }
        commander.setPosition(left, top);
	},
	_editorActivated: function(editor) {
        this._super(editor);
        var rect, width, height, left, top, 
        	container = this._grid.container(), 
        	commander = this._commander;
        if (editor && commander && this._grid.mobileOptions().isShowEditCommander()) {
        	commander._editIndex = editor._editIndex;
            commander.updateElement();
            this.$_setCommanderPostion(commander);
            container.addFeedback(commander);
        } else {
            container.removeFeedback(commander);
        }
        this._grid.invalidate();
		
	},
});
var MobileSelectionHandle = defineClass("MobileSelectionHandle", VisualElement, {
	init: function (selectionView, dir) {
		this._super(selectionView._dom, "mobileSelectionHandle");
		this._view = selectionView;
		this._dir = dir;
		//this._background = new SolidBrush(0xff333333);
		//this._border = new SolidPen(0xffdddddd, 1);
		this.setWidth(21);
		this.setHeight(21);
	},
	view: function () {
		return this._view;
	},
	dir: function () {
		return this._dir;
	},
	propertyChanged: function (/*prop, value*/) {
		this.invalidate();
	},
	_doDraw: function (g) {
		g.drawBounds(this._background, this._border, 5, 5, 11, 11);
	}
});
var MobileSelectionView = defineClass("MobileSelectionView", LayerElement, {
	init : function(dom) {
		this._super(dom, "mobileSelectionView");
		this._item = null;
		this._background = MobileSelectionView.$$_defBackground;
		this._border = MobileSelectionView.$$_defBorder;
		this.addElement(this._leftHandle = new MobileSelectionHandle(this, "left"));
		this.addElement(this._rightHandle = new MobileSelectionHandle(this, "right"));
		this.addElement(this._topHandle = new MobileSelectionHandle(this, "top"));
		this.addElement(this._bottomHandle = new MobileSelectionHandle(this, "bottom"));
	},
	background: null,
	border: null,
	item: function () {
		return this._item;
	},
	setBackground: function (value) {
		if (value !== this._background) {
			this._background = value;
			this.invalidate();
		}
	},
	setBorder: function (value) {
		if (value != this._border) {
			this._border = value;
			this.invalidate();
		}
	},
	setHandleBackground: function (value) {
		this._leftHandle._background = value;
		this._rightHandle._background = value;
		this._topHandle._background = value;
		this._bottomHandle._background = value;
	},
	setHandleBorder: function (value) {
		this._leftHandle._border = value;
		this._rightHandle._border = value;
		this._topHandle._border = value;
		this._bottomHandle._border = value;
	},
	updateElement: function (item, styles) {
		this._item = item;
		this.setBackground(styles.background());
		this.setBorder(styles.border());
		this.setHandleBackground(styles.figureBackground());
		this.setHandleBorder(styles.figureBorder());
		var cw = this.width();
		var ch = this.height();
		var w = this._leftHandle.width();
		var h = this._leftHandle.height();
		var x = (cw - w) / 2;
		var y = (ch - h) / 2;
		var st = item.style();
		var isBlock = st == SelectionStyle.BLOCK || st == SelectionStyle.SINGLE;
		this._leftHandle._context = this._context;
		this._rightHandle._context = this._context;
		this._topHandle._context = this._context;
		this._bottomHandle._context = this._context;
		this._leftHandle.setVisible(isBlock || SelectionStyle.isColumn(st));
		this._rightHandle.setVisible(this._leftHandle.isVisible());
		this._topHandle.setVisible(isBlock || SelectionStyle.isRow(st));
		this._bottomHandle.setVisible(this._topHandle.isVisible());
		this._leftHandle.isVisible() && this._leftHandle.move(-w / 2, y);
		this._rightHandle.isVisible() && this._rightHandle.move(cw - w / 2, y);
		this._topHandle.isVisible() && this._topHandle.move(x, -h / 2);
		this._bottomHandle.isVisible() && this._bottomHandle.move(x, ch - h / 2);
		this._leftHandle.invalidate();
		this._rightHandle.invalidate();
		this._topHandle.invalidate();
		this._bottomHandle.invalidate();
	},
	_doDraw: function (g) {
		var grid = this.container().gridView();
		var lm = grid.layoutManager();
		var r = lm.gridBounds();
		r = grid.translateBy(this, r);
		g.clipRectEx(r);
		g.drawBoundsI(this._background, this._border, 0, 0, this.width(), this.height());
	}
});
MobileSelectionView.$$_defBackground = new SolidBrush(0x10000000);
MobileSelectionView.$$_defBorder = new SolidPen(0xff333333, 2);
var TapDragTracker = defineClass("TapDragTracker", null, {
	init: function(grid, name) {
		this._super();
		this._grid = grid;
		this._name = name;
	},
	grid: function () {
		return this._grid;
	},
	name: function () {
		return this._name;
	},
	start: function(startX, startY, currX, currY) {
		return this._doStart(startX, startY, currX, currY);
	},
	stop : function() {

	},
	drag: function(startX, startY, currX, currY) {
		return this._doDrag(startX, startY, currX, currY);
	},
	drop: function (x, y) {
		this._doDrop(x, y);
	},
	cancel: function () {
		this._doCancel();
	},
	_doStart: function(startX, startY, currX, currY) {
		return true;
	},
	_doDrag: function(startX, startY, currX, currY) {
		return true;
	},
	_doDrop: function (x, y) {
	},
	_doCancel: function () {
	}
});
var MobileScrollTracker = defineClass("MobileScrollTracker", TapDragTracker, {
	init: function(grid) {
		this._super(grid, "mobileScrollTracker");
		this._tapX = this._tapY = NaN;
		this._vertical = true;
	},
	_doStart: function(startX, startY, currX, currY) {

		var dx = currX - startX;
		var dy = currY - startY;
		var grid = this._grid;
		/* */
		if (grid.isEditing()) {
			var scrollOnEditing = grid.mobileOptions()._scrollOnEditing;
			switch (scrollOnEditing) {
				case ScrollOnEditing.CANCEL :
					grid.cancelEditor(true);
					break;
				case ScrollOnEditing.COMMIT :
					grid.commitEditor(true);
					break;
				case ScrollOnEditing.DEFAULT :
				default :
					break;
			}
		}
		/* */

		this._vertical = Math.abs(dy) >= Math.abs(dx);
		if (this._vertical) {
			this._grid.setTopIndex(this._grid.topIndex() + (dy > 0 ? -1 : 1));
		} else {
			this._grid.setLeftPos(this._grid.leftPos() - dx);
		}
		this._tapX = currX;
		this._tapY = currY;
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var dx = currX - this._tapX;
		var dy = currY - this._tapY;
		var grid = this._grid;

		var vertical = Math.abs(dy) >= Math.abs(dx);
		if (vertical != this._vertical) {
			if (vertical && Math.abs(dy) > Math.abs(dx) * 2 || !vertical && Math.abs(dx) > Math.abs(dy) * 2) {
				this._vertical = vertical;
			}
		}
		if (this._vertical) {
			if (Math.abs(dy) > 5) {
				var topIndex = grid.topIndex();
				var fullItemCount = grid.layoutManager().fullItemCount();
				var itemCount = grid.itemCount();
				dy = dy > 0 ? -1 : 1
				if ((topIndex+fullItemCount >= itemCount && dy == 1) || (topIndex == 0 && dy == -1)) {
					return false;
				}
				grid.setTopIndex(grid.topIndex() + (dy));
				this._tapY = currY;
			}
		} else {
			grid.setLeftPos(grid.leftPos() - dx);
			this._tapX = currX;
		}
		return true;
	}
});
var MobileRowSelectTracker = defineClass("MobileRowSelectTracker", TapDragTracker, {
	init: function(grid, cell) {
		this._super(grid, "mobileRowSelectTracker");
		this._cell = cell;
		this._item = null;
	},
	_doStart: function(startX, startY, currX, currY) {
		var grid = this._grid;
		var selections = grid._selections;
		var index = this._cell.index();
		selections.clear();
		this._item = selections.add(index, index, SelectionStyle.ROWS);
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var grid = this._grid;
		var index = grid.pointToIndex(currX, currY, false);
		if (index.I() >= 0) {
			this._item.resizeTo(index);
		}
		return true;
	}
});
var MobileColumnSelectTracker = defineClass("MobileColumnSelectTracker", TapDragTracker, {
	init: function(grid, cell) {
		this._super(grid, "mobileColumnSelectTracker");
		this._cell = cell;
		this._item = null;
	},
	_doStart: function(startX, startY, currX, currY) {
		var grid = this._grid;
		var selections = grid._selections;
		var opts = grid.selectOptions();
		var index = this._cell.index();
		selections.clear();
		if ( opts.mode() === SelectionMode.SINGLE && ( opts.style === SelectionStyle.SINGLE_COLUMN || opts.style === SelectionStyle.COLUMNS ) ) {
			this._item = selections.add(index, index, SelectionStyle.COLUMNS);
		} else {
			this._item = null;
		}
		// this._item = selections.add(index, index, SelectionStyle.COLUMNS);
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var grid = this._grid;
		var index = grid.pointToIndex(currX, currY, false);
		if (grid.groupingOptions().isEnabled() && index.dataColumn() && index.dataColumn().isGroupable() && grid.panel().isVisible()) {
			//currY -= grid.y();
			if (currY < grid.layoutManager().headerBounds().y) {
        		var panelView = grid.panelView();
        		if (panelView) {
	        		panelView.setState(GridPanelElement.GROUPING);
		        	if (!grid.isGrouped(index.column())) {
						grid.addGroupBy(panelView.groupingIndex(), index.column());
					}
					panelView.setState(GridPanelElement.NORMAL);
					return false;
				}
			}
		}
		if (index.column() && this._item) {
			this._item.inflate(currX > prevX ? "right" : "left", index);
		}
		return true;
	}
});
var MobileSelectHandleTracker = defineClass("MobileSelectHandleTracker", TapDragTracker, {
	init: function(grid, handle) {
		this._super(grid, "mobileSelectHandleTracker");
		this._handle = handle;
	},
	_doStart: function(startX, startY, currX, currY) {
		return true;
	},
	_doDrag: function(prevX, prevY, currX, currY) {
		var grid = this._grid;
		var index = grid.pointToIndex(currX, currY, false);
		if (index.I() >= 0) {
			var item = this._handle.view().item();
			item.inflate(this._handle.dir(), index);
		}
		return true;
	}
});
var /* internal */ TabScrollThumbTracker = defineClass("TabScrollThumbTracker", null, {
	init: function (grid, thumbView) {
		this._super();
		this._grid = grid;
		this._thumb = thumbView;
	},
	start: function (x, y) {
		this._thumb.setPressed(true);
		var bar = this._thumb.scrollBar();
		var p = bar.containerToElement(x, y);
		if (bar.isVertical()) {
			this._offset = p.y - this._thumb.y();
		} else {
			this._offset = p.x - this._thumb.x();
		}
	},
	move: function (x, y) {
		this.$_doScroll(x, y, ScrollEventType.THUMB_TRACK);
	},
	stop: function (x, y) {
		this._thumb.setPressed(false);
		this.$_doScroll(x, y, ScrollEventType.THUMB_END);
	},
	$_doScroll: function (x, y, eventType) {
		var bar = this._thumb.scrollBar();
		var len = bar._maxPosition - bar._min + 1;
		var szBtn = bar._buttonSize;
		var p = bar.containerToElement(x, y);
		if (bar.isVertical()) {
			p.y -= this._offset;
			p.y = (p.y - szBtn) * len / (bar.height() - szBtn * 2 - this._thumb.height());
			bar._doScroll(eventType, 0, _int(p.y));
		} else {
			p.x -= this._offset;
			p.x = (p.x - szBtn) * len / (bar.width() - szBtn * 2 - this._thumb.width());
			bar._doScroll(eventType, 0, _int(p.x));
		}
	}
});
var /* internal */ MobileResizer = defineClass("MobileResizer", LayerElement, {
	init: function () {
		this._super("focusView");
		this._border = new SolidPen(0xff333333, 2);
		this._editBorder = new SolidPen(0xff000000 + (82 << 16) + (146 << 8) + 247, 2);
		this._editing = false;
	},
	setEditing: function (editing, buttonWidth) {
		if (editing != this._editing) {
			this._editing = editing;
			this._buttonWidth = buttonWidth;
			this.invalidate();
		}
	},
	_doDraw: function (g) {
		var w = this.width() - (this._editing ? this._buttonWidth : 0);
		g.drawBoundsI(null, this._editing ? this._editBorder : this._border, -1, -1, w - 1, this.height() - 1);
	}
});
var GridContainer = defineClass("GridContainer", VisualContainer, {
	init : function (dom, containerId, accessbility) {
		this._super(dom, containerId, accessbility);
        this._createBackgroundElements(this.$_dom);
		this._gridView = this._createGridView(this.$_dom, this, accessbility);
		this.addElement(this._gridView);
        this._prepareBorder();
        this._prepareLayers();
		this.setDefaultTool(this._createDefaultTool(), true);
	},
	destroy: function() {
		this._destroying = true;
		$$_activeGrid === this._gridView && ($_setActiveGrid(null));
		this._gridView = null;
		this._super();
	},
	gridView: function () {
		return this._gridView;
	},
	addFeedback: function (element) {
		this._feedbackView.addElement(element);
	},
	removeFeedback: function (element) {
		this._feedbackView.removeElement(element);
	},
	_createChildren: function (containerElement) {
	},
	_layoutChildren: function (bounds) {
        /*
         var r = bounds.clone();
         r.inflate(-1, -1);
		this._vscrollBar.setBounds(r.right() - 20, r.y, 20, r.height);
		this._hscrollBar.setVisible(false);
		*/
	},
	_beforeRender: function (bounds) {
		this._gridView._beforeRender(bounds);
	},
	_doLayout: function (bounds) {
		var r = bounds.clone();
		if (this._borderView) {
            var border = this._gridView._styles.border();
            var displayOptions = this._gridView.displayOptions();
			this._borderView.setVisible(border && border.width() > 0);
            if (this._borderView.isVisible()) {
                this._borderView._border = border;
                this._borderView.setRect(r);
                this._borderView.invalidate();
                this._borderView.setDrawBorderTop(displayOptions.isDrawBorderTop());
                this._borderView.setDrawBorderBottom(displayOptions.isDrawBorderBottom());
                this._borderView.setDrawBorderLeft(displayOptions.isDrawBorderLeft());
                this._borderView.setDrawBorderRight(displayOptions.isDrawBorderRight());
                // left top, right, bottom
                r.inflate(displayOptions.isDrawBorderLeft() ? -border.width() : 0, 
                		  displayOptions.isDrawBorderTop() ? -border.width() : 0, 
                		  displayOptions.isDrawBorderRight() ? -border.width() : 0, 
                		  displayOptions.isDrawBorderBottom() ? -border.width() : 0);
            }
		} else {
        }
		this._gridView.setRect(r);
		this._feedbackView.setRect(r);
		r.x = r.y = 0;
		this._gridView._doLayout(r);
	},
	_doDrawContainer: function (g, bounds) {
	},
	_focusHandler: function (event) {
		$_setActiveGrid(this._gridView);
		if (this._gridView._exiting) {
			delete this._gridView._exiting;
		} else {
			this._gridView._focusHandler(event);
		}
	},
    _createBackgroundElements: function () {
    },
	_createGridView: function (dom, container, accessbility) {
		return new GridView(dom, container, accessbility);
	},
    _prepareBorder: function () {
        if (this.$_rich) {
            this._borderView = new GridBorderElement(this.$_dom);
            this.addElement(this._borderView);
        } else {
            this._container.style.border = "1px solid #888";
        }
    },
    _prepareLayers: function () {
        this._feedbackView = new LayerElement(this.$_dom, "feedbackLayer");
        this.addElement(this._feedbackView);
    },
	_createDefaultTool: function () {
		if ($_mobileEnable) {
			return _isMobile() ? new MobileGridSelectionTool(this) : new GridViewSelectionTool(this);
		} else {
			return new GridViewSelectionTool(this);
		}
	}
});
var GridBorderElement = defineClass("GridBorderElement", LayerElement, {
	init: function (dom) {
		this._super(dom, "gridBorderView");
		this._border = new SolidPen(0xffaaaaaa);
		this.setMouseEnabled(false);
	},
	drawBorderTop: true,
	drawBorderBottom: true,
	drawBorderLeft: true,
	drawBorderRight: true,
	_doDraw: function (g) {
		var w = this._border.width();
		var p = _int(w / 2);
		if (this._drawBorderTop && this._drawBorderBottom && this._drawBorderLeft && this._drawBorderRight) {
			g.drawBoundsI(null, this._border, p, p, this.width() - w, this.height() - w);
		} else {
			this._drawBorderTop && g.drawHorzLineI(this._border, 0, this.width(), p);
			this._drawBorderBottom && g.drawHorzLineI(this._border, 0, this.width(), this.height() - p);
			this._drawBorderLeft && g.drawVertLineI(this._border, 0, this.height(), p);
			this._drawBorderRight && g.drawVertLineI(this._border, 0, this.height(), this.width() - p);
		}
	}
});
var _wmv_ = function (dom) {
	var img = new _egam_();
	img.src = "data:image/png;base64," + _wm_;
	var view = new LayerElement(dom);
	view._doDraw = function (g) {
		g.aL(img, (this.width() - img.width) / 2, (this.height() - img.height) / 2, img.width, img.height);
	};
	return view;
};
var $_INVISIBLE_EDIT_BOUNDS = new Rectangle(-10000, -10000, 100, 100);
var GridBase = defineClass("GridBase", LayerElement, {
	init: function (dom, container, accessbility) {
		this._super(dom, "gridView");
		this._container = container;
		this._accessbility = accessbility;
		this._shadowDom = container._shadowDom;
		this._offsetX = 0;
		this._offsetY = 0;
		if (container.$_rich) {
			this._context = container._context;
			this._toolContext = new CanvasContext("toolContext", container);
			container.addContext(this._toolContext);
		}
		this._loading = true;
        this._userMode = false;
        this._userModeError = null;
		this._gridObjects = [];
		this._addGridObject(this._panel = this._createPanelModel());
		this._addGridObject(this._header = new Header(this));
		this._addGridObject(this._editBar = new EditBar(this));
		this._addGridObject(this._footer = this._createFooterModel());
		this._addGridObject(this._indicator = new Indicator(this));
		this._addGridObject(this._stateBar = new StateBar(this));
		this._addGridObject(this._checkBar = new CheckBar(this));
		this._addGridObject(this._body = new GridBody(this));
		this._addGridObject(this._rowGroup = new RowGroup(this));
		var view = this._rootElement = new LayerElement(dom, "grid root view");
		this.addChild(view);
		view = this._emptyView = this._createEmptyView(dom);
		view.setVisible(false);
		this.addChild(view);
		view = this._debugView = new GridDebugElement(dom, this);
		this.addChild(view);
		this._panelView = this._createPanelView(dom, this._panel);
		this._bodyView = this._createBodyView(dom, this._body, false);
		this._fixedBodyView = this._createBodyView(dom, this._body, true);
		this._rfixedBodyView = this._createBodyView(dom, this._body, true, true);
		this._mergeView = new GridMergeElement(dom);
		this._fixedMergeView = new GridMergeElement(dom, true);
		this._rfixedMergeView = new GridMergeElement(dom, true, true);
		this._mergeHeaderLayer = new GridMergeHeaderElement(dom);
		this._headerView = new HeaderElement(dom, this._header);
		this._fixedHeaderView = new HeaderElement(dom, this._header, true);
		this._rfixedHeaderView = new HeaderElement(dom, this._header, true, true);
        this._summaryView = new HeaderSummaryElement(dom, this._header.summary());
        this._fixedSummaryView = new HeaderSummaryElement(dom, this._header.summary(), true);
        this._rfixedSummaryView = new HeaderSummaryElement(dom, this._header.summary(), true, true);
		this._indicatorView = new IndicatorElement(dom, this._indicator);
		this._stateBarView = new StateBarElement(dom, this._stateBar);
		this._checkBarView = new CheckBarElement(dom, this._checkBar);
		this._footerView = this._createFooterView(dom, this._footer);
		this._fixedFooterView = new FooterElement(dom, this._footer, true);
		this._rfixedFooterView = new FooterElement(dom, this._footer, true, true);
		this._rowGroupView = new RowGroupElement(dom, this._rowGroup);
		this._indicatorHeadView = new IndicatorHeadElement(dom);
		this._stateBarHeadView = new StateBarHeadElement(dom);
		this._checkBarHeadView = new CheckBarHeadElement(dom);
		this._indicatorFootView = new IndicatorFootElement(dom);
		this._stateBarFootView = new StateBarFootElement(dom);
		this._checkBarFootView = new CheckBarFootElement(dom);
        this._indicatorSummaryView = new IndicatorSummaryElement(dom);
        this._stateBarSummaryView = new StateBarSummaryElement(dom);
        this._checkBarSummaryView = new CheckBarSummaryElement(dom);
		if (this._panelView) {
			this.addElement(this._panelView);
		}
		this.addElement(this._bodyView);
		this.addElement(this._mergeView);
		this.addElement(this._fixedBodyView);
		this.addElement(this._rfixedBodyView);
		this.addElement(this._fixedMergeView);
		this.addElement(this._rfixedMergeView);
		this.addElement(this._mergeHeaderLayer);
		this.addElement(this._headerView);
		this.addElement(this._fixedHeaderView);
        this.addElement(this._rfixedHeaderView);
        this.addElement(this._summaryView);
        this.addElement(this._fixedSummaryView);
		this.addElement(this._rfixedSummaryView);
		this._addGroupView();
		this.addElement(this._indicatorView);
		this.addElement(this._stateBarView);
		this.addElement(this._checkBarView);
		this.addElement(this._footerView);
		this.addElement(this._fixedFooterView);
		this.addElement(this._rfixedFooterView);
		this.addElement(this._indicatorHeadView);
		this.addElement(this._stateBarHeadView);
		this.addElement(this._checkBarHeadView);
		this.addElement(this._indicatorFootView);
		this.addElement(this._stateBarFootView);
		this.addElement(this._checkBarFootView);
        this.addElement(this._indicatorSummaryView);
        this.addElement(this._stateBarSummaryView);
        this.addElement(this._checkBarSummaryView);
		this._linesLayer = new GridLinesElement(dom, this);
		this.addElement(this._linesLayer);
		this._selectionLayer = new LayerElement(dom, "selectionLayer");
		this.addElement(this._selectionLayer);
		this._focusLayer = new LayerElement(dom, "focusLayer");
		this.addElement(this._focusLayer);
		this._rowFocusLayer = new LayerElement(dom, "rowFocusLayer");
		this.addElement(this._rowFocusLayer);
		this._scrollLayer = new LayerElement(dom, "scrollLayer");
		this.addElement(this._scrollLayer);
		this._hscrollBar = null;
		this._vscrollBar = null;
		this._scrollCorner = null;
		this._scrolledTime = 0;
		this._feedbackLayer = new LayerElement(dom, "feedbackLayer");
		this.addElement(this._feedbackLayer);
		/*$addWatermark$*/
		this._rootColumn = new RootColumn(this);
		this._dataRoots = new DataRootCollection();
		this._columnLayouts = new ColumnLayoutCollection();
		this._columnLayout = null;
		this._orgColumns = [];
		this._orgColumned = true;
		this._columnLayoutChanged = false;
		this._columnsLock = false;
		this._columnWidthsDirty = false;
		this._columnsDirty = false;
		this._itemProvider = null;
		this._lookupProvider = null;
		this._delegate = this._createDelegate();
        this._eventHandler = this._delegate.createGridEventHandler();
        this._eventHandler && this.addListener(this._eventHandler);
		this._layoutManager = this._createLayoutManager();
		this._heightMeasurer = null;
		this._toolTipManager = new ToolTipManager(this);
		this._clipboardManager = new ClipboardManager(this);
		this._progressManager = new ProgressManager(this._container._container);
		this._indicatorFootView.setRenderer(this._delegate.getFooterHeadRenderer());
        this._indicatorSummaryView.setRenderer(this._delegate.getRowHeaderSummaryRenderer());
		this._selections = new SelectionManager(this);
		this._selections.addListener(this);
		this._selectionViews = new Dictionary();
		this._editOptions = new EditOptions(this);
		this._editorOptions = new EditorOptions(this);
		this._editController = this._createEditController();
		this._validations = new EditValidationCollection();
		this._validationManager = new ValidationManager(this);
		this._columnSummaryRuntime = new ColumnSummaryRuntime();
		this._rowGroupSummaryRuntime = new RowGroupSummaryRuntime();
		this._columnValidationRuntime = new DataCellValidationRuntime();
		this._rowValidationRuntime = new DataRowValidationRuntime();
		this._displayOptions = new DisplayOptions(this);
		this._copyOptions = new CopyOptions();
		this._pasteOptions = new PasteOptions();
		this._fixedOptions = new FixedOptions(this);
		this._selectOptions = new SelectOptions(this);
		this._sortingOptions = new SortingOptions(this);
		this._filteringOptions = new FilteringOptions(this);
		this._groupingOptions = new GroupingOptions(this);
		this._columnHeaderOptions = new ColumnHeaderOptions(this);
		this._mobileOptions = new MobileOptions(this);
		this._styles = new VisualStyles(this, "grid");
		this._stylesDirty = false;
		this.initStyles();
		this._dataCellStyles = new DataCellStyleCollection(this);
		this._styleMap = null;
		this._resetting = false;
		this._layouted = false;
		this._focusing = false;
		this._focusedIndex = new CellIndex();
		this._shadowIndex = new CellIndex();
		this._currentRow = -1;
		this._currentRowId = -1;
		this._vertScroll = 0;
		this._horzScroll = 0;
		this._imageLists = {};
		this._delegate.prepareResources();
		this._filterSelector = new ColumnFilterSelector(this._container._container);
		this._toastManager = new ToastManager(this);
		this._popupMenuManager = new PopupMenuManager(this.container()).addListener(this);
        this._contextMenu = null;
		this._dataCellRenderers = new DataCellRendererCollection(this._delegate);
		this._groupFooterMergeManager = new RowGroupFooterMergeManager();
		this._footerMergeManager = new FooterMergeManager();
		this._headerSummaryMergeManager = new FooterMergeManager();

		this._horzScrolling = false;
		this._scrollTipView = null;

		this._topIndex = 0;
		this._dataChanged = false;
		this._cellUpdateEventLock = false;
		this._updateLock = false;
		this._rowChangeTimer = undefined;
		this._rowChangeTimerCallback = function () {
			this.$_checkCurrentRow(true);
		}.bind(this);
        this.$_fixedColCount = this.$_fixedRowCount = 0;
        this.$_fixedColEditable = this.$_fixedRowEditable = true;
        this.$_editOptionsWritable = false;
        this._tmpIndex = new CellIndex(this);
        this._productName = "RealGridJS v1.0";
	},
	destroy: function() {
		this._destroying = true;
		this.closePopups();
		for (var attr in this) {
			if ( this.hasOwnProperty(attr) && 
				(this[attr] instanceof VisualObject || 
				 this[attr] instanceof CellElement ||
				 this[attr] instanceof GridElement ||
				 this[attr] instanceof GridBaseOptions ||
				 this[attr] instanceof ColumnFilterSelector )) {
				this[attr] = null;
			}
		};
		this._selectionViews = null;
		this._rowChangeTimerCallback = null;
		this._delegate && !this._delegate._destroying && this._delegate.destroy && this._delegate.destroy();
		this._delegate = null;
		this._debugView = null;
		this._footerView = null;
		this._selections = null;
		this._rowGroupView = null;
		this._summaryView = null;
		this._styles = null;
		this._dataCellRenderers = null;
        this._productName = null;
        this._imageLists = null;
        this._dataCellStyles = null;
		this._hscrollBar = null;
		this._vscrollBar = null;
		this._scrollCorner = null;
		this._prevLast = null;
		this._topIndex = null;
		this._prevTopIndex = null;
		this._leftPos = null;
		this._editController = null;
		this._shadowDom = null;
		this._heightMeasurer = null;
		CellIndex.$_temp._grid = null;
		CellIndex.$_temp._column = null;
		CellIndex.$_temp._itemIndex = null;
		this._scrollTipView = this._scrollTipView && this._scrollTipView.destroy();
		this._super();
	},
	/*
	$_initialize: function (container, offsetX, offsetY) {
		this._container = container;
		this._offsetX = offsetX;
		this._offsetY = offsetY;
	},
	*/
	stylesChanged: function (entry) {
		if (!this._stylesDirty) {
			this._stylesDirty = true;
			this.refreshView();
		}
	},
	dataCellStyleAdded: function (id, needUpdate) {
		if (needUpdate) {
			this.invalidateLayout();
		}
	},
	dataCellStyleChanged: function (id, needUpdate) {
		if (needUpdate) {
			this.invalidateLayout();
		}
	},
	dataCellStyleRemoved: function (id, style, needUpdate) {
		this.itemSource().removeCellStyle(style);
		if (needUpdate) {
			this.invalidateLayout();
		}
	},
	dataCellStylesCleared: function (needUpdate) {
		this.itemSource().clearCellStyles();
		if (needUpdate) {
			this.invalidateLayout();
		}
	},
	scrollBarWidth: 16,
    scrollBarHeight: 16,
    scrollThumbRadius: 0,
	body: null,
	panel: null,
	header: null,
	editBar: null,
	footer: null,
	indicator: null,
	checkBar: null,
	stateBar: null,
	rowGroup: null,
	columnHeaderOptions: null,
	displayOptions: null,
	editOptions: null,
	editorOptions: null,
	copyOptions: null,
	pasteOptions: null,
	fixedOptions: null,
	selectOptions: null,
	sortingOptions: null,
	filteringOptions: null,
	groupingOptions: null,
	mobileOptions: null,
	styles: null,
	topIndex: 0,
	leftPos: 0,
	summaryMode: SummaryMode.AGGREGATE,
	validations: null,
    sortMode: SortMode.AUTO,
    filterMode: FilterMode.AUTO,
    userMode: false,
    userModeError: null,
    changingMode: ChangingMode.NORMAL,
    backgroundImage: null,
    keepNullFocus: false,
    setUserMode: function (value) {
        this._userMode = value;
    },
    setUserModeError: function (value) {
        this._userModeError = value;
    },
	isAccessbility: function () {
		return this._accessbility;
	},
	setStyles: function (value) {
		if (value !== this._styles) {
			this._styles.extend(value);
		}
	},
	setScrollBarWidth: function (value) {
		value = Math.max(4, value);
		if (value != this._scrollBarWidth) {
			this._scrollBarWidth = value;
			this.refreshView();
		}
	},
    setScrollBarHeight: function (value) {
        value = Math.max(4, value);
        if (value != this._scrollBarHeight) {
            this._scrollBarHeight = value;
            this.refreshView();
        }
    },
    setScrollThumbRadius: function(value) {
    	value = Math.max(0, value);
    	if (value != this._scrollThumbRadius) {
    		this._scrollThumbRadius = value;
    		this.refreshView();
    	}
    },
    setChangingMode: function(value) {
    	if (value != this._changingMode) {
    		switch(value) {
    			case ChangingMode.BEFORE_EDITCOMMIT :
    				break;
    			default :
    				value = ChangingMode.NORMAL;
    		}
    		this._changingMode = value;
    	}
    },
    setPageSorting: function (value) {
    },
    setBackgroundImage: function(value) {
    	if (value) {
    		if (this._backgroundImageElement) {
    			this.removeFeedbackElement(this._backgroundImageElement);
    			this._backgroundImageElement.destroy();
    			this._backgroundImageElement = null;
    		}
    		var img = new _egam_();
    		var options = typeof value === "object" ? value : {imageUrl:value};
    		if (!options.imageUrl) {
    			return;
    		}
    		img.src = options.imageUrl;
    		var view = this._backgroundImageElement =  new LayerElement(this.$_dom, "backgroundImageLayer");
    		view._grid = this;
    		view._imageLocation = options.location || BackgroundImageLocation.CENTER;
    		view._paddingTop = options.padding || options.paddingTop || 0;
    		view._paddingBottom = options.padding || options.paddingBottom || 0;
    		view._paddingLeft = options.padding || options.paddingLeft || 0;
    		view._paddingRight = options.padding || options.paddingRight || 0;
    		view._alpha = options.alpha == null || isNaN(parseFloat(options.alpha)) ? 0.4 : parseFloat(options.alpha);
    		view._base = options.base || "grid";
    		view._doDraw = function(g) {
    			var x, y;  // leftTop;
    			var padding = this._padding;
    			var grid = this._grid;
    			var br = view._base == "grid" ? grid.getBounds() : grid._layoutManager.gridBounds();
    			switch(this._imageLocation) {
				    case BackgroundImageLocation.LEFT:
				    	x = br.x + this._paddingLeft;
				    	y = br.y + (br.height - img.height) / 2;
				    	break;
				    case BackgroundImageLocation.RIGHT:
				    	x = br.right() - img.width - this._paddingRight;
				    	y = br.y + (br.height - img.height) / 2;
				    	break;
				    case BackgroundImageLocation.TOP:
				    	x = br.x + (br.width - img.width) / 2;
				    	y = br.y + this._paddingTop;
				    	break;
				    case BackgroundImageLocation.BOTTOM:
				    	x = br.x + (br.width - img.width) / 2;
				 		y = br.bottom() - img.height - this._paddingBottom;
				    	break;
				    case BackgroundImageLocation.LEFT_TOP:
				    	x = br.x + this._paddingLeft;
				    	y = br.y + this._paddingTop;
				    	break;
				    case BackgroundImageLocation.LEFT_BOTTOM:
				    	x = br.x + this._paddingLeft;
				    	y = br.bottom() - img.height - this._paddingBottom;
				    	break;
				    case BackgroundImageLocation.RIGHT_TOP:
				    	x = br.right() - img.width - this._paddingRight;
				    	y = br.y + this._paddingTop;
				    	break;
				    case BackgroundImageLocation.RIGHT_BOTTOM:
				    	x = br.right() - img.width - this._paddingRight;
				    	y = br.bottom() - img.height - this._paddingBottom;
				    	break;
				    case BackgroundImageLocation.CENTER:
				    	x = br.x + (br.width - img.width) / 2;
				    	y = br.y + (br.height - img.height) / 2;
				    	break;
    			}
    			g.save();
    			try {
    				g.setAlpha(this._alpah);
    				g.aL(img, x, y, img.width, img.height);		
    			} finally {
    				g.restore();
    			}
    		}
    		this.addFeedbackElement(this._backgroundImageElement);
    	} else {
    		this.removeFeedbackElement(this._backgroundImageElement);
    	};
    	this.invalidate();
    },
	dataCellRenderers: function () {
		return this._dataCellRenderers;
	},
	getItemSource: function () {
		return this._itemProvider;
	},
	itemSource: function () {
		return this._itemProvider;
	},
	setItemSource: function (value) {
		if (this._itemProvider) {
			this._itemProvider.removeListener(this);
		}
		this._itemProvider = value;
		if (this._itemProvider) {
			this._itemProvider.addListener(this);
		}
	},
	dataSource: function () {
		return this._itemProvider ? this._itemProvider.dataSource() : null;
	},
	setDataSource: function (value) {
        var oldDs = this.dataSource();
        if (this._itemProvider) {
            this._itemProvider.setDataSource(value);
        }
        if (this.dataSource() !== oldDs) {
            this.dataSource() && this.applyFilters();
        }
	},
    maxItemCount: function () {
        return 0;
    },
    setMaxItemCount: function (value) {
    },
	activeTool: function () {
		return this.container().activeTool(); 
	},
	toolTipManager: function () {
		return this._toolTipManager;
	},
	validationManager: function () {
		return this._validationManager;
	},
	footerMergeManager: function () {
		return this._footerMergeManager;
	},
	headerSummaryMergeManager: function () {
		return this._headerSummaryMergeManager;
	},
	groupFooterMergeManager: function () {
		return this._groupFooterMergeManager;
	},
	setValidations: function (value) {
		this._validations.assign(value);
	},
	editController: function () {
		return this._editController;
	},
	dataCellStyles: function () {
		return this._dataCellStyles;
	},
	setBody: function (value) {
		this._body.assign(value);
	},
	setPanel: function (value) {
		if (this instanceof TreeView) return;
		this._panel && this._panel.assign(value);
	},
	setIndicator: function (value) {
		this._indicator.assign(value);
	},
	setStateBar: function (value) {
		this._stateBar.assign(value);
	},
	setCheckBar: function (value) {
		this._checkBar.assign(value);
	},
	setEditBar: function (value) {
		this._editBar.assign(value);
	},
	setHeader: function (value) {
		this._header.assign(value);
	},
	setFooter: function (value) {
		this._footer.assign(value);
	},
	setRowGroup: function (value) {
		this._rowGroup.assign(value);
	},
	panelView: function () {
		return this._panelView;
	},
	mergeView: function () {
		return this._mergeView;
	},
	fixedMergeView: function () {
		return this._fixedMergeView;
	},
	rfixedMergeView: function () {
		return this._rfixedMergeView;
	},
	mergeHeaderView: function () {
		return this._mergeHeaderLayer;
	},
	indicatorView: function () {
		return this._indicatorView;
	},
	stateBarView: function () {
		return this._stateBarView;
	},
	checkBarView: function () {
		return this._checkBarView;
	},
	headerView: function () {
		return this._headerView;
	},
	fixedHeaderView: function () {
		return this._fixedHeaderView;
	},
	rfixedHeaderView: function () {
		return this._rfixedHeaderView;
	},
    summaryView: function () {
        return this._summaryView;
    },
    fixedSummaryView: function () {
        return this._fixedSummaryView;
    },
	rfixedSummaryView: function () {
        return this._rfixedSummaryView;
    },
	footerView: function () {
		return this._footerView;
	},
	fixedFooterView: function () {
		return this._fixedFooterView;
	},
	rfixedFooterView: function () {
		return this._rfixedFooterView;
	},
	rowGroupView: function () {
		return this._rowGroupView;
	},
    summaryHeadView: function () {
        return this._summaryHeadView;
    },
	indicatorHeadView: function () {
		return this._indicatorHeadView;
	},
	indicatorFootView: function () {
		return this._indicatorFootView;
	},
    indicatorSummaryView: function () {
        return this._indicatorSummaryView;
    },
	stateBarHeadView: function () {
		return this._stateBarHeadView;
	},
	stateBarFootView: function () {
		return this._stateBarFootView;
	},
    stateBarSummaryView: function () {
        return this._stateBarSummaryView;
    },
	checkBarHeadView: function () {
		return this._checkBarHeadView;
	},
	checkBarFootView: function () {
		return this._checkBarFootView;
	},
    checkBarSummaryView: function () {
        return this._checkBarSummaryView;
    },
	bodyView: function () {
		return this._bodyView;
	},
	fixedBodyView: function () {
		return this._fixedBodyView;
	},
	rfixedBodyView: function () {
		return this._rfixedBodyView;
	},
	delegate: function () {
		return this._delegate;
	},
	layoutManager: function () {
		return this._layoutManager;
	},
	popupMenuManager: function () {
		return this._popupMenuManager;
	},
	selections: function () {
		return this._selections;
	},
	columnSummaryRuntime: function () {
		return this._columnSummaryRuntime;
	},
	rowGroupSummaryRuntime: function () {
		return this._rowGroupSummaryRuntime;
	},
	columnValidationRuntime: function () {
		return this._columnValidationRuntime;
	},
	rowValidationRuntime: function () {
		return this._rowValidationRuntime;
	},
	setDisplayOptions: function (value) {
		this._displayOptions.assign(value);
	},
	setSelectOptions: function (value) {
		this._selectOptions.assign(value);
	},
	setEditOptions: function (value) {
		this._editOptions.assign(value);
	},
	setEditorOptions: function (value) {
		this._editorOptions.assign(value);
	},
	setCopyOptions: function (value) {
		this._copyOptions.assign(value);
	},
	setPasteOptions: function (value) {
		this._pasteOptions.assign(value);
	},
	setFixedOptions: function (value) {
		this._fixedOptions.assign(value);
	},
	setSortingOptions: function (value) {
		this._sortingOptions.assign(value);
		if (value && value.handleImages) 
			this._sortingOptions.handleImages().loadImages(this._container);
	},
	setFilteringOptions: function (value) {
		this._filteringOptions.assign(value);
		if (value && value.handleImages) 
			this._sortingOptions.handleImages().loadImages(this._container);
	},
	setGroupingOptions: function (value) {
		this._groupingOptions.assign(value);
	},
	setColumnHeaderOptions: function (value) {
		this._columnHeaderOptions.assign(value);
		if (value && value.checkImages) 
			this._columnHeaderOptions.checkImages().loadImages(this._container);
	},
	setMobileOptions: function(value) {
		this._mobileOptions.assign(value);
	},
	setSummaryMode: function (value) {
		if (value != this._summaryMode) {
			this._summaryMode = value;
			this.$_summaryModeChanged();
		}
	},
	heightMeasurer: function () {
		return this._heightMeasurer || SimpleHeightsMeasurer.Default;
	},
	setHeightMeasurer: function (value) {
		this._heightMeasurer = value;
	},
	setTopIndex: function (value, isFiltering) {
		value = Math.max(0, Math.min(parseInt(value), this.itemCount() - this._layoutManager._fixedRows - 1, this._vscrollBar ? this._vscrollBar.maxPosition() : 0));
		if (value != this._topIndex) {
			this._topIndex = value;
			this.refreshView();
			!isFiltering ? this.closePopups() : this.closePopups2();
		}
	},
	topItem: function () {
		return this._topIndex + this.layoutManager().fixedItemCount();
	},
	getTopItem: function() {
		var cnt = this._items.itemCount();
		var fixedCnt = this.layoutManager().fixedItemCount();
		if (cnt <= fixedCnt || cnt <= 0) {
			return -1;
		}
		return this.topItem();
	},
	setTopItem: function (value) {
		this.setTopIndex(value - this.layoutManager().fixedItemCount());
	},
	setLeftPos: function (value, checkScorll) {
		value = isNaN(parseInt(value)) ? this.leftPos() : parseInt(value);
		value = Math.max(0, Math.min(value, this._hscrollBar ? this._hscrollBar.maxPosition() : 0));
		if (value != this._leftPos) {
			this._leftPos = value;
			this._horzScrolling = !!checkScorll;
			this.refreshView();
			this.closePopups();
		}
	},
	leftCol: function () {
		var lm = this._layoutManager;
		return lm ? lm.firstCol() : 0;
	},
	setLeftCol: function (value) {
		var lm = this._layoutManager;
		if (lm) {
			value = Math.max(lm.fixedColCount(), Math.min(value, lm.columnCount() - 1));
			this.setLeftPos(lm.columnBounds(value).x);
		}
	},
	setRightCol: function (value) {
	    var lm = this._layoutManager;
	    if (lm) {
	        var colPos = Math.min(lm.columnCount() - 1, Math.max(0, (lm.columnCount() - value - 1)));
	        var barLength = this._hscrollBar._max - this._hscrollBar.maxPosition()
	        var x = Math.min(this._hscrollBar.maxPosition(), lm.columnBounds(colPos).x + lm._columns[colPos]._width - barLength);           
            x = Math.max(x, 0);
            
	        this.setLeftPos(x);
	    }
	},
	isEmpty: function () {
		return this.itemCount() == 0 || this.visibleColumnCount() == 0;
	},
	lookupProvider: function () {
		return this._lookupProvider;
	},
	setLookupProvider: function (value) {
		if (value != this._lookupProvider) {
			if (this._lookupProvider) {
				this._lookupProvider.removeListener(this);
			}
			if (value && !(value instanceof LookupSourceProvider)) {
				value = new LocalLookupSourceProvider(value);
			}
			this._lookupProvider = value;
			if (this._lookupProvider) {
				this._lookupProvider.addListener(this);
			}
			this.refreshView();
		}
	},
	getHeaderLevel: function () {
		return this._rootColumn.headerLevel();
	},
	getDataLevel: function () {
		return this._rootColumn.dataLevel();
	},
	itemCount: function () {
		return this._itemProvider ? this._itemProvider.itemCount() : 0;
	},
	rowCount: function () {
		var ds = this.dataSource();
		return ds ? ds.rowCount() : 0;
	},
	getColumn: function (index) {
		return this._rootColumn.getItem(index);
	},
	columns: function () {
		return this._rootColumn.columns();
	},
	getOrderedColumns: function () {
		return this._rootColumn.getOrderedColumns();
	},
	setColumns: function (value) {
		this._checkEditing();
		this._columnsLock = true;
		try {
			this._rootColumn.setColumns(value);
			this._orgColumns = this._rootColumn.columns();
			this._orgColumned = true;
			this._columnLayoutChanged = true;
		} finally {
			this._columnsLock = false;
			this._columnsReset(this._rootColumn);
            this.dataSource() && this.applyFilters();
		}
	},
	addColumn: function (column, group, index) {
		var col;
		this._checkEditing();
		try {
			group && (group = typeof group === "string" ? this.columnByName(group) : typeof group === "object" ? this.columnByName(group.name) : group);
			group = group || this._rootColumn;
			if (group instanceof ColumnGroup) {
				col = group.add(column, index);
				return col;
			}
		} finally {
			col && this.dataSource() && this.applyFilters();
		}
	},
	removeColumn: function(column, group) {
		var ret = false;
		this._checkEditing();
		try {
			column && (column = typeof column === "string" ? this.columnByName(column) : typeof column === "object" ? this.columnByName(column.name) : column);
			group && (group = typeof group === "string" ? this.columnByName(group) : typeof group === "object" ? this.columnByName(group.name) : group);
			group = group || this._rootColumn;
			if (group instanceof ColumnGroup && column) {
				ret = group.remove(column); 
			}
			return ret;

		} finally {
            ret && this.dataSource() && this.applyFilters();
		}
	},
	collectColumns: function (columnsOnly, visibleOnly, ordered) {
		var columns = [];
		this._rootColumn.collectColumns(columns, columnsOnly, visibleOnly, ordered);
		return columns;
	},
	collectGroups: function () {
		var groups = [];
		this._rootColumn.collectGroups(groups);
		return groups;
	},
	getColumnNames: function (columnsOnly, visibleOnly, ordered) {
		return this._rootColumn.collectColumnNames([], columnsOnly, visibleOnly, ordered);
	},
	columnByHash: function (hash) {
		return this._rootColumn._columnMap[hash];
	},
	columnByName: function (name) {
		return this._rootColumn.columnByName(name);
	},
	/* @internal */ layoutColumnByName: function (name) {
		for (var i = 0, cnt = this._orgColumns.length; i < cnt; i++) {
			var c = this._orgColumns[i];
			if (c instanceof ColumnGroup) {
				c = c.valueColumnByName(name);
				if (c) {
					return c;
				}
			} else if (c.name() == name) {
				return c;
			}
		}
		return this._rootColumn.valueColumnByName(name);
	},
	columnByField: function (fieldIndex) {
		return this._rootColumn.columnByField(fieldIndex);
	},
	columnByFieldName: function (fieldName) {
		return this._rootColumn.columnByFieldName(fieldName);
	},
	columnsByFieldName: function (fieldName) {
		var columns = [];
		this._rootColumn.collectColumnsByFieldName(fieldName, columns);
		return columns.length > 0 ? columns : null;
	},
	columnByTag: function (tag) {
		return this._rootColumn.columnByTag(tag);
	},
	columnsByTag: function (tag) {
		var columns = [];
		this._rootColumn.collectColumnsByTag(tag, columns);
		return columns.length > 0 ? columns : null;
	},
	getDataColumn: function (dataIndex) {
		var i, 
			column,	// DataColumn
			group,	// ColumnGroup
			cnt = this._rootColumn.count();
		for (i = 0; i < cnt; i++) {
			column = _cast(this._rootColumn.getItem(i), DataColumn); 
			if (column) {
				if (column.dataIndex() == dataIndex) {
					return column;
				}
			} else {
				group = _cast(this._rootColumn.getItem(i), ColumnGroup);
				if (group) {
					column = group.getDataColumn(dataIndex);
					if (column) {
						return column;
					}
				}
			}
		}
		return null;
	},
	columnLayouts: function () {
		return this._columnLayouts.items();
	},
	setColumnLayouts: function (value) {
		if (value != this._columnLayouts) {
			this._columnLayouts.clear();
			this._columnLayouts.load(value);
		}
	},
	columnLayout: function () {
		return this._columnLayout;
	},
	setColumnLayout: function (value) {
		this._checkEditing();
		var layout = _cast(value, ColumnLayout);
		if (!layout) {
			if (typeof value == "string") {
				layout = this._columnLayouts.find(value);
			} else {
				layout = ColumnLayout.create(value);
			}
		}
		if (layout != this._columnLayout) {
			this._columnLayout = layout;
			if (layout) {
				this._columnsLock = true;
				try {
					if (this._orgColumned) {
						this._saveOrgWidths();
						this._orgColumned = false;
					}
					this._rootColumn.setColumns(layout.build(this));
					this._columnLayoutChanged = true;
				} finally {
					this._columnsLock = false;
					this._columnsRestore();
					this._rootColumn._clearSavedWidths();
				}
			} else {
				this.restoreColumns(true);
			}
		}
	},
	restoreColumns: function (restoreSize) {
		this._checkEditing();
		this._columnsLock = true;
		try {
			if (restoreSize) {
				this._restoreOrgWidths();
			}
			this._rootColumn.setColumns(this._orgColumns);
			this._orgColumned = true;
			this._columnLayout = null;
			this._columnLayoutChanged = true;
		} finally {
			this._columnsLock = false;
			this._columnsRestore();
		}
	},
	_doColumnsReset: function (group) {
	},
	_columnsReset: function (group) {
		if (!this._columnsLock) {
			this._rootColumn.initVisibles();
			this._resetColumnIndicies();
			for (var i = 0, cnt = this._rootColumn.count(); i < cnt; i++) {
				var column = this._rootColumn.getItem(i);
				if (column instanceof ColumnGroup) {
					column.initGroupWidths();
				}
			}
			this._columnWidthsDirty = true;
			this._columnsDirty = true;
			this.resetGrid();
			this._doColumnsReset(group);
			this._resetFooterMerge();
			this._resetHeaderSummaryMerge();
			this._shadowDom && this._shadowDom.setColumns(this, this.getLeafColumns());
		}
	},
	_columnsRestore: function (group) {
		if (!this._columnsLock) {
			this._rootColumn.initVisibles();
			this._resetColumnIndicies();
			var i, column,
				cnt = this._rootColumn.count();
			for (i = 0; i < cnt; i++) {
				column = this._rootColumn.getItem(i);
				if (!isNaN(column._saveWidth)) {
					column._width = column._displayWidth = column._groupWidth = column._saveWidth;
				}
				if (column instanceof ColumnGroup && column.count() > 0) {
					column.restoreGroupWidths();
				}
			}
			this._columnWidthsDirty = true;
			this._columnsDirty = true;
			this.resetGrid();
			this._doColumnsReset(group);
			this._resetFooterMerge();
			this._resetHeaderSummaryMerge();
			this._shadowDom && this._shadowDom.setColumns(this, this.getLeafColumns());
		}
	},
	_saveOrgWidths: function () {
		for (var i = 0, cnt = this._orgColumns.length; i < cnt; i++) {
			var c = this._orgColumns[i];
			c._orgWidth = c.saveWidth();
			if (c instanceof ColumnGroup) {
				c._saveOrgWidths();
			}
		}
	},
	_restoreOrgWidths: function () {
		for (var i = 0, cnt = this._orgColumns.length; i < cnt; i++) {
			var c = this._orgColumns[i];
			c.setSaveWidth(c._orgWidth);
			if (c instanceof ColumnGroup) {
				c._restoreOrgWidths();
			}
		}
	},
	linearizeColumns: function (sortProps) {
		var i, cnt;
		var columns = this.getLeafColumns(true);
		if (columns && (cnt = columns.length) > 0) {
			if (sortProps && sortProps.length > 0) {
				for (i = 0; i < sortProps.length; i++) {
					columns.sort(function (col1, col2) {
						var prop = sortProps[i];
						var v1 = col1.getProperty(prop);
						var v2 = col2.getProperty(prop);
						return v1 < v2 ? 1 : v1 > v2 ? -1 : 0;
					});
				}
			}
			var cols = [];
			var layout = new ColumnLayout();
			for (i = 0; i < cnt; i++) {
				var c = columns[i];
				c._saveWidth = c.width();
				cols.push(c);
			}
			layout.setItems(cols);
			this.setColumnLayout(layout);
		}
	},
	$_setPosition: function (column, y) {
		var i, cnt;
		column._layoutRect.y = y;
		if (column instanceof ColumnGroup && (cnt = column.visibleCount()) > 0) {
			if (column.isVertical()) {
				if (cnt > 1) {
					for (i = 0; i < cnt; i++) {
						this.$_setPosition(column.getVisibleItem(i), y + 1);
					}
				} else {
					this.$_setPosition(column.getVisibleItem(0), y);
				}
			} else {
				for (i = 0; i < cnt; i++) {
					this.$_setPosition(column.getVisibleItem(i), y);
				}
			}
		}
	},
	$_setRoot: function (column) {
		var i, cnt, group;
		if (column._layoutRect.y == 0) {
			column._dataRoot = column;
		} else {
			group = column.group();
			while (group) {
				if (group._layoutRect.y == 0) {
					break;
				}
				group = group.group();
			}
			column._dataRoot = group;
		}
		if (column instanceof ColumnGroup) {
			cnt = column.visibleCount();
			for (i = 0; i < cnt; i++) {
				this.$_setRoot(column.getVisibleItem(i));
			}
		}
	},
	$_setDistance: function (column, x) {
		column._distance = x;
		var d = 1;
		var group = _cast(column, ColumnGroup);
		if (group) {
			var i;
			var c;
			var g;
			var cnt = group.visibleCount();
			if (group.isVertical()) {
				for (i = 0; i < cnt; i++) {
					c = group.getVisibleItem(i);
					d = Math.max(d, this.$_setDistance(c, x));
				}
			} else {
				d = 0;
				for (i = 0; i < cnt; i++) {
					c = group.getVisibleItem(i);
					d += this.$_setDistance(c, x + d);
				}
			}
		}
		return d;
	},
	_resetColumnPositions: function () {
		var i, 
			column, 
			cnt = this.getVisibleColumnCount();
		for (i = 0; i < cnt; i++) {
			column = this.getVisibleColumn(i);
			this.$_setPosition(column, 0);
			this.$_setRoot(column);
			this.$_setDistance(column, i * 1000000);
		}
		this._dataRoots.collect(this._rootColumn);
	},
	_resetColumnIndicies: function () {
		this._rootColumn.resetIndicies(this);
		this._resetVisibleColumns();
		this._resetColumnPositions();
		this._resetColumnStates();
	},
	_resetVisibleColumns: function () {
		this._rootColumn.resetVisibles();
	},
	_resetColumnStates: function () {
		this._rootColumn.resetStates();
	},
	_resetFooterMerge: function () {
		this._footerMergeManager.buildRooms(this, this.footer()._mergeCells);
		this._groupFooterMergeManager.buildRooms(this);
	},
	_resetHeaderSummaryMerge: function () {
		this._headerSummaryMergeManager.buildRooms(this, this.header().summary()._mergeCells);
	},
	isColumnLayoutChanged: function () {
		return this._columnLayoutChanged;
	},
	focusedIndex: function () {
		return this._shadowIndex.assign(this._focusedIndex);
	},
	setFocusedIndex: function (value, select, focus) {
		select = arguments.length > 1 ? select : true;
		focus = arguments.length > 2 ? focus : false;
		if (!this._focusing) {
			this._focusing = true;
			try {
				return this._doSetFocusedIndex(value, select, focus);
			} finally {
				this._focusing = false;
			}
		}
		return false;
	},
	_doSetFocusedIndex: function (value, select, focus) {
		if (!value) {
			return false;
		}
		if (value && !this.isValid(value)) {
			value = value.clone();
			value.normalize(this, this.isKeepNullFocus());
		}
		if (value.column() instanceof ColumnGroup) {
			value.column(value.column().first());
		}
		if (!this.isValid(value)) {
			var ds = this.dataSource();
			if (!ds || ds.rowCount() == 0 || this.itemCount() == 0) {
				this._focusedIndex.itemIndex(-1);
				this._focusedIndex.column(this.getFirstColumn());
			}
			if (ds && ds.rowCount() > 0 && this.itemCount() > 0 && this.isKeepNullFocus()) {

			} else {
				return false;	
			}
		}
		if (value && CellIndex.areEquals(value, this._focusedIndex)) {
			if (focus) {
				this.$_makeFocusIndexVisible();
			}
			return true;
		}
		var options = this.editOptions();
		var oldIndex = this._focusedIndex.clone();
        if (this._changingMode === ChangingMode.BEFORE_EDITCOMMIT && !this._fireCurrentChanging(oldIndex, value)) {
            return false;
        }
		var itemSource = this.itemSource();
		var tool = this.container().activeTool();
		var lm = this.layoutManager();
		var editing = this.isEditing();
		var cellView, force;
		this.closePopups2();
		if (!this._editController.focusedIndexChanging()) {
			return false;
		}
        if (this._changingMode === ChangingMode.NORMAL && !this._fireCurrentChanging(oldIndex, value)) {
            return false;
        }
        if (!this.isValid(value)) {
            return false;
        }
		var item = oldIndex.item();
		var room;
		if (itemSource && value.I() != oldIndex.I()) {
			try {
				if (item) {
					switch (item.itemState()) {
						case ItemState.INSERTING:
							if (!this.commit(options.isForceInsert(), true)) {
								this.cancel(true);
								return false;
							}
							break;
						case ItemState.APPENDING:
							if (!this.commit(options.isForceAppend()), true) {
								this.cancel(true);
								return false;
							}
							break;
						case ItemState.UPDATING:
							if (!this.commit(this.isEditing() && options.isCommitWhenNoEdit(), true)) {
								this.cancel(true);
								return false;
							}
							break;
					}
				}
			} catch (err) {
				if (err instanceof ValidationError) {
					err = this._fireValidationFail(item._index, err.column, err);
					err ? alert(options.isShowOnlyValidationMessage() && err.userMessage ? err.userMessage : err.toString()) : null;
					return false;
				}
				if (err instanceof AbortError) {
					return false;
				}
				throw err;
			}
		} else if (item && this.isItemEditing(item) && options.isValidateOnExit()) {
            this.$_validateCellValue(oldIndex, oldIndex.value);
            this.invalidateLayout();
        }
		tool.focusedIndexChanging(value);
		if (this.isValid(oldIndex)) {
			room = lm.getMergedCell(oldIndex);			
			cellView = this.getCellView(room ? this._mergeView : null, oldIndex);
			if (cellView) {
				if (editing) {
					var cell = this._body.getCell(cellView._index);;
					// if (cellView._index.itemIndex() !== oldIndex.itemIndex()) {
					// 	this._tmpIndex = CellIndex.temp(this, this.getItemIndexOfRow(item.dataRow()), oldIndex.column());
					// 	cell = this._body.getCell(this._tmpIndex);	
					// } else {
					// 	cell = this._body.getCell(cellView._index);
					// }
					cell && cellView.updateCell(cell);
				}
				cellView.setFocused(false);
				cellView.setMouseEntered(false);
			}
		}
		this._focusedIndex.assign(value);
        if (itemSource instanceof EditableItemProvider) {
            itemSource.setDiffs(this._editOptions.isCheckDiff(), this._editOptions.isCheckCellDiff(), this._editOptions.isStrictDiff());
        }
		this._editController.focusedIndexChanged(oldIndex, value);
		tool.focusedIndexChanged(oldIndex, value);
		if (this.isValid(this._focusedIndex)) {
			room = !(this._focusedIndex.item() instanceof GroupItemImpl) && lm.getMergedCell(this._focusedIndex);
			cellView = this.getCellView(room ? this._mergeView : null, this._focusedIndex);
			if (cellView) {
				cellView.setFocused(true);
				if (cellView._renderer instanceof ImageButtonsCellRenderer)  {
					this._editController._editable = this._editController._editable && (cellView._renderer.canEditable());
				}
			}
		}
		if (select) {
			this.clearSelection();
		}
		if (this.isValid(this._focusedIndex)) {
			if (this._indicatorView.isVisible()) {
				this._indicatorView.refresh();
			}
			if (this._headerView.isVisible()) {
				this._headerView.refresh();
			}
			if (this._fixedHeaderView.isVisible()) {
				this._fixedHeaderView.refresh();
			}
			if (this._rfixedHeaderView.isVisible()) {
				this._rfixedHeaderView.refresh();
			}
		}
		if (focus || (force = !CellIndex.areEquals(this._focusedIndex, lm._focusIndex))) {
			force = force || this.topIndex() !== lm.topIndex();
			this.$_makeFocusIndexVisible(force);
		}
		this._fireCurrentChanged(this._shadowIndex.assign(this._focusedIndex));

		this.isValid(oldIndex) && oldIndex.item() instanceof GridRow && this.$_refreshRow(oldIndex._itemIndex);
		this.isValid(this._focusedIndex) && this._focusedIndex.item() instanceof GridRow && this.$_refreshRow(this._focusedIndex._itemIndex);
		if (!this.$_checkCurrentRow()) {
            this.$_checkLastCellCommit(oldIndex);
        }
		return true;
	},
	setCurrent: function (curr, select) {
		if (curr) {
			var index = this.getIndex(this._focusedIndex._itemIndex, this._focusedIndex._column);
			if (curr.column) {
				index._column = this.columnByName(curr.column);
			} else if (curr.fieldName) {
				index._column = this.columnByFieldName(curr.fieldName);
			} else if (curr.fieldIndex !== undefined && curr.fieldIndex >= 0) {
				index._column = this.columnByField(curr.fieldIndex);
			}
			if (curr.itemIndex !== undefined && curr.itemIndex >= 0) {
				index._itemIndex = curr.itemIndex;
			} else if (curr.dataRow !== undefined && curr.dataRow >= 0) {
				index._itemIndex = this.getItemIndexOfRow(curr.dataRow);
			}
			if (index._column && index._itemIndex < 0) {
				index._itemIndex = 0;
			}
			if (index._itemIndex >= 0 && !index._column) {
				index._column = this.getFirstColumn();
			}
			this.setFocusedIndex(index, select, true);
		}
	},
	$_makeFocusIndexVisible: function (force) {
		if (this.isValid(this._focusedIndex)) {
			this.makeCellVisible(this._focusedIndex, force);
		}
	},
	cancelEditor: function (hideEditor) {
		hideEditor = arguments.length > 0 ? hideEditor : true;
		this._editController.cancelEditor(hideEditor);
	},
	itemEditCancel: function() {
		return this._fireItemEditCancel(this._itemProvider._editingItem);
	},
	cancel: function (focus) {
		var editController = this.editController();
		if (this.isEditing()) {
			editController.cancelEditor(true);
			editController.invalidateEditor();
		};
		var index = this.focusedIndex();
		if (this.isValid(index) && this.itemSource().isEditing(index.item())) {
			var dataId = index.dataId();
			index = index.clone();
			this.itemSource().cancel();
			if (this._validationManager._userValidations && dataId > -1) {
				this._validationManager.checkValidateCells(index.itemIndex());
				this._setColumnErrors(index.item());
			}
			editController._prepareEditor(editController._editIndex);// insert/append중인경우 editor에 값이 없다. 이것을 다시 채워준다.
			index.normalize(this);
			this.setFocusedIndex(index);
			if (focus) {
				this.$_makeFocusIndexVisible();
			}
			return true;
		}
		return false;
	},
    commitEditor: function (hideEditor) {
        hideEditor = arguments.length > 0 ? hideEditor : true;
        this.editController().commitEditor(hideEditor);
    },
	commit: function (force, raiseFailError) {
		var index = this.focusedIndex();
		if (!this.isValid(index)) {
			return false;
		}
		var items = _cast(this.itemSource(), EditableItemProvider);
		if (!items) {
			return false;
		}
		if (this.isEditing()) {
			this.editController().commitEditor(true);
			this.editController().invalidateEditor();
		}
		var item = index.item();
		if (items.isEditing(item) && (force || items.isEdited(item))) {
			var inserting = ItemState.isInserting(item.itemState());
			try {
				this._validationManager.validateRow(item, inserting);
				this.$_validateRow(item, inserting);
			} catch (err) {
				if (err instanceof ValidationError && err.column && err.column.setError) {
					err.column.setError(err.message || err);
					err.column.setErrorLevel(err.level || ValidationLevel.ERROR);
				}
				throw err;
			}
			if (!items.commit()) {
                if (raiseFailError) {
                    throw new AbortError();
                }
                return false;
			}
			return true;
		}
		return false;
	},
	isScrolling: function () {
		return this._scrolling;
	},
	isHorzScrolling: function () {
		return this._horzScrolling;
	},
	toastManager: function () {
		return this._toastManager;
	},
	setCellUpdateEventLock: function (value) {
		this._cellUpdateEventLock = value;
	},
	editorActivated: function (editor) {
		this.activeTool() && this.activeTool().editorActivated(editor);
	},
    onCurrentChanging: undefined,
    onCurrentChanged: undefined,
	onCurrentRowChanged: undefined,
	onValidateCell: undefined,
	onValidateRow: undefined,
	onColumnHeaderClicked: undefined,
	onColumnHeaderImageClicked: undefined,
	onColumnHeaderDblClicked: undefined,
	onFooterCellClicked: undefined,
	onFooterCellDblClicked: undefined,
	onHeaderSummaryCellClicked: undefined,
	onHeaderSummaryCellDblClicked: undefined,
	onCheckBarHeadClicked: undefined,
	onCheckBarFootClicked: undefined,
	onIndicatorCellClicked: undefined,
	onStateBarCellClicked: undefined,
	onRowGroupHeadClicked: undefined,
	onRowGroupFootClicked: undefined,
	onRowGroupHeaderFooterClicked: undefined,
	onRowGroupBarClicked: undefined,
	onCheckBarFootDblClicked: undefined,
	onIndicatorCellDblClicked: undefined,
	onStateBarCellDblClicked: undefined,
	onRowGroupHeadDblClicked: undefined,
	onRowGroupFootDblClicked: undefined,
	onRowGroupHeaderFooterDblClicked: undefined,
	onRowGroupBarDblClicked: undefined,
	onPanelClicked: undefined,
	onPanelDblClicked: undefined,
	onRowGroupPanelClicked: undefined,
	onRowGroupPanelDblClicked: undefined,
	onGridMenuItemClicked: undefined,
	onContextMenuItemClicked: undefined,
	onCellButtonClicked: undefined,
	onEditButtonClicked: undefined,
	onImageButtonClicked: undefined,
	onClickableCellClicked: undefined,
	onScrollToBottom: undefined,
	onDataCellClicked: undefined,
	onDataCellDblClicked: undefined,
	onRowsDeleting: undefined,
	onRowInserting: undefined,
    onUpdateStarted: undefined,
    onInsertStarted: undefined,
	onShowEditor: undefined,
	onHideEditor: undefined,
	onEditChange: undefined,
    onGetEditValue: undefined,
	onEditCommit: undefined,
	onEditCanceled: undefined,
	onEditSearch: undefined,
	onCellEdited: undefined,
	onEditRowChanged: undefined,
	onEditRowPasted: undefined,
	onRowsPated: undefined,
	onItemChecked: undefined,
	onItemsChecked: undefined,
	onItemAllChecked: undefined,
	onErrorClicked: undefined,
	onSorting: undefined,
	onSortingChanged: undefined,
	onFiltering: undefined,
	onFilteringChanged: undefined,
	onFilterActionClicked: undefined,
	getOptions: function () {
		var options = {};
		var items = this.itemSource();

		options.summaryMode = this.summaryMode();
		options.changingMode = this.changingMode();
		options.keepNullFocus = this.isKeepNullFocus();
		options.hideDeletedRows = items.isHideDeleted();
		if (items.sortMode)
			options.sortMode = items.sortMode();
		if (items.filterMode)
			options.filterMode = items.filterMode();
		return options;
	},
	setOptions: function (source) {
		if (source) {
            var items = this.itemSource();
            var v;
            source.summaryMode !== UNDEFINED && this.setSummaryMode(source.summaryMode);
            source.scrollBarWidth !== UNDEFINED && this.setScrollBarWidth(source.scrollBarWidth);
            source.scrollBarHeight !== UNDEFINED && this.setScrollBarHeight(source.scrollBarHeight);
            source.scrollThumbRadius != UNDEFINED && this.setScrollThumbRadius(source.scrollThumbRadius);
            source.changingMode !== UNDEFINED && this.setChangingMode(source.changingMode);
            source.hideDeletedRows !== UNDEFINED && items.setHideDeleted(source.hideDeletedRows);
            source.keepNullFocus !== UNDEFINED && this.setKeepNullFocus(source.keepNullFocus);
            source.resizeDelay !== UNDEFINED && this._container.setResizeDelay(source.resizeDelay);
            source.sortMode != undefined && items.setSortMode(source.sortMode);
            source.filterMode != undefined && items.setFilterMode(source.filterMode);
            source.filterOr != UNDEFINED && items.setFilterOr(source.filterOr);
            source.backgroundImage !== undefined && this.setBackgroundImage(source.backgroundImage);
            source.display && this.setDisplayOptions(source.display);
            source.fixed && this.setFixedOptions(source.fixed);
            (v = _pick(source.editing, source.edit)) && this.setEditOptions(v);
            (v = _pick(source.selecting, source.select, source.selection)) && this.setSelectOptions(v);
            (v = _pick(source.sorting, source.sort)) && this.setSortingOptions(v);
            (v = _pick(source.filtering, source.filter)) && this.setFilteringOptions(v);
            source.grouping && this.setGroupingOptions(source.grouping);
            source.copy && this.setCopyOptions(source.copy);
            source.paste && this.setPasteOptions(source.paste);
            source.body && this.setBody(source.body);
            source.panel && this.setPanel(source.panel);
            source.indicator && this.setIndicator(source.indicator);
            source.stateBar && this.setStateBar(source.stateBar);
            source.checkBar && this.setCheckBar(source.checkBar);
            source.editBar && this.setEditBar(source.editBar);
            source.header && this.setHeader(source.header);
            source.footer && this.setFooter(source.footer);
            source.rowGroup && this.setRowGroup(source.rowGroup);
            source.columnHeader && this.setColumnHeaderOptions(source.columnHeader);
            source.editor && this.setEditorOptions(source.editor);
		}
	},
/*
    setOptions: function (source) {
        if (source) {
            source.summaryMode !== UNDEFINED && this.setSummaryMode(source.summaryMode);
            source.hideDeletedRows !== UNDEFINED && this.itemSource().setHideDeleted(source.hideDeletedRows);
            source.display && this._displayOptions.assign(source.display);
            source.fixed && this._fixedOptions.assign(source.fixed);
            source.edit && this._editOptions.assign(source.edit);
            source.select && this._selectOptions.assign(source.select);
            source.sorting && this._sortingOptions.assign(source.sorting);
            source.filtering && this._filteringOptions.assign(source.filtering);
            source.grouping && this._groupingOptions.assign(source.grouping);
            source.copy && this._copyOptions.assign(source.copy);
            source.paste && this._pasteOptions.assign(source.paste);
            source.body && this.setBody(source.body);
            source.panel && this.setPanel(source.panel);
            source.header && this.setHeader(source.header);
            source.rowHeader && this.setIndicator(source.rowHeader);
            source.stateBar && this.setStateBar(source.stateBar);
            source.checkBar && this.setCheckBar(source.checkBar);
            source.editBar && this.setEditBar(source.editBar);
            source.footer && this.setFooter(source.footer);
            source.rowGroup && this.setRowGroup(source.rowGroup);
        }
    },
*/
	loadStyles: function (styles) {
		StylesArchiver.deserialize(styles, this);	
	},
	containerToGridRect: function (r) {
		r.x -= this._offsetX;
		r.y -= this._offsetY;
		return r;
	},
	containerToGridX: function (x) {
		return x - this._offsetX;
	},
	containerToGridY: function (y) {
		return y - this._offsetY;
	},
	setCursor: function (cursor) {
		this.container().setCursor(cursor);
	},
	updateNow: function () {
		this.container().updateNow();
	},
    setColumnsProperty: function (prop, value, recursive, visibleOnly) {
        this._rootColumn.setChildrenProperty(prop, value, recursive, visibleOnly);
    },
	invalidateColumnWidths: function () {
		if (!this._columnWidthsDirty) {
			this._columnWidthsDirty = true;
			this._columnsDirty = true;
			this.refreshView();
		}
	},
	invalidateColumns: function () {
		if (!this._columnsDirty) {
			this._columnsDirty = true;
			this.refreshView();
		}
	},
	getItem: function (index) {
		return this._itemProvider.getItem(index);
	},
	getItemIndexOfRow: function (dataRow) {
		return this._itemProvider.getIndexOfRow(dataRow);
	},
	getItemOfRow: function (dataRow, force) {
		return this._itemProvider.getItemOfRow(dataRow, force);
	},
	getItemIndiciesOfRows: function (dataRows) {
		return this._itemProvider.getIndicesOfRows(dataRows);
	},
	getAllItems: function () {
		return this._itemProvider ? this._itemProvider.getAllItems() : null;
	},
	getPagingAllItems: function () {
		return this._itemProvider ? this._itemProvider.getPagingAllItems() : null;
	},
	getIndex: function (itemIndex, column) {
		itemIndex = arguments.length > 0 ? itemIndex : -1;
		column = arguments.length > 1 ? column : null;
		return new CellIndex(this, itemIndex, column);
	},
	isValid: function (index) {
		/*
		try {
			if (index.column() && !index.column().grid())
				debugger;
		} catch (e) {
			debugger;
		}
		*/
		return index && (index.grid() === this) && (index.I() >= 0) &&
		(index.I() < this.itemCount()) && index.column() && (index.column().grid() === this);
	},
	isValidColumn: function (index) {
		return index && (index.grid() === this) && index.column() && (index.column().grid() === this);
	},
	isValidRow: function (index) {
		return index && (index.grid() === this) && (index.I() >= 0) && (index.I() < this.itemCount());
	},
	beginUpdate: function () {
		this._updateLock = true;
		this._itemProvider.beginUpdate();
	},
	endUpdate: function (force) {
		if (force || this._updateLock) {
			this._updateLock = false;
			this._itemProvider.endUpdate();
			this.refreshView();
		}
	},
	invalidateLayout: function () {
		if (!this._updateLock) {
			this._super();
		}
	},
	refreshView: function () {
		if (!this._loading && !this._updateLock) {
			this.invalidateLayout();
			this.setTopIndex(this.topIndex(), this._filterRunning);
			this.setLeftPos(this.leftPos());
			this.setFocusedIndex(this.focusedIndex(), true);
		}
	},
	$_refreshRow: function(itemIndex) {
		if (itemIndex <= -1 || itemIndex >= this.itemCount()) {
			return;
		}
		var columns = this.getDataColumns();
		for (var i = 0, cnt = columns.length; i < cnt ; i++) {
			var index = CellIndex.temp(this, itemIndex, columns[i]);
			if (index) {
				var cellView = this.getFocusedCellView(index);
				if (cellView) {
					cellView.invalidate(true,true);
				}
			}
		}
	},
	resetGrid: function () {
		this._resetting = true;
		this.setTopIndex(0);
		this.setLeftPos(0);
		this.setFocusedIndex(this.getIndex(0, this.getFirstColumn()), true);
		this.refreshView();
	},
    getFirstCell: function () {
        if (this.itemCount() > 0) {
            var index = -1;
            // keepNullFocus이면 현재 화면 위치의 첫번째 (fixed제외)에 focus처리.
            if (this.isKeepNullFocus()) {
            	var top = this.topItem();
            	for (var i = top, cnt = top + this.layoutManager().fullItemCount(); i < cnt ; i++){
	            	if (this.getItem(i) instanceof GridRow) {
	            		index = i;
	            		break;
	            	}
            	}
            };
            if (index < 0) {
		        for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
		            if (this.getItem(i) instanceof GridRow) {
		                index = i;
		                break;
		            }
		        }
            }
            return new CellIndex(this, index >= 0 ? index : 0, this.getFirstColumn());
        }
        return null;
    },
	getFirstColumn: function () {
		return this._rootColumn.first();
	},
	getVisibleColumnCount: function () {
		return this._rootColumn.visibleCount();
	},
	visibleColumnCount: function () {
		return this._rootColumn.visibleCount();
	},
	getVisibleColumn: function (index) {
		return this._rootColumn.getVisibleItem(index);
	},
	getHorzColumns: function (start, count) {
		return this._rootColumn.getHorzColumns(start, count);
	},
	getLeafColumns: function (visibleOnly) {
		visibleOnly = arguments.length > 0 ? visibleOnly : true;
		return this._rootColumn.getLeafItems(visibleOnly);
	},
	getValueColumns: function (visibleOnly) {
		visibleOnly = arguments.length > 0 ? visibleOnly : true;
		return this._rootColumn.getValueColumns(visibleOnly);
	},
	getDataColumns: function (visibleOnly) {
		visibleOnly = arguments.length > 0 ? visibleOnly : true;
		return this._rootColumn.getDataColumns(visibleOnly);
	},
	getDataRootColumns: function () {
		return this._dataRoots.roots();
	},
	collectDataColumns: function (c1, c2) {
		return this._dataRoots.collectDataColumns(c1, c2);
	},
	isCheckable: function (itemIndex) {
		var item = this.getItem(itemIndex);
		return item && item.isCheckable();
	},
	setCheckable: function (itemIndex, value) {
		var item = this.getItem(itemIndex);
		item && item.setCheckable(value);
	},
	isCheckedItem: function (itemIndex) {
		var item = this.getItem(itemIndex);
		return item && item.isChecked();
	},
	isCheckedRow: function (dataRow) {
		var item = this._itemProvider.getItemOfRow(dataRow, true);
		return item && item.isChecked();
	},
	checkAll: function (checked, visibleOnly, checkableOnly, checkEvent) {
		var groupCheckable = this._checkBar.isShowGroup();
		this._itemProvider.checkAll(checked, visibleOnly, checkableOnly, checkEvent, groupCheckable);
	},
	checkItem: function (itemIndex, checked, exclusive, checkEvent) {
		var item = this.getItem(itemIndex);
		item && this._itemProvider.checkItem(item, checked, exclusive, checkEvent);
	},
	checkRow: function (dataRow, checked, exclusive, checkEvent) {
		// TODO editing중인 row는 getItemOfRow로 가져올수 없다.
		// check관련만 처리하고 지속적으로 필요하다면 defaultItemProvider.getItemOfRow에서 
		// editing중인지 확인하고 editing중이라면 editItem을 return해서 처리해야 한다.
		var idx = this.getItemIndexOfRow(dataRow);
		var item;
		if (idx > -1 && (item = this.getItem(idx))) {
			item = item instanceof EditItem ? item : null;
		}
		item = item || this.getItemOfRow(dataRow, true);
		item && this._itemProvider.checkItem(item, checked, exclusive, checkEvent);
	},
	checkItems: function (itemIndicies, checked, checkEvent) {
		var items = this._itemProvider.getItemsByIndices(itemIndicies);
		this._itemProvider.checkItems(items, checked, checkEvent);
	},
	checkRows: function (dataRows, checked, checkEvent) {
		var items = this._itemProvider.getItemsByRows(dataRows, true);
		this._itemProvider.checkItems(items, checked, checkEvent);
	},
	setAllCheck: function (checked, itemChecked) {
		this._checkBarHeadView.setChecked(checked);
		if (itemChecked) {
			var checkBar = this.checkBar();
			this.checkAll(checked, checkBar.isVisibleOnly(), checkBar.isCheckableOnly(), false);
		}
	},
	isAllChecked: function () {
		return this._checkBarHeadView.isChecked();
	},
	resetCheckables: function () {
	},
	applyaCheckables: function () {
	},
	addLookupSource: function (source) {
		var provider = this._lookupProvider || (this._lookupProvider = new LocalLookupSourceProvider());
		provider.add(source);
	},
	removeLookupSource: function (sourceId) {
		this._lookupProvider && this._lookupProvider.remove(sourceId);
	},
	existsLookupData: function (sourceId, keys) {
		if (sourceId && keys) {
			var source = this._lookupProvider && this._lookupProvider.getSource(sourceId);
			if (!source) {
				throw "Invalid lookup source id: " + sourceId;
			}
			if (!_isArray(keys)) {
				keys = [keys];
			}
			return source.exists(keys);
		}
		return false;
	},
	fillLookupData: function (sourceId, data) {
		if (sourceId && data) {
			var source = this._lookupProvider && this._lookupProvider.getSource(sourceId);
			if (!source) {
				throw "Invalid lookup source id: " + sourceId;
			}
			if (data.rows) {
				source.fillRows(data.rows);
			} else {
				source.fill(data.keys, data.values);
			}
		}
	},
	clearLookupData: function (sourceId) {
		if (sourceId) {
			var source = this._lookupProvider && this._lookupProvider.getSource(sourceId);
			if (!source) {
				throw "Invalid lookup source id: " + sourceId;
			}
			source.clear();
		}
	},
	getIndicatorIndex: function (item) {
		return item.index();
	},
	canHovering: function () {
		return !this.isEditing();
	},
	calcGroupLevels: function () {
		this._rootColumn.calcHeaderLevels();
		this._rootColumn.calcDataLevels();
	},
	showToast: function (options, force) {
		this._toastManager.show(options, force);
	},
	hideToast: function (action) {
		this._toastManager.close();
		action && typeof action === "function" && setTimeout(action, 0);
	},
	isEditing: function (index) {
		return this._editController && this._editController.isEditing() &&	(!index || CellIndex.areEquals(index, this._editController.editIndex()));
	},
	isItemEditing: function (item) {
		item = item || this.focusedIndex().item();
		return item && (this.itemSource() instanceof EditableItemProvider) && this.itemSource().isEditing(item);
	},
	isItemEdited: function (item) {
		item = item || this.focusedIndex().item();
		return item && (this.itemSource() instanceof EditableItemProvider) && this.itemSource().isEdited(item);
	},
    canWrite: function (index) {
        var can = this._editOptions.isEditable() && this.isValid(index) && (this.visibleColumnCount() > 0)
            	&& index.item().canEdit() && !!index.dataColumn()
            	&& (this.fixedOptions().isRowEditable() || index.itemIndex() >= this.layoutManager().fixedItemCount()) 

        if (can) {
        	var view = this.getFocusedCellView(index);
        	can = view && view.renderer() ? (!view.renderer().canEditable || view.renderer().canEditable()) : can;
	        var colIndex = index.C().root().displayIndex();
        	if (colIndex < this._layoutManager.fixedColCount() || colIndex >= this._layoutManager.rfixedStartCol() ) {
            	can = can && this.fixedOptions().isEditable();
            }
        }
        return can;
    },
    canEdit: function (index) {
    	var cellEditable = this.getCellEditable(index);
    	if (typeof cellEditable === "boolean") {
    		return this.canWrite(index) && cellEditable;
    	};
        return this.canWrite(index) && index.dataColumn().isEditable();
    },
    canShowEditor: function (index, attrs) {
        if (this.isValid(index)) {
            this._tmpIndex.assign(index);
            return this._fireShowEditor(this._tmpIndex, attrs);
        }
        return false;
    },
	canUpdate: function (item, field) {
		return this.editOptions().canUpdate() && 
		   (this.visibleColumnCount() > 0) && this.itemSource() && this.itemSource().canUpdate(item, field);
	},
	canAppend: function () {
		var can = !this.isEditing() && this.editOptions().canAppend() && (this.visibleColumnCount() > 0) && this.itemSource() && this.itemSource().canAppend();
		if (can) {
			try {
				if (!this._fireRowInserting(this.itemSource().itemCount(), -1)) {
					return false;
				}
			} catch (e) {
				alert(e.message || e);
				return false;
			}
		}
		return can;
	},
	canInsert: function (item, shift, ctrl) {
		var can = !this.isEditing() && this._doCanInsert(item, shift, ctrl) && this.editOptions().canInsert() && (this.visibleColumnCount() > 0) && this.itemSource() && this.itemSource().canInsert(item);
		if (can) {
			try {
				if (!this._fireRowInserting(item.index() + (shift ? 1 : 0), -1)) {
					return false;
				}
			} catch (e) {
				alert(e.message || e);
				return false;
			}
		}
		return can;
	},
	_doCanInsert: function (item, shift, ctrl) {
		return true;
	},
	canDelete: function (item) {
		return this.editOptions().canDelete() && (this.visibleColumnCount() > 0) && 
			this.itemSource() && (this.isItemEditing(item) || this.itemSource().canDelete(item));
	},
	canCommit: function (item) {
		return this.isItemEditing(item) && (this.isItemEdited() || this.editOptions().isCommitWhenNoEdit());
	},
	canCancel: function (item) {
		return this.isItemEditing(item);
	},
	_appendDummy: function(){
		var options = this._editOptions;
		if (options.isDisplayEmptyEditRow() && options.isAppendable()) {
			this._items.appendDummy();
		}
	},
	_cancelDummy: function() {
		this._items.cancelDummy();
	},
	append: function () {
		var items = this.itemSource();
		if (items instanceof EditableItemProvider && items.dataSource() && this.canAppend()) {
			var defaults = this.$_getInsertDefaults(null);
			this._cancelDummy();
            return items.append(defaults);
		}
		return false;
	},
	insertAt: function (itemIndex, shift) {
		return this.insert(this.getItem(itemIndex), shift);
	},
	insert: function (item, shift, ctrl) {
		if (!item) {
			item = this.focusedIndex() ? this.focusedIndex().item() : null;
		}
		if (!item) {
			return false;
		}
		if (!(this.itemSource() instanceof EditableItemProvider) || !this.canInsert(item, shift, ctrl)) {
			return false;
		}
		var defaults = this.$_getInsertDefaults(null);
		this._cancelDummy();
		return this.itemSource().insert(item, defaults, shift, ctrl);
	},
	edit: function (index) {
		if (!index) {
			index = this.focusedIndex();
		}
		if (!this.isValid(index) || !(this.itemSource() instanceof EditableItemProvider)) {
			return false;
		}
		if (index.dataColumn() && !this.canUpdate(index.item(), index.dataField())) {
			return false;
		}
		return this.itemSource().edit(index.item());
	},
	fillEditSearchItems: function (column, searchKey, values, labels) {
		this._editController.fillSearchItems(column, searchKey, values, labels);
	},
	showEditor: function (index, append, dropdown) {
		index = index || this.focusedIndex();
		if (this._editController.showEditor(index, dropdown)) {
            append && this._editController.caretToLast();
            return true;
        }
        return false;
	},
	editorButtonClick: function (index) {
		this._editController.buttonClicked(index);
	},
	hideEditor: function () {
		this._editController.closeList(false);
		this._editController.hideEditor();
	},
	reprepareEditor: function () {
		this._editController.reprepareEditor(this.focusedIndex());
	},
	isReadOnly: function (index) {
		if (!this.isValid(index)) {
			return false;
		}
		var col = index.dataColumn();
		if (!col) {
			return true;
		};
		var cs = this.getDataCellStyle(index.dataRow(), index.dataField());
		var readOnly;
		if (cs) {
			if ((readOnly = cs.isReadOnly()) != undefined) {
				return readOnly;
			}
		} else if ( (readOnly = this.getCellReadOnly(index)) != undefined) {
			return readOnly;
		}
		return col.isReadOnly();
	},
	getEditingItem: function () {
		var items = _cast(this.itemSource(), EditableItemProvider);
		return items ? items.editingItem() : null;
	},
	getSortFields: function () {
		return null;
	},
	getSortDirections: function () {
		return null;
	},
    getSortCases: function () {
        return null;
    },
    getLabelComparer: function() {
    	return null;
    },
    setLabelComparer: function(comparer) {
    	this._items.setLabelComparer(comparer)
    },
	addFocusElement: function (element) {
		if (element && !this._focusLayer.contains(element)) {
			this._focusLayer.addElement(element, this._toolContext);
			return true;
		}
		return false;
	},
	removeFocusElement: function (element) {
		if (this._focusLayer.contains(element)) {
			this._focusLayer.removeElement(element);
			return true;
		}
		return false;
	},
	addRowFocusElement: function (element) {
		if (element && !this._rowFocusLayer.contains(element)) {
			this._rowFocusLayer.addElement(element, this._toolContext);
			return true;
		}
		return false;
	},
	removeRowFocusElement: function (element) {
		if (this._rowFocusLayer.contains(element)) {
			this._rowFocusLayer.removeElement(element);
			return true;
		}
		return false;
	},
	addFeedbackElement: function (element) {
		if (element && !this._feedbackLayer.contains(element)) {
			this._feedbackLayer.addElement(element, this._toolContext);
			return true;
		}
		return false;
	},
	removeFeedbackElement: function (element) {
		if (this._feedbackLayer.contains(element)) {
			this._feedbackLayer.removeElement(element);
			return true;
		}
		return false;
	},
	getEditCellBounds: function (index) {
        var lm = this.layoutManager();
        var room = lm.getMergedCell(index);
        var view = this.getCellView(room ? this._mergeView : null, index);
		if (view) {
			var r = view.getBounds();
			r.x = r.y = 0;
			r = view.boundsByContainer(r);
            if (room) {
                var i = index.itemIndex();
                if (i >= lm.topIndex() + lm.fixedRowCount() && i < lm.topIndex() + lm.itemCount() + lm.fixedRowCount()) {
                    var r1 = lm.itemBounds(view._topIndex);
                    var r2 = lm.itemBounds(index.I() - this._topIndex);
                    r.y += r2.y - r1.y;
                    r.height = r2.height;
                } else {
                    r = $_INVISIBLE_EDIT_BOUNDS.clone();
                }
            }
			return r;
		} else {
			return $_INVISIBLE_EDIT_BOUNDS.clone();
		}
	},
	getEditBounds: function (index) {
        var lm = this.layoutManager();
        var room = lm.getMergedCell(index);
		var view = this.getCellView(room ? this._mergeView : null, index, index.isFixedCol());
		if (view) {
            var r = view.getBounds();
			r.x = r.y = 0;
			if (view instanceof DataCellElement) {
				r.width -= view.getButtonsWidth();
				view._isLeftImageButton && (r.x += view.getLeftButtonsWidth())
			}
			r = view.boundsByContainer(r);
            if (room) {
                var i = index.itemIndex();
                if (i >= lm.topIndex() + lm.fixedRowCount() && i < lm.topIndex() + lm.itemCount() + lm.fixedRowCount()) {
                    var r1 = lm.itemBounds(view._topIndex);
                    var r2 = lm.itemBounds(index.I() - this._topIndex);
                    r.y += r2.y - r1.y;
                    r.height = r2.height;
                } else {
                    r = $_INVISIBLE_EDIT_BOUNDS.clone();
                }
            }
			return r;
		} else {
			return $_INVISIBLE_EDIT_BOUNDS.clone();
		}
	},
	getCellView: function (owner, index, fixed, rightFixed) {
		var item, idx;
		var column = index._column;
        fixed = fixed || column.isFixed();
        rightFixed = rightFixed || column.isRightFixed();
		if (owner == null || owner instanceof GridBodyElement) {
			item = index.item();
			if (item && item.isEditable()) {
				idx = item.index();
				var rowView = rightFixed ? this._rfixedBodyView.findRowView(idx) : 
				                       fixed ? this._fixedBodyView.findRowView(idx) :
							                   this._bodyView.findRowView(idx);
				if (rowView && rowView.isVisible()) {
					return rowView.findCell(column);
				}
			}
		} else if (owner === this._rowGroupView) {
			return this._rowGroupView.getCellView(index, !!fixed, !!rightFixed);
		} else if (owner instanceof GridMergeElement) {
            var mergeView = rightFixed ? this._rfixedMergeView : fixed ? this._fixedMergeView : this._mergeView;
			return  mergeView.getCellView(index);
		} else if (owner === this._mergeHeaderLayer) {
			return this._mergeHeaderLayer.getCellView(index);
		}
		return null;
	},
	getFocusedCellView: function (index) {
		index = index || this._focusedIndex;
		var lm = this.layoutManager();
        var item = index.item();
        var merged = item && item.isMerged();
        var fixed = index.isFixedCol();
        var rfixed = index.isRightFixedCol();
        var isGroupItem = item instanceof GroupItemImpl;
		var cell = isGroupItem ? null : 
						rfixed ? this.getCellView(this._rfixedMergeView, index, true) : 
		                 fixed ? this.getCellView(this._fixedMergeView, index, true) : null;
		if (!cell && !fixed && !isGroupItem) {
			cell = this.getCellView(this._mergeView, index, false);
		} 
		if (!cell && merged) {
			cell = this.getCellView(this._mergeHeaderLayer, index);
		} 
		if (!cell) {
			cell = this.getCellView(null, index, fixed);
		}
		if (!cell && !merged) {
			cell = this.getCellView(this._rowGroupView, index, false);
            if (!cell) {
                cell = this.getCellView(this._rowGroupView, index, true);
            }
		}
		return cell;
	},
	pointToIndex: function (x, y, clipped) {
		var index = CellIndex.temp(this, -1, null);
		if (clipped) {
			this._layoutManager.mouseToIndex(x, y, index);
		} else {
			this._layoutManager.mouseToIndexEx(x, y, index);
		}
		return index;
	},
	getCellBounds: function (index, outer) {
		var r = this.getEditCellBounds(index);
		if (r.x == -10000) {
			r = null;
		}
		if (r && outer) {
			r = this.container().toScreen(r);
		}
		return r;
	},
	getSelection: function () {
		return this._selections.count() > 0 ? this._selections.getItem(0) : null;
	},
	clearSelection: function () {
		var idx = this.focusedIndex();
		this._selections.clear();
		if (this.isValid(idx) && (this.itemCount() > 0) && (this.visibleColumnCount() > 0)) {
			this._selections.add(idx, idx, this._selectOptions.style());
		}
	},
	deleteSelection: function (force) {
		function checkDelete(self, item) {
			var items = [];
			items.push(item);
			return checkDeleteAll(self, items);
		}
		function checkDeleteAll(self, items) {
			try {
				if (items && items.length > 0) {
					var i, item;
					var cnt = items.length;
					var rows = [];
					for (i = 0; i < cnt; i++) {
						item = self.getItem(items[i]);
						if (item && item.dataRow() >= 0) {
							rows.push(item.dataRow());
						}
					}
					if (rows.length > 0) {
						if (!self._fireRowsDeleting(rows)) {
							return false;
						}
					}
				}
			} catch (err) {
				alert(err);
				return false;
			}
			return true;
		}
		function deleteSingleCell(self, selections) {
			if (selections.count() == 0 || selections.count() == 1 && selections.getItem(0).isSingleCell()) {
				var item;
				var r = -1;
				if (selections.count() == 0) {
					r = self.focusedIndex().itemIndex();
				} else {
					r = selections.getItem(0).getBounds().R1();
				}
				if (r >= 0 && self.canDelete(item = self.getItem(r))) {
					if (force || !self.editOptions().isConfirmWhenDelete()) {
						self.cancel();
						if (!ItemState.isInserting(item.itemState())) {
							self.itemSource().remove(item);
						}
					} else {
						if (confirm(self.editOptions().deleteRowsMessage()) && checkDelete(self, r)) {
							self.cancel();
							if (!ItemState.isInserting(item.itemState())) {
								self.itemSource().remove(item);
							}
						}
					}
				}
				return true;
			}
			return false;
		}
		function removeItems(self, items) {
			var editingItem = null;
			for (var i = items.length; i--;) {
				var item = self.getItem(items[i]);
				var state = item.itemState();
				if (ItemState.isEditing(state)) {
					editingItem = item;
					if (ItemState.isInserting(state)) {
						items.splice(i, 1);
					}
					break;
				}
			}
			var rows = null;
			if (items.length > 0) {
				rows = self.itemSource().getRemovableRows(items);
			}
			if (editingItem) {
				self.cancel();
			}
			if (rows) {
				self.itemSource().removeRows(rows);
			}
		}
		var options = this.editOptions();
		var selections = this.selections();
		var itemSource = this.itemSource();
		if (!force && !options.isDeletable()) {// || !isValid(m_focusedIndex))
			return;
		}
		if (!(itemSource instanceof EditableItemProvider)) {
			return;
		}
		if (this.isItemEditing(null) && !options.isDeletableWhenEdit()) {
			alert(window.RG_CONST && window.RG_CONST.COMMITEDITING ? window.RG_CONST.COMMITEDITING : "먼저 편집을 완료 하십시오.");
			return;
		}
		this.commitEditor(true);
		if (deleteSingleCell(this, selections)) {
			return;
		}
		var i, sel, range, r1, r2, r, item;
		var cnt = selections.count();
		var items = [];
		for (i = 0; i < cnt; i++) {
			sel = selections.getItem(i);
			if (sel.style() == SelectionStyle.ROWS || sel.style() == SelectionStyle.BLOCK) {
				range = sel.getBounds();
				r1 = Math.min(range.R1(), range.R2());
				r2 = Math.max(range.R1(), range.R2());
				for (r = r1; r <= r2; r++) {
					item = this.getItem(r);
					if (item.dataRow() >= 0 || item instanceof EditItem || item instanceof TreeEditItem) {
						items.push(r);
					}
				}
			}
		}
		items.sort(function (v1, v2) {
			return v2 - v2;
		});
		r = -1;
		for (i = items.length; i--;) {
			if (items[i] == r) {
				items.splice(i, 1);
			} else {
				r = items[i];
			}
		}
		if (items.length > 0 && this.canDelete(this.getItem(items[0]))) {
			if (force || !options.isConfirmWhenDelete()) {
				if (checkDeleteAll(this, items)) {
					removeItems(this, items);
					this.clearSelection();
				}
			} else if (confirm(options.deleteRowsMessage()) && checkDeleteAll(this, items)) {
				removeItems(this, items);
				this.clearSelection();
			}
		}
	},
    revertSelection: function (force) {
        function revertSingleCell(self, selections) {
            if (selections.count() == 0 || selections.count() == 1 && selections.getItem(0).isSingleCell()) {
                var r = -1;
                if (selections.count() == 0) {
                    r = self.focusedIndex().itemIndex();
                } else {
                    r = selections.getItem(0).getBounds().R1();
                }
                if (r >= 0) {
                    self.itemSource().revert(r);
                }
            }
        }
        var options = this.editOptions();
        var selections = this.selections();
        var itemSource = this.itemSource();
        if (!force && !options.isRevertable()) {
            return;
        }
        if (!(itemSource instanceof EditableItemProvider)) {
            return;
        }
        this.commitEditor(true);
        if (revertSingleCell(this, selections)) {
            return;
        }
        var i, sel, range, r1, r2, r, item;
        var cnt = selections.count();
        var items = [];
        for (i = 0; i < cnt; i++) {
            sel = selections.getItem(i);
            if (sel.style() == SelectionStyle.ROWS || sel.style() == SelectionStyle.BLOCK) {
                range = sel.getBounds();
                r1 = Math.min(range.R1(), range.R2());
                r2 = Math.max(range.R1(), range.R2());
                for (r = r1; r <= r2; r++) {
                    item = this.getItem(r);
                    if (item.dataRow() >= 0 || item instanceof EditItem || item instanceof TreeEditItem) {
                        items.push(r);
                    }
                }
            }
        }
        items.sort(function (v1, v2) {
            return v2 - v2;
        });
        r = -1;
        for (i = items.length; i--;) {
            if (items[i] == r) {
                items.splice(i, 1);
            } else {
                r = items[i];
            }
        }
        if (items.length > 0) {
            this.itemSource().revertAll(items);
        }
    },
	registerImageList: function (images) {
		if (images && images.name() && !this._imageLists.hasOwnProperty(images.name())) {
			this._imageLists[images.name()] = images;
			images.addListener(this);
			this._assignImageList(images);
		}
	},
	unregisterImageList: function (images) {
		if (images && images.name() && this._imageLists.hasOwnProperty(images.name())) {
			delete this._imageLists[images.name()];
			images.removeListener(this);
			this._assignImageList(images, true);
		}
	},
	getImageList: function (imagesName) {
		return imagesName && this._imageLists[imagesName];
	},
	getListImage: function (images, index) {
		if (images instanceof ImageList) {
			return images.getImage(index);
		} else if (images) {
			images = this._imageLists[images];
			return images ? images.getImage(index) : null;
		}
	},
	_assignImageList: function (images, clear) {
        var columns = this.getDataColumns();
        for (var i = 0, cnt = columns.length; i < cnt; i++) {
			var col = columns[i];
			if (col.imageList() == images.name()) {
				col._images = clear ? null : images;
			}
		}
	},
	getImage: function (url) {
		return this._container.getImage(url);
	},
	getSummarizer: function () {
		return null;
	},
	getSummary: function (field, value) {
		var ds = this.dataSource();
		value = value && value.trim().toLowerCase();
		if (value && ds) {
			var summarizer = this.getSummarizer();
			if (summarizer) {
				var fld = isNaN(field) ? ds.getFieldIndex(field) : field;
				if (fld >= 0 && fld < ds.fieldCount()) {
					switch (value) {
						case "count":
							return summarizer.getCount(fld);
						case "sum":
							return summarizer.getSum(fld);
						case "max":
							return summarizer.getMax(fld);
						case "min":
							return summarizer.getMin(fld);
						case "avg":
							return summarizer.getAvg(fld);
						case "var":
							return summarizer.getVar(fld);
						case "varp":
							return summarizer.getVarp(fld);
						case "stdev":
							return summarizer.getStdev(fld);
						case "stdevp":
							return summarizer.getStdevp(fld);
						case "datacount":
							return summarizer.getDataCount(fld);
						case "dataavg":
							return summarizer.getDataAvg(fld);
					}
				}
			}
		}
		return NaN;
	},
	orderBy: function (columns, directions, textCases) {
		if (this.isItemEditing(null)) {
			return;
		};
		var labelComparer = {};
		if (!columns || columns.length < 1) {
			this.setLabelComparer(labelComparer);
			this._sortItems([], [], []);
		} else {
			var	flds = [];
			var	dirs = [];
            var cases = [];
            var	cnt = columns.length;
            var column;
			for (var i = 0; i < cnt; i++) {
				column = columns[i];
				flds.push(column.dataIndex());
				if (column.isSortByLabel() && column.isLookupDisplay()) {
					labelComparer[column.dataIndex()] = new ColumnLabelComparer(column);
				};
			}
			if (directions) {
				dirs = directions.concat();
			}
            if (textCases) {
                cases = textCases.concat();
            }
			this.setLabelComparer(labelComparer);
			this._sortItems(flds, dirs, cases);
		}
	},
	orderByFields: function (fieldNames, directions, textCases) {
		if (this.isItemEditing(null)) {
			return;
		}
		var labelComparer = {};
		var columns;
		var column;
		if (!fieldNames || fieldNames.length < 1) {
			this.setLabelComparer(labelComparer);
			this._sortItems([], [], []);
		} else {
			var	cnt = fieldNames.length;
			var	ds = this.dataSource();
			var	flds = [];
			var	dirs = [];
            var cases = [];
            var i, f, fld;
			for (i = 0; i < cnt; i++) {
				f = Number(fieldNames[i]);
				fld = isNaN(f) ? ds.getFieldIndex(fieldNames[i]) : f;
				columns = this.columnsByFieldName(fieldNames[i]);
				column = columns && columns.length == 1 && columns[0];
				column instanceof DataColumn && column.isSortByLabel() && column.isLookupDisplay() && (labelComparer[fld] = new ColumnLabelComparer(column));
				flds.push(fld);
			}
			if (directions) {
				dirs = directions.concat();
			}
            if (textCases) {
                cases = textCases.concat();
            }
			this.setLabelComparer(labelComparer);
			this._sortItems(flds, dirs, cases);
		}
	},
	sortColumn: function (column, event) {
		if (column) {
			if (this.sortingOptions().style() == SortStyle.EXCLUSIVE) {
				( event && event.shiftKey) ? this.sortColumnWithStyle(SortStyle.INCLUSIVE, column) : this.sortColumnWithStyle(SortStyle.EXCLUSIVE, column);
			} else {
				this.sortColumnWithStyle(this.sortingOptions().style(), column);
			}
		}
	},
	unsortColumn: function (column) {
		if (column) {
			this.unsortColumnWithStyle(this.sortingOptions().style(), column);
		}
	},
	$$_addSort: function (column, dir, textCase, reverse) {
		var field = column.dataIndex();
		var flds = this.getSortFields();
		var	dirs = this.getSortDirections();
        var cases = this.getSortCases();
        var labelComparer = this.getLabelComparer();
		var	idx = -1;
		var	cnt = flds.length;
		for (var i = 0; i < cnt; i++) {
			if (flds[i] == field) {
				idx  = i;
				break;
			}
		}
		if (idx >= 0) {
			dirs[idx] = dir;
            cases[idx] = textCase;
		} else if (reverse) {
			flds.splice(0, 0, field);
			dirs.splice(0, 0, dir);
            cases.splice(0, 0, textCase);
		} else {
			flds.push(field);
			dirs.push(dir);
            cases.push(textCase);
		};
		if (column.isSortByLabel() && column.isLookupDisplay()) {
			if (!labelComparer[field]) {
				labelComparer[field] = new ColumnLabelComparer(column);
			}
		} else {
			delete labelComparer[field]
		};
		this._sortItems(flds, dirs, cases);
	},
	sortColumnWithStyle: function (sortStyle, column) {
		if (this.isItemEditing(null)) {
			return;
		}
		if (!column) {
			throw new Error("column is null");
		}
		if (column.dataIndex() < 0) {
			return;
		}
        var sortCase = this._sortingOptions.textCase();
		if (sortStyle == SortStyle.EXCLUSIVE) {
			if (column.sortOrder() < 0) {
				this.orderBy([column], [SortDirection.ASCENDING], [sortCase]);
			} else if (column.sortDirection() == SortDirection.ASCENDING) { 
				this.orderBy([column], [SortDirection.DESCENDING], [sortCase]);
			} else if (this.isGroupedColumn(column) && this._items._groupSorting) {
				this.orderBy([column], [SortDirection.ASCENDING], [sortCase]);
			} else {
				this.unsortColumnWithStyle(sortStyle, column);
			}
		} else if (sortStyle == SortStyle.INCLUSIVE || sortStyle == SortStyle.REVERSE) {
			if (column.sortOrder() < 0) {
				this.$$_addSort(column, SortDirection.ASCENDING, sortCase, sortStyle == SortStyle.REVERSE);
			} else if (column.sortDirection() == SortDirection.ASCENDING) { 
				this.$$_addSort(column, SortDirection.DESCENDING, sortCase, sortStyle == SortStyle.REVERSE);
			} else if (this.isGroupedColumn(column) && this._items._groupSorting) {
				this.$$_addSort(column, SortDirection.ASCENDING, sortCase, sortStyle == SortStyle.REVERSE);
			} else {
				this.unsortColumnWithStyle(sortStyle, column);
			}
		}
	},
	unsortColumnWithStyle: function (sortStyle, column) {
		if (this.isItemEditing(null)) {
			return;
		}
		if (!column) {
			return;
		}
		var	flds = this.getSortFields();
		var	dirs = this.getSortDirections();
        var cases = this.getSortCases();
        var labelComparer = this.getLabelComparer();
		var	idx = -1;
		var	cnt = flds.length;
		for (var i = 0; i < cnt; i++) {
			if (flds[i] == column.dataIndex()) {
				idx  = i;
				break;
			}
		}
		if (idx < 0) {
			return;
		}
		if (sortStyle == SortStyle.EXCLUSIVE) {
			this.orderBy([], [], []);
		} else if (sortStyle == SortStyle.INCLUSIVE || sortStyle == SortStyle.REVERSE) {
			flds.splice(idx, 1);
			dirs.splice(idx, 1);
            cases.splice(idx, 1);
            delete labelComparer[column.dataIndex()]
			this._sortItems(flds, dirs, cases);
		}
	},
    canFiltering: function () {
        return this._fireFiltering();
    },
    applyFilters: function (filterCollection, filter) {
        if (this.isItemEditing(null)) {
            return false;
        }
        if (this._fireFiltering()) {
            this._toastManager.show(this.filteringOptions().toast(), true, function () {
                this.$_doApplyFilters(filterCollection, filter);
            }.bind(this));
            return true;
        }
        return false;
    },
    $_doApplyFilters: function (filterCollection, filter) {
    	var applyCnt = this._items.itemCount();
        this._items.beginFiltering();
        try {
        	this._filterRunning = true;
            this._items.clearAllFilters();
            this.$_addFilters(this._rootColumn);
        } finally {
            this._items.endFiltering(filterCollection, filter);
            this._filterRunning = false;
        }
        applyCnt !== this._items.itemCount() && this.setTopIndex(0, true);
    },
    $_addFilters: function (group) {
        var c;
        var column;
        var dc;
        var filters;
        var i;
        var n;
        var filter;
        var cnt = group.count();
        for (c = 0; c < cnt; c++) {
            column = group.getItem(c);
            if (column instanceof DataColumn) {
                filters = column.filters();
                if (filters) {
                    n = filters.length;
                    for (i = 0; i < n; i++) {
                        filter = filters[i];
                        if (filter.isActive()) {
                            // this._items.addFilter(column.dataIndex(), filter.criteria());
                            this._items.addFilter(column.dataIndex(), filter);
                        }
                    }
                }
            } else if (column instanceof ColumnGroup) {
                this.$_addFilters(column);
            }
        }
    },
    isFiltered: function (column) {
    	return this._items.isFiltered(column && column.dataIndex());
    },
	isGroupedColumn: function (column) {
		return false;
	},
	getGroupLevel: function (field) {
		return -1;
	},
	getGroupLevels: function () {
		return 0;
	},
	clearColumnMergeGrouped: function () {
		this._rootColumn.clearMergeGrouped();
	},
	$_makeRowInView: function (row) {
		var r;
		var cnt;
		var lm = this.layoutManager();
		if (row >= lm.fixedItemCount()) {
			r = row;
			cnt = lm.fullItemCount();
			if (cnt == 0) {
				if (lm.itemCount() > 0) {
					this.setTopItem(r);
				} else {
					this.seTopIndex(0);
				}
			} else {
				if (r >= this.topItem() && r < this.topItem() + cnt) {
					return;
				}
				if (r >= this.topItem() + cnt) {
					r = r - cnt + 1;
				}
				this.setTopItem(Math.max(0, r));
			}
		}
	},
	$_makeColumnInView: function (column) {
		var c;
		var x;
		var dx;
		var lm = layoutManager();
		var root = column.root();
		var col = root.displayIndex();
		if (col >= lm.fixedColCount()) {
			x = lm.columnBounds(col).x;
			c = column;
			while (c != root) {
				x += c.displayOffset();
				c = c.parent();
			}			
			if (x < this.leftPos()) {
				this.setLeftPos(x);
			} else if ((dx = (x + column.displayWidth() - this.leftPos()) - lm.nonfixedBounds().width) > 0) {
				this.setLeftPos(Math.min(x, this.leftPos() + dx));
			}
		}
	},
    makeColumnVisible: function (column) {
        var index = this.getIndex(-1, column);
        this.makeCellVisible(index);
    },
    makeItemVisible: function (itemIndex) {
        var index = this.getIndex(itemIndex, null);
        this.makeCellVisible(index, true);
    },
	makeCellVisible: function (index, force) {
		if (force) {
            this.layoutManager().makeCellVisible(index);
            this.invalidateLayout();
		} else if (this.isValid(index)) {
			if (!this.layoutManager().cellIsVisible(index)) {
				this.layoutManager().makeCellVisible(index);
				this.invalidateLayout();
			}
		} else if (index && index.column()) {
            this.layoutManager().makeCellVisible(index);
            this.invalidateLayout();
        }
		/*
		if (this._layouted) {
			if (!force && this._layoutNeeded) {
				this._focusNeededIndex.assign(index);
				this._focusNeeded = true;
				return;
			}
			if (this.isValidRow(index)) {
				this.$_makeRowInView(index.I());
			}
			if (this.isValidColumn(index)) {
				this.$_makeColumnInView(index.column());
			}
		}
		*/
	},
	copyToClipboard: function (event, range, force) {
		var item, isSingle;
		var index = this.focusedIndex();
		if (force || this._copyOptions.isEnabled()) {
			if (!force) {
				var selections = this.selections();
				isSingle = this._copyOptions.isSingleMode() || selections.count() == 0 || selections.isSingleCell()
				item = isSingle ? new BlockSelection(selections, index, index) : selections.getItem(0);
				force = this._fireCopy(item, event);
			}
			if (force) {
				return isSingle ? this._clipboardManager.copyCellToClipboard(index) : this._clipboardManager.copyToClipboard(range || item.getBounds());
			} else {
				return null;
			};
		}
		return this._clipboardManager.copyEmptyToClipboard();
	},
	toClipboard: function (selection, copy) {
		if (this.isEmpty()) {
			return;
		}
		if (!selection || !(selection instanceof GridRange)) {
			var startColumn;
			var endColumn;
			if (selection) {
				startColumn = selection.startColumn ? this.columnByName(selection.startColumn) : this.getVisibleColumn(0);
				endColumn = selection.endColumn ? this.columnByName(selection.endColumn) : this.getVisibleColumn(this.visibleColumnCount()-1);
			} else {
				startColumn = this.getVisibleColumn(0);
				endColumn = this.getVisibleColumn(this.visibleColumnCount()-1);
			};
			if (!startColumn || !endColumn) {
				return;
			}
			selection = selection || {};
			var startItem = selection.startItem == null ? 0 : Math.max(0, selection.startItem);
			var endItem = selection.endItem == null ? this.itemCount()-1 : Math.min(selection.endItem, this.itemCount()-1);
			selection = GridRange.createRange(startItem, startColumn, endItem, endColumn);
		}
		var text = this.copyToClipboard(null, selection, true);
		text = text == null ? "" : text;
		if (copy) {
			if (window.clipboardData) {
				window.clipboardData.setData('text', text);
			} else {
				var area = document.createElement('textarea');
				document.body.appendChild(area);
				area.value = text;
				area.select();
				document.execCommand('copy');
				setTimeout(function() {
					document.body.removeChild(area);
					area = null;	
				}, 100)
				
			};
		} else {
			return text;
		}
	},
	pasteFromClipboard: function (data, event) {
		var index = this.focusedIndex().clone();
		index.normalize(this);
		if (!this.isValid(index) || !index.dataColumn()) {
			return;
		}
		if (this._pasteOptions.isEnabled() && this._firePaste(index, event)) {
			try {
				if (this._pasteOptions.isSingleMode()) {
					this._clipboardManager.pasteCellFromClipboard(index, data);
				} else {
					var noDataEvent = this._pasteOptions.isNoDataEvent();
					this._clipboardManager.pasteFromClipboard(index, data, noDataEvent);
					if (index.item() && ItemState.isEditing(index.item().itemState())) {
						var v = index.item().getData(index.dataField());
						this.validateCellCommit(index, v);
						this.refreshView();
					}
				}
				this._editController.reprepareEditor(index);
				this._firePasted();
			} catch (err) {
                if (err instanceof ValidationError) {
                	err = this._fireValidationFail(this._clipboardManager._appendingIndex.itemIndex(), err.column, err);
					err ? alert(this._editOptions.isShowOnlyValidationMessage() && err.userMessage ? err.userMessage : err.toString()) : null;
                }
                throw err;
			}
		}
	},
	$_editRowPasted: function (item, fields, oldValues, newValues) {
		this._fireEditItemPasted(item, fields, oldValues, newValues)
	},
	$_rowsPasted: function (items) {
		this._fireItemsPasted(items);
	},
	$_cellPasting: function (index, value) {
		return this._fireCellPasting(index, value);
	},
	selectColumnFilters: function (columnView) {
		if (this.isItemEditing(null)) {
			return;
		}
        if (this._fireFiltering()) {
            this._filterSelector.show(columnView, this.filteringOptions().selector());
        }
	},
	closeFilterSelector: function () {
		this._filterSelector.hide();
	},
	closePopups: function () {
		this._filterSelector.hide();
		this._popupMenuManager.close();
		this._editController.closeList();
	},
    closePopups2: function () {
        this._popupMenuManager.close();
        this._editController.closeList();
    },
	isFilterSelecting: function (column) {
		return this._filterSelector.isOpened() && this._filterSelector.column() === column;
	},
	getCellValue: function (itemIndex, field) {
    	var item = this.getItem(itemIndex);
    	if (item) {
        	if (typeof field == "string") {
            	var dataProvider = this.itemSource().dataSource();
            	if (!dataProvider) {
            		return undefined;
            	}
            	field = dataProvider.getFieldIndex(field);
        	}
        	return item.getData(field);
    	}
    	return undefined;
	},
	setCellValue: function (itemIndex, field, newValue) {
    	var item = this.getItem(itemIndex);
    	if (item) {
        	if (typeof field == "string") {
            	var dataProvider = this.itemSource().dataSource();
            	if (!dataProvider) {
            		return;
            	}
            	field = dataProvider.getFieldIndex(field);
        	}
        	if (item instanceof EditItem || item instanceof TreeEditItem) {
        		item.setValue(field, newValue);
        	} else {
        		item.setData(field, newValue);
        	}
    	}
	},
	getEditCellValue: function () {
		if (this.isEditing()) {
			return this._editController._editor._editor.value;
		}
	},
	setEditCellValue: function(value, startEdit, dropdown) {
		if (this.isEditing() || startEdit) {
			this._editController._editor && this._editController._editor.setCellEditValue(value, dropdown);
		}
	},
	searchItem: function (fields, values, options/* SearchOptions */, startItem, wrap, select) {
		startItem = arguments.length > 3 ? startItem : 0;
		wrap = arguments.length > 4 ? wrap : true;
		select = arguments.length > 5 ? select : false;
		options = options instanceof SearchOptions ? options : options ? new SearchOptions(options) : null;
		var itemSource;
		var result = -1;
		if (fields && fields.length > 0 && values && values.length > 0 && (itemSource = this.itemSource())) {
			var c, n, f, index;
			var cnt = fields.length;
			var flds = [];
			var dataSource = itemSource.dataSource();
			for (c = 0; c < cnt; c++) {
				n = parseFloat(fields[c]);
				if (!isNaN(n) && n | 0 == n) {
					flds.push(n);
				} else {
					f = dataSource.getFieldIndex(fields[c]);
					if (f >= 0) {
						flds.push(f);
					}
				}
			}
			if (flds.length > 0) {
				cnt = itemSource.itemCount();
				startItem = Math.max(0, startItem);
				result = startItem < cnt ? itemSource.findItem(flds, values, options, startItem, cnt - 1) : -1;
				if (result < 0 && wrap && startItem > 0) {
					result = itemSource.findItem(flds, values, options, 0, startItem - 1);
				}
			}
			if (result >= 0 && select) {
				index = this.getIndex(result, _pick(this.focusedIndex().C(), this.getFirstColumn()));
				this.setFocusedIndex(index, true, true);
			}
		}
		return result;
	},
	searchCell: function (searchFields, value, options/* SearchCellOptions */, startItem, startFieldIndex, wrap, select) {
		startItem = arguments.length > 3 ? startItem : 0;
		startFieldIndex = arguments.length > 4 ? startFieldIndex : 0;
		wrap = arguments.length > 5 ? wrap : true;
		select = arguments.length > 6 ? select : false;
		options = options instanceof SearchCellOptions ? options : options ? new SearchCellOptions(options) : null;
		var fields = searchFields && _isArray(searchFields) && searchFields.concat();
		var itemSource = this.itemSource();
		var result = null;
        var dataSource = itemSource && itemSource.dataSource();
        var columns, col, fldName;
		if (!fields && (columns = options.columns)) {
			fields = [];
			for (var i = 0, cnt = columns.length; i < cnt ; i++) {
				col = this.columnByName(columns[i]);
				if (col instanceof DataColumn) {
					fldName = col.getField() && col.getField().orgFieldName();
					if (!fldName) {
						throw new Error("invalid field name");
					}
					fields.push(fldName);
				} else {
					throw new Error("invalid search Column "+ columns[i]);
				}
			}
		}
		if (dataSource) {
			if (!fields || fields.length < 1) {
				fields = [];
				var arr = dataSource.getFields();
				for (var i = 0; i < arr.length; i++) {
					fields.push(arr[i].orgFieldName());
				}
			}
			if (fields && fields.length > 0 && value != null) {
				var c, n;
				var cnt = fields.length;
				var flds = [];
				for (c = 0; c < cnt; c++) {
					n = parseFloat(fields[c]);
					if (!isNaN(n) && n | 0 == n) {
						flds.push(n);
					} else {
						flds.push(dataSource.getFieldIndex(fields[c]));
					}
				}
				if (flds.length > 0) {
					cnt = itemSource.itemCount();
					startItem = Math.max(0, startItem);
					startFieldIndex = Math.max(0, startFieldIndex);
					result = startItem < cnt ? itemSource.findCell(flds, value, options, startItem, cnt - 1, startFieldIndex) : null;
					if (!result && wrap && startItem > 0) {
						result = itemSource.findCell(flds, value, options, 0, startItem - 1, 0);
					}
					if (result) {
						result.fieldName = dataSource.getOrgFieldName(result["fieldIndex"]);
					}
				}
				if (result && select) {
					var index;
					if (columns) {
						index = this.getIndex(result.itemIndex, _pick(this.columnByName(columns[result.searchFieldIndex]), this.focusedIndex().C()));
					} else {
						index = this.getIndex(result.itemIndex, _pick(this.columnByField(result.fieldIndex), this.focusedIndex().C()));
					}
					index && this.setFocusedIndex(index, true, true);
				}
			}
		}
        return result;
	},
	$_setDataCellStyle: function (ds, row, field, style) {
		var f;
		var r = Math.max(-1, row); // TODO: -1이면 추가 중인 행에 적용한다.
		if (typeof field === "string") {
			f = ds.getFieldIndex(field);
			if (f < 0) return;
		} else {
			f = field; // -1 이면 모든 필드에 적용한다.
		}
		this.itemSource().setCellStyle(r, f, style);
	},
	setDataCellStyle: function (dataRow, field, styleId, updateNow) {
		var style = styleId ? this._dataCellStyles.get(styleId) : null;
		this.$_setDataCellStyle(this.dataSource(), dataRow, field, style);
		if (updateNow) {
            var idx = this.focusedIndex();
            if (idx) {
				if (idx.dataField() == field && idx.dataRow() == dataRow) {
					this._editController.reprepareEditor(this.focusedIndex());
				}
            }
			this.invalidateLayout();
		}
	},
	getDataCellStyle: function (dataRow, field) {
		return this.itemSource().getCellStyle(dataRow, this.dataSource().getFieldIndexOf(field));
	},
	getDataCellStyleId: function (dataRow, field) {
		var style = this.itemSource().getCellStyle(dataRow, this.dataSource().getFieldIndexOf(field));
		return style ? style.id() : null;
	},
	setDataCellStyles: function (dataRows, fields, styleId) {
		var r, cnt, f, cnt2;
		var ds = this.dataSource();
		var rows = _asArray(dataRows);
		var flds = _asArray(fields);
		var style = styleId ? this._dataCellStyles.get(styleId) : null;
		if (rows && flds) {
			cnt2 = flds.length;
			for (r = 0, cnt = rows.length; r < cnt; r++) {
				for (f = 0; f < cnt2; f++) {
					this.$_setDataCellStyle(ds, rows[r], flds[f], style);
				}
			}
		} else if (rows) {
			for (r = 0, cnt = rows.length; r < cnt; r++) {
				this.$_setDataCellStyle(ds, rows[r], fields, style);
			}
		} else if (flds) {
			for (f = 0, cnt = flds.length; f < cnt; f++) {
				this.$_setDataCellStyle(ds, dataRows, flds[f], style);
			}
		} else {
			this.$_setDataCellStyle(ds, dataRows, fields, style);
		}
        this._editController.reprepareEditor(this.focusedIndex());
		this.invalidateLayout();
	},
	setDataCellStyleRows: function (rows, fieldMap) {
		this.itemSource().setCellStyles(this._dataCellStyles, rows, fieldMap);
		this._editController.reprepareEditor(this.focusedIndex());
		this.invalidateLayout();
	},
	clearDataCellStyles: function () {
		this.itemSource().clearCellStyles();
		this._editController.reprepareEditor(this.focusedIndex());
		this.invalidateLayout();
	},
	setCellWritable: function (index, value) {
		var dataRow = index.dataRow();
		var column = index.column().$_hash;
		var name;
		for (var attr in value) {
			name = "setCell"+_capitalize(attr);
			var setter = this.itemSource()[name];
			setter && setter.call(this.itemSource(), dataRow, column, value[attr]);
		}
		if (!this.isEditing(index) && CellIndex.areEquals(this.focusedIndex(), index)) {
			this.reprepareEditor();
		};
	},
	getCellEditable: function(index) {
		var dataRow = index.dataRow();
		var column = index.column().$_hash;
		return this.itemSource().getCellEditable(dataRow, column);
	},
	getCellReadOnly: function(index) {
		var dataRow = index.dataRow();
		var column = index.column().$_hash;
		return this.itemSource().getCellReadOnly(dataRow, column);
	},
	getCellWritable: function(index) {
		var editable = this.getCellEditable(index);
		var readOnly = this.getCellReadOnly(index);
		if (editable == null && readOnly == null) {
			return undefined;
		}
		return (editable == null || editable) && !readOnly;
	},
	getCellCursor: function(index) {
		var dataRow = index.dataRow();
		var column = index.column().$_hash;
		return this.itemSource().getCellCursor(dataRow, column);
	},
	getCellEditor: function(index) {
		var dataRow = index.dataRow();
		var column = index.column().$_hash;
		var editor = this.itemSource().getCellEditor(dataRow, column);
		return editor && (typeof editor === "string" ? editor : (editor.type||"text"));
	},
	getCellEditorOptions: function (index) {
		var dataRow = index.dataRow();
		var column = index.column().$_hash;
		var editor = this.itemSource().getCellEditor(dataRow, column);
		return editor && (typeof editor === "string" ? null : editor);
	},
	clearEditableMap: function() {
		if (this.itemSource().clearEditableMap() && !this.isEditing()) {
			this.reprepareEditor();
		}
	},
	getStylesOf: function (region) {
		var map = this._styleMap;
		if (!map) {
			map = this._styleMap = {};
            map[GridStyleSheet.GRID] = map[GridStyleSheet.DEFAULT] = this.styles();
			map[GridStyleSheet.PANEL] = this._panel.styles();
			map[GridStyleSheet.BODY] = this._body.styles();
			map[GridStyleSheet.BODY_EMPTY] = this._body.emptyStyles();
			map[GridStyleSheet.BODY_ROWHOVER] = this._body.rowHoverStyles();
			map[GridStyleSheet.BODY_ROWFOCUS] = this._body.rowFocusStyles();
			map[GridStyleSheet.FIXED] = this._fixedOptions.styles();
			map[GridStyleSheet.FIXED_COLBAR] = this._fixedOptions.colBarStyles();
			map[GridStyleSheet.FIXED_ROWBAR] = this._fixedOptions.rowBarStyles();
			map[GridStyleSheet.HEADER] = this._header.styles();
			map[GridStyleSheet.HEADER_GROUP] = this._header.groupStyles();
			map[GridStyleSheet.FOOTER] = this._footer.styles();
			map[GridStyleSheet.FOOTER_GROUP] = this._footer.groupStyles();
			map[GridStyleSheet.ROWGROUP_HEADER] = this._rowGroup.headerStyles();
			map[GridStyleSheet.ROWGROUP_FOOTER] = this._rowGroup.footerStyles();
			map[GridStyleSheet.ROWGROUP_HEAD] = this._rowGroup.headStyles();
			map[GridStyleSheet.ROWGROUP_FOOT] = this._rowGroup.footStyles();
			map[GridStyleSheet.ROWGROUP_SUMMARY] = this._rowGroup.summaryStyles();
			map[GridStyleSheet.ROWGROUP_BAR] = this._rowGroup.barStyles();
			map[GridStyleSheet.ROWGROUP_HEADER_BAR] = this._rowGroup.headerBarStyles();
			map[GridStyleSheet.ROWGROUP_FOOTER_BAR] = this._rowGroup.footerBarStyles();
			map[GridStyleSheet.ROWGROUP_PANEL] = this._rowGroup.panelStyles();
			map[GridStyleSheet.INDICATOR] = this._indicator.styles();
			map[GridStyleSheet.INDICATOR_HEAD] = this._indicator.headStyles();
			map[GridStyleSheet.INDICATOR_FOOT] = this._indicator.footStyles();
			map[GridStyleSheet.INDICATOR_SUMMARY] = this._indicator.summaryStyles();
			map[GridStyleSheet.CHECKBAR] = this._checkBar.styles();
			map[GridStyleSheet.CHECKBAR_HEAD] = this._checkBar.headStyles();
			map[GridStyleSheet.CHECKBAR_FOOT] = this._checkBar.footStyles();
			map[GridStyleSheet.CHECKBAR_SUMMARY] = this._checkBar.summaryStyles();
			map[GridStyleSheet.STATEBAR] = map["statusBar"] = this._stateBar.styles();
			map[GridStyleSheet.STATEBAR_HEAD] = map["statusBarHead"] = this._stateBar.headStyles();
			map[GridStyleSheet.STATEBAR_FOOT] = map["statusBarFoot"] = this._stateBar.footStyles();
			map[GridStyleSheet.STATEBAR_SUMMARY] = map["statusBarSummary"] = this._stateBar.summaryStyles();
			map[GridStyleSheet.SELECTION] = this._selectOptions.maskStyles();
			map[GridStyleSheet.SCROLLBAR] = this._displayOptions.scrollBarStyles();
			map[GridStyleSheet.SCROLLTHUMB] = this._displayOptions.scrollThumbStyles();
			map[GridStyleSheet.SCROLLBUTTON] = this._displayOptions.scrollButtonStyles();
			if (this._treeOptions) {
				map[GridStyleSheet.TREE_EXPANDER] = this._treeOptions.expanderStyles();
			}
		}
		if(region == "all"){
			return map;
		}else{
			return map[region];			
		}
		
	},
	clearStyles: function (region) {
		var styles = this.getStylesOf(region);
		if(region == "all"){
			for(var style in styles){
				if(styles[style]) {
					styles[style].clearValues();
				}
			}
			this.refreshView();
		}else {
			if (styles) {
				styles.clearValues();
				this.refreshView();
			}
		}
	},
	alertCellError: function (cell, error) {
		this._fireErrorClicked(cell, error);
	},
	canMoveIndex: function (index) {
		var lm = this.layoutManager();
		return this.fixedOptions().isMovable() || (index >= lm.fixedColCount() && index < lm.rfixedStartCol());
	},
	canMoveToIndex: function (index) {
		var lm = this.layoutManager();
		return this._fixedOptions.isMovable() || (index >= lm.fixedColCount() && index < lm.rfixedStartCol());
	},
	showProgress: function (modal) {
		this._progressManager.show(null, null, modal);
	},
	setProgress: function (min, max, pos, msg) {
		this._progressManager.setProperties(min, max, pos, msg);
	},
	closeProgress: function () {
		this._progressManager.close();
	},
	beginExportProgress: function (msg) {
		this._progressManager.show(null, msg, false);
	},
	endExportProgress: function () {
		this._progressManager.close();
	},
	setExportProgress: function (max, pos, msg) {
		this._progressManager.setProperties(0, max, pos, msg);
	},
	measureText: function (font, text) {
		return this._container.measureText(font, text);
	},
	measureTextRect: function (font, text, x, y, w, h, align, layout, textWrap, rect) {
		return this._container.measureTextRect(font, text, x, y, w, h, align, layout, textWrap, rect);
	},
    setContextMenu: function (menuItems) {
        if (menuItems) {
			if (!this.$_contextMenuHandler) {
				this.$_contextMenuHandler = function (e) {
					var target = e.target || e.srcElement;
					var r = target.getBoundingClientRect();
					var x = e.clientX - r.left;
					var y = e.clientY - r.top;
					var element = this._container.findElementAt(x,y);
					var eltName = element && element.$name ? (element.$name+"").replace("Element","") : eltName;
					var _showContextMenu = this._fireContextMenuPopup(x, y, eltName);
					if (this._contextMenu) {
						e.preventDefault();
						if (_showContextMenu) {
							this._popupMenuManager.showContext(this._contextMenu, x, y);
						}
					}
				}.bind(this);
				if ($_evl) {
					this._container._canvas.addEventListener("contextmenu", this.$_contextMenuHandler);
				} else {
					this._container._canvas.attachEvent("contextmenu", this.$_contextMenuHandler);
				}
			}
			this._contextMenu = new PopupMenu("gridContextMenu", this, menuItems);
        } else {
            this._contextMenu = null;
            if (this.$_contextMenuHandler) {
				if ($_evl) {
					this._container._canvas.removeEventListener("contextmenu", this.$_contextMenuHandler);
				} else {
					this._container._canvas.detachEvent("contextmenu", this.$_contextMenuHandler);
				}
                this.$_contextMenuHandler = null;
            }
        }
		return this._contextMenu;
    },
	container: function () {
		return this._container;
	},
	addElement: function (element, context) {
		this._rootElement.addElement(element, context);
	},
	invalidate: function () {
		this._container.invalidate();
	},
	_beforeRender: function (bounds) {
		this._linesLayer.invalidate();
		/*
		var items = this._bodyView.children;
		if (items) {
			for (var i = 50; i < items.length; i++) {
				items[i]._nodraw = true;
			}
		}
		*/
	},
    $_setEditFocused: function (value,e) {
		// var hasCommit = false;
		// if (!value && !this.$_editFocused && (e.type == "focusout" || e.type == "blur")) {
		//  	var options = this.editOptions();
		//  	var editor = this._editController._editor;
		//  	if (editor && editor.isListing && editor.isListing()) {
		//  		hasCommit = false;
		//  	} else if (options._gridExitWhenCommit && (this.isItemEdited() ||this.isItemEditing())) {
		//     			hasCommit = true;
		//    	}	    	
		// }    		
        if (value != this.$_editFocused) {
            this.$_editFocused = value;
            if (value) {
                var index = this.focusedIndex();
                if (!index || !this.isValid(index)) {
                    index = this.getFirstCell();
                    index && this.setFocusedIndex(index);
                }
            }
        };
        value && e.type == "focusin" && Dom.isAncestorOf(this._container._container, e.target) && $_setActiveGrid(this);
        // if (hasCommit) {
        // 	this.commit(false,true);
        // }
    },
	_resetFocusMask: function () {
		var lm = this._layoutManager;
		var r = lm.gridBounds();
		var item = this._focusedIndex.item();
		var cell = this.getFocusedCellView();
		if (lm.isRowGrouped() && !this.isMergedRowGrouped() && !(item instanceof GridRow)) {			
			r.setLeft(lm.rowGroupBounds().x);
		} else if (this.isValid(this._focusedIndex) && (lm.fixedColCount() > 0 || lm.rfixedColCount() > 0) && (cell instanceof DataCellElement || (item instanceof GroupItem) || (item instanceof GroupFooter))) {			
			var col = this._focusedIndex.column().root().displayIndex();
			if (item instanceof MergedGroupFooter || item instanceof MergedGroupHeader) {

			} else if (col < lm.fixedColCount()) {
				r.copyHorz(lm.fixedBounds());
			} else if (col >= lm.rfixedStartCol()) {
				r.copyHorz(lm.rfixedBounds());
			} else {
				r.copyHorz(lm.nonfixedBounds());
			}
		}
		this._focusLayer._mask = r;//lm.fixedBounds();// lm.nonfixedBounds();// lm.gridBounds();
	},
	_resetRowFocusMask: function () {
		var lm = this._layoutManager;
		var r = lm.gridBounds();
		switch (this.displayOptions().rowFocusMask()) {
			case RowFocusMask.DATA : 
				r.width = lm.bodyBounds().right()+lm.rfixedWidth()-r.x;
				break;
			case RowFocusMask.FILL :
				r.setLeft(-r.x);
				break;
			default :
				r.width = lm.bodyBounds().right()+lm.rfixedWidth();
				r.x = 0;
				break;
		}
		this._rowFocusLayer._mask = r;//
	},
	_doDraw: function(g) {
		var r = this.clientRect();
		var displayOptions = this._displayOptions;
		var emptyStyles = this._body.emptyStyles();
		var fill = emptyStyles.background();
		var sysEmptybg = GridStyleSheet && GridStyleSheet.Default && GridStyleSheet.Default._bodyEmpty && GridStyleSheet.Default._bodyEmpty.background();
		g.clipRect(r);

		if (fill && (fill != sysEmptybg)) {
			this._hscrollBar && this._hscrollBar.isVisible() && (r.height -= ( isNaN(this._scrollBarHeight) ? 0 : this._scrollBarHeight));
			g.drawRectI(fill, null, r);
		}
		if (!this.isEmpty()) {
			/*
			 var styles = this._model.getStyles();
			 var fill = styles.getFill();
			 var stroke = styles.getStroke();
			 if (fill || stroke) {
			 var r = new Rectangle(0, 0, this.getWidth(), this.getHeight());
			 styles.deflateMargin(r);
			 g.drawRoundRectIWith(fill, stroke, r, styles.getBorderRadiuses(), -1);
			 }
			 */
			/*
			 var r = new Rectangle(0, 0, this.getWidth(), this.getHeight());
			 var fill = new SolidBrush("#ffff00");
			 g.drawRectI(fill, null, r);
			 var stroke = new SolidPen("#555555");
			 for (var row = 0; row < 32; row++) {
			 for (var col = 0; col < 20; col++) {
			 fill = new SolidBrush("#ffffff");
			 r = new Rectangle(col * 100, row * 21, 100, 21);
			 g.drawRectI(fill, null, r);
			 g.drawLineI(stroke, r.right() - 1, r.y, r.right() - 1, r.bottom());
			 g.drawLineI(stroke, r.x, r.bottom() - 1, r.right(), r.bottom() - 1);
			 g.drawText(null, new SolidBrush("#000000"), (row + this._topIndex) + "," + col, col * 100 + 2, row * 21 + 1);
			 }
			 }
			 */
		} else if ( displayOptions && displayOptions._showEmptyMessage && this._rootColumn.visibleCount() > 0 ){
			var r2 = this._bodyView.getBounds();
			r2.width = r.width;
			var font = emptyStyles.font();
			var color = emptyStyles.foreground();
			var text = displayOptions._emptyMessage;
			var align = emptyStyles.textAlignment();
			var line = emptyStyles.lineAlignment();
			line = line == Alignment.FAR ? "bottom" : line == Alignment.NEAR ? "top" : "middle";
			g.getExplicitTextRect(font, text, r2.x, r2.y, r2.width, r2.height, align, line, r2)
			r2.x -= emptyStyles.paddingLeft() , r2.y -= emptyStyles.paddingTop(), r2.width += emptyStyles.paddingLeft()+emptyStyles.paddingRight(), r2.height += emptyStyles.paddingTop()+emptyStyles.paddingBottom();
			g.drawTextRectExplicit(font, color, text, r2, align, line);
			// g.drawRect(null, emptyStyles.border(), r2);
		}
	},
	setFocus: function () {
        this._editController.setFocus(true);
        if ($$_activeGrid !== this) {
        	$_setActiveGrid(this);
        }
	},
	_isColumnsDirty: function () {
		return this._columnsDirty;
	},
	_isStylesDirty: function () {
		return this._stylesDirty;
	},
	_rootGroup: function () {
		return this._rootColumn;
	},
	_checkEditing: function () {
		if (this.itemSource() instanceof EditableItemProvider && this.itemSource().isEditing()) {
			throw "Item is editing";
		}
	},
	_focusHandler: function (event) {
		this._editController.setFocus();
	},
	_validateScrollBars: function () {
		this._hscrollBar && this._hscrollBar._mouseOut();
		this._vscrollBar && this._vscrollBar._mouseOut();
	},
	_addGroupView: function () {
		this.addElement(this._rowGroupView);
	},
	_addGridObject: function (obj) {
		this._gridObjects.push(obj);
	},
	_cleanGridObjects: function () {
		for (var i = 0, cnt = this._gridObjects.length; i < cnt; i++) {
			this._gridObjects[i].clean();
		}
		this._stylesDirty = false;
	},
	_visualObjectChanged: function (obj) {
		if (obj instanceof GridPanel) {
			this._panelView.invalidate();
		} else if (obj instanceof GridBody) {
			this._bodyView.invalidate();
		} else if (obj instanceof Indicator) {
			this._indicatorView.invalidate();
		} else if (obj instanceof StateBar) {
			this._stateBarView.invalidate();
		} else if (obj instanceof CheckBar) {
			this._checkBarView.invalidate();
		} else if (obj instanceof Header || obj instanceof HeaderSummary) {
			this._doHeaderSummaryMergeChanged(obj);
			this._headerView.invalidate();
		} else if (obj instanceof Footer) {
			this._doFooterMergeChanged(obj);
			this._footerView.invalidate();
		} else if (obj instanceof EditBar) {
		}
	},
	_doLayout: function (bounds) {
		this._resetting = false;
		try {
			this.$_doLayout(bounds);
		} finally {
			if (this._loading) {
				this._loading = false;
			}
			this._dataChanged = false;
			this._updateRows = null;
		}
		this._cleanGridObjects();
		if (this._columnsDirty) {
			this._columnsDirty = false;
			this._rootColumn.clean();
		}
		this._columnLayoutChanged = false;
		var lm = this.layoutManager();
		if (lm.itemCount() > 0) {
			var topIndex = lm.topIndex();
			var last = topIndex + lm.itemCount();
			if (topIndex != this._prevTopIndex) {
				setTimeout(function() {
					this._fireTopIndexChanged(topIndex);
				}.bind(this),0);
			}
			this._prevTopIndex = topIndex;

			if (last != this._prevLast && last == this.itemCount()) {
				setTimeout(function () {
					this._fireScrollToBottom();
				}.bind(this), 1);
			}
			this._prevLast = last;
		}
		this.$_checkCurrentRow();
	},
	$_doLayout: function (bounds) {
		trace(">>> GridBase.doLayout");
		var	cnt = this._rootColumn.visibleCount();
        var fixedCols = this.$_fixedColCount = this._fixedOptions.colCount();
        var rfixedCols = this.$_rfixedColCount = this._fixedOptions.rightColCount();
		var	b = this._body.styles();
		var	h = this._header.styles();
        var	gh = this._header.groupStyles();
        var sh = this._header.subStyles();
        var hs = this._header.summary().styles();
		var	f = this._footer.styles();
		var	def = b.sysDefault();
		var	hdef = h.sysDefault();
        var shdef = sh.sysDefault();
        var hsdef = hs.sysDefault();
		var	fdef = f.sysDefault();
        var rowGroup = this._rowGroup;
		var lm = this._layoutManager;
		var fl = lm.yU();
		var r = bounds.clone();
        var c, column, level;
        this.$_fixedRowCount = this._fixedOptions.rowCount();
        this.$_fixedColEditable = this._fixedOptions.isEditable();
        this.$_fixedRowEditable = this._fixedOptions.isRowEditable();
		this.$_editOptionsWritable = this._editOptions.isWritable();
		this._body._prepareUpdate();
		this.clearEditableMap();
		if (cnt < 1) {
			this._rootElement.setVisible(false);
			this._emptyView.setVisible(true);
			this._emptyView.setSize(r.width, r.height);
			this._emptyView.invalidate();
			return;
		}
		for (c = 0; c < cnt; c++) {
			column = this._rootColumn.getVisibleItem(c);
			column.prepare(this, c < fixedCols, c >= cnt - rfixedCols);
			column.styles().setSysDefault(def);
			if (column instanceof ValueColumn) {
				column.styles().setParent(b, false);
				column._header.styles().setParentAndDefault(h, hdef);
                column._header.subStyles().setParentAndDefault(sh, shdef);
                column._header.summary().styles().setParentAndDefault(hs, hsdef);
				column._footer.styles().setParentAndDefault(f, fdef);
				column.rendererObj().prepareRuntime(this);
				if (column instanceof DataColumn) {
				}
			} else if (column instanceof ColumnGroup) {
				this.$_setColumnGroupStyles(column, b, gh, h, sh, hs, f);
			}
		}
        for (c = 0, cnt = rowGroup.levelCount(); c < cnt; c++) {
            level = rowGroup.getLevel(c);
            level.headerStyles().setParent(rowGroup.headerStyles());
            level.footerStyles().setParent(rowGroup.footerStyles());
            level.barStyles().setParent(rowGroup.barStyles());
            level.headerBarStyles().setParent(rowGroup.headerBarStyles());
            level.footerBarStyles().setParent(rowGroup.footerBarStyles());
        }
		this._linesLayer.invalidate();
		if (this._columnWidthsDirty) {
			this._columnWidthsDirty = false;
			this.$_resetColumnWidths();
		}
		this._emptyView.setVisible(false);
		this._rootElement.setVisible(true);
		lm.setHeightMeasurer(this.heightMeasurer());
		lm.measure(r, this._leftPos, this._topIndex, this._displayOptions.isVscrollBar() ? this._scrollBarWidth : 0,this._displayOptions.isHscrollBar() ? this._scrollBarHeight : 0);
		this._topIndex = lm.topIndex();
		var leftPos = this._leftPos = lm.leftPos();
		lm.layout(r);
		/*$watermarkSize$*/
		if (this.activeTool()) {
			this.activeTool().layoutChanged();
		}
		this._updateScrollBars(lm, r);
		/*
		 var x = bounds.x;
		 var y = bounds.y;
		 var w = bounds.width;
		 var h = bounds.height;
		 var view = this._emptyView;
		 if (view.isVisible()) {
		 view.setBounds(x, y, w, h);
		 return;
		 }
		 view = this._panelView;
		 if (view && view.isVisible()) {
		 view.setBounds(x, y, w, this.getPanel().getMinHeight());
		 y += view.getHeight();
		 }
		 view = this._headerView;
		 if (view.isVisible()) {
		 view.setBounds(x, y, w, 25);
		 view.layoutContent(lm);
		 y += view.getHeight();
		 }
		 view = this._bodyView;
		 view.setBounds(x, y, w, h - y);
		 for (var i = 0; i < 20; i++) {
		 view.addItem(this._itemProvider.getItem(i));
		 }
		 view.layoutContent(lm);
		 */
		/*
		 var layout = this.getLayout();
		 if (layout) {
		 layout.layout(this, bounds);
		 }
		 */
		if (this._footerView.isVisible()) {
			if (lm.isRowGrouped() && leftPos > 0) {
				r = lm.footerBounds();
				r.x = leftPos;
				r.y = 0;
				this._footerView.setMask(r);
			} else {
				this._footerView.setMask(null);
			}
		}
		this._layoutSelectionViews();
		this._layouted = true;
		var cellView = this.getCellView(null, this._focusedIndex);
		if (cellView) {
			cellView.setFocused(true);
		}
		this._editController.resetEditor();
		if (this._debugView) {
			this._debugView.setBounds(0, 0, this._width, this._height);
			this._debugView.invalidate();
		}
		this._horzScrolling = false;
	},
	groupingOptionsChanged: function () {
		this._doGroupingOptionsChanged();
	},
	_doGroupingOptionsChanged: function () {
	},
	_createEmptyView: function (dom) {
		return new EmptyGridElement(dom);
	},
    _createPanelModel: function () {
        return new GridPanel(this);
    },
	_createPanelView: function (dom, panel) {
		return new PanelElement(dom, panel);
	},
    _createFooterModel: function () {
        return new Footer(this);
    },
    _createFooterView: function (dom, footer) {
        return new FooterElement(dom, footer);
    },
	_createBodyView: function (dom, body, fixed, rightFixed) {
		return new GridBodyElement(dom, body, fixed, rightFixed);
	},
	_createDelegate: function () {
		return new GridDelegate(this);
	},
	_createLayoutManager: function () {
		return new GridLayoutManager(this);
	},
    _createEditController: function () {
        return _isMobile() ? new MobileEditController(this) : new DefaultEditController(this);
    },
	_objectVisualChanged: function (object) {
		this._shadowDom && this._shadowDom.reset();
	},
	_columnIndexChanged: function (column) {
		this.clearSelection();
		this._resetColumnIndicies();
		this._resetFooterMerge();
		this._resetHeaderSummaryMerge();
		this.refreshView();
		this._shadowDom && this._shadowDom.setColumns(this, this.getLeafColumns());
	},
	_columnVisibleIndexChanged: function (column) {
		this.clearSelection();
		this._resetVisibleColumns();
		this._resetColumnPositions();		
		this._resetFooterMerge();
		this._resetHeaderSummaryMerge();
		this._populateMerges();
		this.refreshView();
		this._shadowDom && this._shadowDom.setColumns(this, this.getLeafColumns());
	},
    _columnCheckedChanged: function (column) {
        this._fireColumnCheckedChanged(column);
    },
	_dataColumnChanged: function (column) {
        !column._ignoreRefresh && this.refreshView();
		this._editController && this._editController.dataColumnChanged(column);
	},
	_updateScrollBars: function (lm, r) {
        /*
        if (this._dom) {
            this._hscrollBar && this._hscrollBar.setVisible(false);
            this._vscrollBar && this._vscrollBar.setVisible(false);
            return;
        }
        */
		if (lm._hscrollBar) {
			if (!this._hscrollBar) {
				this._hscrollBar = new ScrollBar(this._dom, false);
				this._scrollLayer.addElement(this._hscrollBar);
				this._hscrollBar.addListener(this);
			}
			var hMax = lm.bodyBounds().width;
			var hPage = Math.min(r.width - lm.gridBounds().x - lm.fixedWidth() - lm.rfixedWidth() - (lm._vscrollBar ? this._scrollBarWidth : 0), lm.columnsLength() - lm.leftPos());
			this._hscrollBar.setProperties(0, hMax, hPage);
			this._hscrollBar.setPosition(lm.leftPos());
			this._hscrollBar.setVisible(true);
		} else if (this._hscrollBar) {
			this._hscrollBar.setProperties(0, 0, 0);
			this._hscrollBar.setPosition(0);
			this._hscrollBar.setVisible(false);
		}
		if (lm._vscrollBar) {
			if (!this._vscrollBar) {
				this._vscrollBar = new ScrollBar(this._dom, true);
				this._scrollLayer.addElement(this._vscrollBar);
				this._vscrollBar.addListener(this);
			}
			var itemCount = this.itemCount();
			var vMax = itemCount - lm.fixedItemCount();
			var vPage = Math.min(lm.fullItemCount(), itemCount - lm.topIndex());
			this._vscrollBar.setProperties(0, vMax, vPage);
			this._vscrollBar.setPosition(lm.topIndex());
			this._vscrollBar.setVisible(true);
		} else if (this._vscrollBar) {
			this._vscrollBar.setProperties(0, 0, 0);
			this._vscrollBar.setPosition(0);
			this._vscrollBar.setVisible(false);
		}
		this._layoutScrollBars(lm, r);
	}, 
	_layoutScrollBars: function (lm, r) {
		this._scrollLayer.setBounds(r.x, r.y, r.width, r.height);
		var sw = this._displayOptions.isVscrollBar() ? this._scrollBarWidth : 0;
        var sh = this._displayOptions.isHscrollBar() ? this._scrollBarHeight : 0;
		var hbar = this._hscrollBar;
		var vbar = this._vscrollBar;
		if (lm._hscrollBar) {
			hbar.setBounds(r.x, r.bottom() - sh, r.width - (lm._vscrollBar ? sw : 0), sh);
			hbar.layoutContent(lm);
		};
		if (lm._vscrollBar) {
			vbar.setBounds(r.right() - sw, r.y, sw, r.height - (lm._hscrollBar ? sh : 0));
			vbar.layoutContent(lm);
		};
		if (lm._vscrollBar && lm._hscrollBar) {
			if (!this._scrollCorner) {
				this._scrollCorner = new ScrollCorner(this._dom);
				this._scrollLayer.addElement(this._scrollCorner);
				this._scrollCorner.addListener(this);
			}
			this._scrollCorner.setVisible(true)
			this._scrollCorner.setBounds(r.right() - sw, r.bottom() - sh, sw, sh);
		} else {
			this._scrollCorner && this._scrollCorner.setVisible(false);
		}
	},
	_addSelectionElement: function (view) {
		if (view && !this._selectionLayer.contains(view)) {
			this._selectionLayer.addElement(view, this._toolContext);
			return true;
		}
		return false;
	},
	_removeSelectionElement: function (view) {
		if (this._selectionLayer.contains(view)) {
			this._selectionLayer.removeElement(view);
			return true;
		}
		return false;
	},
	_addSelectionView: function (item) {
		var view = null;
		if (!this._selectionViews.get(item)) {
			view = this._delegate.borrowSelectionView(item);
			this._selectionViews.set(item, view);
			this._addSelectionElement(view);
		}
		return view;
	},
	_clearSelectionViews: function () {
		this._selectionViews.each(function (key, value) {
			this._removeSelectionElement(value);
			this._delegate.returnSelectionView(value);
		}.bind(this));
		this._selectionViews.clear();
	},
	_layoutSelectionViews: function () {
		if (!this._layouted || this._resetting) {
			return;
		}
		this._selectionViews.each(function (item, view) {
			var mobile = _isMobile();
			var lm = this.layoutManager();
			if (this._selections.isSingleCell() && !mobile) {
				view.setVisible(false);
			} else {
				var visible = false;
				var r = new Rectangle();
				if (item instanceof RowSelection) {
					visible = this.$_getSelectionRowsRect(lm, item, r);
				} else if (item instanceof ColumnSelection) {
					visible = this.$_getSelectionColumnsRect(lm, item, r);
				} else {
					visible = this.$_getSelectionRangeRect(lm, item, r);
				}
				view.setVisible(visible);
				if (view.isVisible()) {
					view._border.width() === 1 && (r.setLeft(r.x-1), r.setTop(r.y-1));
					view.setRectI(r);
					view.updateElement(item, mobile ? this._selectOptions.mobileStyles() : this._selectOptions.maskStyles());
					view.invalidate();
				}
			}
		}.bind(this));
	},
	$_getSelectionRowsRect: function (lm, item, r) {
		var range = item.getBounds();
		var fixed = lm.fixedItemCount();
		var t = this.topIndex();
		var r1, r2;
		var y;
		if (fixed > 0) {
			if (range.R1() >= t + fixed + lm.itemCount() || range.R2() < 0 || range.R1() >= fixed && range.R2() < t + fixed) {
				return false;
			}
			y = lm.fixedHeight() + this.fixedOptions().rowBarHeight();
			if (range.R1() < fixed) {
				r1 = lm.itemBounds(Math.max(0, range.R1()));
			} else {
				r1 = lm.itemBounds(Math.max(0, range.R1() - t));
				r1.y = Math.max(r1.y, y);
			}
			if (range.R2() < fixed) {
				r2 = lm.itemBounds(range.R2());
			} else if (range.R1() <= fixed && range.R2() < fixed+t) { // fixed 영역과 body영역에 겹쳐있을 때
				r2= lm.itemBounds(Math.min(fixed + t, fixed)-1);
			} else if (range.R2() >= t) {
				r2 = lm.itemBounds(Math.min(lm.itemCount() + fixed - 1, range.R2() - t));
				r2.y = Math.max(r2.y, y);
			} else {
				r2 = r1;
			}
		} else if (lm.itemCount() > 0) {
			if (range.R1() >= t + lm.itemCount() || range.R2() < t) {
				return false;
			}
			r1 = lm.itemBounds(Math.max(0, range.R1() - t));
			r2 = lm.itemBounds(Math.min(lm.itemCount() - 1, range.R2() - t));
		} else {
			return false;
		}
		r.copy(r1.union(r2));
		r.offset(0, lm.bodyBounds().y);
		r.setRight(lm.bodyBounds().right()+lm.rfixedWidth());
		return true;
	},
	$_getSelectionColumnsRect: function (lm, item, r) {
		var range = item.getBounds();
		var fixed = lm.fixedColCount();
		var rfixed = lm.rfixedColCount();
		var rstart = lm.rfixedStartCol();
		var r1, r2;
		var c1 = range.C1().root().displayIndex();
		var c2 = range.C2().root().displayIndex();
		var wbar = this.fixedOptions().colBarWidth();
		var r1 = lm.dataRootRect(range.C1());
		var r2 = lm.dataRootRect(range.C2());
		if (fixed > 0) {
			var x = lm.columnRect(fixed - 1).right();
			var fx = x + wbar;
			if (c1 >= fixed) {
				r1.setRight(Math.max(fx, r1.right()));
				r1.setLeft(Math.max(fx, r1.x));
			}
			if (c2 >= fixed) {
				r2.setRight(Math.max(c1 < fixed ? x : fx, r2.right()));
				r2.setLeft(Math.max(fx, r2.x));
			}
		}
		if (rfixed > 0) {
			var fx = lm.rfixedLeft();
			var x = fx + wbar;
			if (c1 < rstart) {
				r1.setRight(Math.min(fx, r1.right()));
				r1.setLeft(Math.min(c2 >= rstart ? x : fx, r1.x));
			}
			if (c2 < rstart) {
				r2.setRight(Math.min(fx, r2.right()));
				r2.setLeft(Math.min(fx, r2.x));
			}

		}
		r.setLeft(Math.min(r1.x, r2.x));
		r.setRight(Math.max(r1.right(), r2.right()));
		r2.setBottom(lm.itemRect(lm.itemCount() - 1).bottom());
		r.setTop(lm.headerBounds().y);
		r.setBottom(r2.bottom());
		return true;
	},
	$_getSelectionRangeRect: function (lm, item, r) {
		var tr = new Rectangle();
		if (!this.$_getSelectionRowsRect(lm, item, tr)) {
			return false;
		}
		r.setTop(tr.y);
		r.setBottom(tr.bottom()-1);
		this.$_getSelectionColumnsRect(lm, item, tr);
		r.setLeft(tr.x);
		r.setRight(tr.right()-1);
		return true;
	},
	initStyles: function () {
		var g = this.styles();
		var h = this.header().styles();
        var s = this.header().summary().styles();
		var f = this.footer().styles();
		this.panel().styles().setParent(g, false);
		this.body().styles().setParent(g, false);
		this.body().emptyStyles().setParent(g, false);
		this.body().rowHoverStyles().setParent(g, false);
		this.body().rowFocusStyles().setParent(g, false);
		this.fixedOptions().styles().setParent(g, false);
		this.fixedOptions().colBarStyles().setParent(g, false);
		this.fixedOptions().rowBarStyles().setParent(g, false);
		this.header().styles().setParent(g, false);
		this.header().groupStyles().setParent(g, false);
        this.header().subStyles().setParent(g, false);
        this.header().summary().styles().setParent(g, false);
		this.footer().styles().setParent(g, false);
		this.footer().groupStyles().setParent(g, false);
		this.indicator().styles().setParent(g, false);
		this.indicator().headStyles().setParent(h, false);
		this.indicator().footStyles().setParent(f, false);
        this.indicator().summaryStyles().setParent(s, false);
		this.checkBar().styles().setParent(g, false);
		this.checkBar().headStyles().setParent(h, false);
		this.checkBar().footStyles().setParent(f, false);
        this.checkBar().summaryStyles().setParent(s, false);
		this.stateBar().styles().setParent(g, false);
		this.stateBar().headStyles().setParent(h, false);
		this.stateBar().footStyles().setParent(f, false);
        this.stateBar().summaryStyles().setParent(s, false);
		this.rowGroup().headStyles().setParent(h, false);
		this.rowGroup().footStyles().setParent(f, false);
		this.rowGroup().summaryStyles().setParent(s, false);
		this.rowGroup().headerStyles().setParent(g, false);
		this.rowGroup().footerStyles().setParent(g, false);
		this.rowGroup().panelStyles().setParent(h, false);
		this.rowGroup().barStyles().setParent(this.rowGroup().headerStyles(), false);
		this.rowGroup().headerBarStyles().setParent(this.rowGroup().headerStyles(), false);
		this.rowGroup().footerBarStyles().setParent(this.rowGroup().footerStyles(), false);
		this.selectOptions().maskStyles().setParent(null, false);
		this.displayOptions().scrollBarStyles().setParent(null, false);
		this.displayOptions().scrollThumbStyles().setParent(null, false);
		this.displayOptions().scrollButtonStyles().setParent(null, false);
		s = GridStyleSheet.Default;
		this.styles().setSysDefault(s.getGrid(), false);
		this.panel().styles().setSysDefault(s.panel(), false);
		this.body().styles().setSysDefault(s.body(), false);
		this.body().emptyStyles().setSysDefault(s.bodyEmpty(), false);
		this.body().rowHoverStyles().setSysDefault(s.bodyRowHover(), false);
		this.body().rowFocusStyles().setSysDefault(s.bodyRowFocus(), false);
		this.fixedOptions().styles().setSysDefault(s.fixed(), false);
		this.fixedOptions().colBarStyles().setSysDefault(s.fixedColBar(), false);
		this.fixedOptions().rowBarStyles().setSysDefault(s.fixedRowBar(), false);
		this.header().styles().setSysDefault(s.header(), false);
		this.header().groupStyles().setSysDefault(s.headerGroup(), false);
        this.header().subStyles().setSysDefault(s.headerSub(), false);
        this.header().summary().styles().setSysDefault(s.headerSummary(), false);
		this.footer().styles().setSysDefault(s.footer(), false);
		this.footer().groupStyles().setSysDefault(s.footerGroup(), false);
		this.indicator().styles().setSysDefault(s.indicator(), false);
		this.indicator().headStyles().setSysDefault(s.indicatorHead(), false);
		this.indicator().footStyles().setSysDefault(s.indicatorFoot(), false);
        this.indicator().summaryStyles().setSysDefault(s.indicatorSum(), false);
		this.checkBar().styles().setSysDefault(s.checkBar(), false);
		this.checkBar().headStyles().setSysDefault(s.checkBarHead(), false);
		this.checkBar().footStyles().setSysDefault(s.checkBarFoot(), false);
        this.checkBar().summaryStyles().setSysDefault(s.checkBarSum(), false);
		this.stateBar().styles().setSysDefault(s.stateBar(), false);
		this.stateBar().headStyles().setSysDefault(s.stateBarHead(), false);
		this.stateBar().footStyles().setSysDefault(s.stateBarFoot(), false);
        this.stateBar().summaryStyles().setSysDefault(s.stateBarSum(), false);
		this.rowGroup().headStyles().setSysDefault(s.rowGroupHead(), false);
		this.rowGroup().footStyles().setSysDefault(s.rowGroupFoot(), false);
		this.rowGroup().summaryStyles().setSysDefault(s.rowGroupSummary(), false);
		this.rowGroup().headerStyles().setSysDefault(s.rowGroupHeader(), false);
		this.rowGroup().footerStyles().setSysDefault(s.rowGroupFooter(), false);
		this.rowGroup().panelStyles().setSysDefault(s.rowGroupPanel(), false);
		this.rowGroup().barStyles().setSysDefault(s.rowGroupBar(), false);
		this.rowGroup().headerBarStyles().setSysDefault(s.rowGroupHeaderBar(), false);
		this.rowGroup().footerBarStyles().setSysDefault(s.rowGroupFooterBar(), false);
		this.selectOptions().maskStyles().setSysDefault(s.selection(), false);
		this.displayOptions().scrollBarStyles().setSysDefault(s.scrollBar(),false);
		this.displayOptions().scrollThumbStyles().setSysDefault(s.scrollThumb(),false);
		this.displayOptions().scrollButtonStyles().setSysDefault(s.scrollButton(),false);
	},
	$_setColumnGroupStyles: function (group, styles, groupHeaderStyles, headerStyles, headerSubStyles, summaryStyles, footerStyles) {
		var	cnt = group.count();
		var	def = styles.sysDefault();
		var	headerDef = headerStyles.sysDefault();
        var	headerSubDef = headerSubStyles.sysDefault();
        var summaryDef = summaryStyles.sysDefault();
		var	footerDef = footerStyles.sysDefault();
		group.styles().setParent(styles, false);
		group.header().styles().setParentAndDefault(groupHeaderStyles, groupHeaderStyles.sysDefault());
		for (var i = 0; i < cnt; i++) {
			var column = group.getItem(i);
			column.prepare(this, group.$_fixed, group.$_rightFixed);
			column.styles().setSysDefault(def);
			if (column instanceof ValueColumn) {
                var header = column.header();
				column.styles().setParent(styles, false);
				header.styles().setParentAndDefault(headerStyles, headerDef);
                header.subStyles().setParentAndDefault(headerSubStyles, headerSubDef);
                header.summary().styles().setParentAndDefault(summaryStyles, summaryDef);
				column.footer().styles().setParentAndDefault(footerStyles, footerDef);
				column.rendererObj().prepareRuntime(this);
				if (column instanceof DataColumn) {
					column.dynamicStyles().prepare();
				}
			} else if (column instanceof ColumnGroup) {
				this.$_setColumnGroupStyles(column, styles, groupHeaderStyles, headerStyles, headerSubStyles, summaryStyles, footerStyles);
			}
		}
	},
	$_resetColumnWidths: function () {
		for (var i = this._rootColumn.visibleCount(); i--;) {
			var column = this._rootColumn.getVisibleItem(i);
			column._displayWidth = column._groupWidth = column._width = _int(column.width());
			if (column instanceof ColumnGroup) {
				column.resetGroupWidths();
			}
		}
	},
	_canMerge: function () {
		return false;
	},
	_populateMerges: function () {
		if (!this._canMerge()) {
			return;
		}
		var i, cnt;
		var col;
		var merges;
		var level;
		var columns = this.getHorzColumns();
		for (i = 0, cnt = columns.length; i < cnt; i++) {
			col = _cast(columns[i], ValueColumn);
			if (col && col.canMerge()) {
				merges = col.stateFor(ColumnMergeManager.MERGE_ROOMS);
				if (!merges) {
					merges = new ColumnMergeManager(col);
					col.setState(ColumnMergeManager.MERGE_ROOMS, merges);
				}
				merges.clear();
				if (col instanceof DataColumn && col.isMergeGrouped()) {
					level = this.getGroupLevel(col.dataIndex());
					if (level > 0) {
						merges.initialize(RowGroupMergeRule.INIT_COUNT);
					}
				} else {
					merges.initialize(ColumnMergeRule.INIT_COUNT);
				}
			}
		}
	},
	_sortItems: function (fields, directions, textCases) {
        var flds = fields.concat();
        var dirs = directions ? directions.concat() : [];
        var cases = textCases ? textCases.concat() : [];
        if (this._fireSorting(flds, dirs)) {
            this._toastManager.show(this.sortingOptions().toast(), true, function () {
                var row = this.sortingOptions().isKeepFocusedRow() && this.focusedIndex() ? this.focusedIndex().dataRow() : -1;
                this._doSortItems(fields, dirs, cases);
                if (row >= 0) {
                    var idx = CellIndex.temp(this, this.getItemIndexOfRow(row), this.focusedIndex().C());
                    this.setFocusedIndex(idx, true, true);
                }
            }.bind(this));
        }
	},
	_doSortItems: function (fields, directions, textCases) {
	},
	_clearFitWidths: function () {
		this._rootColumn.clearFitWidths();
	},
	$_rowGroupMergeModeChanged: function () {
		this._doRowGroupMergeModeChanged();
	},
	_doRowGroupMergeModeChanged: function () {
		this.rowGroupView() && this.rowGroupView().clearFooterViews();
	},
	$_rowGroupFooterMergeChanged: function () {
		this._doRowGroupFooterMergeChanged();
	},
	_doRowGroupFooterMergeChanged: function () {
	},
	$_footerMergeChanged: function () {
		this._doFooterMergeChanged();
	},
	_doFooterMergeChanged: function () {
		var footer = this.footer();
		if (footer._summaryMergeDirty) {
			this._footerMergeManager.buildRooms(this, footer._mergeCells);
			footer._summaryMergeDirty = false;
		}
	},
	$_headerSummaryMergeChanged: function () {
		this._doHeaderSummaryMergeChanged();
	},
	_doHeaderSummaryMergeChanged: function () {
		var headerSummary = this.header().summary();
		if (headerSummary._summaryMergeDirty) {
			this._headerSummaryMergeManager.buildRooms(this, headerSummary._mergeCells);
			headerSummary._summaryMergeDirty = false;
		}
	},
	$_rowGroupAdornmentsChanged: function () {
		this._doRowGroupAdornmentsChanged();
	},
	_doRowGroupAdornmentsChanged: function () {
	},
	$_summaryModeChanged: function () {
		this._doSummaryModeChanged();
	},
	_doSummaryModeChanged: function () {
	},
	$_groupSummaryModeChanged: function () {
		this._doGroupSummaryModeChanged();
	},
	_doGroupSummaryModeChanged: function () {
	},
	$_groupSortingChanged: function() {
		this._doGroupSortingChanged();
	},
	_doGroupSortingChanged: function() {
	},
	_columnMergeRuleChanged: function (column) {
		this._populateMerges();
		this.refreshView();
	},
	$_columnFiltersChanged: function (filterCollection, filter) {
		this._doColumnFiltersChanged(filterCollection, filter);
	},
	_doColumnFiltersChanged: function (filterCollection, filter) {
		this._fireFilteringChanged();
	},
	$_columnFilterActionsChanged: function (column) {
		this._doColumnFilterActionsChanged(column);
	},
	_doColumnFilterActionsChanged: function (column) {
		this.invalidateLayout();
	},
	$_columnFilterActionClicked: function (action, x, y) {
		this._fireFilterActionClicked(action, x, y);
	},
	_editorStarted: function (editor, index) {
		if (this.edit(index)) {
		}
	},
	_editorChange: function (editor, index, value) {//}, text) {
		this._fireEditChange(index, value);//, text);
	},
    getEditValue: function (editor, index, editResult) {
        this._doGetEditValue(index, editResult);
    },
    _doGetEditValue: function (index, editResult) {
        this._fireGetEditValue(index, editResult)
    },
	editorCommit: function (editor, index, oldValue, newValue) {
		return this._doCellCommit(index, oldValue, newValue);
	},
	_doCellCommit: function (index, oldValue, newValue) {
		return this._fireEditCommit(index, oldValue, newValue);
	},
	editorCancel: function (editor, index) {
		this._doCellCancel(index);
	},
	editorCanceled: function () {
		this.activeTool().resetFocused();
	},
	_doCellCancel: function (index) {
		return this._fireEditCanceled(index);
	},
	_editorSearch: function (editor, index, text) {
		this._fireEditSearch(index, text);;
	},
	_searchCellButtonClick: function( editor, index, text) {
		return this._fireSearchCellButtonClick(index, text);
	},
	$_validateCell: function (index, value, inserting) {
		try {
			this._fireValidateCell(index, inserting, value);
		} catch (err) {
			if (err instanceof ValidationError && err.level !== ValidationLevel.IGNORE) {
				err.column = index.column();
				throw err;
			}
			throw err;
		}
	},
	$_validateRow: function (item, inserting) {
		var columns = this.getDataColumns();
		for (var i = 0, cnt = columns.length; i < cnt; i++) {
			var column = columns[i];
			var index = CellIndex.temp(this, item.index(), column);
			var value = item.getData(column.dataIndex());
			this.$_validateCell(index, value, inserting);
		}
		var values = item.getRowObject();
		try {
			this._fireValidateRow(item, inserting, values);
		} catch (err) {
			if (err instanceof ValidationError && err.level !== ValidationLevel.IGNORE) {
				throw err;
			}
			throw err;
		}
	},
	$_validateCellValue: function (index, value) {
		try {
			var inserting = ItemState.isInserting(index.item().itemState());
			this._validationManager.validateCell(index, inserting);
			this.$_validateCell(index, value, inserting);
			index.dataColumn().setError(null);
			index.dataColumn().setErrorLevel(ValidationLevel.IGNORE);
			var dataId = index.dataId();
			var dataIndex = index.dataColumn().dataIndex();
			var row = this._validationManager._validateCellList[dataId];
			if (row && row[dataIndex]) {
				delete row[dataIndex];
			}
			return true;
		} catch (err) {
			if (err instanceof ValidationError) {
				index.dataColumn().setError(err.message || err);
				index.dataColumn().setErrorLevel(err.level || ValidationLevel.ERROR);
				this._validationManager._userValidations && this._validationManager.addInvalidateCell(index, err);

			} else {
				throw err;
			}
		}
		return false;
	},
	validateCellCommit: function (index, value) {
		if (this.editOptions().isValidateOnEdited()) {
			this.$_validateCellValue(index, value);
		}
	},
	checkValidateCells: function(itemIndices, visibleOnly) {
		return this._validationManager.checkValidateCells(itemIndices, visibleOnly);
	},
	getInvalidCellList:function() {
		return this._validationManager.getInvalidCellList();
	},
	clearInvalidCellList: function() {
		this._validationManager.clearInvalidCellList();
	},
	scrollRow: function (delta) {
		var oldTop = this.topIndex();
		this.setTopIndex(oldTop + delta);
		delta = this.topIndex() - oldTop;
		if (delta) {
			if (delta > 0) {
			} else {
			}
		}
	},
	$_getFieldDefaults: function (dataSource) {
		function getDefault(group, dataIndex) {
			for (var i = 0; i < group.count(); i++) {
				var column = _cast(group.getItem(i), DataColumn);
				if (column && column.dataIndex() == dataIndex) {
					var field = column.getField();
					var value = field && field.defaultValue();
					return value;
				}
				var g = _cast(group.getItem(i), ColumnGroup);
				if (g) {
					value = getDefault(g, dataIndex);
					if (value != UNDEFINED) {
						return value;
					}
				}
			}
			return UNDEFINED;
		}
		var flds = this.dataSource().fieldCount();
		var values = [];
		var value;
		for (var i = 0; i < flds; i++) {
			values.push(UNDEFINED);
		}
		for (i = 0; i < flds; i++) {
			value = getDefault(this._rootColumn, i);
			value && (values[i] = value);
		}
		return values;
	},
	$_getColumnDefaults: function (group, defaults) {
		for (var i = 0, cnt = group.count(); i < cnt; i++) {
			var column = group.getItem(i);
			if (column instanceof DataColumn) {
				var defValue = column.defaultValue();
				defValue != null && (defaults[column.dataIndex()] = column.defaultValue());
			} else if (column instanceof ColumnGroup) {
				this.$_getColumnDefaults(column, defaults);
			}
		}
	},
	$_getItemDefaults: function (item, defaults) {
	},
	$_readDefaultValues: function (defaults) {
	},
	$_getInsertDefaults: function (item) {
		var defaults = this.$_getFieldDefaults(this.itemSource().dataSource());
		this.$_getColumnDefaults(this._rootColumn, defaults);
		this.$_getItemDefaults(null, defaults);
		this.$_readDefaultValues(defaults);
		return defaults;
	},
	_clearColumnErrors: function () {
		function clearErrors(group) {
			for (var i = 0, cnt = group.count(); i < cnt; i++) {
				var dc = group.getItem(i);
				if (dc instanceof DataColumn) {
					dc.setError(null);
				} else if (dc instanceof ColumnGroup) {
					clearErrors(dc);
				}
			}
		}
		clearErrors(this._rootColumn);
	},
	_setColumnErrors: function(item) {
		function setErrors(errData, group) {
			for (var i = 0, cnt = group.count(); i < cnt; i++) {
				var dc = group.getItem(i);
				if (dc instanceof DataColumn) {
					var err = errData[dc.dataIndex()];
					if (err) {
						dc.setError(err.message);
						dc.setErrorLevel(err.level)
					}
				} else if (dc instanceof ColumnGroup) {
					setErrors(errData, dc);
				}
			}
		}
		var errData = this._validationManager._validateCellList && this._validationManager._validateCellList[item.dataId()];
		if (!errData) {return}
		setErrors(errData, this._rootColumn);
	},
	$_checkCurrentRow: function (force) {
        if (this._focusedIndex) {
            var id = this._focusedIndex.dataId();
			var row = this._focusedIndex.dataRow();
            if (force || (id != this._currentRowId)) {
                clearTimeout(this._rowChangeTimer);
                var oldRow = this._currentRow;
                var delay = this._displayOptions.rowChangeDelay();
                var needFire = force || delay <= 0;
                this._currentRowId = id;
				this._currentRow = row;
                if (needFire) {
                    this._fireCurrentRowChanged(oldRow, row);
                } else if (delay > 0) {
                    this._rowChangeTimer = setTimeout(function () {
                        this._fireCurrentRowChanged(oldRow, row);
                    }.bind(this), delay);
                }
                return true;
            }
        }
        return false;
	},
    $_checkLastCellCommit: function (index) {
        if (index && index.isLast()) {
        }
    },
    $_syncHeadCheck: function (checkItems ,checked) { // inserted, deleted 의 경우 checkItems:[], checked:undefined
    	var check = this.checkBar();
    	if (!check.isSyncHeadCheck()) {
    		return;
    	}
    	var showGroup = check.isShowGroup();
    	var item, i, cnt, allChecked, items;
    	this._syncHeadCheck = false;
    	if (checked === false) {
    		this._checkBarHeadView.setChecked(checked);
    	} else if (checkItems == null) {
    		this._checkBarHeadView.setChecked(checked);
    	} else {
	    	allChecked = true;
	    	if (check.isVisibleOnly()) {
		    	for (i = 0, cnt = this._items.itemCount(); i < cnt ; i++) {
		    		item = this._items.getItem(i);
		    		if ((item instanceof GridRow || item instanceof TreeItem || showGroup) &&  item.isCheckable() && !item.isChecked()) {
		    			allChecked = false;
		    			break;
		    		}
		    	};
	    	} else {
	    		items = this.getAllItems();
	    		for (i = 0, cnt = items.length; i < cnt ; i++) {
	    			item = items[i];
		    		if ((item instanceof GridRow || item instanceof TreeItem || showGroup) &&  item.isCheckable() && !item.isChecked()) {
		    			allChecked = false;
		    			break;
		    		}
	    		}
	    	}
	    	this._checkBarHeadView.setChecked(allChecked);
    	};
    },
	_fireCurrentChanging: function (oldIndex, newIndex) {
		return this.fireConfirmEvent(GridBase.CURRENT_CHANGING, oldIndex, newIndex);
	},
	_fireCurrentChanged: function (newIndex) {
		return this.fireEvent(GridBase.CURRENT_CHANGED, newIndex);
	},
	_fireCurrentRowChanged: function (oldRow, newRow) {
		return this.fireEvent(GridBase.CURRENT_ROW_CHANGED, oldRow, newRow);
	},
	_fireValidateCell: function (index, inserting, value) {
		return this.fireEvent(GridBase.VALIDATE_CELL, index, inserting, value);
	},
	_fireValidateRow: function (item, inserting, values) {
		return this.fireEvent(GridBase.VALIDATE_ROW, item, inserting, values);
	},
	_fireValidationFail:function(itemIndex, column, err) {
		return this.fireObjectEvent(GridBase.VALIDATION_FAIL, itemIndex, column, err);
	},
	_fireColumnHeaderClicked: function (column, rightClicked, event) {
		return this.fireEvent(GridBase.COLUMN_HEADER_CLICKED, column, rightClicked, event);
	},
	_fireColumnHeaderImageClicked: function (column) {
		return this.fireEvent(GridBase.COLUMN_HEADER_IMAGE_CLICKED, column);
	},
	_fireColumnHeaderDblClicked: function (column) {
		return this.fireEvent(GridBase.COLUMN_HEADER_DBL_CLICKED, column);
	},
    _fireColumnCheckedChanged: function (column) {
        return this.fireEvent(GridBase.COLUMN_CHECKED_CHANGED, column);
    },
	_fireFooterCellClicked: function (column) {
		return this.fireEvent(GridBase.FOOTER_CELL_CLICKED, column);
	},
	_fireFooterCellDblClicked: function (column) {
		return this.fireEvent(GridBase.FOOTER_CELL_DBL_CLICKED, column);
	},
	_fireHeaderSummaryCellClicked: function (column) {
		return this.fireEvent(GridBase.HEADERSUMMARY_CELL_CLICKED, column);
	},
	_fireHeaderSummaryCellDblClicked: function (column) {
		return this.fireEvent(GridBase.HEADERSUMMARY_CELL_DBL_CLICKED, column);
	},
	_fireCheckBarHeadClicked: function () {
		return this.fireEvent(GridBase.CHECK_BAR_HEAD_CLICKED);
	},
	_fireCheckBarFootClicked: function () {
		return this.fireEvent(GridBase.CHECK_BAR_FOOT_CLICKED);
	},
	_fireIndicatorCellClicked: function (index) {
		return this.fireEvent(GridBase.INDICATOR_CELL_CLICKED, index);
	},
	_fireStateBarCellClicked: function (index) {
		return this.fireEvent(GridBase.STATE_BAR_CELL_CLICKED, index);
	},
	_fireRowGroupHeadClicked: function () {
		return this.fireEvent(GridBase.ROWGROUP_HEAD_CLICKED);
	},
	_fireRowGroupFootClicked: function () {
		return this.fireEvent(GridBase.ROWGROUP_FOOT_CLICKED);
	},
	_fireRowGroupHeaderFooterClicked: function (kind, index) {
		return this.fireEvent(GridBase.ROWGROUP_HEADER_FOOTER_CLICKED, kind, index);
	},
	_fireRowGroupBarClicked: function (index) {
		return this.fireEvent(GridBase.ROWGROUP_BAR_CLICKED, index);
	},
	_fireCheckBarFootDblClicked: function () {
		return this.fireEvent(GridBase.CHECK_BAR_FOOT_DBL_CLICKED);
	},
	_fireIndicatorCellDblClicked: function (index) {
		return this.fireEvent(GridBase.INDICATOR_CELL_DBL_CLICKED, index);
	},
	_fireStateBarCellDblClicked: function (index) {
		return this.fireEvent(GridBase.STATE_BAR_CELL_DBL_CLICKED, index);
	},
	_fireRowGroupHeadDblClicked: function () {
		return this.fireEvent(GridBase.ROWGROUP_HEAD_DBL_CLICKED);
	},
	_fireRowGroupFootDblClicked: function () {
		return this.fireEvent(GridBase.ROWGROUP_FOOT_DBL_CLICKED);
	},
	_fireRowGroupHeaderFooterDblClicked: function (kind, index) {
		return this.fireEvent(GridBase.ROWGROUP_HEADER_FOOTER_DBL_CLICKED, kind, index);
	},
	_fireRowGroupBarDblClicked: function (index) {
		return this.fireEvent(GridBase.ROWGROUP_BAR_DBL_CLICKED, index);
	},
	_firePanelClicked: function () {
		return this.fireEvent(GridBase.PANEL_CLICKED);
	},
	_firePanelDblClicked: function () {
		return this.fireEvent(GridBase.PANEL_DBL_CLICKED);
	},
	_fireRowGroupPanelClicked: function (column) {
		return this.fireEvent(GridBase.ROWGROUP_PANEL_CLICKED, column);
	},
	_fireRowGroupPanelDblClicked: function (column) {
		return this.fireEvent(GridBase.ROWGROUP_PANEL_DBL_CLICKED, column);
	},
	_fireBodyEmptyClicked: function() {
		return this.fireEvent(GridBase.BODY_EMPTY_CLICKED);
	},
	_fireBodyEmptyDblClicked: function() {
		return this.fireEvent(GridBase.BODY_EMPTY_DBL_CLICKED);
	},
	_fireMenuItemClicked: function (menuItem, index) {
		return this.fireEvent(GridBase.MENU_ITEM_CLICKED, menuItem, index);
	},
	_fireContextMenuPopup: function (x, y, eltName) {
		return this.fireConfirmEvent(GridBase.CONTEXT_MENU_POPUP, x, y, eltName);
	},
    _fireContextMenuItemClicked: function (menuItem, index) {
        return this.fireEvent(GridBase.CONTEXT_MENU_ITEM_CLICKED, menuItem, index);
    },
	_fireCellButtonClicked: function (index) {
		this._buttonClicked = true;
		return this.fireEvent(GridBase.CELL_BUTTON_CLICKED, index);
	},
	_fireEditButtonClicked: function (index) {
		// this._buttonClicked = true;
		return this.fireEvent(GridBase.EDIT_BUTTON_CLICKED, index);
	},
	_fireImageButtonClicked: function (index, buttonIndex, name) {
		this._buttonClicked = true;
		return this.fireEvent(GridBase.IMAGE_BUTTON_CLICKED, index, buttonIndex, name);
	},
	_fireScrollToBottom: function () {
		return this.fireEvent(GridBase.SCROLL_TO_BOTTOM);
	},
	_fireTopIndexChanged: function (itemIndex) {
		return this.fireEvent(GridBase.TOPITEMINDEX_CHANGED, itemIndex);
	},
	_fireDataCellClicked: function (index) {
		var editOptions = this.editOptions();
		var except = editOptions.isExceptDataClickWhenButton();
		if (except && this._buttonClicked) {

		} else {
			return this.fireEvent(GridBase.DATA_CELL_CLICKED, index);
		}
	},
	_fireDataCellDblClicked: function (index) {
		return this.fireEvent(GridBase.DATA_CELL_DBL_CLICKED, index);
	},
	_fireRowsDeleting: function (rows) {
		return this.fireConfirmEvent(GridBase.ROWS_DELETING, rows);
	},
	_fireRowInserting: function (itemIndex, dataRow) {
		return this.fireConfirmEvent(GridBase.ROW_INSERTING, itemIndex, dataRow);
	},
    _fireItemCommit: function (itemIndex, dataRow) {
        return this.fireEvent(GridBase.ITEM_COMMIT);
    },
	_fireSelectionChanged: function () {
		return this.fireEvent(GridBase.SELECTION_CHANGED);
	},
	_fireSelectionAdded: function (selection) {
		return this.fireEvent(GridBase.SELECTION_ADDED, selection);
	},
	_fireSelectionRemoved: function () {
		return this.fireEvent(GridBase.SELECTION_REMOVED);
	},
	_fireSelectionCleared: function () {
		return this.fireEvent(GridBase.SELECTION_CLEARED);
	},
	_fireSelectionResized: function () {
		return this.fireEvent(GridBase.SELECTION_RESIZED);
	},
	_fireSelectionEnded: function (selection) {
		return this.fireEvent(GridBase.SELECTION_ENDED, selection);
	},
    _fireUpdateStarted: function (item, appending) {
        return this.fireEvent(GridBase.UPDATE_STARTED, item);
    },
    _fireInsertStarted: function (item, appending) {
        return this.fireEvent(GridBase.INSERT_STARTED, item, appending);
    },
    _fireShowEditor: function (index, attrs) {
        return this.fireConfirmEvent(GridBase.SHOW_EDITOR, index, attrs);
    },
	_fireHideEditor: function (index) {
		return this.fireEvent(GridBase.HIDE_EDITOR, index);
	},
	_fireEditChange: function (index, value) {
		return this.fireEvent(GridBase.EDIT_CHANGE, index, value);
	},
    _fireGetEditValue: function (index, editResult) {
        return this.fireEvent(GridBase.GET_EDIT_VALUE, index, editResult);
    },
	_fireEditCommit: function (index, oldValue, newValue) {
		return this.fireConfirmEvent(GridBase.EDIT_COMMIT, index, oldValue, newValue);
	},
	_fireEditCanceled: function (index) {
		return this.fireEvent(GridBase.EDIT_CANCELED, index);
	},
	_fireItemEditCancel:function (item) {
		return this.fireConfirmEvent(GridBase.ITEM_EDIT_CANCEL, item);
	},
	_fireItemEditCanceled: function (item) {
		return this.fireEvent(GridBase.ITEM_EDIT_CANCELED, item);
	},
	_fireEditSearch: function (index, text) {
		this.fireEvent(GridBase.EDIT_SEARCH, index, text);
	},
	_fireSearchCellButtonClick: function(index, text) {
		return this.fireObjectEvent(GridBase.SEARCH_BUTTON_CLICK, index, text);
	},
	_fireCellEdited: function (item, field) {
		this.fireEvent(GridBase.CELL_EDITED, item, field);
	},
	_fireEditRowChanged: function (item, field, oldValue, newValue) {
		this.fireEvent(GridBase.EDIT_ROW_CHANGED, item, field, oldValue, newValue);
	},
	_fireEditItemPasted: function (item, fields, oldValues, newValues) {
		this.fireEvent(GridBase.EDIT_ROW_PASTED, item, fields, oldValues, newValues);
	},
	_fireItemsPasted: function (items) {
		this.fireEvent(GridBase.ROWS_PASTED, items);
	},
	_fireCellPasting: function (index, value) {
		return this.fireObjectEvent(GridBase.CELL_PASTING, index, value);
	},
	_fireItemChecked: function (item) {
		this.fireEvent(GridBase.ITEM_CHECKED, item, item.isChecked());
	},
	_fireItemsChecked: function (items, checked) {
		this.fireEvent(GridBase.ITEMS_CHECKED, items, checked);
	},
	_fireItemAllChecked: function (checked) {
		this.fireEvent(GridBase.ITEM_ALL_CHECKED, checked);
	},
	_fireErrorClicked: function (cell, error) {
		this.fireEvent(GridBase.ERROR_CLICKED, error);
	},
    _fireSorting: function (fields, directions) {
        return this.fireConfirmEvent(GridBase.SORTING, fields, directions);
    },
    _fireFiltering: function () {
        return this.fireConfirmEvent(GridBase.FILTERING);
    },
	_fireFilterActionClicked: function (action, x, y) {
		this.fireEvent(GridBase.FILTER_ACTION_CLICKED, action, x, y);
	},
	_fireKeyDown: function(key, ctrl, shift, alt) {
		return this.fireConfirmEvent(GridBase.KEY_DOWN, key, ctrl, shift, alt);
	},
	_fireKeyPress: function(key) {
		this.fireEvent(GridBase.KEY_PRESS, key);
	},
	_fireKeyUp: function(key, ctrl, shift, alt) {
		this.fireEvent(GridBase.KEY_UP, key, ctrl, shift, alt);
	},
	_fireShowTooltip: function(index, value) {
		return this.fireObjectEvent(GridBase.SHOW_TOOLTIP, index, value);
	},
	_fireShowHeaderTooltip: function(column, value) {
		return this.fireObjectEvent(GridBase.SHOW_HEADER_TOOLTIP, column, value);
	},
	_fireColumnPropertyChanged: function (column, property, value) {
		return this.fireEvent(GridBase.COLUMN_PROPERTY_CHANGED, column, property, value);
	},
	_fireShowInnerDragCursor: function(cells){
		return this.fireObjectEvent(GridBase.SHOW_INNER_DRAG_CURSOR, cells);
	},
	_fireInnerDragStart: function(cells) {
		return this.fireConfirmEvent(GridBase.INNER_DRAG_START, cells);
	},
	_fireInnerDragOver: function(index, cells) {
		// return this.fireConfirmEvent(GridBase.INNER_DRAG_OVER, index, cells);
		return this.fireObjectEvent(GridBase.INNER_DRAG_OVER, index, cells);
	},
	_fireInnerDrop: function(index, cells) {
		return this.fireConfirmEvent(GridBase.INNER_DROP, index, cells);
	},
	_fireGridActivated: function() {
		return this.fireEvent(GridBase.GRID_ACTIVATED);
	},
	_fireApplyCallback:function() {
		var args = Array.prototype.slice.call(arguments, 0);
		args.splice(0,1,GridBase.APPLY_CALLBACK);
		return this.fireEvent.apply(this, args);
	},
	_fireCopy: function (range, e) {
		return this.fireConfirmEvent(GridBase.COPY, range, e);
	},
	_firePaste: function(index, e) {
		return this.fireConfirmEvent(GridBase.PASTE, index, e);
	},
	_firePasted: function() {
		return this.fireEvent(GridBase.PASTED);
	},
	getHandler:function() {
		return this.fireObjectEvent(GridBase.GET_HANDLER);
	},
	onApplyCallback: function() {
		this._fireApplyCallback.apply(this, arguments);
	},
	onPopupMenuManagerMenuItemClicked: function (manager, menuItem, index) {
		this._fireMenuItemClicked(menuItem, index);
	},
	onScrollBarScrolled: function (bar, eventType, delta, position) {
		var options = this.displayOptions();
		var tipView;
		var lm = this.layoutManager();
		var msg;
		var cb = options.scrollMessageCallback();
		var pos;
		cb = cb && typeof cb === "function" ? cb : null;
		if (bar.isVertical()) {
			switch (eventType) {
				case ScrollEventType.LINE_DOWN:
				case ScrollEventType.LINE_UP:
					this.scrollRow(delta);
					break;
				case ScrollEventType.PAGE_DOWN:
				case ScrollEventType.PAGE_UP:
					this.setTopIndex(this.topIndex() + delta * bar._page);
					break;
				case ScrollEventType.THUMB_TRACK:
					var scrollDuration = options.scrollDuration();
					if (options.isLiveScroll() || (this._scrolledTime > 0 && getTimer() - this._scrolledTime > scrollDuration)) {
						this.setTopIndex(position);
						this._scrolledTime = 0;
					} else {
						if (!this._scrollTipView) {
							this._scrollTipView = new ScrollTipView(this.container()._container);
						}
						tipView = this._vscrollBar._tipView = this._scrollTipView;

						this._vscrollBar.setPosition(position, true);
						pos = this._vscrollBar._pos + this.$_fixedRowCount;
						msg = cb ? cb(this.getHandler(), ContentOrientation.VERTICAL, pos) : String(pos + 1);
						this._vscrollBar.setText(msg);

						if (scrollDuration > 0 && this._scrolledTime == 0)
							this._scrolledTime = getTimer();

					}
					break;
				case ScrollEventType.THUMB_END:
					this._scrollTipView && this._scrollTipView.hide();
					this._vscrollBar._tipView = null;
					this.setTopIndex(position);
					break;
				default:
					this.setTopIndex(position);
					break;
			}
		} else {
			switch (eventType) {
				case ScrollEventType.LINE_RIGHT:
				case ScrollEventType.LINE_LEFT:
					this.setLeftPos(this.leftPos() + delta * 8, true);
					break;
				case ScrollEventType.PAGE_RIGHT:
					if (this._layoutManager) { 
						this.setLeftPos(this._layoutManager.scrollToNextColumn(), true);
					} else {
						this.setLeftPos(this.leftPos() + bar._page, true);
					}
					break;
				case ScrollEventType.PAGE_LEFT:
					if (this._layoutManager) { 
						this.setLeftPos(this._layoutManager.scrollToPrevColumn(), true);
					} else {
						this.setLeftPos(this.leftPos() - bar._page, true);
					}
					break;
				case ScrollEventType.THUMB_TRACK:
					var scrollDuration = options.hscrollDuration();
					if (options.isHorizLiveScroll() || (this._scrolledTime > 0 && getTimer() - this._scrolledTime > scrollDuration)) {
						this.setLeftPos(position, false);
						this._horzScrolling = false;
						this._scrolledTime = 0;
					} else {
						if (!this._scrollTipView) {
							this._scrollTipView = new ScrollTipView(this.container()._container);
						}
						tipView = this._hscrollBar._tipView = this._scrollTipView;
						this._hscrollBar.setPosition(position, true);
						var pos = lm.positionToColumn(this._hscrollBar._pos) + this.$_fixedColCount;
						if (pos >= 0) {
							var col = this.getVisibleColumn(pos);
							// msg = cb ? cb(this.getHandler(), ContentOrientation.HORIZONTAL, pos) : col ? col.header().displayText() : "";
							msg = col ? col.header().displayText() : ""; // 사용자가 header의 text를 가져올만한 적당한 방법이 없다. horizontal에서는 header의 text만 표시.
							this._hscrollBar.setText(msg);
						}

						if (scrollDuration > 0 && this._scrolledTime == 0) {
							this._scrolledTime = getTimer();
						}
					}
					break;
				case ScrollEventType.THUMB_END:
					this._scrollTipView && this._scrollTipView.hide();
					this._hscrollBar._tipView = null;
					this.setLeftPos(position);
					break;
				default:
					this.setLeftPos(position);
					break;
			}
		}
	},
	onImageListImageLoaded: function (images, index) {
		var img = images.getImage(index);
		trace(images.name() + "'s image loaded at " + index + " [" + img.width + "," + img.height + "]");
		this.invalidateLayout();
	},
	onItemProviderReset: function (itemProvider) {
		_trace(">> onItemProviderReset");
		this.hideEditor();
		this._dataChanged = true;
		this._resetColumnIndicies();
		this._populateMerges();
		this.resetGrid();
		this.$_syncHeadCheck([], undefined);
		this._shadowDom && this._itemProvider && this._shadowDom.setItemProvider(this._itemProvider);
	},
	onItemProviderRefresh: function (itemProvider) {
		_trace(">> onItemProviderRefresh");
		this.hideEditor();
		this._dataChanged = true;
		this._resetColumnIndicies();
		this._populateMerges();
		this.refreshView();
		this._syncHeadCheck && this.$_syncHeadCheck([], undefined);
		this._shadowDom && this._itemProvider && this._shadowDom.setItemProvider(this._itemProvider);
	},
	onItemProviderRefreshClient: function (itemProvider) {
		_trace(">> onItemProviderRefreshClient");
		this.hideEditor();
		this._dataChanged = true;
		this._resetColumnIndicies();
		this._populateMerges();
		this.refreshView();
		this._syncHeadCheck && this.$_syncHeadCheck([], undefined);
		this._shadowDom && this._itemProvider && this._shadowDom.setItemProvider(this._itemProvider);
	},
	onItemProviderItemInserted: function (itemProvider, item) {
		_trace(">> onItemProviderItemInserted: " + item.dataRow());
		this.hideEditor();
		this._dataChanged = true;
		this._syncHeadCheck = true;
		this._populateMerges();
		this.refreshView();
	},
	onItemProviderItemDeleted: function (itemProvider, item) {
		_trace(">> onItemProviderItemDeleted: " + item.dataRow());
		this.hideEditor();
		this._dataChanged = true;
		this._syncHeadCheck = true;
		this._populateMerges();
		this.refreshView();
	},
	onItemProviderItemUpdated: function (itemProvider, item) {
		_trace(">> onItemProviderItemUpdated: " + item.dataRow());
		this.hideEditor();
		this._dataChanged = true;
		this._updateRows ? this._updateRows.push(item.dataId()) : (this._updateRows = [item.dataId()]);
		this._populateMerges();
		this.refreshView();
	},
	onItemProviderCheckableChanged: function (itemProvider, item) {
		_trace(">> onItemProviderCheckableChanged: " + item.dataRow() + ", " + item.isCheckable());
		this.refreshView();
		this.$_syncHeadCheck([], undefined);
	},
	onItemProviderItemChecked: function (itemProvider, item) {
		_trace(">> onItemProviderItemChecked: " + item.dataRow() + ", " + item.isChecked());
		this.refreshView();
		this._fireItemChecked(item);
	},
	onItemProviderItemsChecked: function (itemProvider, items, checked) {
		_trace(">> onItemProviderItemsChecked: " + items.length + " items, " + checked);
		this.refreshView();
		this._fireItemsChecked(items, checked);
	},
	onItemProviderItemAllChecked: function (itemProvider, checked) {
		_trace(">> onItemProviderItemAllChecked: " + checked);
		this.refreshView();
		this._fireItemAllChecked(checked);
	},
	onItemProviderItemCheckChanged: function (itemProvider, items, checked) {
		_trace(">> onItemProviderItemCheckChanged: " + checked);
		this.$_syncHeadCheck(items, checked);
	},
	onItemProviderRowStateChanged: function (itemProvider, item) {
		_trace(">> onItemProviderRowStateChanged: " + item.dataRow());
		this.refreshView();
	},
	onItemProviderRowStatesChanged: function (itemProvider, items) {
		_trace(">> onItemProviderRowStatesChanged");
		this.refreshView();
	},
	onItemProviderRowStatesCleared: function (itemProvider) {
		_trace(">> onItemProviderRowStatesCleared");
		this.refreshView();
	},
	onItemProviderSort: function (itemProvider, fields, directions) {
		_trace(">> onItemProviderSort");
		this.refreshView();
	},
	onItemProviderSorted: function (itemProvider) {
		_trace(">> onItemProviderSorted");
		this.refreshView();
		this.fireEvent(GridBase.SORTING_CHANGED);
		this._shadowDom && this._itemProvider && this._shadowDom.reset();
	},
	onItemProviderFilterAdded: function (itemProvider) {
		_trace(">> onItemProviderFilterAdded");
	},
	onItemProviderFilterRemoved: function (itemProvider) {
		_trace(">> onItemProviderFilterRemoved");
	},
	onItemProviderFilterCleared: function (itemProvider) {
		_trace(">> onItemProviderFilterCleared");
	},
	onItemProviderFilterAllCleared: function (itemProvider) {
		_trace("onItemProviderFilterAllCleared");
	},
	onItemProviderFiltered: function (itemProvider, filterCollection, filter) {
		this.refreshView();
		!this._loading && this.$_syncHeadCheck([], undefined);	// filter의 경우 refresh이후에 이벤트가 발생 주의해서 처리.
		this.fireEvent(GridBase.FILTERING_CHANGED, filterCollection, filter);
		this._shadowDom && this._itemProvider && this._shadowDom.reset();
	},
	$_focusEditItem: function (item) {
		var index = this.getIndex(item.index(), this.focusedIndex() ? this.focusedIndex().column() : null);
		if (!index.C() && this.visibleColumnCount() > 0) {
			index._column = this.getVisibleColumn(0);
		}
		this.setFocusedIndex(index, true);
		this.makeCellVisible(this.focusedIndex());
	},
	onItemEditUpdateStarted: function (itemProvider, item) {
		this._clearColumnErrors();
		this._setColumnErrors(item)
		this.refreshView();
        this._fireUpdateStarted(item);
	},
	onItemEditAppendStarted: function (itemProvider, item) {
		this.hideEditor();
		this.reprepareEditor();
		this._clearColumnErrors();
		this._populateMerges();
		this.refreshView();
		this.$_focusEditItem(item);
        this._fireInsertStarted(item, true);
	},
	onItemEditInsertStarted: function (itemProvider, item) {
		this.hideEditor();
		this.reprepareEditor();
		this._clearColumnErrors();
		this._populateMerges();
		this.refreshView();
		this.$_focusEditItem(item);
        this._fireInsertStarted(item, false);
	},
	onItemEditCellEdited: function (itemProvider, item, field) {
		this.refreshView();
		!this._cellUpdateEventLock && this._fireCellEdited(item, field);
	},
	onItemEditCellUpdated: function (itemProvider, item, field, oldValue, newValue) {
		this.refreshView();
		!this._cellUpdateEventLock && this._fireEditRowChanged(item, field, oldValue, newValue);
	},
	onItemEditCommitting: function (itemProvider, item) {
	},
	onItemEditCommitted: function (itemProvider, item) {
		this._appendDummy();		
		this.hideEditor();
		this.refreshView();
	},
	onItemEditCanceled: function (itemProvider) {
		this._appendDummy();
		this.hideEditor();
		this._populateMerges();
		this.refreshView();
		this._fireItemEditCanceled(itemProvider._editingItem);
	},
	onItemEditCommitRequest: function (itemProvider) {
		this.commit(false);
	},
	onItemEditCancelReuqest: function (itemProvider) {
		this.cancel();
	},
	onLookupSourceProviderChanged: function (provider) {
		this.refreshView();
	},
	onSelectionChanged: function (manager) {
		this._fireSelectionChanged();
	},
	onSelectionAdded: function (manager, item) {
		this._addSelectionView(item);
		this._layoutSelectionViews();
		this._fireSelectionAdded(item);
		this._fireSelectionChanged();
	},
	onSelectionRemoved: function (manager) {
		this._fireSelectionRemoved();
		this._fireSelectionChanged();
	},
	onSelectionCleared: function (manager) {
		this._clearSelectionViews();
		this._fireSelectionCleared();
		this._fireSelectionChanged();
	},
	onSelectionResized: function (manager, item) {
		this._layoutSelectionViews();
		this._fireSelectionResized();
		this._fireSelectionChanged();
	},
	onSelectionEnded: function (manager, item) {
		this._fireSelectionEnded(item);
	},
    onMenuItemClick: function (menuItem, index) {
        this._fireContextMenuItemClicked(menuItem, index);
    }
}, {
	setGridMapper: function (mapper) {
		GridBase._gridMapper = mapper;
	},
	createColumn: function (source) {
		if (source) {
			var column;
			if (source.type == "group" || source.columns) {
				column = new ColumnGroup();
			} else if (source.type == "series") {
                column = new SeriesColumn();
			} else {
				column = new DataColumn();
			}
			column.assign(source);
			var colMap;
			var map = GridBase._gridMapper;
			if (map && (colMap = map.column)) {
				for (var p in colMap) {
					var prop = colMap[p];
					if (source.hasOwnProperty(prop)) {
						column.setProperty(p, source[prop]);
					}
				}
			}
			if (column instanceof ColumnGroup && source.columns) {
				var columns = GridBase.createColumns(source.columns);
				column.setColumns(columns);
			}
			return column;
		}
		return null;
	},
	createColumns: function (source) {
		if (_isArray(source)) {
			var columns = [];
			for (var i = 0, cnt = source.length; i < cnt; i++) {
				var column = GridBase.createColumn(source[i]);
				column && columns.push(column);
			}
			return columns;
		}
		return null;
	}
});
GridBase.CURRENT_CHANGING = "onGridBaseCurrentChanging";
GridBase.CURRENT_CHANGED = "onGridBaseCurrentChanged";
GridBase.CURRENT_ROW_CHANGED = "onGridBaseCurrentRowChanged";
GridBase.VALIDATE_CELL = "onGridBaseValidateCell";
GridBase.VALIDATE_ROW = "onGridBaseValidateRow";
GridBase.VALIDATION_FAIL = "onGridBaseValidationFail";
GridBase.COLUMN_HEADER_CLICKED = "onGridBaseColumnHeaderClicked";
GridBase.COLUMN_HEADER_IMAGE_CLICKED = "onGridBaseColumnHeaderImageClicked";
GridBase.COLUMN_HEADER_DBL_CLICKED = "onGridBaseColumnHeaderDblClicked";
GridBase.COLUMN_CHECKED_CHANGED = "onGridBaseColumnCheckedChanged";
GridBase.FOOTER_CELL_CLICKED = "onGridBaseFooterCellClicked";
GridBase.FOOTER_CELL_DBL_CLICKED = "onGridBaseFooterCellDblClicked";
GridBase.HEADERSUMMARY_CELL_CLICKED = "onGridBaseHeaderSummaryCellClicked";
GridBase.HEADERSUMMARY_CELL_DBL_CLICKED = "onGridBaseHeaderSummaryCellDblClicked";
GridBase.CHECK_BAR_HEAD_CLICKED = "onGridBaseCheckBarHeadClicked";
GridBase.CHECK_BAR_FOOT_CLICKED = "onGridBaseCheckBarFootClicked";
GridBase.INDICATOR_CELL_CLICKED = "onGridBaseIndicatorCellClicked";
GridBase.STATE_BAR_CELL_CLICKED = "onGridBaseStateBarCellClicked";
GridBase.ROWGROUP_HEAD_CLICKED = "onGridBaseRowGroupHeadClicked";
GridBase.ROWGROUP_FOOT_CLICKED = "onGridBaseRowGroupFootClicked";
GridBase.ROWGROUP_BAR_CLICKED = "onGridBaseRowGroupBarClicked";
GridBase.ROWGROUP_HEADER_FOOTER_CLICKED = "onGridBaseRowGroupHeaderFooterClicked";
GridBase.CHECK_BAR_FOOT_DBL_CLICKED = "onGridBaseCheckBarFootDblClicked";
GridBase.INDICATOR_CELL_DBL_CLICKED = "onGridBaseIndicatorCellDblClicked";
GridBase.STATE_BAR_CELL_DBL_CLICKED = "onGridBaseStateBarCellDblClicked";
GridBase.ROWGROUP_HEAD_DBL_CLICKED = "onGridBaseRowGroupHeadDblClicked";
GridBase.ROWGROUP_FOOT_DBL_CLICKED = "onGridBaseRowGroupFootDblClicked";
GridBase.ROWGROUP_BAR_DBL_CLICKED = "onGridBaseRowGroupBarDblClicked";
GridBase.ROWGROUP_HEADER_FOOTER_DBL_CLICKED = "onGridBaseRowGroupHeaderFooterDblClicked";
GridBase.PANEL_CLICKED = "onGridBasePanelClicked";
GridBase.PANEL_DBL_CLICKED = "onGridBasePanelDblClicked";
GridBase.ROWGROUP_PANEL_CLICKED = "onGridBaseRowGroupPanelClicked";
GridBase.ROWGROUP_PANEL_DBL_CLICKED = "onGridBaseRowGroupPanelDblClicked";
GridBase.BODY_EMPTY_CLICKED = "onGridBaseBodyEmptyClicked";
GridBase.BODY_EMPTY_DBL_CLICKED = "onGridBaseBodyEmptyDblClicked";
GridBase.MENU_ITEM_CLICKED = "onGridBaseMenuItemClicked";
GridBase.CONTEXT_MENU_POPUP = "onGridBaseContextMenuPopup";
GridBase.CONTEXT_MENU_ITEM_CLICKED = "onGridBaseContextMenuItemClicked";
GridBase.CELL_BUTTON_CLICKED = "onGridBaseCellButtonClicked";
GridBase.IMAGE_BUTTON_CLICKED = "onGridBaseImageButtonClicked";
GridBase.EDIT_BUTTON_CLICKED = "onGridBaseEditButtonClicked";
GridBase.CLICKABLE_CELL_CLICKED = "onGridBaseClickableCellClicked";
GridBase.SCROLL_TO_BOTTOM = "onGridBaseScrollToBottom";
GridBase.TOPITEMINDEX_CHANGED = "onGridBaseTopItemIndexChanged";
GridBase.DATA_CELL_CLICKED = "onGridBaseDataCellClicked";
GridBase.DATA_CELL_DBL_CLICKED = "onGridBaseDataCellDblClicked";
GridBase.ROWS_DELETING = "onGridBaseRowsDeleting";
GridBase.ROW_INSERTING = "onGridBaseRowInserting";
GridBase.SELECTION_ADDED = "onGridBaseSelectionAdded";
GridBase.SELECTION_CHANGED = "onGridBaseSelectionChanged";
GridBase.SELECTION_REMOVED = "onGridBaseSelectionRemoved";
GridBase.SELECTION_CLEARED = "onGridBaseSelectionCleared";
GridBase.SELECTION_RESIZED = "onGridBaseSelectionResized";
GridBase.SELECTION_ENDED = "onGridBaseSelectionEnded";
GridBase.INSERT_STARTED = "onGridBaseInsertStarted";
GridBase.UPDATE_STARTED = "onGridBaseUpdateStarted";
GridBase.SHOW_EDITOR = "onGridBaseShowEditor";
GridBase.HIDE_EDITOR = "onGridBaseHideEditor";
GridBase.EDIT_CHANGE = "onGridBaseEditChange";
GridBase.GET_EDIT_VALUE = "onGridBaseGetEditValue";
GridBase.EDIT_COMMIT = "onGridBaseEditCommit";
GridBase.EDIT_CANCELED = "onGridBaseEditCanceled";
GridBase.ITEM_EDIT_CANCELED = "onGridBaseItemEditCanceled";
GridBase.ITEM_EDIT_CANCEL = "onGridBaseItemEditCancel";
GridBase.EDIT_SEARCH = "onGridBaseEditSearch";
GridBase.SEARCH_BUTTON_CLICK = "onGridBaseSearchCellButtonClick";
GridBase.CELL_EDITED = "onGridBaseCellEdited";
GridBase.EDIT_ROW_CHANGED = "onGridBaseEditRowChanged";
GridBase.EDIT_ROW_PASTED = "onGridBaseEditRowPasted";
GridBase.ROWS_PASTED = "onGridBaseRowsPasted";
GridBase.CELL_PASTING = "onGridBaseCellPasting";
GridBase.ITEM_CHECKED = "onGridBaseItemChecked";
GridBase.ITEMS_CHECKED = "onGridBaseItemsChecked";
GridBase.ITEM_ALL_CHECKED = "onGridBaseItemAllChecked";
GridBase.ERROR_CLICKED = "onGridBaseErrorClicked";
GridBase.SORTING = "onGridBaseSorting";
GridBase.SORTING_CHANGED = "onGridBaseSortingChanged";
GridBase.FILTERING = "onGridBaseFiltering";
GridBase.FILTERING_CHANGED = "onGridBaseFilteringChanged";
GridBase.FILTER_ACTION_CLICKED = "onGridBaseFilterActionClicked";
GridBase.KEY_PRESS = "onGridBaseKeyPress";
GridBase.KEY_DOWN = "onGridBaseKeyDown";
GridBase.KEY_UP = "onGridBaseKeyUp";
GridBase.SHOW_TOOLTIP = "onGridBaseShowTooltip";
GridBase.SHOW_HEADER_TOOLTIP = "onGridBaseShowHeaderTooltip";
GridBase.COLUMN_PROPERTY_CHANGED = "onGridBaseColumnPropertyChanged";
GridBase.SHOW_INNER_DRAG_CURSOR = "onGridBaseShowInnerDragCursor";
GridBase.INNER_DRAG_START = "onGridBaseInnerDragStart";
GridBase.INNER_DRAG_OVER = "onGridBaseInnerDragOver";
GridBase.INNER_DROP = "onGridBaseInnerDrop";
GridBase.GRID_ACTIVATED = "onGridBaseGridActivated";
GridBase.APPLY_CALLBACK = "onGridBaseApplyCallback";
GridBase.RUN_CALLBACK = "onApplyCallback";
GridBase.GET_HANDLER = "getHandler";
GridBase.COPY = 'onGridBaseCopy';
GridBase.PASTE = "onGridBasePaste";
GridBase.PASTED = "onGridBasePasted";
/*
var GridBaseObserver = defineClass("GridBaseObserver", null, {
	init: function () {
		this._super();
	},
	onGridBaseCurrentChanging: function (grid, oldIndex, newIndex) {
	},
	onGridBaseCurrentChanged: function (grid, newIndex) {
	},
	onGridBaseCurrentRowChanged: function (grid, oldRow, newRow) {
	},
	onGridBaseValidateCell: function (grid, index, inserting, value) {
	},
	onGridBaseValidateRow: function (grid, item, inserting, values) {
	},
	onGridBaseColumnHeaderClicked: function (grid, column) {
	},
	onGridBaseMenuItemClicked: function (grid, menuItem) {
	},
	onGridBaseCellButtonClicked: function (grid, index) {
	},
	onGridBaseImageButtonClicked: function (grid, index, buttonIndex, name) {
	},
	onGridBaseEditButtonClicked: function (grid, index) {
	},
	onGridBaseScrollToBottom: function (grid) {
	}
});
*/
var /* @internal */ RootColumn = defineClass("RootColumn", ColumnGroup, {
	init : function(owner) {
		this._super();
		this._owner = owner; // GridBase
		this._columnMap = {};
		this._header._visible = false;
		this._isLastColumn = true;
	},
	destroy: function() {
		this._destroying = true;
		for (var column in this._columnMap) {
			var col = this._columnMap[column];
			col && !col._destroying && col.destroy && col.destroy();
			this._columnMap[column] = null;
		}
		this._columnMap = null;
		this._super();
	},
	grid : function() {
		return this._owner;
	},
	_columnAdded: function (column) {
		this._super(column);
		this._columnMap[column.$_hash] = column;
		var group = _cast(column, ColumnGroup);
		if (group) {
			this.$_groupAdded(group);
		}
	},
	_columnRemoved: function (column) {
	},
	$_groupAdded: function (group) {
		for (var i = 0, cnt = group.count(); i < cnt; i++) {
			var c = group.getItem(i);
			var g = _cast(c, ColumnGroup);
			this._columnMap[c.$_hash] = c;
			if (g) {
				this.$_groupAdded(g);
			}
		}
	}
});
var DataRootCollection = defineClass("DataRootCollection", null, {
	init : function() {
		this._super();
		this._root = null;
		this._dataRoots = [];
		this._list = [];
	},
	roots: function () {
		return this._dataRoots;
	},
	collect: function (root) {
		this._root = root;
		this._dataRoots.length = 0;
		if (root.visibleCount() > 0) {
			this.$_collectGroup(root);
			this.$_checkValid(root);
		}
	},
	collectDataColumns: function (c1, c2) {
		var columns = [];
		if (c1.dataRoot() !== c1) {
			c1 = c1.dataRoot();
		}
		if (c2.dataRoot() != c2) {
			c2 = c2.dataRoot();
		}
		var g = _cast(c1, ColumnGroup);
		if (g) {
			c1 = ColumnGroup.getFirstDataRoot(g);
		}
		g = _cast(c2, ColumnGroup);
		if (g) {
			c2 = ColumnGroup.getLastDataRoot(g);
		}
		var c;
		var j;
		var cnt;
		var i;
		var i1 = this._dataRoots.indexOf(c1);
		var i2 = this._dataRoots.indexOf(c2);
		if (i1 > i2) {
			i = i1;
			i1 = i2;
			i2 = i;
		}
		for (i = i1; i <= i2; i++) {
			c = this._dataRoots[i];
			if (c.isVisible()) {
				g = _cast(c, ColumnGroup);
				if (g) {
					this._list.length = 0;
					this.$_collectDataColumns(g, this._list);
					for (j = 0, cnt = this._list.length; j < cnt; j++) {
						columns.push(this._list[j]);
					}
				} else if (c instanceof DataColumn) {
					columns.push(c);
				}
			}
		}
		return columns;
	},
	$_collectGroup: function (group) {
		var c;
		var g;
		var i;
		var cnt = group.visibleCount();
		if (cnt < 1) {
			this._dataRoots.push(group);
		} else if (cnt == 1) {
			c = group.getVisibleItem(0);
			g = _cast(c, ColumnGroup);
			if (!g) {
				this._dataRoots.push(c);
			} else {
				this.$_collectGroup(g);
			}
		} else if (group.isVertical()) {
			this._dataRoots.push(group);
		} else {
			for (i = 0; i < cnt; i++) {
				c = group.getVisibleItem(i);
				g = _cast(c, ColumnGroup);
				if (!g) {
					this._dataRoots.push(c);
				} else {
					this.$_collectGroup(g);
				}
			}
		}
	},
	$_collectDataColumns: function (group, list) {
		for (var i = 0, cnt = group.visibleCount(); i < cnt; i++) {
			var col = group.getVisibleItem(i);
			if (col instanceof DataColumn) {
				list.push(col);
			} else if (col instanceof ColumnGroup) {
				this.$_collectDataColumns(col, list);
			}
		}
	},
	$_checkValid: function (group) {
	}
});


/* column.lookupDisplay 가 true이고 sortByLable이 true일때 comparer */
var ColumnLabelComparer = function(column) {
	var grid = column.grid();
	return function(field, row1, row2) {
		var item1 = grid.getItemOfRow(row1, true);
		var item2 = grid.getItemOfRow(row2, true);
		var v1 = DataCell._displayText(item1, column);
		var v2 = DataCell._displayText(item2, column);
		if (v1 === v2) {
			return 0;
		} else {
			if (v1 === UNDEFINED || v1 === null) {
				return (v2 === UNDEFINED || v2 === null) ? 0 : -1;
			}
			if (v2 === UNDEFINED || v2 === null) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		}
	};
}
/*
var DummyEditController = defineClass("DummyEditController", null, {
	init: function (grid) {
		this._super();
		this._grid = grid;
		this._editIndex = new CellIndex();
	},
	editIndex: function () {
		return this._editIndex.clone();
	},
	isEditing: function () {
		return false;
	},
	setFocus: function () {
		this._grid.container().setFocus();
	},
	resetEditor: function (resetValue) {
	},
	reprepareEditor: function (index) {
	},
	invalidateEditor: function () {
	},
	closeList: function () {
	},
	focusedIndexChanging: function () {
		//if (this._grid._readMode)
		//	return true;
	},
	focusedIndexChanged: function (oldIndex, newIndex) {
	},
	showEditor: function (index) {
	},
	hideEditor: function () {
	},
	commitEditor: function (hideEditor) {
		return true;
	},
	cancelEditor: function (hideEditor) {
	},
	fillSearchItems: function (column, searchKey, values, labels) {
	},
	buttonClicked: function (index) {
	},
	_focusHandler: function (event) {
	},
	onEditorStart: function (editor) {
	},
	onEditorKeyDown: function (editor, keyCode, ctrl, shift) {
	},
	onEditorChange: function (editor) {
	},
	onEditorSearch: function (editor, text) {
	}
});
*/
var GridView = defineClass("GridView", GridBase, {
	init : function(dom, containerId, accessbility) {
		this._super(dom, containerId, accessbility);
		this._items = this._createItemSource();
		if (!this._items) {
			throw new Error("ItemProvider can not be null");
		}
		this.setItemSource(this._items);
		this.groupingOptionsChanged();
	},
	destroy: function() {
		this._destroying = true;
		this._items = null;
		this._super();
	},
    pageCount: 0,
	rowGroupLevels: function () {
		return this._items.groupLevels();
	},
	rowGroupFields: function () {
		return this._items.groupByFields();
	},
    isRowGrouped: function () {
        return this._items.isGrouped();
    },
    getGroupList: function() {
    	return this._items.groupList();
    },
    isPaged: function() {
		return this._items.page() >= 0;    	
    },
    isMergedRowGrouped: function () {
        return this._items.isMergedRowGrouped();
    },
    page: function () {
        return this._items.page();
    },
    pageCount_: function () {
        return this._items.pageCount();
    },
    setPageCount: function (value) {
        var oldCount = this._items.pageCount();
        this._items.setPageCount(value);
        if (this._items.pageCount() != oldCount) {
            this._firePageCountChanged(this._items.pageCount());
        }
    },
    setPageSorting: function (value) {
    	this._items.setPageSorting(value);
    },
	isGrouped: function (dataColumn/* DataColumn */) {
		return dataColumn && dataColumn.groupLevel() > 0;
	},
	groupByFieldNames: function (fieldNames, sorting, direction) {
		var ds = this.dataSource();
		var labelComparer = {};
		if (ds && fieldNames && fieldNames.length > 0) {
			var i;
			var f;
			var fld;
			var flds = [];
			var columns;
			var column;
			for (var i = 0; i < fieldNames.length; i++) {
				var f = parseInt(fieldNames[i]);
				var fld = isNaN(f) ? ds.getFieldIndex(fieldNames[i]) : f;
				if (fld >= 0) {
					columns = this.columnsByFieldName(fieldNames[i]);
					column = columns && columns.length == 1 && columns[0];
					column instanceof DataColumn && column.isSortByLabel() && column.isLookupDisplay() && (labelComparer[fld] = new ColumnLabelComparer(column));
					flds.push(fld);
				}
			}
			if (flds.length > 0) {
				sorting = sorting == null ? this.rowGroup()._sorting : sorting;
				direction = direction == null ? SortDirection.ASCENDING : direction;
				this.setLabelComparer(labelComparer);
				this.groupBy(flds, sorting, direction);
			}			
		} else {
			this.setLabelComparer(labelComparer);
			this.ungroupBy();
		}
	},
	groupBy: function (fields, sorting, direction) {
		if (this.isItemEditing(null)) {
			return;
		}
		this._toastManager.show(this.groupingOptions().toast(), true, function () {
			this.$_doGroupBy(fields, sorting, direction);
		}.bind(this));
	},
	$_getVisibleRootByField: function (fld) {
		var i;
		var col;
		var cnt = this.visibleColumnCount();
		for (i = 0; i < cnt; i++) {
			col = _cast(this.getVisibleColumn(i), DataColumn);
			if (col && col.dataIndex() == fld) {
				return col;
			}
		}
		return null;
	},
	$_doGroupBy: function (fields, sorting, direction) {
		var ds = this.dataSource();
		var cnt;
		this.clearColumnMergeGrouped();
		if (ds && fields && (cnt = fields.length) > 0) {
			var i;
			var flds = [];
			for (i = 0; i < cnt; i++) {
				if (fields[i] >= 0 && fields[i] < ds.fieldCount()) {
					flds.push(fields[i]);
				}
			}
			if (flds.length > 0) {
				if (this.rowGroup().isMergeMode()) {
					for (i = flds.length - 1; i >= 0; i--) {
						var column = this.$_getVisibleRootByField(flds[i]);
						if (column) {
							column._setMergeGrouped(true);
						} else {
							flds.splice(i, 1);
						}
					}
				}
				if (flds.length > 0) {
					this._items.groupBy(flds, sorting, direction);
				}
			}
		} else {
			this._items.groupBy(null, true, SortDirection.ASCENDING);
		}
		this._doRowGroupFooterMergeChanged();
	},
	clearGroupBy: function () {
		if (this.isItemEditing(null)) {
			return;
		}
		this._items.groupBy(null, true, SortDirection.ASCENDING);
		this._items._groupSorting = this.rowGroup().isSorting();
		this._doRowGroupFooterMergeChanged();
	},
    /* realgrid */ ungroupBy: function () {
        this.clearGroupBy();
    },
	getGroupByFields: function () {
		return this._items.groupByFields();
	},
	addGroupBy: function (index, column) {
		if (this.isItemEditing(null)) {
			return;
		}
		if (this.isGrouped(column)) {
			return;
		}
		if (!column.isVisible()) {
			return;
		}
		if (!column.isRoot() && this.rowGroup().isMergeMode()) {
			return;
		}
		if (column.dataIndex() >= 0) {
			this._toastManager.show(this.groupingOptions().toast(), true, function () {
				this.$_doAddGroupBy(index, column);
			}.bind(this));
		}
	},
	$_doAddGroupBy: function (index, column) {
		var field = column.dataIndex();
		column._setMergeGrouped(this.rowGroup().isMergeMode());
		try {
			if (column.isSortByLabel() && column.isLookupDisplay()) {
				var labelComparer = this._items.getLabelComparer();
				if (!labelComparer[field]) {
					labelComparer[field] = new ColumnLabelComparer(column);
				}
			}
			this._items.addGroupBy(index, field);
			this._doRowGroupFooterMergeChanged();
		} catch (err) {
			column._setMergeGrouped(false);
			throw err;
		}
	},
	removeGroupBy: function (column) {
		if (this.isItemEditing(null)) {
			return;
		}
		if (!this.isGrouped(column)) {
			return;
		}
		var includeLower = this.groupingOptions().isRemoveIncludeLower();
		var labelComparer = this._items.getLabelComparer();
		var fields = this._items._groupedProvider.getGroupedFields();
		var dataIndex = column.dataIndex();
		if (includeLower) {
			for (var i = fields.length-1 ; i ; i--) {
				delete labelComparer[fields[i]];
				if (fields[i] == dataIndex) {
					break;
				}
			}
		} else {
			delete labelComparer[dataIndex];
		}
		this._items.removeGroupBy(dataIndex, includeLower);
		fields = this._items._groupedProvider.getGroupedFields();
		if (fields.length <= 0) {
			this._items._groupSorting = this.rowGroup().isSorting();
		}
		this._doRowGroupFooterMergeChanged();
	},
	expand: function (group, recursive, force, level) {
        if (this.isItemEditing(null)) {
            return;
        }
		this._items.expand(group, recursive, force, level);
	},
	collapse: function (group, recursive, force) {
        if (this.isItemEditing(null)) {
            return;
        }
		this._items.collapse(group, recursive, force);
	},
    getCheckedItems: function (all) {
        var items = [];
        for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
            var item = this.getItem(i);
            if (item.isChecked() && (all || (item.dataRow() >= 0))) {
                items.push(item);
            }
        }
        return items;
    },
	getCheckedItemIndices: function (all) {
		var items = [];
		for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
			var item = this.getItem(i);
			if (item.isChecked() && (all || (item.dataRow() >= 0))) {
				items.push(item.index());
			}
		}
		return items;
	},
	getCheckedRows: function (sort, visibleOnly, allRows) {
		var r, row, rows;
		if (visibleOnly) {
			rows = [];
			for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
				row = this.getItem(i);
				if (row.isChecked() && (r = row.dataRow()) >= 0) {
					rows.push(r);
				}
			}
		} else {
			rows = this._items.getCheckedRows(allRows);
		}
		if (sort) {
			rows.sort(function (r1, r2) {
				return r1 - r2;
			});
		}
		return rows;
	},
	getMergedItems: function (itemIndex, column) {
		if (typeof column === "string") {
			column = this.columnByName(column);
		} else if (column && column.$_hash) {
			column = this.columnByHash(column.$_hash);
		}
		var index = CellIndex.temp(this, itemIndex, column); 
		var room = this.layoutManager().getMergedCell(index);
		var items = [];
		if (room) {
			for (var i = room.headItem(), last = room.tailItem(); i <= last; i++) {
				var item = this.getItem(i); 
				if (item instanceof GridRow) {
					items.push(i);
				}
			}
		}
		return items;
	},
	setPaging: function (paging, pageSize, pageCount, pageSource) {
		pageSize = arguments.length > 1 ? pageSize : 10;
		pageCount = arguments.length > 2 ? pageCount : -1;
		this._items.setPaging(paging, pageSize, pageCount, null);
	},
	setPage: function (newPage, startItem) {
		startItem = arguments.length > 1 ? startItem : -1;
		newPage = Math.max(0, Math.min(newPage, this._items.pageCount() - 1));
		if (newPage != this._items.page()) {
			var changed = false;
			if (this._firePageChanging(newPage)) {
				this._items.setPage(newPage, startItem);
				changed = true;
			}
			if (changed) {
				this._firePageChanged(this._items.page());
			}
		}
	},
	resetCheckables: function () {
		this._items.resetCheckables();
	},
	applyCheckables: function () {
		this._items.applyCheckables();
	},
	dataSource: function () {
		return  this._items && this._items.dataSource();
	},
	setDataSource: function (value) {
        var oldDs = this.dataSource();
		this._items && this._items.setDataSource(value);
        if (this.dataSource() !== oldDs && this.dataSource()) {
            this.applyFilters();
        }
	},
	maxItemCount: function () {
		return this._items.maxItemCount();
	},
	setMaxItemCount: function (value) {
		this._items.setMaxItemCount(value);
	},
	_createLayoutManager: function () {
		return new GridViewLayoutManager(this);
	},
	_createItemSource: function () {
		var items = new GridItemProvider(true);
		items.setSummaryMode(this.summaryMode());
		items.setRowGroupSummaryMode(this.rowGroup().summaryMode());
		return items;
	},
	_createPanelView: function () {
		return new GridPanelElement(this._dom);
	},
	_doColumnsReset: function (group) {
		this.ungroupBy();
		this._super(group);
	},
	_visualObjectChanged: function (obj) {
		this._super(obj);
		if (obj instanceof CheckBar) {
			this._items.setCheckableExpression(obj.checkableExpression());
		}
	},
	getSummarizer: function () {
		return this._items.summarizer();
	},
	_doSortItems: function (fields, directions, textCases) {
		this._items.orderBy(fields, directions, textCases);
	},
	getSortFields: function () {
		return this._items.getSortFields();
	},
	getSortDirections: function () {
		return this._items.getSortDirections();
	},
    getSortCases: function () {
        return this._items.getSortCases();
    },
    getLabelComparer: function() {
        return this._items.getLabelComparer();
    },
	isGroupedColumn: function (column) {
		return column && column.dataIndex && this._items.isGroupedField(column.dataIndex()); // && column.root().displayIndex() < this._items.getGroupLevels();
	},
	getGroupLevels: function () {
		return this._items.getGroupLevels();
	},
	getGroupLevel: function (field) {
		return this._items.getGroupLevel(field);
	},
	_doGroupingOptionsChanged: function () {
		this._items.setExpandWhenGrouping(this.groupingOptions().isExpandWhenGrouping());	
	},
	_doRowGroupAdornmentsChanged: function () {
		this._items.setGroupedStyle(this.rowGroup().expandedAdornments(), this.rowGroup().collapsedAdornments(), this.rowGroup().createFooterCallback(), this.getHandler());
	},
	_doGroupSortingChanged: function() {
		this._items.setGroupSorting(this.rowGroup().isSorting());
	},
	_canMerge: function () {
		return !this._updateLock;
	},
	_doRowGroupMergeModeChanged: function () {
		this._super();
		this.clearColumnMergeGrouped();
		if (this.rowGroup().isMergeMode()) {
			var i;
			var flds = this._items.groupByFields();
			if (flds && flds.length > 0) {
				for (i = flds.length - 1; i >= 0; i--) {                
					var column = this.$_getVisibleRootByField(flds[i]);
					if (column) {
						column._setMergeGrouped(true);
					} else {
						flds.splice(i, 1);
					}
				}
			}
			if (flds && flds.length > 0) {
				this._items.groupByMode(flds, true);
			} else {
				this._items.groupByMode(null, true);
			}
		} else {
			this._items.setMergeMode(false);
		}
	},
	_doRowGroupFooterMergeChanged: function () {
		this._groupFooterMergeManager.buildRooms(this);
	},
	_doColumnFiltersChanged: function (filterCollection, filter) {
		this.applyFilters(filterCollection, filter);
		this.invalidateLayout();
	},
	_doSummaryModeChanged: function () {
		this._items.setSummaryMode(this.summaryMode());
	},
	_doGroupSummaryModeChanged: function () {
		this._items.setRowGroupSummaryMode(this.rowGroup().summaryMode());
	},
	getIndicatorIndex: function (item) {
		return this._items.getDisplayItemIndex(item);
	},
	updatePastedRow: function (item, values, strict) {
		var row = item.dataRow();
		if (row >= 0) {
			var ds = _cast(this.dataSource(), DataProvider);
			if (ds) {
				strict ? ds.updateStrictRow(row, values) : ds.updateRow(row, values);
			}
		}
	},
	appendPastedRow: function (values) {
		var ds = _cast(this.dataSource(), DataProvider);
		if (ds) {
			ds.appendRow(values);
		}
	},
	canMoveIndex: function (index) {
		var can = this._super(index);
		if (can && this.isMergedRowGrouped() && this.groupingOptions().isFixMergedColumns()) {
			can = index >= this.rowGroupLevels();
		}
		return can;
	},
	canMoveToIndex: function (index) {
		var can = this._super(index);
		if (can && this.isMergedRowGrouped() && this.groupingOptions().isFixMergedColumns()) {
			can = index >= this.rowGroupLevels();
		}
		return can;
	},
	_firePageChanging: function (newPage) {
		return this.fireConfirmEvent(GridView.PAGE_CHANGING, newPage);
	},
	_firePageChanged: function (newPage) {
		return this.fireEvent(GridView.PAGE_CHANGED, newPage);
	},
	_firePageCountChanged: function (newCount) {
		return this.fireEvent(GridView.PAGE_COUNT_CHANGED, newCount);
	},
	_fireGrouping: function (fields) {
		return this.fireConfirmEvent(GridView.GROUPING, fields);
	},
	_fireGrouped: function () {
		return this.fireEvent(GridView.GROUPED);
	},
	_fireExpanding: function (group) {
		return this.fireConfirmEvent(GridView.EXPANDING, group);
	},
	_fireExpanded: function (group) {
		return this.fireEvent(GridView.EXPANDED, group);
	},
	_fireCollapsing: function (group) {
		return this.fireConfirmEvent(GridView.COLLAPSING, group);
	},
	_fireCollapsed: function (group) {
		return this.fireEvent(GridView.COLLAPSED, group);
	},
	onGroupedItemProviderGrouping: function (provider, fields) {
		return this._fireGrouping(fields);
	},
	$_clearGroupedIndex: function (group) {
		var i;
		var column;
		var dcolumn;
		for (i = group.count() - 1; i >= 0; i--) {
			column = group.getItem(i);
			dcolumn = _cast(column, DataColumn);
			if (dcolumn) {
				dcolumn.setGroupLevel(-1);
			}
			if (column instanceof ColumnGroup) {
				this.$_clearGroupedIndex(column);
			}
		}
	},
	$_setGroupedIndex: function (group) {
		var i;
		var column;
		var dcolumn;
		for (i = group.count() - 1; i >= 0; i--) {
			column = group.getItem(i);
			dcolumn = _cast(column, DataColumn);
			if (dcolumn) {
				dcolumn.setGroupLevel(this._items.getGroupLevel(dcolumn.dataIndex()));
			}
			if (column instanceof ColumnGroup) {
				this.$_setGroupedIndex(column);
			}
		}
	},
	onGroupedItemProviderGrouped: function (provider) {
		this.selections().clear();
		this.$_clearGroupedIndex(this._rootGroup());
		var fields = this._items.groupByFields();
		if (fields && fields.length > 0) {
			this.$_setGroupedIndex(this._rootGroup());
		}
        var cnt, i, dcolumn, merges;
		if (this.rowGroup().isMergeMode()) { // TODO: group item provider의 mergeMode만을 기준으로 해야 한다.
			var cols = [];
            cnt = this.visibleColumnCount();
			for (i = 0; i < cnt; i++) {
				dcolumn = _cast(this.getVisibleColumn(i), DataColumn);
				if (dcolumn) {
					if (dcolumn.isMergeGrouped() && dcolumn.groupLevel() <= 0) {
						merges = _cast(dcolumn.stateFor(ColumnMergeManager.MERGE_ROOMS), ColumnMergeManager);
						if (merges) {
							merges.clear();
						}
						dcolumn._setMergeGrouped(false);
					} else if (dcolumn.isMergeGrouped()) {
						merges = _cast(dcolumn.stateFor(ColumnMergeManager.MERGE_ROOMS), ColumnMergeManager);
						if (!merges) {
							merges = new ColumnMergeManager(dcolumn);
							dcolumn.setState(ColumnMergeManager.MERGE_ROOMS, merges);
						}
						cols.push(dcolumn);
					}
				}
			}
			cnt = cols.length;
			if (cnt > 0) {
				cols = cols.sort(function (col1, col2) {
					return col1.groupLevel() - col2.groupLevel();
				});
				for (i = 0; i < cnt; i++) {
					cols[i].setDisplayIndex(i);
					merges = cols[i].stateFor(ColumnMergeManager.MERGE_ROOMS);
					merges.clear();
					merges.initialize(RowGroupMergeRule.INIT_COUNT);
				}
			}
            cnt = this.visibleColumnCount();
            for (i = 0; i < cnt; i++) {
                dcolumn = _cast(this.getVisibleColumn(i), DataColumn);
                if (dcolumn && !dcolumn.isMergeGrouped()) {
                    merges = dcolumn.stateFor(ColumnMergeManager.MERGE_ROOMS);
                    if (merges) {
                        merges.clear();
                        merges.initialize(RowGroupMergeRule.INIT_COUNT);
                    }
                }
            }
		}
		this.$_syncHeadCheck([], undefined);
		return this._fireGrouped();
	},
	onGroupedItemProviderExpand: function (provider, group) {
		return this._fireExpanding(group);
	},
	onGroupedItemProviderExpanded: function (provider, group) {
		return this._fireExpanded(group);
	},
	onGroupedItemProviderCollapse: function (provider, group) {
		return this._fireCollapsing(group);
	},
	onGroupedItemProviderCollapsed: function (provider, group) {
		return this._fireCollapsed(group);
	}
});
GridView.PAGE_CHANGING = "onGridViewPageChanging";
GridView.PAGE_CHANGED = "onGridViewPageChanged";
GridView.PAGE_COUNT_CHANGED = "onGridViewPageCountChanged";
GridView.GROUPING = "onGridViewGrouping";
GridView.GROUPED = "onGridViewGrouped";
GridView.EXPANDING = "onGridViewExpanding";
GridView.EXPANDED = "onGridViewExpanded";
GridView.COLLAPSING = "onGridViewCollapsing";
GridView.COLLAPSED = "onGridViewCollapsed";
/* 미사용 
var GridViewObserver = defineClass("GridViewObserver", GridBaseObserver, {
	init: function () {
		this._super();
	},
	onGridViewPageChanging: function (grid, newPage) {
		return true;
	},
	onGridViewPageChanged: function (grid, newPage) {
	},
	onGridViewPageCountChanged: function (grid, newCount) {
	},
	onGridGrouping: function (grid, fields) {
		return true;
	},
	onGridGrouped: function (grid) {
	},
	onGridExpanding: function (grid, group) {
		return true;
	},
	onGridExpanded: function (grid, group) {
	},
	onGridCollapsing: function (grid, group) {
		return true;
	},
	onGridGCollapsed: function (grid, group) {
	}
});
*/
var GridViewLayoutManager = defineClass("GridViewLayoutManager", GridLayoutManager, {
	init: function(grid) {
		this._super(grid);
	},
	isRowGrouped: function () {
		return !this.grid().rowGroup().isMergeMode() && this.grid().isRowGrouped();
	},
	rowGroupLevels: function () {
		return this.grid().rowGroupLevels();
	}
});
var GridViewSelectionTool = defineClass("GridViewSelectionTool", GridSelectionTool, {
	init : function(owner) {
		this._super(owner);
	},
	_getEditRequest: function (source, x, y, ctrlKey, shiftKey) {
		if (source instanceof ColumnView) {
			return new PanelCellRequest(source);
		}
		var request = this._super(source, x, y, ctrlKey, shiftKey);
		if (request) {
			return request;
		}
		var grid = this.grid();
		if (source instanceof HeaderCellElement) {
			var index = source.index();
			var dataColumn = index.dataColumn();
			if (grid.groupingOptions().isEnabled && grid.panel().isVisible() && dataColumn && dataColumn.isGroupable()) {
				return new RowGroupingRequest(source);
			}
		}
		return null;
	},
	_getDragTracker: function (request, x, y) {
		if (request instanceof PanelCellRequest) {
			return new PanelCellTracker(this.grid(), request);
		} else if (request instanceof RowGroupingRequest) {
			return new RowGroupingTracker(this.grid(), request);
		}
		return this._super(request, x, y);
	},
	_doColumnHeaderClicked: function (column, rightClicked, event) {
		this._super(column);
        if (!rightClicked) {
            var grid = this.grid();
            var dcol = _cast(column, DataColumn);
            if (!grid.isEmpty() && dcol && dcol.isSortable() && grid.sortingOptions().isEnabled()) {
                grid.sortColumn(dcol, event);
            }
        }
	},
	_doHandleClicked: function (handle) {
		var grid = this.grid();
		var group;
		if (handle instanceof HeaderSortHandle) {
			var leftPos = grid.leftPos();
			grid.sortColumn(handle.cellView().index().dataColumn());
			grid.setLeftPos(leftPos);
		} else if (handle instanceof RowGroupExpandHandle) {
			var item = handle.cellView().item();
			group = item instanceof GroupItemImpl ? item : handle.cellView().item().parent();
			group = _cast(group, GroupItemImpl);
			if (group) {
				if (group.isExpanded()) {
					grid.collapse(group);
				} else {
					grid.expand(group, false, false)
				}
			}
		} else if (handle instanceof DataCellExpandHandle) {
			group = handle.group();
			if (group) {
				if (group.isExpanded()) {
					grid.collapse(group);
				} else {
					grid.expand(group, false, false)
				}
				if (!group.isExpanded()) {
					var i = group.index() >= 0 ? group.index() : group.firstItem().index();
					if (i < 0 && group.footer()) {
						i = group.footer().index();
					}
					if (i >= 0) {
						var index = grid.getIndex(i);
						grid.makeCellVisible(index);
					}
				}
			}
		} else {
			this._super(handle);
		}
	}
});
var GridPanelElement = defineClass("GridPanelElement", PanelElement, {
	init: function(dom) {
		this._super(dom);
		this._messageView = new PanelMessageView(dom, "messageView");
		this.addElement(this._messageView);
		this._groupByView = new GroupByView(dom, "groupByView");
		this.addElement(this._groupByView);
		this._state = GridPanelElement.NORMAL;
	},
	state: 0, 
	groupingIndex: -1,
	setState: function (value) {
		if (value != this._state) {
			this._state = value;
			switch (value) {
			case GridPanelElement.NORMAL:
				this._groupingIndex = -1;
				break;
			case GridPanelElement.GROUPING:
				this._groupingIndex = this._groupByView.childCount();
				break;
			case GridPanelElement.UNGROUPING:
				this._groupingIndex = 0;
				break;
			}
			this.layoutContent(null);
			this.invalidate();
		}
	},
	setGroupingIndex: function (value) {
		if (value != this._groupingIndex) {
			this._groupingIndex = value;
			this.layoutContent(null);
			this.invalidate();
		}
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		var sz;
		var sz2;
		var options = grid.groupingOptions();
		this._messageView.setText(options.prompt());
		this._messageView.updateStyles(this.model().styles());
		this._groupByView.setLinear(options.isLinear());
		this._groupByView.updateStyles(this.model().styles());
		sz = this._groupByView.measure(hintWidth, hintHeight).clone();
		if (this._groupByView.fieldCount() < 1) {
			sz = this._messageView.measure(hintWidth, hintHeight).clone();
		}
		sz2 = this._super(grid, hintWidth, hintHeight);
		sz.width = Math.max(sz.width, sz2.width);
		sz.height = Math.max(sz.height, sz2.height, 30);
		return sz;	
	},
	_doLayoutContent: function (lm) {
		var w = this.width();
		var h = this.height();
		this._messageView.setVisible((this._state == GridPanelElement.NORMAL) && !this.grid().isRowGrouped());
		if (this._messageView.isVisible()) {
			var sz = this._messageView.measure(w, h);
			this._messageView.setBounds(4, 0, sz.width + 10, h);
		}
		this._groupByView.setVisible(true);
		if (this._groupByView.isVisible()) {
			this._groupByView.setBounds(4, 0, w, h);
			this._groupByView.layoutContent(lm);
		}
	}
}, {
	NORMAL: 0,
	GROUPING: 1,
	UNGROUPING: 2
});
var PanelMessageView = defineClass("PanelMessageView", VisualElement, {
	init: function(dom, name) {
		this._super(dom, name);
		this._paddingLeft = 4;
	},
	destroy: function() {
		this._destroying = true;
		this._font = null;
		this._super();
	},
	font: null,
	foreground: SolidBrush.BLACK,
	textAlignment:Alignment.NEAR,
	text: null,
	/* @internal */ measure: function (hintWidth, hintHeight) {
		return new Size(hintWidth, 20);// hintHeight);
	},
	/* @internal */ updateStyles: function (styles) {
		this._paddingLeft = styles.paddingLeft();
		this.setForeground(styles.foreground());
		this.setFont(styles.font());
	},
	_doDraw: function (g) {
		var r = this.getClientRect();
		r.setLeft(this._paddingLeft);
		g.drawTextRect(this.font(), this.foreground(), this._text, r, this.textAlignment());
	}
});
var ColumnView = defineClass("ColumnView", HeaderCellElement, {
	init: function(grid, dom, name) {
		CellElement$.init.call(this, dom, name);
		this._acceptable = true;
		this._stroke = new SolidPen(0x88000000, 3);
		this.setShowHandles(false);
		this._removeButton = new GroupRemoveButtonHandle(grid, dom, this);
		this._removeButton.setVisible(false);
		this.addElement(this._removeButton);
	},
	removeButton: null,
	setAcceptable: function (value) {
		if (value != this._acceptable) {
			this._acceptable = value;
			this.invalidate();
		}
	},
	_doMeasure: function (grid, hintWidth, hintHeight) {
		var w = this.container().measureText(this.font(), this.text()) + this.paddingHorz() + this.borderWidth() * 2; 
		w += this._removeButton && this._removeButton.isVisible() ? this._removeButton.size() + this._removeButton._buttonGap: 0;
		return new Size(w, hintHeight);
	},
	setBorderRight: function(value) {
		CellElement$.setBorderRight.call(this, value);
		// var column = this._index && this._index._column;
		// var drawRight = this.grid().displayOptions().isDrawLastColumnRight();
		// this._super(!drawRight && column && column._isLastColumn ? null : value);
	},	
	_doPrepareElement: function (styles) {
		this._super(styles);
		this.setShowHandles(false);
	},
	_doLayoutHandles: function () {
		var grid = this.grid();
		var column = this._column;
		if (grid && column instanceof DataColumn) {
			var r = this._getRenderRect(null);
			var x = r.right() - 4;
			var y = r.y;
			var h = r.height;
			if (this._removeButton && this._removeButton.isVisible()) {
				var size = this._removeButton.size();
				this._removeButton.setMouseEnabled(true);
				this._removeButton.setBounds(x - size, y, size, h);
				this._removeButton.invalidate();
			}
		}		
	},
	_doUpdateContent: function(model) {
		var grid = this.grid();
		var removeButton = grid && grid.groupingOptions() && grid.groupingOptions().removeButton();
		this._removeButton.setVisible(removeButton && removeButton.isVisible());
		removeButton && removeButton.fill() && (this._removeButton._fill = removeButton.fill());
		removeButton && removeButton.hoveredFill() && (this._removeButton._hoveredFill = removeButton.hoveredFill());
		removeButton && removeButton.size() && (this._removeButton._size = removeButton.size());
		removeButton && removeButton.buttonGap != null && (this._removeButton._buttonGap = removeButton.buttonGap());
	},
	_doRender: function (g, r) {
		var border = this.border();
		var borderWidth = border ? border.width() : 0;
		var fill = null;
		if (this.isHovered()) {
			fill = this.hoveredBackground() || this.background();
		} else {
			fill = this.background();
		}
		if (fill) {
			g.drawRectI(fill, null, r);
		}
		if (borderWidth > 0) {
			r.inflate(borderWidth, borderWidth);
		}
		fill = null;
		if (this.isHovered()) {
			fill = this.hoveredForeground();
			if (!fill) {
				fill = this.foreground();
			}
		} else {
			fill = this.foreground();
		}
		var tr = r.clone();
		this._removeButton.isVisible() && (tr.width -= (this._removeButton.size()+this._removeButton.buttonGap()));
		if (fill) {
			g.drawTextRect(this.font(), fill, this.text(), tr, TextAlign.CENTER);
		}
		if (border) {
			r.inflate(-borderWidth, -borderWidth);
			g.drawBoundsI(null, border, r.x, r.y, r.right() - 1, r.bottom() - 1);
		}
		if (!this._acceptable) {
			r.inflate(-3, -3);
			g.drawLine(this._stroke, r.x, r.y, r.right(), r.bottom());
			g.drawLine(this._stroke, r.right(), r.y, r.x, r.bottom());
		}
	},
	isHovered: function() {
		return this._hovered || this._removeButton.isHovered();
	}
});
var GroupByView = defineClass("GroupByView", VisualElement, {
	init: function(dom, name) {
		this._super(dom, name);
		this._columnViews = [];
		this._fields = [];
		this._paddingLeft = 8;
		this._paddingTop = 4;
		this._paddingBottom = 5;
		this._columnWidth = 80;
		this._columnHeight = 20;
	},
	destroy: function() {
		this._destroying = true;
		this._columnViews = null;
		this._fields = null;
		this._super();
	},
	verticalGap: 12,
	horizontalGap: 12,
	linear: false,
	fieldCount: function () {
		return this._fields ? this._fields.length : 0;
	},
	/* @internal */ measure: function(hintWidth, hintHeight) {
		this._fields = this.container().gridView().getGroupByFields();
		if (this._fields && this._fields.length > 0) {
			this.$_prepareColumnViews(this._fields);
			return new Size(hintWidth, 
						this._paddingTop + this._paddingBottom + this._columnHeight + (this._linear ? 0 : (this._fields.length - 1) * this._verticalGap));
		} else {
			return new Size(hintWidth, hintHeight);
		}
	},
	/* @internal */ layoutContent: function (lm) {
		this.$_layoutColumnViews(this._fields);
		this.invalidate();
	},
	/* @internal */ updateStyles: function (styles) {
		this._paddingLeft = styles.paddingLeft();
		this._paddingTop = styles.paddingTop();
		this._paddingBottom = styles.paddingBottom();
	},
	_doDraw: function(g) {
		if (!this._fields || this._fields.legnth < 1) {
			return;
		}
		var line = this.container().gridView().rowGroup().panelStyles().line();
		if (line) {
			var i;
			var cnt = this._fields.length;
			if (cnt < 1) {
				return;
			}
			var view = this._columnViews[0];
			var r1 = view.getBounds();
			var r2 = new Rectangle();
			for (i = 1; i < cnt; i++) {
				view = this._columnViews[i];
				r2 = view.getBounds();
				if (this._linear) {
					g.drawLineI(line, r1.right(), r1.y + r1.height / 2, r2.x, r1.y + r1.height / 2);
				} else {
					g.drawLinesI(line, r1.right(), r1.y + r1.height / 3, r2.x + r2.width / 4, r1.y + r1.height / 3, r2.x + r2.width / 4, r2.y);
				}
				r1.copy(r2);
			}
		}
	},
	$_prepareColumnViews: function (fields) {
		if (this._fields && this._fields.length > 0) {
			var cnt = this._fields.length;
			while (this._columnViews.length < cnt) {
				this._columnViews.push(new ColumnView(this.container().gridView(), this._dom));
			}
		}
	},
	$_layoutColumnViews: function (fields) {
		this.hideAll();
		if (!fields || fields.length < 1) {
			return;
		}
		var i;
		var column;
		var cell;
		var view;
		var w;
		var grid = this.container().gridView();
		var lm = grid.layoutManager();
		var cnt = fields.length;
		var x = this._paddingLeft;
		var y = this._paddingTop;
		for (i = 0; i < cnt; i++) {
			column = grid.getDataColumn(fields[i]);
			cell = grid.header().getGroupingCell(column);
			view = this._columnViews[i];
			if (view.parent() == this) {
				view.setVisible(true);
				view.invalidate(); // TODO: 이걸 안해주면 처음에 못 그린다.
			} else {
				this.addElement(view);
			};
			view.updateCell(cell);
			w = Math.max(this._columnWidth, view.measure(grid, this._columnWidth, this._columnHeight).width);
			view.setBounds(x, y, w, this._columnHeight);
			view.layoutContent(lm);
			x += w + this._horizontalGap;
			if (!this._linear) {
				y += this._verticalGap;
			}
		}
	}
});
var RowGroupingRequest = defineClass("RowGroupingRequest", CellRequest, {
	init: function (cell) {
		this._super(cell);
	},
	groupIndex: -1,
	column: function () {
		return _cast(this.cell().index().column(), DataColumn);
	},
	cursor: function () {
		return null;
	}
});
var RowGroupingTracker = defineClass("RowGroupingTracker", GridDragTracker, {
	init: function (grid, request) {
		this._super(grid, "rowGroupingTracker");
		this._request = request;
		this._columnView = null;
		this._panelView = grid.panelView();
	},
	request: function () {
		return this._request;
	},
	_doStart: function (x, y) {
		this._panelView.setState(GridPanelElement.GROUPING);
		return true;
	},
	_canAccept: function (x, y) {
		return y - 2 < this.grid().layoutManager().headerBounds().y;
	},
	_doCompleted: function () {
		var grid = this.grid();
		if (!grid.isGrouped(this._request.column())) {
			grid.addGroupBy(this._panelView.groupingIndex(), this._request.column());
		}
	},
	_doEnded: function () {
		this._panelView.setState(GridPanelElement.NORMAL);
	},
	_showFeedback: function (x, y) {
        var grid = this.grid();
        var index = CellIndex.temp(grid, -1, this._request.column());
        if (!this._columnView) {
			this._columnView = new ColumnView(grid, grid._dom);
		}
		this._columnView.updateCell(grid.header().getCell(index));
		this._columnView.setBounds(0, 0, 100, 20);
		this._columnView.invalidate();
		this._columnView.setAcceptable(!grid.isGrouped(this._request.column()));
		grid.addFeedbackElement(this._columnView);
		this._columnView.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
	},
	_moveFeedback: function (x, y) {
		var grid = this.grid();
		this._columnView.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
	},
	_hideFeedback: function () {
		this.grid().removeFeedbackElement(this._columnView);
	}
});
var PanelCellRequest = defineClass("PanelCellRequest", CellRequest, {
	init: function (cell) {
		this._super(cell);
	},
	groupIndex: -1,
	column: function () {
		return _cast(this.cell().index().column(), DataColumn);
	},
	cursor: function () {
		return null;
	}
});
var PanelCellTracker = defineClass("PanelCellTracker", GridDragTracker, {
	init: function (grid, request) {
		this._super(grid, "panelCellTracker");
		this._request = request;
		this._columnView = null;
		this._panelView = grid.panelView();
	},
	request: function () {
		return this._request;
	},
	_doStart: function (x, y) {
		this._panelView.setState(GridPanelElement.NORMAL);
		return true;
	},
	_canAccept: function (x, y) {
		return y - 2 >= this.grid().layoutManager().headerBounds().y;
	},
	_showFeedback: function (x, y) {
        var grid = this.grid();
        var index = CellIndex.temp(grid, -1, this._request.column());
        if (!this._columnView) {
			this._columnView = new ColumnView(grid, grid._dom);
		}
		this._columnView.updateCell(grid.header().getCell(index));
		this._columnView.setBounds(0, 0, 100, 20);
		this._columnView.invalidate();
		grid.addFeedbackElement(this._columnView);
		this._columnView.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
	},
	_moveFeedback: function (x, y) {
		var grid = this.grid();
		this._columnView.move(grid.containerToGridX(x) - 4, grid.containerToGridY(y) - 2);
	},
	_hideFeedback: function () {
		var grid = this.grid();
		grid.removeFeedbackElement(this._columnView);
	},
	_doCompleted: function () {
		var grid = this.grid();
		grid.removeGroupBy(this._request.column());
	}
});
var ScrollEventType = {
	LINE_UP: "lineUp",
	LINE_DOWN: "lineDown",
	LINE_LEFT: "lineLeft",
	LINE_RIGHT: "lineRight",
	PAGE_UP: "pageUp",
	PAGE_DOWN: "pageDown",
	PAGE_LEFT: "pageLeft",
	PAGE_RIGHT: "pageRight",
	THUMB_TRACK: "thumbTrack",
	THUMB_END: "thumbEnd"
};
var ScrollCorner = defineClass("ScrollConrer", GridElement, {
	init: function (dom) {
		this._super(dom, "scrollCorner");
	},
	_doRender: function(g, r) {
		var grid = this.grid();
		var styles = grid.displayOptions().scrollBarStyles();
		var fill = styles.background() || (new SolidBrush("#fff0f0f0"));
		g.drawRectI(fill, null, r);
	},
})
var ScrollBar = defineClass("ScrollBar", GridElement, {
	init: function (dom, vertical) {
		this._super(dom, "scrollBar");
		this._nearButton = new ScrollButton(dom, this, false);
		this.addElement(this._nearButton);
		this._farButton = new ScrollButton(dom, this, true);
		this.addElement(this._farButton);
		this._thumb = new ScrollThumb(dom, this);
		this.addElement(this._thumb);
		this._vertical = vertical;
		this._buttonSize = 20;
		this._min = 0;
		this._max = 0;
		this._pos = 0;
		this._page = 0;
		this._maxPosition = 0;
		this._tipView = null;
	},
	lineScrollSize: 1,
	pageScrollSize: 1,
	minThumbSize: 20,
	isVertical: function () {
		return this._vertical;
	},
	maxPosition: function () {
		return this._maxPosition;
	},
	setProperties: function (min, max, page) {
		min = Math.max(0, min);
		max = Math.max(min, max);
		if (min != this._min || max != this._max || page != this._page) {
			this._min = min;
			this._max = max;
			this._page = page;
			this._pos = Math.min(this._max, Math.max(this._min, this._pos));
			this._maxPosition = Math.max(0, this._max - this._page);
			this.invalidate();
		}
	},
	setPosition: function (value, layout) {
		value = Math.min(this._maxPosition, Math.max(this._min, value));
		if (value != this._pos) {
			this._pos = value;
			this.invalidate(false, true);
			layout && this._doLayoutContent();
		}
	},
	setText: function(value) {
		if (this._tipView && value) {
			this._tipView.show();
			this._tipView.setText(value);
			var x, y;
			if (this._vertical) {
				var tw = this._tipView.width();
				x = this.x() - tw - 5;
				y = this._thumb.y();
			} else {
				var th = this._tipView.height();
				x = this._thumb.x();
				y = this.y() - th - 5;
			}
			this._tipView.move(x, y);
		}
	},
	ptInTrack: function (x, y, isFar) {
		var p = this.containerToElement(x, y);
		if (this._vertical) {
			if (p.y >= this._nearButton.height() && p.x < this._farButton.y()) {
				return !isFar && p.y < this._thumb.y() || isFar && p.y >= this._thumb.bottom();
			}
		} else {
			if (x >= this._nearButton.width() && x < this._farButton.x()) {
				return !isFar && p.x < this._thumb.x() || isFar && p.x >= this._thumb.right();
			}
		}
		return false;
	},
	_doLayoutContent: function (lm) {
		var vertical = this._vertical;
		var szBtn = this._buttonSize;
		var szTrack = (vertical ? this._height : this._width) - szBtn * 2;
		var szThumb = Math.min(szTrack, Math.max(this._minThumbSize, _int(szTrack * this._page / (this._max - this._min + 1))));
		var pos = szBtn + Math.min(szTrack - szThumb, Math.max(0, _int((szTrack - szThumb) * this._pos / (this._maxPosition - this._min))));
		if (vertical) {
			this._nearButton.setBounds(0, 0, this._width, szBtn);
			this._farButton.setBounds(0, this._height - szBtn, this._width, szBtn);
			if (szThumb <= szTrack) {
				this._thumb.setBounds(1, pos, this._width - 2, szThumb);
			}
		} else {
			this._nearButton.setBounds(0, 0, szBtn, this._height);
			this._farButton.setBounds(this._width - szBtn, 0, szBtn, this._height);
			if (szThumb <= szTrack) {
				this._thumb.setBounds(pos, 1, szThumb, this._height - 2);
			}
		}
	},
	_doRender: function(g, r) {
		var grid = this.grid();
		var styles = grid.displayOptions().scrollBarStyles();
		var fill = styles.background() || (new SolidBrush("#fff0f0f0"));
		g.drawRectI(fill, null, r);
		if (this._vertical) {
		} else {
		}
	},
	_doScroll: function (eventType, delta, position) {
		this.fireEvent(ScrollBar.SCROLLED, eventType, delta, position);
	},
	_mouseOut: function () {
		this._nearButton.setPressed(false);
		this._farButton.setPressed(false);
		this._thumb.setPressed(false);
	}
});
ScrollBar.SCROLLED = "onScrollBarScrolled";
var ScrollButton = defineClass("ScrollButton", VisualElement, {
	init: function (dom, scrollBar, far) {
		this._super(dom);
		this._scrollBar = scrollBar;
		this._far = far;
		this._enabled = true;
	},
	pressed: false,
	enabled: true,
	isVertical: function () {
		return this._scrollBar._vertical;
	},
	isFar: function () {
		return this._far;
	},
	scrollBar: function () {
		return this._scrollBar;
	},
	_hoveredChanged: function () {
		this.invalidate();
	},
	_doDraw: function(g) {
		var r = this.getClientRect();
		var x = _int(r.width / 2);
		var y = _int(r.height / 2);
		var grid = this.scrollBar().grid();
		var styles = grid.displayOptions().scrollButtonStyles();
		var fill = this._pressed ? styles.selectedBackground() : this.isHovered() ? styles.hoveredBackground() : styles.background();
		var s = this._pressed ? styles.selectedForeground(): this.isHovered() ? styles.hoveredForeground():styles.foreground();
		s = new SolidPen(s ? s._color.toString() : this._pressed ? "#ffffffff" : "#ff333333");
		g.drawRectI(fill, null, r);
		if (this._scrollBar._vertical) {
			if (this._far) {
				g.drawVertLineI(s, y - 1, y + 3, x);
				g.drawHorzLineI(s, x - 3, x + 4, y - 1);
				g.drawHorzLineI(s, x - 2, x + 3, y);
				g.drawHorzLineI(s, x - 1, x + 2, y + 1);
			} else {
				g.drawVertLineI(s, y - 2, y + 1, x);
				g.drawHorzLineI(s, x - 3, x + 4, y + 1);
				g.drawHorzLineI(s, x - 2, x + 3, y);
				g.drawHorzLineI(s, x - 1, x + 2, y - 1);
			}
		} else {
			if (this._far) {
				g.drawHorzLineI(s, x - 1, x + 3, y);
				g.drawVertLineI(s, y - 3, y + 4, x - 1);
				g.drawVertLineI(s, y - 2, y + 3, x);
				g.drawVertLineI(s, y - 1, y + 2, x + 1);
			} else {
				g.drawHorzLineI(s, x - 2, x + 1, y);
				g.drawVertLineI(s, y - 3, y + 4, x + 1);
				g.drawVertLineI(s, y - 2, y + 3, x);
				g.drawVertLineI(s, y - 1, y + 2, x - 1);
			}
		}
	}
});
var ScrollThumb = defineClass("ScrollThumb", VisualElement, {
	init: function (dom, scrollBar) {
		this._scrollBar = scrollBar;
		this._super(dom);
	},
	pressed: false,
	scrollBar: function () {
		return this._scrollBar;
	},
	isVertical: function () {
		return this._scrollBar._vertical;
	},
	_hoveredChanged: function () {
		this.invalidate();
	},
	_doDraw: function(g) {
		var r = this.getClientRect();
		var grid = this.scrollBar().grid();
		var styles = grid.displayOptions().scrollThumbStyles();
		var fill = this._pressed ? styles.selectedBackground() : this.isHovered() ? styles.hoveredBackground() : styles.background();
		var s = styles.border();
		if (grid.scrollThumbRadius() > 0) {
			var radius = grid.scrollThumbRadius();
			g.drawRoundRectI(fill, s, r, radius,radius,radius,radius,0);
		} else {
			g.drawRectI(fill, s, r);
		}
	}
});
var ScrollThumbRequest = defineClass("ScrollThumbRequest", GridEditRequest, {
	init: function (thumb) {
		this._super();
		this._thumb = thumb;
	},
	thumb: function () {
		return this._thumb;
	},
	scrollBar: function () {
		return this._thumb.scrollBar();
	},
	cursor: function () {
		return Cursor.ARROW;
	},
	isSelectable: function () {
		return false;
	}
});
var ScrollThumbTracker = defineClass("ScrollThumbTracker", GridDragTracker, {
	init: function (request, x, y) {
		this._super(request.scrollBar().grid(), "scrollThumbTracker");
		this._request = request;
		this._thumb = request.thumb();
		this._scrollBar = request.scrollBar();
		this._vertical = this._scrollBar.isVertical();
		var p = this._scrollBar.containerToElement(x, y);
		if (this._scrollBar.isVertical()) {
			this._offset = p.y - this._thumb.y();
		} else {
			this._offset = p.x - this._thumb.x();
		}
	},
	isStartWhenCreated: function () {
		return true;
	},
	_doStart: function (x, y) {
		this._thumb.setPressed(true);
		return true;
	},
	_doDrag: function (x, y) {
		return this.$_doScroll(x, y, ScrollEventType.THUMB_TRACK);
	},
	_doCompleted: function (x, y) {
		return this.$_doScroll(x, y, ScrollEventType.THUMB_END);
	},
	_doCanceled: function (x, y) {
	},
	_doEnded: function () {
		this._thumb.setPressed(false);
	},
	$_doScroll: function (x, y, eventType) {
		var len = this._scrollBar._maxPosition - this._scrollBar._min + 1;
		var szBtn = this._scrollBar._buttonSize;
		var p = this._scrollBar.containerToElement(x, y);
		if (this._scrollBar.isVertical()) {
			var scrLen = this._scrollBar.height() - szBtn * 2 - this._thumb.height();
			if ( scrLen <= 0 ) {
				return;
			};
			p.y -= this._offset;
			p.y = (p.y - szBtn) * len / scrLen;
			this._scrollBar._doScroll(eventType, 0, _int(p.y));
		} else {
			var scrLen = this._scrollBar.width() - szBtn * 2 - this._thumb.width();
			if (scrLen <= 0) {
				return;
			}
			p.x -= this._offset;
			p.x = (p.x - szBtn) * len / scrLen;
			this._scrollBar._doScroll(eventType, 0, _int(p.x));
		}
		return true;
	}
});

var ScrollTipView = defineClass("ScrollTipTracker", null, {
	init: function(container) {
		this._super();
		this._container = container;
		this._dom = new Dom(this._element = this.$_createElement());
	},
	destroy: function() {
		this.hide();
		this._element && this._element.parentElement && this._element.parentElement.removeChild(this._element);
		this._container = null;
		this._dom = this._element = null;
		this._super();
		return null;
	},
	show: function () {
		this._container.appendChild(this._element);
	},
	hide: function () {
		this._element.parentElement && this._element.parentElement.removeChild(this._element);
	},
	move: function (x, y) {
		this._dom.move(x, y);
	},
	setText: function(msg) {
		// if (/(<([^>]+)>)/.test(msg)) {

		// }
		this._element.innerHTML = this._msg = msg;
		// this._element.textContent = msg;
	},
	width: function() {
		return this._element.offsetWidth;
	},
	height: function() {
		return this._element.offsetHeight;
	},
	getRect: function() {
		return  this._element.getBoundingClientRect();
	},
	$_createElement: function() {
        var div = Dom.createElement("div", {
            position: "absolute",
            padding: "4px 8px",
            fontSize: "12px",
            boxSizing: "border-box",
            display: "inline-block",
            borderRadius: "4px",
            pointerEvents: "none",
            userSelect: "none"
            // backgroundColor: "rgba(0, 111, 245, 0.05)",
            // border: "1px solid #ddd"
        });
        div.className = "rg-scroll-tip-view";
        div.style.backgroundColor = "rgba(214, 214, 214, 0.8)";
        div.style.border = "1px solid rgb(0, 66, 148)";
        return div;
	}
});

var ScrollButtonTimer = defineClass("ScrollButtonTimer", EventAware, {
	init: function (button) {
		this._super();
		this._button = button;
		this._scrollBar = button.scrollBar();
		this._active = false;
		this._timer = UNDEFINED;
		this._ready = false;
	},
	start: function () {
		this._button.setPressed(true);
		this._active = true;
		this.$_fireEvent();
		setTimeout( function () {
			if (this._ready) {
				this._ready = false;
				this._timer = setInterval(function () {
					if (this._active) {
						this.$_fireEvent();
					}
				}.bind(this), 50);
			}
		}.bind(this), 200);
		this._ready = true;
	},
	move: function (x, y) {
		var p = this._button.containerToElement(x, y);
		this._active = this._button.containsInClient(p.x, p.y);
	},
	stop: function (x, y) {
		this._ready = false; // 위 setTimeout callback이 실행되기 전에 stop()이 호출되면 무시해야 한다.
		if (this._timer) {
			clearInterval(this._timer);
		}
		this._button.setPressed(false);
	},
	$_fireEvent: function () {
		var type = null;
		var delta = 1;
		if (this._scrollBar.isVertical()) {
			if (this._button.isFar()) {
				type = ScrollEventType.LINE_DOWN;
			} else {
				type = ScrollEventType.LINE_UP;
				delta = -1;
			}
		} else {
			if (this._button.isFar()) {
				type = ScrollEventType.LINE_RIGHT;
			} else {
				type = ScrollEventType.LINE_LEFT;
				delta = -1;
			}
		}
		this._scrollBar._doScroll(type, this._scrollBar.lineScrollSize() * delta, 0);
	}
});
var ScrollTrackTimer = defineClass("ScrollTrackTimer", EventAware, {
	init: function (bar, isFar) {
		this._super(bar);
		this._scrollBar = bar;
		this._isFar = isFar;
		this._active = false;
		this._timer = UNDEFINED;
		this._ready = false;
	},
	start: function () {
		this._active = true;
		this.$_fireEvent();
		setTimeout( function () {
			if (this._ready) {
				this._ready = false;
				this._timer = setInterval(function () {
					if (this._active) {
						this.$_fireEvent();
					}
				}.bind(this), 50);
			}
		}.bind(this), 200);
		this._ready = true;
	},
	move: function (x, y) {
		var p = this._scrollBar.containerToElement(x, y);
		this._active = this._scrollBar.ptInTrack(p.x, p.y, this._isFar);
	},
	stop: function (x, y) {
		this._ready = false;
		if (this._timer) {
			clearInterval(this._timer);
		}
	},
	$_fireEvent: function () {
		var type = null;
		var delta = 0;
		var thumb = this._scrollBar._thumb;
		if (this._scrollBar.isVertical()) {
			var y = this._scrollBar.mouseY();
			if (this._isFar && y > thumb.bottom()) {
				type = ScrollEventType.PAGE_DOWN;
				delta = 1;
			} else if (y < thumb.y()) {
				type = ScrollEventType.PAGE_UP;
				delta = -1;
			}
		} else {
			var x = this._scrollBar.mouseX();
			if (this._isFar && x > thumb.right()) {
				delta = 1;
				type = ScrollEventType.PAGE_RIGHT;
			} else if (x < thumb.x()) {
				type = ScrollEventType.PAGE_LEFT;
				delta = -1;
			}
		}
		delta != 0 && this._scrollBar._doScroll(type, this._scrollBar.pageScrollSize() * delta, 0);
	}
});

/*
var  ExpressionRuntime = defineClass("ExpressionRuntime", null, {
	init: function () {
		this._super();
	},
	isIdentifier: function (token) {
		throw new ExpressionSyntaxError("Token is not a valid Identifier: " + token, null);
	},
	evaluateIdentifier: function (idKey) {
	},
	evaluateIndexerI: function (idKey, index) {
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
	},
	_invalidIdentError: function (idKey) {
		throw "Invalid identifier key: " + idKey;
	}
});
*/

var DataRowExpressionRuntime = defineClass("DataRowExpressionRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._item = null;
		this._group = null;
		this._dataSource = null;
		this._fieldCount = null;
		this._grid = null;
	},
	destroy: function() {
		this._destroying = true;
		this._item = null;
		this._group = null;
		this._dataSource = null;
		this._grid = null;
		this._super();
	},
	index: function () {
		return this._item.index();
	},
	item: function () {
		return this._item;
	},
	setDataSource: function (value) {
		this._dataSource = value;
		this._fieldCount = value ? value.fieldCount() : 0;
	},
	setItem: function (item, grid) {
		if (!item) {
			if ($_debug) debugger;
		}
		this._item = item;
		this._group = _cast(item, GroupItem);
		this._grid = grid;
	},
	_evaluate: function (func) {
		var handler = this._grid ? this._grid.getHandler() : null;
		var index = {dataRow:this._item._dataRow, itemIndex:this._item._index};
		return func(handler, index);
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataRowExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return DataRowExpressionRuntime.IDENTS[token];
		} 
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		assert(this._item != null, "item is null");
		switch (idKey) {
		case DataRowExpressionRuntime.ID_ROW:
			return this._item.index();
		case DataRowExpressionRuntime.ID_DATA_ROW:
			return this._item.dataRow();
		case DataRowExpressionRuntime.ID_CHECKED:
			return this._item.isChecked();
		case DataRowExpressionRuntime.ID_STATE:
			switch (this._item.rowState()) {
			case RowState.CREATED:
				return "c";
			case RowState.UPDATED:
				return "u";
			case RowState.DELETED:
				return "d";
			case RowState.CREATE_AND_DELETED:
				return "x";
			}
			return UNDEFINED;
		case DataRowExpressionRuntime.ID_COUNT:
			return this._group ? this._group.count() : 0;
		case DataRowExpressionRuntime.ID_DCOUNT:
			return this._group ? this._group.descendantCount() : 0;
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (this._item) {
			if (idKey == DataRowExpressionRuntime.ID_VALUE || idKey == DataRowExpressionRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._item.getData(index);
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return UNDEFINED;
		}
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == DataRowExpressionRuntime.ID_VALUE || idKey == DataRowExpressionRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field is not exists:" + index);
				}
				return this._item.getData(idx);
			} else {
				return UNDEFINED;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_ROW: 0,
	ID_DATA_ROW: 1,
	ID_CHECKED: 2,
	ID_VALUE: 3,
	ID_VALUES: 4,
	ID_STATE: 5,
	ID_COUNT: 6,
	ID_DCOUNT: 7
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		checked: f.ID_CHECKED,
		value: f.ID_VALUE,
		values: f.ID_VALUES,
		state: f.ID_STATE,
		count: f.ID_COUNT,
		dcount: f.ID_DCOUNT
	};
});
var DataCellExpressionRuntime = defineClass("DataCellExpressionRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._cell = null;
		this._item = null;
		this._dataSource = null,
		this._fieldCount = 0;
		this._grid = null;
	},
	destroy: function() {
		this._destroying = true;
		this._cell =null;
		this._grid = null;
		this._dataSource = null;
		this._super();
	},
	setDataSource: function (value) {
		this._dataSource = value;
		this._fieldCount = value ? value.fieldCount() : 0;
	},
	setCell: function (value, item) {
		this._cell = value;
		this._grid = value._index.grid();
		this._item = value.index().item() || item;
	},
	_evaluate: function (func) {
		var handler = this._grid ? this._grid.getHandler() : null;
		var cell = this._cell;
		var index = cell._index;
		if (!index.item()) {
			index._item = this._item;
		}
		var value = cell.value();
		return func(handler, index.proxy(), value);
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataCellExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return DataCellExpressionRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		if (this._cell.index().I() < 0) {
			var fld = this._cell.index().dataField();
			switch(idKey) {
				case DataCellExpressionRuntime.ID_VALUE:
					return this._item.getData(fld);
				case DataCellExpressionRuntime.ID_DATA_ROW:
					return this._item.dataRow();
			}
		}
		switch (idKey) {
		case DataCellExpressionRuntime.ID_VALUE:
			return this._cell.value();
		case DataCellExpressionRuntime.ID_ROW:
			return this._cell.index().I();
		case DataCellExpressionRuntime.ID_DATA_ROW:
			return this._cell.index().dataRow();
		case DataCellExpressionRuntime.ID_INDEX:
			return this._cell.index().column().index();
		case DataCellExpressionRuntime.ID_FIELD:
			return this._cell.index().dataField();
		case DataCellExpressionRuntime.ID_CHECKED:
			return this._item.isChecked();
		case DataCellExpressionRuntime.ID_STATE:
			switch (this._item.rowState()) {
			case RowState.CREATED:
				return "c";
			case RowState.UPDATED:
				return "u";
			case RowState.DELETED:
				return "d";
			case RowState.CREATE_AND_DELETED:
				return "x";
			}
			return UNDEFINED;
		case DataCellExpressionRuntime.ID_TAG:
			return this._cell.index().C().tag();
		case DataCellExpressionRuntime.ID_BASE:
			var idx = this._cell.index().dataColumn().baseIndex();
			return idx >= 0 ? this._item.getData(idx) : UNDEFINED;
		case DataCellExpressionRuntime.ID_COUNT:
			return this._item instanceof GroupItem ? this._item.count() : 0;
		case DataCellExpressionRuntime.ID_DCOUNT:
			return this._item instanceof GroupItem ? this._item.descendantCount() : 0;
		case DataCellExpressionRuntime.ID_CHANGED_CELL:
			// update 인경우만 가능하다.
			var index = this._cell.index();
			var dataRow = this._item.dataRow();
			var dataField = index.dataField();
			return dataField >= 0 && this._item.rowState() == RowState.UPDATED && this._dataSource.isDataChanged(dataRow, dataField);
		case DataCellExpressionRuntime.ID_LOOKUP_EXISTS:
			var lookup;
			var column = this._cell.index().column();
			if (lookup = column.lookupSource()) {
                var i,
                    flds = column.lookupKeyFieldIds(),
                    cnt = flds.length,
                    keys = [];
                for (i = 0; i < cnt; i++) {
                    keys.push(this._item.getData(flds[i]));
                }
                return lookup.exists(keys);
			} else {
				return column.getLookupIndex(this._item.getData(this._cell.index().dataField())) > -1;
			}
			
		}
		if ($_debug) debugger;
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (this._item) {
			if (idKey == DataCellExpressionRuntime.ID_VALUE || idKey == DataCellExpressionRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._item.getData(index);
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == DataCellExpressionRuntime.ID_VALUE || idKey == DataCellExpressionRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field is not exists:" + index);
				}
				return this._item.getData(idx);
			} else {
				return undefined;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_VALUE: 0,
	ID_ROW: 1,
	ID_DATA_ROW: 2,
	ID_INDEX: 3,
	ID_FIELD: 4,
	ID_CHECKED: 5,
	ID_STATE: 6,
	ID_TAG: 7,
	ID_BASE: 8,
	ID_VALUES: 9,
	ID_COUNT: 10,
	ID_DCOUNT: 11,
	ID_CHANGED_CELL: 12,
	ID_LOOKUP_EXISTS: 13
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		index: f.ID_INDEX,
		field: f.ID_FIELD,
		checked: f.ID_CHECKED,
		state: f.ID_STATE,
		tag: f.ID_TAG,
		base: f.ID_BASE,
		values: f.ID_VALUES,
		count: f.ID_COUNT,
		dcount: f.ID_DCOUNT,
		changedcell: f.ID_CHANGED_CELL,
		lookupexists: f.ID_LOOKUP_EXISTS
	};
});
var FooterExpressionRuntime = defineClass("FooterExpressionRuntime", ExpressionRuntime, {
    init: function () {
        this._super();
        this._cell = null;
        this._grid = null;
    },
    destroy: function() {
    	this._destroying = true;
    	this._cell = null;
    	this._grid = null;
    	this._super();
    },
    setCell: function (cell, item) {
        this._cell = cell;
        this._grid = cell._index && cell._index._grid;
        this._item = item;
    },
    _evaluate: function (func) {
    	var handler = this._grid && this._grid.getHandler();
    	var cell = this._cell;
    	var index = _extend({}, cell._index.proxy());
    	var value = cell.value() != null ? cell.value() : cell.displayText ? cell.displayText() : cell.value();
    	index["footerIndex"] = this._cell._footerIndex;
    	return func(handler, index, value);
    },
    isIdentifier: function (token) {
        token = token.toLowerCase();
        if (FooterExpressionRuntime.IDENTS.hasOwnProperty(token)) {
            return FooterExpressionRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function (idKey) {
        switch (idKey) {
            case FooterExpressionRuntime.ID_VALUE:
                return this._cell.value();
            case FooterExpressionRuntime.ID_FIELD:
                return this._cell.index().dataField();
            case FooterExpressionRuntime.ID_LEVEL:
                return this._cell.level();
        }
        if ($_debug) debugger;
        throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
    },
    evaluateIndexerI: function (idKey, index) {
        return undefined;
    },
    evaluateIndexerS: function (idKey, index, capitalized) {
        return undefined;
    }
}, {
    ID_VALUE: 0,
    ID_FIELD: 1,
    ID_LEVEL: 2
}, function (f) {
    f.IDENTS = {
        value: f.ID_VALUE,
        field: f.ID_FIELD,
        level: f.ID_LEVEL
    };
});
var CheckBarExpressionRuntime = defineClass("CheckBarExpressionRuntime", ExpressionRuntime, {
    init: function () {
        this._super();
        this._cell = null;
        this._grid = null;
    },
    setCell: function (cell) {
        this._cell = cell;
        this._grid = cell._index && cell._index._grid;
    },
    destroy: function() {
    	this._destroying = true;
    	this._cell = null;
    	this._grid = null;
    	this._super();
    },
    isIdentifier: function (token) {
        token = token.toLowerCase();
        if (CheckBarExpressionRuntime.IDENTS.hasOwnProperty(token)) {
            return CheckBarExpressionRuntime.IDENTS[token];
        }
        return this._super(token);
    },
    evaluateIdentifier: function (idKey) {
        switch (idKey) {
            case CheckBarExpressionRuntime.ID_VALUE:
       			return this._cell.item().isChecked();
            case CheckBarExpressionRuntime.ID_CHECKED:
       			return this._cell.item().isChecked();
       		case CheckBarExpressionRuntime.ID_CHECKABLE:
       			return this._cell.item().isCheckable();
       		case CheckBarExpressionRuntime.ID_ROW:
       			return this._cell.item().I();
       		case CheckBarExpressionRuntime.ID_DATA_ROW:
       			return this._cell.item().dataRow();
			case CheckBarExpressionRuntime.ID_STATE:
				switch (this._cell.item().rowState()) {
				case RowState.CREATED:
					return "c";
				case RowState.UPDATED:
					return "u";
				case RowState.DELETED:
					return "d";
				case RowState.CREATE_AND_DELETED:
					return "x";
				}
				return UNDEFINED;
        }
        if ($_debug) debugger;
        throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
    },
	evaluateIndexerI: function (idKey, index) {
		if (this._cell) {
			var item = this._cell.item();
			var ds = item && item.dataSource();
			var fieldCount = ds.fieldCount();
			if (idKey == CheckBarExpressionRuntime.ID_VALUE || idKey == CheckBarExpressionRuntime.ID_VALUES) {
				if (index < 0 || index >= fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return item.getData(index);
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == CheckBarExpressionRuntime.ID_VALUE || idKey == CheckBarExpressionRuntime.ID_VALUES) {
			var item = this._cell.item();
			var ds = item && item.dataSource();
			var fieldCount = ds.fieldCount();
			if (ds) {
				var idx = capitalized ? ds.getFieldIndexC(index) : ds.getFieldIndex(index);
				if (idx < 0 || idx >= fieldCount) {
					throw new ExpressionEvaluationError("Data field is not exists:" + index);
				}
				return item.getData(idx);
			} else {
				return undefined;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
    ID_VALUE: 0,
    ID_VALUES: 1, 
    ID_CHECKED: 2,
    ID_CHECKABLE: 3,
	ID_ROW: 4,
	ID_DATA_ROW: 5,
	ID_STATE : 6
}, function (f) {
    f.IDENTS = {
        value: f.ID_VALUE,
        values: f.ID_VALUES,
        checked: f.ID_CHECKED,
        checkable:f.ID_CHECKABLE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		state:f.ID_STATE
    };
});
var RowGroupStatementRuntime = defineClass("RowGroupStatementRuntime", ExpressionRuntime, {
	init : function() {
		this._super();
		this._grid = null;
		this._group = null;
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
		this._group = null;
		this._super();
	},
	setGrid: function (value) {
		this._grid = value;
	},
	setGroup: function (value) {
		this._group = value;
	},
	isIdentifier : function(token) {
		token = token.toLowerCase();
		if (RowGroupStatementRuntime.IDENTS.hasOwnProperty(token)) {
			return RowGroupStatementRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier : function(idKey) {
		assert(this._group != null, "group is null");
		var field;
		var column;
		switch (idKey) {
		case RowGroupStatementRuntime.ID_GROUP_FIELD:
			field = this._group.dataSource().getField(this._group.groupField());
			return field ? field.fieldName() : "";
		case RowGroupStatementRuntime.ID_FIELD_HEADER:
			field = this._group.dataSource().getField(this._group.groupField());
			return field ? field.header() : "";
		case RowGroupStatementRuntime.ID_GROUP_COLUMN:
			column = this._grid ? this._grid.columnByField(this._group.groupField()) : null;
			return column ? column.displayText() : this._group.dataSource().getFieldName(this._group.groupField());
		case RowGroupStatementRuntime.ID_COLUMN_HEADER:
			column = this._grid ? this._grid.columnByField(this._group.groupField()) : null;
			if (column) {
				var header = column.header();
				return header ? header.text() : column.displayText();
			} else {
				return this._group.dataSource().getFieldName(this._group.groupField());
			}
		case RowGroupStatementRuntime.ID_COLUMN_FOOTER:
			column = this._grid ? this._grid.columnByField(this._group.groupField()) : null;
			if (column) {
				var footer = column.footer();
				return footer ? footer.groupText() : column.displayText();
			} else {
				return this._group.dataSource().getFieldName(this._group.groupField());
			}
		case RowGroupStatementRuntime.ID_GROUP_VALUE:
			var item = this._group.firstItem();
			return item ? item.getData(this._group.groupField()) : UNDEFINED;
		case RowGroupStatementRuntime.ID_ROW_COUNT:
			return this._group.descendantCount();
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function(idKey, index) {
		var ret;
		switch(idKey) {
			case RowGroupStatementRuntime.ID_SUM :
			case RowGroupStatementRuntime.ID_MAX :
			case RowGroupStatementRuntime.ID_MIN :
			case RowGroupStatementRuntime.ID_AVG :
			case RowGroupStatementRuntime.ID_DATA_COUNT :
			case RowGroupStatementRuntime.ID_DATA_AVG :
				if (isNaN(index) || index < 0 ) {
					return UNDEFINED;
				} else {
					switch (idKey) {
						case RowGroupStatementRuntime.ID_SUM :
							ret = this._group.getSum(index);
							break;
						case RowGroupStatementRuntime.ID_MAX :
							ret = this._group.getMax(index);
							break;
						case RowGroupStatementRuntime.ID_MIN :
							ret = this._group.getMin(index);
							break;
						case RowGroupStatementRuntime.ID_AVG :
							ret = this._group.getAvg(index);
							break;
						case RowGroupStatementRuntime.ID_DATA_COUNT :
							ret = this._group.getDataCount(index);
							break;
						case RowGroupStatementRuntime.ID_DATA_AVG :
							ret = this._group.getDataAvg(index);
					}
					return isNaN(ret) ? "" : String(ret);
				}
				break;
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);

	},
	evaluateIndexerS: function(idKey, index, capitalized) {
		var dataSource = this._group.dataSource();
		var field = index ? (dataSource ? dataSource.getFieldIndex(index) : -1) : (this._gorup.groupField);
		return this.evaluateIndexerI(idKey, field);
	}
}, {
	ID_GROUP_FIELD	: 0,
	ID_FIELD_HEADER	: 1,
	ID_GROUP_COLUMN	: 2,
	ID_COLUMN_HEADER: 3,
	ID_COLUMN_FOOTER: 4,
	ID_GROUP_VALUE	: 5,
	ID_ROW_COUNT	: 6,
	ID_SUM			: 8,
	ID_MAX			: 9,
	ID_MIN			: 10,
	ID_AVG			: 11,
	ID_DATA_COUNT   : 12,
	ID_DATA_AVG     : 13
}, function (f) {
	f.IDENTS = {
		groupfield	: f.ID_GROUP_FIELD,
		fieldheader	: f.ID_FIELD_HEADER,
		groupcolumn	: f.ID_GROUP_COLUMN,
		columnheader: f.ID_COLUMN_HEADER,
		columnfooter: f.ID_COLUMN_FOOTER,
		groupvalue	: f.ID_GROUP_VALUE,
		rowcount	: f.ID_ROW_COUNT,
		sum 		: f.ID_SUM,
		max 		: f.ID_MAX,
		min 		: f.ID_MIN,
		avg 		: f.ID_AVG,
		datacount   : f.ID_DATA_COUNT,
		dataavg     : f.ID_DATA_AVG
	};
});
var ColumnMergeRuntime = defineClass("ColumnMergeRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._item = null;
		this._field = -1;
		this._dataSource = null;
		this._fieldCount = 0;
	},
	destroy: function() {
		this._destroying = true;
		this._item = null;
		this._dataSource = null;
		this._grid = null;
		this._column = null;
		this._super();
	},
    setDataSource: function (value) {
        this._dataSource = value;
        this._fieldCount = value ? value.fieldCount() : 0;
    },
    setColumn: function(column) {
    	this._column = column;
    	this._grid = column.grid();
    },
	setCell: function(index) {
		this._item = index.item();
		this._field = index.dataField();
	},
	setItem: function (item, field) {
		this._item = item;
		this._field = field;
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (ColumnMergeRuntime.IDENTS.hasOwnProperty(token)) {
			return ColumnMergeRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		if (this._item) {
			switch (idKey) {
			case ColumnMergeRuntime.ID_VALUE:
				return this._item.getData(this._field);
			case ColumnMergeRuntime.ID_ROW:
				return this._item.index();
			case ColumnMergeRuntime.ID_DATA_ROW:
				return this._item.dataRow();
			case ColumnMergeRuntime.ID_CHECKED:
				return this._item.isChecked();
			case ColumnMergeRuntime.ID_GROUP:
				return this._item.parent();
			case ColumnMergeRuntime.ID_PREV_VALUES:
				var cols = this._grid.getDataColumns();
				var idx = cols.indexOf(this._column);
				var vals = [];
				if (cols.length < 0 || idx < 0) {
					return;
				}
				for (var i = 0, cnt = Math.min(idx,cols.length) ; i < cnt ; i++) {
					vals.push(this._item.getData(cols[i].dataIndex()));
				}
				return vals.join("`");
			}
			throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
		} else {
			return UNDEFINED;
		}
	},
	evaluateIndexerI: function(idKey, index) {
		if (this._item) {
			if (idKey == ColumnMergeRuntime.ID_VALUE || idKey == ColumnMergeRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._item.getData(index);
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return UNDEFINED;
		}
	},
	evaluateIndexerS: function(idKey, index, capitalized) {
		if (this._item && this._dataSource) {
			if (idKey == ColumnMergeRuntime.ID_VALUE || idKey == ColumnMergeRuntime.ID_VALUES) {
				var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._item.getData(idx);
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return UNDEFINED;
		}
	}
}, {
	ID_ROW: 0,
	ID_DATA_ROW: 1,
	ID_CHECKED: 2,
	ID_VALUE: 3,
	ID_VALUES: 4,
	ID_GROUP: 5,
	ID_PREV_VALUES: 6
}, function (f) {
	f.IDENTS = {
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		checked: f.ID_CHECKED,
		value: f.ID_VALUE,
		values: f.ID_VALUES,
		group: f.ID_GROUP,
		prevvalues: f.ID_PREV_VALUES
	};
});
var ColumnFilterRuntime = defineClass("ColumnFilterRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
		this._item = null;
		this._field = -1;
		this._dataSource = null;
		this._fieldCount = 0;
	},
	destroy: function() {
		this._destroying = true;
		this._item = null;
		this._dataSource = null;
		this._super();
	},
	setDataSource: function(dataSource) {
		this._dataSource = dataSource;
		this._fieldCount = this._dataSource ? this._dataSource.fieldCount() : 0;
	},
	setData: function (item, field) {
		this._item = item;
		this._field = field;
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (ColumnFilterRuntime.IDENTS.hasOwnProperty(token)) {
			return ColumnFilterRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		switch (idKey) {
		case ColumnFilterRuntime.ID_VALUE:
			return this._item.getData(this._field);
		case ColumnFilterRuntime.ID_STATE:
			switch (this._item.rowState()) {
			case RowState.CREATED:
				return "c";
			case RowState.UPDATED:
				return "u";
			case RowState.DELETED:
				return "d";
			case RowState.CREATE_AND_DELETED:
				return "x";
			}
			return UNDEFINED;
		case ColumnFilterRuntime.ID_CHANGED_CELL:
			// update 인경우만 가능하다.
			var dataRow = this._item.dataRow();
			var dataField = this._field;
			return dataField >= 0 && this._item.rowState() == RowState.UPDATED && this._dataSource.isDataChanged(dataRow, dataField);
		case ColumnFilterRuntime.ID_FIELD:
			return this._field;
		case ColumnFilterRuntime.ID_MAX:
			return 0;
		case ColumnFilterRuntime.ID_MIN:
			return 0;
		case ColumnFilterRuntime.ID_MEAN:
			return 0;
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function(idKey, index) {
		if (this._item) {
			if (idKey == ColumnFilterRuntime.ID_VALUE || idKey == ColumnFilterRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._item.getData(index);
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == ColumnFilterRuntime.ID_VALUE || idKey == ColumnFilterRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field is not exists:" + index);
				}
				return this._item.getData(idx);
			} else {
				return undefined;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_VALUE: 0,
	ID_FIELD: 1,
	ID_VALUES: 2,
	ID_STATE: 3,
	ID_CHANGED_CELL: 4,
	ID_MAX	: 10,
	ID_MIN	: 11,
	ID_MEAN	: 12
}, function(f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		field: f.ID_FIELD,
		values: f.ID_VALUES,
		state: f.ID_STATE,
		changedcell: f.ID_CHANGED_CELL,
		min: f.ID_MAX,
		max: f.ID_MIN,
		mean: f.ID_MEAN
	};
});
var /* abstract */ SummaryExpressionRuntime = defineClass("SummaryExpressionRuntime", ExpressionRuntime, {
	init: function() {
		this._super();
	},
	isIdentifier: function(token) {
		token = token.toLowerCase();
		if (SummaryExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return SummaryExpressionRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function(idKey) {
		switch (idKey) {
		case SummaryExpressionRuntime.ID_COUNT:
			return this._getCount();
		case SummaryExpressionRuntime.ID_SUM:
			return this._getSum();
		case SummaryExpressionRuntime.ID_MAX:
			return this._getMax();
		case SummaryExpressionRuntime.ID_MIN:
			return this._getMin();
		case SummaryExpressionRuntime.ID_AVG:
			return this._getAvg();
		case SummaryExpressionRuntime.ID_VAR:
			return this._getVar();
		case SummaryExpressionRuntime.ID_VARP:
			return this._getVarp();
		case SummaryExpressionRuntime.ID_STDEV:
			return this._getStdev();
		case SummaryExpressionRuntime.ID_STDEVP:
			return this._getStdevp();
		case SummaryExpressionRuntime.ID_DATA_COUNT:
			return this._getDataCount();
		case SummaryExpressionRuntime.ID_DATA_AVG:
			return this._getDataAvg();
		}
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function(idKey, index) {
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function(idKey, index, capitalized) {
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	_getCount: function () {
		return NaN;
	},
	_getSum: function () {
		return NaN;
	},
	_getMax: function () {
		return NaN;
	},
	_getMin: function () {
		return NaN;
	},
	_getAvg: function () {
		return NaN;
	},
	_getVar: function () {
		return NaN;
	},
	_getVarp: function () {
		return NaN;
	},
	_getStdev: function () {
		return NaN;
	},
	_getStdevp: function () {
		return NaN;
	},
	_getDataCount: function () {
		return NaN;
	},
	_dataDataAvg: function () {
		return NaN;
	}
}, {
	ID_COUNT: 0,
	ID_SUM: 1,
	ID_MAX: 2,
	ID_MIN: 3,
	ID_AVG: 4,
	ID_VAR: 5,
	ID_VARP: 6,
	ID_STDEV: 7,
	ID_STDEVP: 8,
	ID_DATA_COUNT: 9,
	ID_DATA_AVG: 10
}, function(f) {
	f.IDENTS = {
		count: f.ID_COUNT,
		sum: f.ID_SUM,
		max: f.ID_MAX,
		min: f.ID_MIN,
		avg: f.ID_AVG,
		"var": f.ID_VAR,
		varp: f.ID_VARP,
		stdev: f.ID_STDEV,
		stdevp: f.ID_STDEVP,
		datacount: f.ID_DATA_COUNT,
		dataavg: f.ID_DATA_AVG
	};
});
var ColumnSummaryRuntime = defineClass("ColumnSummaryRuntime", SummaryExpressionRuntime, {
	init: function() {
		this._super();
		this._grid = null;
        this._dataSource = null;
		this._column = null;
		this._summarizer = null;
	},
	destroy: function() {
		this._destroying = true;
		this._grid = null;
        this._dataSource = null;
		this._column = null;
		this._summarizer = null;
		this._super();
	},
	setColumn: function(column, summarizer) {
		this._column = column;
		this._grid = column && column.grid();
        this._dataSource = this._grid ? this._grid.dataSource() : null;
        this._fieldCount = this._dataSource ? this._dataSource.fieldCount() : 0;
		this._summarizer = this._grid ? summarizer : null;
	},
	_getCount: function () {
		return this._summarizer ? this._summarizer.getCount(this._column.dataIndex()) : 0;
	},
	_getSum: function () {
		return this._summarizer ? this._summarizer.getSum(this._column.dataIndex()) : 0;
	},
	_getMax: function () {
		return this._summarizer ? this._summarizer.getMax(this._column.dataIndex()) : NaN;
	},
	_getMin: function () {
		return this._summarizer ? this._summarizer.getMin(this._column.dataIndex()) : NaN;
	},
	_getAvg: function () {
		return this._summarizer ? this._summarizer.getAvg(this._column.dataIndex()) : NaN;
	},
	_getVar: function () {
		return this._summarizer ? this._summarizer.getVar(this._column.dataIndex()) : NaN;
	},
	_getVarp: function () {
		return this._summarizer ? this._summarizer.getVarp(this._column.dataIndex()) : NaN;
	},
	_getStdev: function () {
		return this._summarizer ? this._summarizer.getStdev(this._column.dataIndex()) : NaN;
	},
	_getStdevp: function () {
		return this._summarizer ? this._summarizer.getStdevp(this._column.dataIndex()) : NaN;
	},
	_getDataCount: function () {
		return this._summarizer ? this._summarizer.getDataCount(this._column.dataIndex()) : NaN;
	},
	_getDataAvg: function () {
		return this._summarizer ? this._summarizer.getDataAvg(this._column.dataIndex()) : NaN;
	},
    evaluateIndexerI: function (idkey, index) {
        if (this._summarizer) {
            if (index < 0 || index >= this._fieldCount) {
                throw new ExpressionEvaluationError("Data field index out of bounds: " + index);
            }
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                    return this._summarizer.getSum(index);
                case SummaryExpressionRuntime.ID_COUNT:
                    return this._summarizer.getCount(index);
                case SummaryExpressionRuntime.ID_MAX:
                    return this._summarizer.getMax(index);
                case SummaryExpressionRuntime.ID_MIN:
                    return this._summarizer.getMin(index);
                case SummaryExpressionRuntime.ID_AVG:
                    return this._summarizer.getAvg(index);
                case SummaryExpressionRuntime.ID_VAR:
                    return this._summarizer.getVar(index);
                case SummaryExpressionRuntime.ID_VARP:
                    return this._summarizer.getVarp(index);
                case SummaryExpressionRuntime.ID_STDEV:
                    return this._summarizer.getStdev(index);
                case SummaryExpressionRuntime.ID_STDEVP:
                    return this._summarizer.getStdevp(index);
            }
            throw new ExpressionEvaluationError("Invalid identifier indexer: " + idkey);
        } else {
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                case SummaryExpressionRuntime.ID_COUNT:
                    return 0;
                case SummaryExpressionRuntime.ID_MAX:
                case SummaryExpressionRuntime.ID_MIN:
                case SummaryExpressionRuntime.ID_AVG:
                case SummaryExpressionRuntime.ID_VAR:
                case SummaryExpressionRuntime.ID_VARP:
                case SummaryExpressionRuntime.ID_STDEV:
                case SummaryExpressionRuntime.ID_STDEVP:
                    return NaN;
            }
            return undefined;
        }
    },
    evaluateIndexerS: function (idkey, index, capitalized) {
        if (this._summarizer && this._dataSource) {
            var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
            if (idx < 0 || idx >= this._fieldCount) {
                throw new ExpressionEvaluationError("Data field index out of bounds: " + idx);
            }
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                    return this._summarizer.getSum(idx);
                case SummaryExpressionRuntime.ID_COUNT:
                    return this._summarizer.getCount(idx);
                case SummaryExpressionRuntime.ID_MAX:
                    return this._summarizer.getMax(idx);
                case SummaryExpressionRuntime.ID_MIN:
                    return this._summarizer.getMin(idx);
                case SummaryExpressionRuntime.ID_AVG:
                    return this._summarizer.getAvg(idx);
                case SummaryExpressionRuntime.ID_VAR:
                    return this._summarizer.getVar(idx);
                case SummaryExpressionRuntime.ID_VARP:
                    return this._summarizer.getVarp(idx);
                case SummaryExpressionRuntime.ID_STDEV:
                    return this._summarizer.getStdev(idx);
                case SummaryExpressionRuntime.ID_STDEVP:
                    return this._summarizer.getStdevp(idx);
            }
            throw new ExpressionEvaluationError("Invalid identifier indexer: " + idkey);
        } else {
            switch(idkey) {
                case SummaryExpressionRuntime.ID_SUM:
                case SummaryExpressionRuntime.ID_COUNT:
                    return 0;
                case SummaryExpressionRuntime.ID_MAX:
                case SummaryExpressionRuntime.ID_MIN:
                case SummaryExpressionRuntime.ID_AVG:
                case SummaryExpressionRuntime.ID_VAR:
                case SummaryExpressionRuntime.ID_VARP:
                case SummaryExpressionRuntime.ID_STDEV:
                case SummaryExpressionRuntime.ID_STDEVP:
                    return NaN;
            }
            return undefined;
        }
    }
});
var RowGroupSummaryRuntime = defineClass("RowGroupSummaryRuntime", ColumnSummaryRuntime, {
	init: function() {
		this._super();
		this._item = null;
	},
	destroy: function() {
		this._destroying = true;
		this._item = null;
		this._super();
	},
	item: null,
	setItem: function (value) {
		this._item = value;
	},
	_getCount: function() {
		return this._item.getNumber(this._column.dataIndex());
	},
	_getSum: function() {
		return this._item.getSum(this._column.dataIndex());
	},
	_getMax: function() {
		return this._item.getMax(this._column.dataIndex());
	},
	_getMin: function() {
		return this._item.getMin(this._column.dataIndex());
	},
	_getAvg: function() {
		return this._item.getAvg(this._column.dataIndex());
	},
	_getVar: function() {
		return this._item.getVar(this._column.dataIndex(), 1);
	},
	_getVarp: function() {
		return this._item.getVar(this._column.dataIndex(), 0);
	},
	_getStdev: function() {
		return this._item.getStdev(this._column.dataIndex(), 1);
	},
	_getStdevp: function() {
		return this._item.getStdev(this._column.dataIndex(), 0);
	},
	_getDataCount: function() {
		return this._item.getDataCount(this._column.dataIndex(), 0);
	},
	_getDataAvg: function() {
		return this._item.getDataAvg(this._column.dataIndex(), 0);
	}
});
var CheckableExpressionRuntime = defineClass("CheckableExpressionRuntime", DataRowExpressionRuntime, {
	init : function() {
		this._super();
	}
});
var DataCellRendererRuntime = defineClass("DataCellRendererRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._target = null; // DataCellElement
		this._item = null; // GridItem
		this._dataSource = null;
		this._fieldCount = 0;
	},
	destroy: function() {
		this._destroying = true;
		this._target = null;
		this._item = null;
		this._dataSource = null;
		this._super();
	},
	setDataSource: function (value) {
		this._dataSource = value;
		this._fieldCount = value ? value.fieldCount() : 0;
	},
	setTarget: function (value) {
		this._target = value;
		this._item = value.index().item();
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (DataCellRendererRuntime.IDENTS.hasOwnProperty(token)) {
			return DataCellRendererRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	_evaluate: function (func) {
		var handler = this._grid && this._grid.getHandler();
		var cell = this._target;
		var index = cell.index();
		var value = cell.value();
		return func(handler, index.proxy(), value);
	},
	evaluateIdentifier: function (idKey) {
		assert(this._target != null, "target is null");
		switch (idKey) {
			case DataCellRendererRuntime.ID_VALUE:
				return this._target.value();
			case DataCellRendererRuntime.ID_ROW:
				return this._target.index().I();
			case DataCellRendererRuntime.ID_DATA_ROW:
				return this._target.index().dataRow();
			case DataCellRendererRuntime.ID_INDEX:
				return this._target.index().column().index();
			case DataCellRendererRuntime.ID_FIELD:
				return this._target.index().dataField();
			case DataCellRendererRuntime.ID_CHECKED:
				return this._item && this._item.isChecked();
			case DataCellRendererRuntime.ID_STATE:
				if (this._item) {
					switch (this._item.rowState()) {
						case RowState.CREATED:
							return "c";
						case RowState.UPDATED:
							return "u";
						case RowState.DELETED:
							return "d";
						case RowState.CREATE_AND_DELETED:
							return "x";
					}
				}
				return UNDEFINED;
			case DataCellRendererRuntime.ID_TAG:
				return this._target.index().C().tag();
			case DataCellRendererRuntime.ID_BASE:
				var idx = this._target.index().dataColumn().baseIndex();
				return idx >= 0 ? this._item.getData(idx) : UNDEFINED;
			case DataCellRendererRuntime.ID_COUNT:
				return this._target.index().childCount();
			case DataCellRendererRuntime.ID_DCOUNT:
				return this._target.index().descendantCount();
		}
		if ($_debug) debugger;
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (idKey == DataCellRendererRuntime.ID_VALUE) { // for series
			var vals = this._target.value();
			if (_isArray(vals) && index < vals.length) {
				return vals[index];
			} else {
				throw new ExpressionEvaluationError("Value index out of bounds:" + index);
			}
		} else if (idKey == DataCellRendererRuntime.ID_VALUES) {
			if (this._dataSource) {
				if (index < 0 || index >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._item.getData(index);
			} else {
				return undefined;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == DataCellRendererRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field is not exits:" + index);
				}
				return this._item.getData(idx);
			} else {
				return undefined;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_VALUE: 0,
	ID_ROW: 1,
	ID_DATA_ROW: 2,
	ID_INDEX: 3,
	ID_FIELD: 4,
	ID_CHECKED: 5,
	ID_STATE: 6,
	ID_TAG: 7,
	ID_BASE: 8,
	ID_VALUES: 9,
	ID_COUNT: 10,
	ID_DCOUNT: 11
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		row: f.ID_ROW,
		datarow: f.ID_DATA_ROW,
		index: f.ID_INDEX,
		field: f.ID_FIELD,
		checked: f.ID_CHECKED,
		state: f.ID_STATE,
		tag: f.ID_TAG,
		base: f.ID_BASE,
		values: f.ID_VALUES,
		count: f.ID_COUNT,
		dcount: f.ID_DCOUNT
	};
});
var LinkCellRendererRuntime = defineClass("LinkCellRendererRuntime", ExpressionRuntime, {
	init : function() {
		this._super();
		this._item = null;
		this._dataSource = null;
		this._requiredFields = null;
	},
	destroy: function() {
		this._destroying = true;
		this._dataSource = null;
		this._requiredFields = null;
		this._super();
	},
	setIndex: function (index) {
		this._item = index.item();
		this._dataSource = index.grid().dataSource();
	},
	setRequiredFields: function (value) {
		this._requiredFields = value;
	},
	isIdentifier: function (token) {
		if (this._dataSource) {
			var fld = this._dataSource.getFieldIndex(token);
			if (fld >= 0) {
				return fld;
			}
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		if (idKey >= 0) {
			var cnt, f;
			var v = this._item.getData(idKey);
			var field = this._dataSource.getField(idKey);
			if (field.isEmpty(v) && this._requiredFields && (cnt = this._requiredFields.length) > 0) {
				var fld = this._dataSource.getFieldName(idKey);
				if (fld) {
					for (var i = 0; i < cnt; i++) {
						f = this._requiredFields[i];
						if (f == fld) {
							throw new Error("Required field error: " + fld);
						}
					}
				}
			}
			return v;
		}
		this._invalidIdentError(idKey);
	}
});
var CalculateExpressionRuntime = defineClass("CalculateExpressionRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._values = null;
		this._fields = null;
		this._fieldCount = 0;
	},
	destroy: function() {
		this._destroying = true;
		this._values = null;
		this._fields = null;
		this._super();
	},
	setValues: function (values, fields) {
		this._values = values;
		this._fields = fields;
		this._fieldCount = fields ? fields.length : 0;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (CalculateExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return CalculateExpressionRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (this._values) {
			if (idKey == CalculateExpressionRuntime.ID_VALUE || idKey == CalculateExpressionRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._values[index];
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return undefined;
		}
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == CalculateExpressionRuntime.ID_VALUE || idKey == CalculateExpressionRuntime.ID_VALUES) {
			if (this._values && this._fields) {
				var idx = this._fields.indexOf(index);
				if (idx < 0 || idx >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field is not exists:" + index);
				}
				return this._values[idx];
			} else {
				return undefined;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_VALUE: 0,
	ID_VALUES: 1
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		values: f.ID_VALUES
	};
});
var EditorTitleExpressionRuntime = defineClass("EditorTitleExpressionRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._value = null;
		this._cell = null;
	},
	destroy: function() {
		this._destroying = true;
		this._cell = null;
		this._super();
	},
	setValue: function (value) {
		this._value = value;
	},
	setCell: function(value) {
		this._cell = value;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (EditorTitleExpressionRuntime.IDENTS.hasOwnProperty(token)) {
			return EditorTitleExpressionRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier : function(idKey) { 
		switch (idKey) {
			case EditorTitleExpressionRuntime.ID_VALUE:
				return this._value;
			case EditorTitleExpressionRuntime.ID_ROW:
				return String(this._cell.index().I() + 1);
			case EditorTitleExpressionRuntime.ID_COLUMN_HEADER:
				var column = this._cell && this._cell.index().column();
				return column && column.header && column.header().text() ? column.header().text() : column.displayText();
		}
	}
}, {
	ID_VALUE : 0,
	ID_ROW : 1,
	ID_COLUMN_HEADER: 2
}, function (f) {
	f.IDENTS = {
		value : f.ID_VALUE,
		row : f.ID_ROW,
		columnheader : f.ID_COLUMN_HEADER
	}
});

var ColumnExportStatementRuntime = defineClass("ColumnExportStatementRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._value = null;
		this._columns = null;
		this._cell = null;
		this._startCol = 0;
	},
	destroy: function() {
		this._destroying = true;
		this._columns = null;
		this._cell = null;
		this._super();
	},
	setColumns : function(columns) {
		this._columns = columns;
	},
	setItemIndex: function(index, startCol) {
		this._itemIndex = index;
		this._startCol = startCol;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (ColumnExportStatementRuntime.IDENTS.hasOwnProperty(token)) {
			return ColumnExportStatementRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier : function(idKey) { 
		switch (idKey) {
			case ColumnExportStatementRuntime.ID_ROW:
				return String(this._itemIndex+1);
		}
	},
	evaluateIndexerI: function (idKey, index) {
		if (idKey == ColumnExportStatementRuntime.ID_EXCELCOLUMN) {
			if (index < 0 || index >= this._columns.length) {
				throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
			}
			return this._columns[index];
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == ColumnExportStatementRuntime.ID_EXCELCOLUMN) {
			if (this._columns) {
				var idx = this._columns.indexOf(index);
				if (idx < 0 || idx >= this._columns.length) {
					throw new ExpressionEvaluationError("Column is not exists:" + index);
				}
				return _excelColCaption(idx+this._startCol);
			} else {
				return undefined;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_EXCELCOLUMN : 0,
	ID_ROW : 1
}, function (f) {
	f.IDENTS = {
		excelcolumn : f.ID_EXCELCOLUMN,
		row : f.ID_ROW
	}
});

var EqualBlankRuntime = defineClass("EqualBlankRuntime", ExpressionRuntime, {
	init: function () {
		this._super();
		this._cell = null; // DataCellElement
		this._item = null; // GridItem
		this._dataSource = null;
		this._fieldCount = 0;
	},
	destroy: function() {
		this._destroying = true;
		this._cell = null;
		this._item = null;
		this._dataSource = null;
		this._grid = null;
		this._super();
	},
	setDataArguments: function(dataSource, cell, item) {
		this._dataSource = dataSource;
		this._fieldCount = dataSource ? dataSource.fieldCount() : 0;
		this._cell = cell;
		this._item = item;
		this._grid = cell && cell.index().column().grid();
	},
	setItem: function(item) {
		this._item = item;
	},
	isIdentifier: function (token) {
		token = token.toLowerCase();
		if (EqualBlankRuntime.IDENTS.hasOwnProperty(token)) {
			return EqualBlankRuntime.IDENTS[token];
		}
		return this._super(token);
	},
	evaluateIdentifier: function (idKey) {
		assert(this._cell != null, "cell is null");
		switch (idKey) {
			case EqualBlankRuntime.ID_VALUE:
				return this._item.getData(this._cell.index().dataField());
			case EqualBlankRuntime.ID_BASE:
				var idx = this._cell.index().dataColumn().baseIndex();
				return idx >= 0 ? this._item.getData(idx) : UNDEFINED;
			case EqualBlankRuntime.ID_PREV_VALUES:
				var col = this._cell.index().column();
				var cols = this._grid.getDataColumns();
				var idx = cols.indexOf(col);
				var vals = [];
				if (cols.length < 0 || idx < 0) {
					return;
				}
				for (var i = 0, cnt = Math.min(idx,cols.length) ; i < cnt ; i++) {
					vals.push(this._item.getData(cols[i].dataIndex()));
				}
				return vals.join("`");
		}
		if ($_debug) debugger;
		throw new ExpressionEvaluationError("Invalid identifier key: " + idKey);
	},
	evaluateIndexerI: function (idKey, index) {
		if (this._item) {
			if (idKey == EqualBlankRuntime.ID_VALUE || idKey == EqualBlankRuntime.ID_VALUES) {
				if (index < 0 || index >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field index out of bounds:" + index);
				}
				return this._item.getData(index);
			}
			throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
		} else {
			return UNDEFINED;
		}
	},
	evaluateIndexerS: function (idKey, index, capitalized) {
		if (idKey == EqualBlankRuntime.ID_VALUE || idKey == EqualBlankRuntime.ID_VALUES) {
			if (this._dataSource) {
				var idx = capitalized ? this._dataSource.getFieldIndexC(index) : this._dataSource.getFieldIndex(index);
				if (idx < 0 || idx >= this._fieldCount) {
					throw new ExpressionEvaluationError("Data field is not exists:" + index);
				}
				return this._item.getData(idx);
			} else {
				return UNDEFINED;
			}
		}
		throw new ExpressionEvaluationError("Invalid identifier indexer: " + idKey);
	}
}, {
	ID_VALUE: 0,
	ID_VALUES: 1,
	ID_BASE: 2,
	ID_PREV_VALUES: 3
}, function (f) {
	f.IDENTS = {
		value: f.ID_VALUE,
		values: f.ID_VALUES,
		base: f.ID_BASE,
		prevvalues: f.ID_PREV_VALUES
	};
});

var /* @abstract */ CellButtonRenderer = defineClass("CellButtonRenderer", null, {
	init: function (name) {
		this._super();
		this._name = name;
	},
	name: function () {
		return this._name;
	},
	measure: function (index, hintWidth, hintHeight) {
		return this._doMeasure(index, hintWidth, hintHeight);	
	},
	render: function (index, g, r, hovered, pressed, focused, buttonIndex) {
		this._doRender(index, g, r, hovered, pressed, focused, buttonIndex);
	},
	hitTest: function (w, h, x, y) {
		return this._doHitTest(w, h, x, y);
	},
	getButtonIndex: function (w, h, x, y) {
		return this._buttonIndex(w, h, x, y);
	},
	toString: function () {
		return this._name;
	},
	_doMeasure: function (index, hintWidth, hintHeight) {
		return new Size(hintWidth, hintHeight);
	},
	_doRender: function (index, g, r, hovered, pressed, focused) {
	},
	_doHitTest: function (w, h, x, y) {
		return true;
	},
	_buttonIndex: function (w, h, x, y) {
		return 0;
	}
});
var DefaultCellButtonRenderer = defineClass("DefaultCellButtonRenderer", CellButtonRenderer, {
	init: function (name) {
		this._super(name);
		this._inited = false;
		this._imageUrls = {
			ed: "ellipsis_down.png",
			eh: "ellipsis_hover.png",
			eu: "ellipsis_up.png",
			dd: "dropdown_down.png",
			dh: "dropdown_hover.png",
			du: "dropdown_up.png",
			cd: "calendar_down.png",
			ch: "calendar_hover.png",
			cu: "calendar_up.png"
		};
		this._images = {};
	},
	prepare: function (grid) {
		if (!this._inited) {
			for (var p in this._imageUrls) {
				grid.getImage($$_rootContext + $$_assets + this._imageUrls[p]);
			}
			this._inited = true;
		}
	},
	_doMeasure: function (index, hintWidth, hintHeight) {
		return new Size(DefaultCellButtonRenderer.BUTTON_WIDTH + 4, hintHeight);
	},
	_doRender: function (index, g, r, hovered, pressed, focused) {
		var column = index.dataColumn();
		if (column) {
			var br = r.clone();
			if (focused && index.grid().isEditing()) {
				br.leftBy(2);
				br.rightBy(-2);
			} else {
				br.leftBy(1);
				br.rightBy(-3);
			}
			var button = column.button();
			if (button == CellButton.ACTION) {
				this.$_drawEllipsisButton(index.grid(), g, br, true, hovered, pressed);
			} else if (button == CellButton.POPUP) {
				this.$_drawMenuButton(index.grid(), g, br, true, hovered, pressed);
			}
		}
	},
	$_getImage: function (grid, key, url) {
		var img = this._images[key];
		if (!img) {
			img = grid.getImage($$_rootContext + $$_assets + url);
			if (img) {
				this._images[key] = img;
			}
		}
		return img;
	},
	$_drawEllipsisButton: function (grid, g, r, enabled, hovered, pressed) {
		var w, h;
		var img = pressed ? "ed" : hovered ? "eh" : "eu";
		img = this.$_getImage(grid, img, this._imageUrls[img]);
		if (img && (w = img.width) > 0 && (h = img.height) > 0) {
			var x = _int(r.x + (r.width - w) / 2);
			var y = _int(r.y + (r.height - h) / 2);
			g.drawImage(img, x, y, w, h);
		}
	},
	$_drawMenuButton: function (grid, g, r, enabled, hovered, pressed) {
		var w, h;
		var img = pressed ? "dd" : hovered ? "dh" : "du";
		img = this.$_getImage(grid, img, this._imageUrls[img]);
		if (img && (w = img.width) > 0 && (h = img.height) > 0) {
			var x = _int(r.x + (r.width - w) / 2);
			var y = _int(r.y + (r.height - h) / 2);
			g.drawImage(img, x, y, w, h);
		}
	},
	$_drawCalendarButton: function (grid, g, r, enabled, hovered, pressed) {
		var w, h;
		var img = pressed ? "cd" : hovered ? "ch" : "cu";
		img = this.$_getImage(grid, img, this._imageUrls[img]);
		if (img && (w = img.width) > 0 && (h = img.height) > 0) {
			var x = _int(r.x + (r.width - w) / 2);
			var y = _int(r.y + (r.height - h) / 2);
			g.drawImage(img, x, y, w, h);
		}
	}
}, {
	BUTTON_WIDTH: 16,
	BUTTON_HEIGHT: 14
});
var EditButtonType = _enum({
	COMBO: "combo",
	ELLIPSIS: "ellipsis",
	CALENDAR: "calendar"
});
var EditButtonRenderer = defineClass("EditButtonRenderer", DefaultCellButtonRenderer, {
	init: function (name) {
		this._super(name);
	},
	buttonType: EditButtonType.COMBO,
	_doRender: function(index, g, rc, hovered, pressed, focused) {
		var column = index.dataColumn();
		if (column) {
			var br = rc.clone();
			br.leftBy(1);
			br.rightBy(-3);
			br.topBy(Math.max(1, _int((rc.height - DefaultCellButtonRenderer.BUTTON_HEIGHT) / 2)));
			br.setBottom(Math.min(br.y + DefaultCellButtonRenderer.BUTTON_HEIGHT, br.bottom() - 3));
			switch (this._buttonType) {
				case EditButtonType.COMBO:
					this.$_drawMenuButton(index.grid(), g, br, true, hovered, pressed);
					break;
				case EditButtonType.ELLIPSIS:
					this.$_drawEllipsisButton(index.grid(), g, br, true, hovered, pressed);
					break;
				case EditButtonType.CALENDAR:
					this.$_drawCalendarButton(index.grid(), g, br, true, hovered, pressed);
					break;
			}
		}
	}
});

var ImageButtonsRenderer = defineClass("ImageButtonsRenderer", CellButtonRenderer, {
	init: function (name) {
		this._super(name);
		this._inited = false;
		this._images = [];
		this._count = 0;
		this._imagePoints = [];
		this._imageGap = 2; // 이미지간의 간격
		this._margin =  2;  // Cell Border에서 간격
	},
	imageWidth: 16,
	imageHeight: 14,
	imageUrls: [],
	margin: null,
	imageGap: null,
	setImageUrls: function (value) {
		if (!value) {
			this._count = 0;
			this._imageUrls = null;
			this._images = null;
		} else {
			value = value && _isArray(value) ? value : [value];
			this._count = value.length;
			this._imageUrls = [];
			this._images = [];
			this._imagePoints = [0];
			var point = 0, w;
			for (var i = 0; i < this._count; i++) {
				var obj = value[i];
				var clone = {};
				for (var attr in obj) {
    				if (obj.hasOwnProperty(attr)) {
    					for (var state in ButtonState) {
    						if (ButtonState[state] == attr) {
		    					clone[attr] = obj[attr];
    							break;
    						}
    					}
    				}
    			}
    			this._imageUrls.push(clone);
    			w = (obj.hasOwnProperty("width") && !isNaN(obj["width"]) ? parseInt(obj["width"]) : this._imageWidth)+ ( i < this._count - 1 ?this._imageGap : 0);
    			point += w;
    			var image = {"name":obj["name"], "width":w, cursor:obj["cursor"]};
    			this._imagePoints.push(point);
    			this._images.push(image);
			}
		}
		this._inited = false;
	},
	prepare: function (grid) {
		if (!this._inited) {
			for (var i = 0; i < this._count; i ++) {
				for (var attr in this._imageUrls[i]) {
					grid.getImage(this._imageUrls[i][attr]);
				}
			}
			this._inited = true;
		}
	},
	_buttonIndex: function (w, h, x, y) {
		var idx = 0;
		for (var i = 1, cnt = this._imagePoints.length; i < cnt ; i++) {
			if (this._imagePoints[i] >= x) {
				idx = this._imagePoints[i] - ( i < cnt - 1 ? this._imageGap : 0 ) >= x ? i-1 : -1;
				return idx;
			}
		}
		return -1;
	},
	_doMeasure: function (index, hintWidth, hintHeight) {
		var w = this._imagePoints.length <= 0 ? 0 : (this._imagePoints[this._imagePoints.length-1]+this._margin);
		return new Size(w, hintHeight);
	},
	_doRender: function (index, g, r, hovered, pressed, focused, buttonIndex) {
		var column = index.dataColumn();
		if (column) {
			var br = r.clone();
			if (focused && index.grid().isEditing()) {
				br.leftBy(2);
				br.rightBy(-2);
			} else {
				br.leftBy(1);
				br.rightBy(-3);
			}
			for (var i = 0; i < this._count; i++) {
				if (buttonIndex === i) {
					this.$_drawButton(index.grid(), g, br, i, hovered, pressed);
				} else {
					this.$_drawButton(index.grid(), g, br, i, false, false);
				}
			}
		}
	},
	_doHitTest: function (w, h, x, y) {
		return this._buttonIndex(w, h, x, y) !== -1;
	},
	$_getImage: function (grid, index, state, url) {
		var img = this._images[index][state];
		if (!img) {
			img = grid.getImage(url);
			if (img) {
				this._images[index][state] = img;
			}
		}
		return img;
	},
	$_drawButton: function (grid, g, r, index, hovered, pressed) {
		var w, h;
		var state = pressed ? ButtonState.DOWN : hovered ? ButtonState.HOVER : ButtonState.UP;
		// Hover, Down Image가 없을땐 Normal이미지로 대체
		if (!this._imageUrls[index][state]) {
			if (this._imageUrls[index][ButtonState.UP]) {
				state = ButtonState.UP;
			}
		}
		img = this.$_getImage(grid, index, state, this._imageUrls[index][state]);
		if (img && (w = img.width) > 0 && (h = img.height) > 0) {
			// var x = _int(r.x + 1 + (this._imageWidth + 2) * index);
			var x = _int(r.x + 1 + this._imagePoints[index]);
			var y = _int(r.y + (r.height - h) / 2);
			g.drawImage(img, x, y, w, h);
		}
	},
	getCursor: function(index) {
		return this._images && this._images[index] && this._images[index].cursor;
	}
}, {

});
var /* abstract */ DynamicRendererOption = defineClass("DynamicRendererOption", null, {
	init: function (owner/* DataCellRenderer */) {
		this._super();
		_assert(owner != null, "owner is null");
		this._owner = owner; //
	},
	owner: function () {
		return this._owner;
	},
	apply: function (runtime/* DataCellRendererRuntime */, target/* Object */) {
	},
	_changed: function () {
	}
});
var DynamicRendererOptionImpl = defineClass("DynamicRendererOptionImpl", DynamicRendererOption, {
	init: function (owner, config) {
		this._super(owner);
		this._exprNode = null;
		this._propMap = {};
		if (config) {
			if (config.hasOwnProperty("criteria")) {
				this.setCriteria(config.criteria);
			}
			if (config.hasOwnProperty("options")) {
				this.setOptions(config.options);
			} else if (config.hasOwnProperty("styles")) {
				this.setOptions(config.styles);
			}
		}
	},
	criteria: null,
	options: null,
	setCriteria: function (value) {
		if (value != this._criteria) {
			this._criteria = value;
			this.$_buildExpression();
			this._changed();
		}
	},
	setOptions: function (value) {
		if (value != this._options) {
			this._options = value;
			this.$_buildStyles();
			this._changed();
		}
	},
	apply: function (runtime, target) {
		var styleMap;
		if (this._exprNode && (styleMap = this._exprNode.evaluate(runtime))) {
			styleMap = this._exprNode instanceof FunctionExpressionNode && (typeof styleMap != "boolean") ? styleMap : this._propMap;
			for (var p in styleMap) {
				var v = this._owner._readOption(p, styleMap[p]);
				if (v !== undefined) {
					target[p] = v;
				}
			}
		}
	},
	$_buildExpression: function () {
		if (this._criteria) {
			this._exprNode = ExpressionParser.Default.parse(this._criteria, this._owner ? this._owner.capitalIndexers() : null);
			if (this._exprNode == null) {
				this._exprNode = EmptyExpressionNode.Default;
			}
		} else {
			this._exprNode = EmptyExpressionNode.Default;
		}
	},
	$_buildStyles: function () {
		var i;
		var cnt;
		var items;
		var item;
		var arr;
		this._propMap = {};
		if (typeof this._options === "string") {
			items = this._options.split(";");
			for (i = 0, cnt = items.length; i < cnt; i++) {
				item = items[i];
				arr = item.split("=");
				if (arr.length > 1) {
					this._propMap[arr[0]] = arr[1];
				} else {
					this._propMap[arr[0]] = UNDEFINED;
				}
			}
		} else if (this._options) {
			for (var p in this._options) {
				this._propMap[p] = this._options[p];
			}
		}
	}
});
var DynamicRendererOptionCase = defineClass("DynamicRendererOptionCase", DynamicRendererOption, {
	init : function(owner, config) {
		this._super(owner);
		this._exprNodes = [];
		this._propMaps = [];
		if (config) {
			if (config.hasOwnProperty("criteria")) {
				this.setCriteria(config.criteria);
			}
			if (config.hasOwnProperty("options")) {
				this.setStyles(config.options);
			} else if (config.hasOwnProperty("styles")) {
				this.setOptions(config.styles);
			}
		}
	},
	criteria: null,
	styles: null,
	setCriteria: function (value) {
		if (value != this._criteria) {
			this._criteria = value;
			this.$_buildExpressions();
			this._changed();
		}
	},
	setStyles: function (value) {
		if (value != this._options) {
			this._options = value;
			this.$_buildStyles();
			this._changed();
		}
	},
	apply: function(runtime, target/* Object */) {
		for (var i = 0, len = this._exprNodes.length; i < len; i++) {
			var expr = this._exprNodes[i];
			if (expr && expr.evaluate(runtime)) {
				var options = this._propMaps[i];
				for (var p in options) {
					var v = this._owner._readOption(p, options[p]);
					if (v !== undefined) {
						target[p] = v;
					}
				}
				break;
			}
		}
	},
	$_buildExpressions: function () {
		var cnt;
		var owner = this.owner();
		this._exprNodes = [];
		if (this._criteria && (cnt = this._criteria.length) > 0) {
			for (var i = 0; i < cnt; i++) {
				var c = this._criteria[i];
				if (c) {
					var expr = ExpressionParser.Default.parse(c, owner ? owner.capitalIndexers() : null);
					if (expr == null) {
						expr = EmptyExpressionNode.Default;
					}
					this._exprNodes.push(expr);
				} else {
					this._exprNodes.push(EmptyExpressionNode.Default);
				}
			}
		}
	},
	$_buildStyles: function () {
		this._propMaps = [];
		for (var i = 0, cnt = this._exprNodes.length; i < cnt; i++) {
			var styles = this._options.length > i ? this._options[i] : this._options[cnt - 1];
			var items = styles.split(";");
			var map = {};
			this._propMaps.push(map);
			for (var j = 0; j < items.length; j++) {
				var item = items[j];
				var arr = item.split(/\s*=/);
				if (arr.length > 1) {
					map[arr[0]] = arr[1];
				} else {
					map[arr[0]] = null;
				}
			}
		}
	}
});
var DynamicRendererOptionCollection = defineClass("DynamicRendererOptionCollection", null, {
	init: function (owner) {
		this._super();
		this._owner = owner;
		this._items = [];
	},
	owner: function () {
		return this._owner;
	},
	count: function () {
		return this._items.length;
	},
	getItem: function (index) {
		return this._items[index];
	},
	clear: function () {
		this._items = [];
	},
	add: function (item) {
		var option = this.$_createOption(item);
		if (option && this._items.indexOf(option) < 0) {
			this._items.push(option);
		}
	},
	setItems: function (items) {
		this._items = [];
		var i, option;
		if (items) {
			if (items instanceof DynamicRendererOptionCollection) {
				items = items.toArray();
			}
			if (typeof items === "function") {
				option = this.$_createOption(items);
				option && this._items.push(option);
			} else {
				if (!_isArray(items)) {
					return;
				}
				var cnt = items.length;
				for (i = 0; i < cnt; i++) {
					option = this.$_createOption(items[i]);
					option && this._items.push(option);
				}
			}
		}
	},
	prepare: function () {
	},
	apply: function (runtime, target) {
		var i, option;
		var cnt = this._items.length;
		for (i = 0; i < cnt; i++) {
			option = this._items[i];
			option.apply(runtime, target);
		}
	},
	toArray: function () {
		return this._items.concat();
	},
	$_createOption: function (source) {
		var s = null;
		if (typeof source === "function") {
			var option = new DynamicRendererOptionImpl(this._owner, {criteria:source});
			s = option;
		} else if (source instanceof DynamicRendererOption) {
			source._owner = this._owner;
			s = source;
		} else if (_isArray(source)) {
			var cstyle;
			if (_isArray(source.options) || _isArray(source.styles)) {
				cstyle = new DynamicRendererOptionCase(this._owner, source);
				s = cstyle;
			} else {
				cstyle = new DynamicRendererOptionCase(this._owner, source);
				s = cstyle;
			}
		} else if (source && source.criteria) {
			var option = new DynamicRendererOptionImpl(this._owner, source);
			s = option;
		}
		return s;
	}
});

var /* abstract */ DataCellRenderer = defineClass("DataCellRenderer", GridObject, {
	init: function () {
		this._super();
		this._rect = new Rectangle();
		this._runtime = null;
		this._dynamicOptions = null;
		this._runtimeOptions = {};
		this._hoveredUnderline = false;
	},
	destroy: function() {
		return false;  // CellRenderer는 삭제하지 않는다.
	},
	minWidth: 4,
	dynamicOptions: null,
	showTooltip: false,
	tooltipEllipseTextOnly:false,
	altText: null,
	hoveredUnderline: false,
	dynamicOptions_: function () {
		return this._dynamicOptions ? this._dynamicOptions.toArray() : null;
	},
	setDynamicOptions: function (value) {
		if (value != this._dynamicOptions) {
			if (value) {
				if (!this._runtime) {
					this._runtime = new DataCellRendererRuntime();
				}
				if (!this._dynamicOptions) {
					this._dynamicOptions = new DynamicRendererOptionCollection(this);
				}
				this._dynamicOptions.setItems(value);
				this._changed();
			} else if (this._dynamicOptions) {
				this._dynamicOptions = null;
				this._changed();
			}
		}
	},
	capitalIndexers: function () {
		return null;
	},
	// renderer자체가 edit기능을 가지는가? (checkRenderer의 경우 editable 속성을 따로 가지고 isEditable도 별도 정의 사용 나머지는 사용안함)
	isEditable: function () {
		return false;
	},
	// renderer가 편집가능한가? (imageButtonsCellRenderer의 경우 alignment에 따라서 동적으로 변경된다.)
	// cell이 편집가능해도 renderer의 상태가 편집불가일수 있다
	canEditable: function() {
		return true;
	},
	isStartEditOnClick: function () {
		return false;
	},
	isDblClickEnabled: function () {
		return false;
	},
	isClickable: function (index) {
		return false;
	},
    isButton: function () {
        return false;
    },
    isHoveredUnderline: function(index) {
    	return this._hoveredUnderline;
    },
	setOptions: function (options) {
	},
	prepareRuntime: function (grid) {
		this._runtime && this._runtime.setDataSource(grid.dataSource());
	},
	applyDynamicStyles: function (target/*DataCellElement*/) {
		if (this._dynamicOptions && this._dynamicOptions.count() > 0) {
			this._runtime.setTarget(target);
			this._dynamicOptions.apply(this._runtime, this._runtimeOptions = {});
		}
	},
	measure: function (grid, cell, hintWidth, hintHeight) {
		return this._doMeasure(grid, cell, hintWidth, hintHeight);
	},
	measureHeight:function (grid, cell, columnWidth, maxHeight) {
		return this._doMeasureHeight(grid, cell, columnWidth, maxHeight)
	},
	render: function (cell, g, r) {
	},
	getButtonRenderer: function () {
		return null;
	},
	isEditableKey: function (index, key) {
		return false;
	},
	performEdit: function (index) {
	},
	performClick: function (cell, x, y) {
		return false;
	},
    getTooltip: function (cell) {
        if (this.isShowTooltip()) {
            var s = this._getText(cell);
            return s ? s : undefined;
        }
        return undefined;
    },
	assign: function (source) {
		this._super(source);
		if (source && !source.hasOwnProperty("dynamicOptions") && source.hasOwnProperty("dynamicStyles")) {
			this.setDynamicOptions(source.dynamicStyles);
		}
	},
	propertyChanged: function (prop, newValue) {
		this._changed();
	},
	_readOption: function (prop, value) {
		return value;
	},
	_getOption: function (prop) {
		if (this._runtimeOptions.hasOwnProperty(prop)) {
			var v = this._runtimeOptions[prop];
			if (v !== undefined) return v;
		}
		return this[prop]();
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		return new Size(Math.max(this._minWidth, hintWidth), hintHeight);
	},
	_doMeasureHeight: function (grid, cell, columnWidth, maxHeight) {
		return new Size(Math.max(this._minWidth, columnWidth), 0);
	},
	_getText: function (cell) {
		var t;
		var s = cell.text();
		if (s === null || s === UNDEFINED) {
			s = "";
		}
		if ((t = cell.prefix()) != null) {
			s = t + s;
		}
		if ((t = cell.suffix()) != null) {
			s += t;
		}
		return s;
	},
	_changed: function () {
	}
}, {
	consumeKey: function (index, key, shift, ctrl) {
		var grid = index ? index.grid() : null;
		if (grid && !grid.isEditing() && index.dataColumn() && key == Keys.SPACE) {
			var cell = grid.body().getCell(index);
			var rendererId = cell ? cell.styles().renderer() : null;
			var renderer = rendererId ? grid.dataCellRenderers().getRenderer(rendererId) : index.dataColumn().rendererObj();
			var images, imageName, buttonIndex;
			if (renderer) {  // (현재 checkCellRenderer 만 존재한다.)
				if (!grid.isReadOnly(index) && renderer.isEditable()) {
					if (renderer.isEditableKey(index, key, shift, ctrl) && grid.edit(index)) {
						var item = index.item();
						if ((grid.isItemEditing(item) || grid.canUpdate(item, index.dataField())) && grid.canWrite(index)) {
							grid.makeCellVisible(index, true);
							renderer.performEdit(index);
							return true;
						}
					}
				}
				// 버튼을 가지는 renderer이고 grid가 edition상태가 아니면 buttonClick을 발생시켜준다.
				// ClickableRenderer인경우 performClick을 호출
				// onDataCellClicked가 있는 경우 호출해 준다.
				var click = grid && grid.editOptions().isButtonClickWhenSpace();
				if (click) {
					var button = index.dataColumn().button();
					var handler = grid.getHandler();
					if (renderer instanceof LinkCellRenderer && renderer.isClickable(index)) {  // linkCellRenderer
						if (handler && handler.onLinkableCellClicked) {
							renderer.performClick(cell);  // linkableCellClick이 설정되어있지 않으면 버튼 클릭으로.
							return true;	
						} 
					};
					if (renderer.isButton && renderer.isButton()) {  // imageButtonCellRenderer , imageButtonsCellRenderer
						buttonIndex = renderer instanceof ImageButtonsCellRenderer ? 0 : undefined;
						images = renderer.images && renderer.images();
						name = _isArray(images) ? images[0].name : undefined;
						grid._fireImageButtonClicked(index, buttonIndex, name)
						return true;
					} else if (button && (button !== CellButton.NONE)) {
						var buttonRender = grid._delegate.getCellButtonRenderer(index);
						switch(button) {
							case CellButton.IMAGE:
								images = buttonRender._images;
								name = _isArray(images) && images[0].name;
								grid._fireImageButtonClicked(index, 0, name)
								break;
							case CellButton.ACTION:
								grid._fireCellButtonClicked(index);
								break;
							case CellButton.POPUP:
								var pManager = grid.popupMenuManager();
								if (pManager.isShow()) {
									return false;
								}							
								var lm = grid.layoutManager();
								var room = lm.getMergedCell(index);
								var view = room ? grid.getCellView(grid._mergeView, index, index.isFixedCol()) :_cast(grid.getCellView(null, index), CellElement);
								var menu = index.column().menu();
								menu && view && pManager.show(menu, view);
								break;
						} 
						return true;
					} else if (handler && handler.onDataCellClicked) {
						grid._fireDataCellClicked(index);
						return true;
					}						
				}
			}
		}
		return false;
	}
});
var /* internal */ DataCellRendererCollection = function (delegate) {
	var _delegate = delegate;
	var _options = {};
	var _renderers = {};
	var grid = delegate._grid;
	this.addRenderers = function (renderers) {
		if (renderers) {
			var options = renderers;
			if (!_isArray(options)) {
				options = [renderers];
			}
			for (var i = 0, cnt = options.length; i < cnt; i++) {
				var opt = options[i];
				if (opt && opt.hasOwnProperty("id") && opt.id) {
					_options[opt.id] = _extend({}, opt);
				}
			}
		}
	};
	this.getRenderer = function (id) {
		var options = _options[id];
		if (options) {
			var renderer = _cast(_renderers[id], DataCellRenderer);
			if (!renderer) {
				renderer = delegate.createRenderer(options);
				if (renderer) {
					_renderers[id] = renderer;
					renderer.prepare && renderer.prepare(grid);
				}
			}
			return renderer;
		}
		return null;
	};
};
var TextCellRenderer = defineClass("TextCellRenderer", DataCellRenderer, {
	init: function () {
		this._super();
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		if (cell._textWrap && (cell._textWrap == TextWrapMode.NORMAL || cell._textWrap == TextWrapMode.EXPLICIT)) {
			var r = new Rectangle(0, 0, 0, 0);
			grid.measureTextRect(cell.font(),this._getText(cell), 0, 0, hintWidth, hintHeight, cell._textAlign, cell._lineAlign, cell._textWrap,r)
			return _tempSize(r.width+cell.paddingHorz(), hintHeight);
		} else {
			return _tempSize(grid.measureText(cell.font(), this._getText(cell)) + cell.paddingHorz(), hintHeight);
		}
	},
	_doMeasureHeight: function (grid, cell, columnWidth, maxHeight) {
		var r = _tempSize(columnWidth, grid.measureTextRect(cell.font(),this._getText(cell), 0, 0, columnWidth, maxHeight, cell._textAlign, cell._lineAlign, cell._textWrap )+cell.paddingVert());
		r.height = Math.min(r.height, maxHeight);
		return r;
    },
	render: function (cell, g, r) {
		var s = this._getText(cell);
		var fName = cell.figureName();
		fName && TextCellRenderer.drawEdgeMark(fName, cell, g, r);
		r = this._rect.copy(r);
		cell.inflatePadding(r);
		TextCellRenderer.renderWrapText(cell, g, r.x, r.y, r.width, r.height, s);
	}
}, {
	renderWrapText: function(cell, g, x, y, w, h, s) {
		switch (cell.textWrap()) {
			case TextWrapMode.EXPLICIT:
				g.drawTextBoundsExplicit(cell.font(), cell.foreground(), s, x, y, w, h, cell.textAlign(), cell.lineAlign());
				break;
			case TextWrapMode.NORMAL:
				g.drawTextBoundsWrap(cell.font(), cell.foreground(), s, x, y, w, h, cell.textAlign(), cell.lineAlign());
				break;
			case TextWrapMode.ELLIPSE:
				g.drawTextBoundsEllipse(cell.font(), cell.foreground(), s, x, y ,w, h, cell.textAlign(), cell.lineAlign());
				break;
			default:
				g.drawTextBounds(cell.font(), cell.foreground(), s, x, y, w, h, cell.textAlign(), cell.lineAlign());
				break;
		}
	},
	drawEdgeMark: function (figureName, cell, g, r) {
		var fill = cell.figureBackground();
		var x = r.x, y = r.y, w = r.width, h = r.height;
		var fs = cell.figureSize();
		var h2 = fs ? fs.getDimension(h) : 10;
		var pts = null;
		switch (figureName) {
			case EdgeMark.LEFT_TOP: pts = [x,y,  x+h2,y,  x,y+h2]; break;
			case EdgeMark.LEFT_BOTTOM: pts = [x,y+h,  x+h2,y+h, x,y+h-h2]; break;
			case EdgeMark.RIGHT_TOP: pts = [x+w-h2,y,  x+w,y,  x+w,y+h2]; break;
			case EdgeMark.RIGHT_BOTTOM: pts = [x+w, y+h-h2,  x+w,y+h, x+w-h2, y+h]; break;
		}
		pts && g.drawPolygonArray(fill, null, pts);

	}
});
TextCellRenderer.Default = new TextCellRenderer();
var BarCellRenderer = defineClass("BarCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this.setMinWidth(100);
	},
	minimum: 0,
	maximum: 100,
	showLabel: false,
	origin: "default",
	absoluteValue: false,
	render: function(cell, g, r) {
		if (this._maximum > this._minimum) {
			var v = this.isAbsoluteValue() ? Math.abs(cell.value()) : cell.value();
			var rate = Math.min(1, (v - this._minimum) / (this._maximum - this._minimum));
			var border = cell.figureBorder();
			var fill = cell.figureBackground();
			if (border || fill) {
				switch (this.origin()) {
					case BarCellRenderer.ORIGIN_LEFT:
						this.$_drawLeft(cell, g, fill, border, r, rate);
						break;
					case BarCellRenderer.ORIGIN_RIGHT:
						this.$_drawRight(cell, g, fill, border, r, rate);
						break;
					case BarCellRenderer.ORIGIN_BOTTOM:
						this.$_drawBottom(cell, g, fill, border, r, rate);
						break;
					case BarCellRenderer.ORIGIN_TOP:
						this.$_drawTop(cell, g, fill, border, r, rate);
						break;
					default:
						this.$_drawLeft(cell, g, fill, border, r, rate);
						break;
				}
			}
		}
		if (this.isShowLabel()) {
			var s = this._getText(cell);
			TextCellRenderer.renderWrapText(cell, g, r.x, r.y, r.width, r.height, s);
			//g.drawTextRect(null, cell.foreground(), s, r, cell.textAlign());
		}
	},
	$_drawLeft: function (cell, g, fill, border, r, rate) {
		var x = cell.paddingLeft();
		var w = (r.width - x - cell.paddingRight()) * rate;
		if (w >= 0) {
			var y = cell.paddingTop();
			var h = r.height - cell.paddingBottom() - y;
			var h2 = h;
			var sz = cell.figureSize();
			if (sz) {
				h2 = sz.getDimension(h);
			}
			if (h2 >= 0) {
				g.drawBoundsI(fill, border, r.x + x, r.y + y + (h - h2) / 2, w, h2);
			}
		}
	},
	$_drawRight: function (cell, g, fill, border, r, rate) {
		var x = cell.paddingRight();
		var w = (r.width - cell.paddingLeft() - x) * rate;
		if (w >= 0) {
			var y = cell.paddingTop();
			var h = r.height - cell.paddingBottom() - y;
			var h2 = h;
			var sz = cell.figureSize();
			if (sz) {
				h2 = sz.getDimension(h)
			}
			if (h2 >= 0) {
				g.drawBoundsI(fill, border, r.right() - x - w, r.y + y + (h - h2) / 2, w, h2);
			}
		}
	},
	$_drawBottom: function (cell, g, fill, border, r, rate) {
		var y = cell.paddingBottom();
		var h = (r.height - y - cell.paddingTop()) * rate;
		if (h >= 0) {
			var x = cell.paddingLeft();
			var w = r.width - cell.paddingRight() - x;
			var w2 = w;
			var sz = cell.figureSize();
			if (sz) {
				w2 = sz.getDimension(w)
			}
			if (w2 >= 0) {
				g.drawBoundsI(fill, border, r.x + x + (w - w2) / 2, r.bottom() - y - h, w2, h);
			}
		}
	},
	$_drawTop: function (cell, g, fill, border, r, rate) {
		var y = cell.paddingTop();
		var h = (r.height - y - cell.paddingBottom()) * rate;
		if (h >= 0) {
			var x = cell.paddingLeft();
			var w = r.width - cell.paddingRight() - x;
			var w2 = w;
			var sz = cell.figureSize();
			if (sz) {
				w2 = sz.getDimension(w)
			}
			if (w2 >= 0) {
				g.drawBoundsI(fill, border, r.x + x + (w - w2) / 2, r.y + y, w2, h);
			}
		}
	}
});
BarCellRenderer.ORIGIN_DEFAULT = "default";
BarCellRenderer.ORIGIN_LEFT = "left";
BarCellRenderer.ORIGIN_RIGHT = "right";
BarCellRenderer.ORIGIN_TOP = "top";
BarCellRenderer.ORIGIN_BOTTOM = "bottom";
var ProgressCellRenderer = defineClass("ProgressCellRenderer", DataCellRenderer, {
	init: function () {
		this._super();
		this.setMinWidth(100);
	},
	render: function (cell, g, r) {
	}
});
var CheckCellRenderer = defineClass("CheckCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this._values = {};
		this._falseValue = undefined;
		this._trueValues = undefined;
	},
	trueValues: null,
	falseValues: null,
	shape: undefined,
	labelPosition: "hidden",
	labelGap: 4,
	spaceKey: true,
	editable: false,
	dblClickEditable: false,
	startEditOnClick: false,
	threeState: false,
	showInnerFocus: true,
	trueImage: null,
	falseImage: null,
	emptyImage: null,
	prepareRuntime: function (grid) {
		this._super(grid);
		this._loadImage(grid);
	},
	_loadImage:function(grid) {
		this._trueImage && grid.getImage(this._trueImage);
		this._falseImage && grid.getImage(this._falseImage);
		this._emptyImage && grid.getImage(this._emptyImage);
	},
	setTrueValues: function (value) {
		if (value != this._trueValues) {
			this._trueValues = value;
			this.$_resetValues();
		}
	},
	setFalseValues: function (value) {
		if (value != this._falseValues) {
			this._falseValues = value;
			this.$_resetValues();
		}
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		var sz = _tempSize(cell.paddingHorz(), hintHeight);
		var w = 12;
		var dim = cell.figureSize();
		if (dim) {
			w = dim.getDimension(12);
		}
		sz.width += w;
		if (this.labelPosition() != CheckCellRenderer.HIDDEN) {
			sz.width += this.labelGap() + grid.measureText(cell.font(), cell.value());
		};
		return sz;
	},
	render: function(cell, g, r) {
		var x, y, w, h, tr, s, sz, image, img;
		var	value = cell.value();
		var	v = this.$_getValue(value);
		var empty = (this._threeState && v === undefined);
		var	border = empty ? null : cell.figureBorder();
		var	fill =  empty ? null : v ? cell.figureBackground() : cell.figureInactiveBackground();
		if (this._trueImage && v) {
			image = this._trueImage;
		} else if (this._falseImage && !empty && !v) {
			image = this._falseImage;
		} else if (this._emptyImage && empty) {
			image = this._emptyImage;
		};
		if (fill || border || image) {
			w = 12;
			h = 10;
			if (image) {
				img = cell.grid().getImage(image);
				if (img) {
					w = Math.min(img.width , r.width);
					h = Math.min(img.height , r.height);
				}
			} else if (this._shape == CheckCellRenderer.SHAPE_BOX) {
				w = 12;
				h = 12;
			};
			sz = cell.figureSize();
			if (sz && !img) {
				w = sz.getDimension(w);
				h = w * 10 / 12;
			}
			tr = null;
			switch (this._labelPosition) {
				case CheckCellRenderer.RIGHT:
					x = cell.paddingLeft() + r.x;
					y = r.y + (r.height - h) / 2;
					tr = this._rect;
					tr.copy(r);
					tr.leftBy(w + this._labelGap);
					tr.rightBy(-cell.paddingRight());
					break;
				case CheckCellRenderer.LEFT:
					x = r.right() - cell.paddingRight() - w;
					y = r.y + (r.height - h) / 2;
					tr = this._rect;
					tr.copy(r);
					tr.leftBy(cell.paddingLeft());
					tr.right(x - this._labelGap);
					break;
				case CheckCellRenderer.BOTTOM:
					x = r.x + (r.width - w) / 2;
					y = cell.paddingTop();
					tr = this._rect;
					tr.copy(r);
					tr.leftBy(cell.paddingLeft());
					tr.rightBy(-cell.paddingRight());
					tr.topBy(h + this._labelGap);
					break;
				case CheckCellRenderer.TOP:
					x = r.x + (r.width - w) / 2;
					y = r.bottom() - h - cell.paddingBottom();
					tr = this._rect;
					tr.copy(r);
					tr.leftBy(cell.paddingLeft());
					tr.rightBy(-cell.paddingRight());
					tr.bottomBy(-h - this._labelGap);
					break;
				default:
					x = r.x + (r.width - w) / 2;
					y = r.y + (r.height - h) / 2;
					break;
			};
			x = _int(x);
			y = _int(y);
			if (tr) {
				s = this._getText(cell);
				tr.topBy(cell.paddingTop());
				tr.bottomBy(-cell.paddingBottom());
				TextCellRenderer.renderWrapText(cell, g, tr.x, tr.y, tr.width, tr.height, s);
				//g.drawTextRect(null, cell.foreground(), s, tr, cell.textAlignment());
			}
			if (img) {
	            g.drawImage(img, x, y, w, h);	
			} else {
				if (this._shape == CheckCellRenderer.SHAPE_BOX) {
					var	line = empty ? null : (cell.line() || SolidPen.DKGRAY);
					var boxR = new Rectangle(x, y, w, h);
					g.drawRectI(null, line, boxR);

					boxR.inflate(-1,-1);
					g.drawPolygonArray(fill, border, [
						boxR.x + boxR.width * 1.25 / 8, boxR.y + boxR.height * 2.65 / 7,
						boxR.x + boxR.width * 0, boxR.y + boxR.height * 4.25 / 7,
						boxR.x + boxR.width * 3.45 / 8, boxR.y + boxR.height * 7.0 / 7,
						boxR.x + boxR.width * 8.0 / 8, boxR.y + boxR.height * 1.2 / 7,
						boxR.x + boxR.width * 6.5 / 8, boxR.y + boxR.height * 0.1,
						boxR.x + boxR.width * 3.45 / 8, boxR.y + boxR.height * 4.25 / 7
					]);
				} else {
					g.drawPolygonArray(fill, border, [
						x + w * 1.25 / 8, y + h * 2.65 / 7,
						x + w * 0, y + h * 4.25 / 7,
						x + w * 3.95 / 8, y + h * 7.0 / 7,
						x + w * 8.0 / 8, y + h * 1.2 / 7,
						x + w * 6.3 / 8, y + h * 0,
						x + w * 3.45 / 8, y + h * 4.25 / 7
					]);
				}
			}
		}
		if (this.isEditable() && cell.isFocused() && this.isShowInnerFocus()) {
			var grid = cell.grid();
			if (grid && !grid.isReadOnly(cell.index())) {
				r.inflate(-3, -3);
				!r.isEmpty() && g.drawRect(null, SolidPen.FOCUS, r);
				/*
				 g.lineStyle(0, 0, 0.5, true);
				 if (tr) {
				 r = cell.getTextBounds();
				 r.inflate(3, 1);
				 r = r.intersection(tr);
				 GraphicUtils.drawFocusRect(g, r.left, r.top, r.width, r.height);
				 } else {
				 GraphicUtils.drawFocusRect(g, x, y, w, h);
				 }
				 */
			}
		}
	},
	isEditableKey: function (index, key) {
		return this.isSpaceKey() && key == Keys.SPACE;
	},
	performEdit: function (index) {
		var v = this.$_getValue(index.value());
		var fld = index.dataField();
		var grid = index.grid();
		var ds = index.grid().dataSource();
		var item = index.item();
		if (fld >= 0 && ds.getValueType(fld) == ValueType.BOOLEAN) {
			if (this._threeState && v !== undefined && !v) {
				v = undefined;
			} else {
				v = !v;
			}
		} else {
			if (v) {
				v = this._falseValue ? this._falseValue : false;
			} else if (v !== undefined && this._threeState) {
				v = undefined;
			} else {
				v = this._trueValue ? this._trueValue : true;
			}
		};
		var commit = grid.editorCommit(null, index, this.$_getValue(index.value()), v);
		if (commit) {
			item.setData(fld, v);
			if (index.grid()) {
				index.grid().validateCellCommit(index, v);
			}
		}
	},
	$_resetValues: function () {
		var vals, len, i;
		this._values = {};
		if (this._falseValues) {
			vals = this._falseValues.split(",");
			if (vals) {
				this._falseValue = (len = vals.length) > 0 ? vals[0] : undefined;
				for (i = 0; i < len; i++) {
					this._values[vals[i]] = false;
				}
			} else {
				this._falseValue = undefined;
			}
		} 
		if (this._trueValues) {
			vals = this._trueValues.split(",");
			if (vals) {
				this._trueValue = (len = vals.length) > 0 ? vals[0] : undefined;
				for (i = 0; i < len; i++) {
					this._values[vals[i]] = true;
				}
			} else {
				this._trueValue = undefined;
			}
		}
	},
	$_getValue: function (v) {
		if (typeof v === "boolean") {
			return v;
		} else {
			var val = String(v);
			if (this._values.hasOwnProperty(val)) {
				return this._values[val];
			} else if (this._threeState && (v == "" || v === undefined || v === null)) {
				return undefined;
			} else {
				return Boolean(v);
			}
		}
	}
});
CheckCellRenderer.HIDDEN = "hidden";
CheckCellRenderer.RIGHT = "right";
CheckCellRenderer.LEFT = "left";
CheckCellRenderer.BOTTOM = "bottom";
CheckCellRenderer.TOP = "top";
CheckCellRenderer.SHAPE_DEFAULT = "default";
CheckCellRenderer.SHAPE_BOX = "box";

var ShapeCellRenderer = defineClass("ShapeCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this._ellipse = null;
		this._polygon = null;
		this._rect = new Rectangle();
	},
	sizeRate: 0.6,
	render: function(cell, g, r) {
		var shapeType = cell.figureName();
		var shape = this._getShape(shapeType);
		switch (cell.iconLocation()) {
			case IconLocation.RIGHT:
				this._drawRight(cell, shape, g, r);
				break;
			case IconLocation.TOP:
				this._drawTop(cell, shape, g, r);
				break;
			case IconLocation.BOTTOM:
				this._drawBottom(cell, shape, g, r);
				break;
			case IconLocation.CENTER:
				this._drawCenter(cell, shape, g, r);
				break;
			case IconLocation.LEFT:
			default:
				this._drawLeft(cell, shape, g, r);
				break;
		}
	},
	_getShape: function (type) {
		var shape = null;
		if (type) {
			type = type.toLowerCase();
			if (type == "null") {
				shape = NullShape.Default;
			} else if (type == "ellipse") {
				shape = this._ellipse ? this._ellipse : (this._ellipse = new EllipseShape());
			} else {
				shape = this._polygon ? this._polygon : (this._polygon = new PolygonShape());
				this._polygon.setShape(type);
			}
		}
		return shape;
	},
	_drawLeft: function (cell, shape, g, r) {
		var iconOff = cell.iconOffset();
		var iconGap = cell.iconPadding() + iconOff;
		var tx = r.x + cell.paddingLeft();
		var ty = r.y + cell.paddingTop();
		var tw = r.width - cell.paddingHorz();
		var th = r.height - cell.paddingVert();
		var sw = 0;
		if (shape) {
			sw = Math.min(tw, th);
			var sh = sw;
			var sz = cell.figureSize();
			if (sz) {
				sw = sz.getDimension(sw);
				sh = sz.getDimension(sh);
			} else {
				sw = sw * this._sizeRate;
				sh = sh * this._sizeRate;
			}
			var x = tx + iconOff;
			var y = ty;
			switch (cell.iconAlignment()) {
				case Alignment.CENTER:
					y += (th - sh) / 2;
					break;
				case Alignment.FAR:
					y += th - cell.paddingVert() - sh;
					break;
			}
			this._rect.set(x, y, sw, sh);
			shape.draw(g, this._rect, cell.figureBackground(), cell.figureBorder());
		}
		var s = this._getText(cell);
		if (s) {
			tx += sw + iconGap;
			tw -= sw + iconGap;
			TextCellRenderer.renderWrapText(cell, g, tx, ty, tw, th, s);
			//g.drawTextBounds(null, cell.foreground(), s, tx, ty, tw, th, cell.textAlign());
		}
	},
	_drawRight: function (cell, shape, g, r) {
		var iconOff = cell.iconOffset();
		var iconGap = cell.iconPadding() + iconOff;
		var tx = r.x + cell.paddingLeft();
		var ty = r.y + cell.paddingTop();
		var tw = r.width - cell.paddingHorz();
		var th = r.height - cell.paddingVert();
		var sw = 0;
		if (shape) {
			sw = Math.min(tw, th);
			var sh = sw;
			var sz = cell.figureSize();
			if (sz) {
				sw = sz.getDimension(sw);
				sh = sz.getDimension(sh);
			} else {
				sw = sw * this._sizeRate;
				sh = sh * this._sizeRate;
			}
			var x = r.right() - sw - iconOff - cell.paddingRight();
			var y = ty;
			switch (cell.iconAlignment()) {
				case Alignment.CENTER:
					y += (th - sh) / 2;
					break;
				case Alignment.FAR:
					y += th - cell.paddingVert() - sh;
					break;
			}
			this._rect.set(x, y, sw, sh);
			shape.draw(g, this._rect, cell.figureBackground(), cell.figureBorder());
		}
		var s = this._getText(cell);
		if (s) {
			tw -= sw + iconGap;
			TextCellRenderer.renderWrapText(cell, g, tx, ty, tw, th, s);
			//g.drawTextBounds(null, cell.foreground(), s, tx, ty, tw, th, cell.textAlign());
		}
	},
	_drawTop: function (cell, shape, g, r) {
		var iconOff = cell.iconOffset();
		var iconGap = cell.iconPadding() + iconOff;
		var tx = r.x + cell.paddingLeft();
		var ty = r.y + cell.paddingTop();
		var tw = r.width - cell.paddingHorz();
		var th = r.height - cell.paddingVert();
		var sh = 0;
		if (shape) {
			sh = Math.min(tw, th);
			var sw = sh;
			var sz = cell.figureSize();
			if (sz) {
				sw = sz.getDimension(sw);
				sh = sz.getDimension(sh);
			} else {
				sw = sw * this._sizeRate;
				sh = sh * this._sizeRate;
			}
			var x = tx;
			var y = ty + iconOff;
			switch (cell.iconAlignment()) {
				case Alignment.CENTER:
					x += (tw - sw) / 2;
					break;
				case Alignment.FAR:
					x += tw - cell.paddingHorz() - sw;
					break;
			}
			this._rect.set(x, y, sw, sh);
			shape.draw(g, this._rect, cell.figureBackground(), cell.figureBorder());
		}
		var s = this._getText(cell);
		if (s) {
			ty += sh + iconGap;
			th -= sh + iconGap;
			TextCellRenderer.renderWrapText(cell, g, tx, ty, tw, th, s);
			//g.drawTextBounds(null, cell.foreground(), s, tx, ty, tw, th, cell.textAlign());
		}
	},
	_drawBottom: function (cell, shape, g, r) {
		var iconOff = cell.iconOffset();
		var iconGap = cell.iconPadding() + iconOff;
		var tx = r.x + cell.paddingLeft();
		var ty = r.y + cell.paddingTop();
		var tw = r.width - cell.paddingHorz();
		var th = r.height - cell.paddingVert();
		var sh = 0;
		if (shape) {
			sh = Math.min(tw, th);
			var sw = sh;
			var sz = cell.figureSize();
			if (sz) {
				sw = sz.getDimension(sw);
				sh = sz.getDimension(sh);
			} else {
				sw = sw * this._sizeRate;
				sh = sh * this._sizeRate;
			}
			var x = tx;
			var y = r.bottom() - sh - iconOff - cell.paddingBottom();
			switch (cell.iconAlignment()) {
				case Alignment.CENTER:
					x += (tw - sw) / 2;
					break;
				case Alignment.FAR:
					x += tw - cell.paddingHorz() - sw;
					break;
			}
			this._rect.set(x, y, sw, sh);
			shape.draw(g, this._rect, cell.figureBackground(), cell.figureBorder());
		}
		var s = this._getText(cell);
		if (s) {
			th -= sh + iconGap;
			TextCellRenderer.renderWrapText(cell, g, tx, ty, tw, th, s);
			//g.drawTextBounds(null, cell.foreground(), s, tx, ty, tw, th, cell.textAlign());
		}
	},
	_drawCenter: function (cell, shape, g, r) {
		var iconOff = cell.iconOffset();
		var iconGap = cell.iconPadding() + iconOff;
		var tx = r.x + cell.paddingLeft();
		var ty = r.y + cell.paddingTop();
		var tw = r.width - cell.paddingHorz();
		var th = r.height - cell.paddingVert();
		var sw = 0;
		if (shape) {
			sw = Math.min(tw, th);
			var sh = sw;
			var sz = cell.figureSize();
			if (sz) {
				sw = sz.getDimension(sw);
				sh = sz.getDimension(sh);
			} else {
				sw = sw * this._sizeRate;
				sh = sh * this._sizeRate;
			}
			var x = tx + iconOff;
			var y = ty + iconOff;
			x += (tw - sw) / 2;
			y += (th - sh) / 2;
			this._rect.set(x, y, sw, sh);
			shape.draw(g, this._rect, cell.figureBackground(), cell.figureBorder());
		}
	}
});
var SignalBarCellRenderer = defineClass("SignalBarCellRenderer", DataCellRenderer, {
	init : function() {
		this._super();
	},
	barCount: 4,
	minimum: NaN,
	maximum: NaN,
	absoluteValue:false,
	setBarCount: function (value) {
		value = Math.max(2, value);
		if (value != this._barCount) {
			this._barCount = value;
			this._changed();
		}
	},
	render : function(cell, g, r) {
		var v = NaN;
		var s = cell.figureState();
		var isValue = s && typeof s == "string" && s.toLowerCase() == "value";
		var state = isValue ? (v = this.isAbsoluteValue() ? Math.abs(cell.value()) : cell.value()) : parseInt(s);
		var border = cell.figureBorder();
		var fill = cell.figureBackground();
		if (isValue && !isNaN(this._minimum) && !isNaN(this._maximum)) {
			state = this._barCount * (v - this._minimum) / (this._maximum - this._minimum); 
		}
		if (border || fill) {
			var i;
			var fillInactive = cell.figureInactiveBackground();
			var w = r.width - cell.paddingHorz();
			var h = r.height - cell.paddingVert();
			var x = cell.paddingLeft();
			var y = cell.paddingTop();
			var bg = 2; // bar gap
			var bw = (w - (this._barCount  + 1) * bg) / this._barCount;
			var bx = x;
			var by = y + h / 2;
			var dy = h / 2 / (this._barCount - 1);
			for (i = 0; i < this._barCount; i++) {
				fill = i < state ? fill : fillInactive;
				g.drawBounds(fill, border, bx, by, bw, h - by);
				bx += bw + bg;
				by -= dy;
			}
		}
	}
});
/* todo 
	지금은 value에 url을 모두 가지고 있어야 하지만. 
	baseUrl을 가지는 data와 fileName을 가지는 data가 분리되어있을때 처리할 방법 필요.
*/
var IconCellRenderer = defineClass("IconCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
	},
	textVisible: true,
	iconWidth:0,
	iconHeight:0,
	_doMeasure: function (grid, cell, hintWidth, maxHeight) {
		return IconCellRenderer.measure(grid, cell, this._getText(cell), hintWidth, maxHeight);
	},
	_doMeasureHeight: function(grid, cell, columnWidth, maxHeight) {
		return IconCellRenderer.measure(grid, cell, this._getText(cell), columnWidth, maxHeight);
	},
	render: function(cell, g, r) {
		var s = this._textVisible ? this._getText(cell) : undefined;
		IconCellRenderer.renderBitmapText(cell, s, g, r);
		// iconRenderer의 경우 그려준 이후 그려진 영역을 기억한다.
		r = this._rect.copy(r);
		cell.inflatePadding(r);
	}
}, {
	measure: function(grid, cell, text, hintWidth, maxHeight) {
		var r = new Rectangle(0, 0, hintWidth, maxHeight);
		var img = IconCellRenderer.getIcon(cell);
		var iconLocation = cell.iconLocation();
		grid.measureTextRect(cell.font(),text, 0, 0, hintWidth, maxHeight, cell._textAlign, cell._lineAlign, cell._textWrap, r);
		if (img) {
			switch (iconLocation) {
				case IconLocation.RIGHT :
				case IconLocation.LEFT :
					if (!isNaN(img.width)) {
						r.width += img.width + cell.iconPadding() + cell.iconOffset();
					}
					r.height = Math.max(r.height, isNaN(img.height) ? 0 : img.height);
					break;
				case IconLocation.TOP:
				case IconLocation.BOTTOM:
					if (!isNaN(img.height)) {
						r.height += img.height + cell.iconPadding() + cell.iconOffset();
					}
					r.width = Math.max(r.width, isNaN(img.width) ? 0 : img.width);
					break;
				case IconLocation.CENTER:
					break;
			}
		}
		r.width += cell.paddingHorz();
		r.height += cell.paddingVert();
		return _tempSize(r.width, r.height);
	},
	getIcon: function(cell) {
		var img, imgIdx, idx = cell.iconIndex();
		if (typeof idx == "string" && idx.indexOf("value") == 0) {
			if (idx.length == 5) {
				idx = cell.value();
			} else if (idx.charAt(5) == "[") {
				var c = idx.lastIndexOf("]");
				if (c >= 0) {
					idx = idx.substring(6, c);
					idx = cell.getValueOf(idx);
				}
			}
		}
		if (!isNaN(imgIdx = parseInt(idx))) {
			var images = cell.index().dataColumn().images();
			img = images ? images.getImage(imgIdx) : null;
		} else if (imgIdx !== -1 && idx != null){
			img = cell.grid().getImage(idx);
		};
		return img;
	},
	renderBitmapText: function (cell, text, g, r) {
		var padHorz = cell.paddingHorz();
		var padVert = cell.paddingVert();
		var iconOff = cell.iconOffset();
		var iconGap = cell.iconPadding() + iconOff;
		var tx = r.x + cell.paddingLeft();
		var ty = r.y + cell.paddingTop();
		var tw = r.width - padHorz;
		var th = r.height - padVert;
		var loc = cell.iconLocation();
		var iw = (cell._renderer && cell._renderer._iconWidth) || 0;
		var ih = (cell._renderer && cell._renderer._iconHeight) || 0;
		var img = IconCellRenderer.getIcon(cell);
		if (img || iw > 0 || ih > 0) {
			var x = tx;
			var y = ty;
			var w = img ? Math.max(img.width, iw) : iw;
			var h = img ? Math.max(img.height, ih) : ih;
			switch (loc) {
				case IconLocation.RIGHT:
					x = r.right() - w - iconOff - cell.paddingRight();
					switch (cell.iconAlignment()) {
						case Alignment.CENTER:
							y += (th - h) / 2;
							break;
						case Alignment.FAR:
							y += th - padVert - h;
							break;
					}
					tw -= w + iconGap;
					break;
				case IconLocation.TOP:
					y += iconOff;
					switch (cell.iconAlignment()) {
						case Alignment.CENTER:
							x += (tw - w) / 2;
							break;
						case Alignment.FAR:
							x += tw - padHorz - w;
							break;
					}
					ty += h + iconGap;
					th -= h + iconGap;
					break;
				case IconLocation.BOTTOM:
					y = r.bottom() - h - iconOff - cell.paddingBottom();
					switch (cell.iconAlignment()) {
						case Alignment.CENTER:
							x += (tw - w) / 2;
							break;
						case Alignment.FAR:
							x += tw - padHorz - w;
							break;
					}
					th -= h + iconGap;
					break;
				case IconLocation.CENTER:
					x += (tw - w) / 2;
					y += (th - h) / 2;
					break;
				case IconLocation.LEFT:
				default:
					x += iconOff;
					switch (cell.iconAlignment()) {
						case Alignment.CENTER:
							y += (th - h) / 2;
							break;
						case Alignment.FAR:
							y += th - padVert - h;
							break;
					}
					tx += w + iconGap;
					tw -= w + iconGap;
					break;
			}
            img && g.drawImageI(img, x, y);
		}
		if (text && loc != IconLocation.CENTER) {
			var rect = new Rectangle(tx, ty, tw, th);
			g.save();
			g.clipRect(rect);
			TextCellRenderer.renderWrapText(cell, g, tx, ty, tw, th, text);
			g.restore();
			//g.drawTextBounds(cell.font(), cell.foreground(), text, tx, ty, tw, th, cell.textAlign());
		}
	}
});
var MultiIconCellRenderer = defineClass("MultiIconCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this.setMinWidth(0);
		this._icons = null;
	},
	renderCallback: null,
	icons: null,
	textVisible: true,
	iconGap: 0,
	setIcons: function(value) {
		this._icons = !value ? null : _isArray(value) ? value : [value]; 
	},
	_doMeasure: function (grid, cell, hintWidth, maxHeight) {
		var i, cnt, x, y, w, h, ww = 0, hh = 0;
		var grid = cell.grid();
		var handler = grid && grid.getHandler();
		var index = cell.index();
		var callback = this.renderCallback();
		var loc = cell.iconLocation();
		var text = this._textVisible && this._getText(cell);
		var padHorz = cell.paddingHorz();
		var padVert = cell.paddingVert();
		var iconOff = cell.iconOffset();
		var iconPadding = cell.iconPadding() + iconOff;
		var iconGap = isNaN(this._iconGap) ? 0 : this._iconGap;
		var value = cell.value();
		var imageUrls = !this._icons && (!callback || typeof callback !== "function") ? [] : (this._icons || callback(handler, index.proxy(), value));
		!imageUrls && (imageUrls = []);
		var tr = new Rectangle(0, 0, hintWidth, maxHeight);
		grid.measureTextRect(cell.font(),text, 0, 0, hintWidth, maxHeight, cell._textAlign, cell._lineAlign, cell._textWrap, tr);
		for (i = 0, cnt = imageUrls.length; i < cnt ; i++) {
			var img = grid.getImage(imageUrls[i]);
			w = img ? Math.max(img.width, this._minWidth) : this._minWidth;
			img && (hh = Math.max(hh, img.height));
			ww += w + ( i + 1 === cnt ? 0 : this._iconGap); // 전체 넓이를 일단 계산.
		}
		switch (loc) {
			case IconLocation.LEFT:
			case IconLocation.RIGHT:
				tr.width += ww + iconPadding + padHorz;
				tr.height = Math.max(tr.height, hh) + padVert;
				break;
			case IconLocation.TOP:
			case IconLocation.BOTTOM:
				tr.width = Math.max(tr.width, ww) + padHorz;
				tr.height += hh + iconPadding + padVert;
				break;
			default:
				tr.width = ww + iconPadding + padHorz;
				tr.height = hh + iconPadding + padVert;
				break;
		}
		return _tempSize(tr.width, tr.height);
	},
	_doMeasureHeight: function(grid, cell, columnWidth, maxHeight) {
		return this._doMeasure(grid, cell, columnWidth, maxHeight);
	},
	render: function(cell, g, r) {
		var i, cnt, x, y, w, h, ww = 0, hh = 0;
		var grid = cell.grid();
		var handler = grid && grid.getHandler();
		var index = cell.index();
		var callback = this.renderCallback();
		var images = [];
		var r = this._rect.copy(r);
		var loc = cell.iconLocation();
		var text = this._textVisible && this._getText(cell);
		var padHorz = cell.paddingHorz();
		var padVert = cell.paddingVert();
		var iconOff = cell.iconOffset(); // cell의 left에서 icon이 떨어지는 간격.
		var iconPadding = cell.iconPadding() + iconOff;  // text의 끝에서 icon
		var iconGap = isNaN(this._iconGap) ? 0 : this._iconGap;
		var tx = r.x + cell.paddingLeft();
		var ty = r.y + cell.paddingTop();
		var tw = r.width - padHorz;
		var th = r.height - padVert;
		var iconAlignment = cell.iconAlignment();
		var value = cell.value();
		var imageUrls = !this._icons && (!callback || typeof callback !== "function") ? [] : (this._icons || callback(handler, index.proxy(), value));
		!imageUrls && (imageUrls = []);
		for (i = 0, cnt = imageUrls.length; i < cnt ; i++) {
			var img = grid.getImage(imageUrls[i]);
			w = img ? Math.max(img.width, this._minWidth) : this._minWidth;
			img && (hh = Math.max(hh, img.height));
			ww += w + ( i + 1 === cnt ? 0 : this._iconGap); // 전체 넓이를 일단 계산.
			images.push(img);
		}
		switch (loc) {
			case IconLocation.LEFT:
				x = r.x+cell.paddingLeft()+iconOff;
				tx += ww+iconPadding;
				tw -= ww+iconPadding; 
				break;
			case IconLocation.RIGHT:
				x = r.right() - ww - cell.paddingRight() - iconOff;
				tw -= ww+iconPadding;
				break;
			case IconLocation.TOP:
				y = r.y+cell.paddingTop() + iconOff;
				ty += hh+iconPadding;
				th -= hh+iconPadding;
				break;
			case IconLocation.BOTTOM:
				y = r.height - hh - cell.paddingBottom() - iconOff;
				th -= hh+iconPadding;
				break;
			case IconLocation.CENTER:
				x = r.x+cell.paddingLeft()+_int((r.width - padHorz - ww ) / 2);
				y = r.y+cell.paddingTop()+(r.height - hh - padVert) / 2;
				break;
		}
		switch(iconAlignment) {
			case Alignment.FAR :
				y = loc == IconLocation.LEFT || loc == IconLocation.RIGHT ? r.height - hh - cell.paddingBottom() - iconOff : y;
				x = loc == IconLocation.TOP || loc == IconLocation.BOTTOM ? r.right() - ww - cell.paddingRight() - iconOff : x;
				break;
			case Alignment.NEAR :
				y = loc == IconLocation.LEFT || loc == IconLocation.RIGHT ? r.y+cell.paddingTop() : y;
				x = loc == IconLocation.TOP || loc == IconLocation.BOTTOM ? r.x+cell.paddingLeft()+iconOff : x;
				break;
			default :
				y = loc == IconLocation.LEFT || loc == IconLocation.RIGHT ? r.y+cell.paddingTop()+(r.height - hh - padVert) / 2 : y;
				x = loc == IconLocation.TOP || loc == IconLocation.BOTTOM ? r.x+cell.paddingLeft()+_int((r.width - padHorz - ww ) / 2) : x;
				break;
		}
		for (i = 0, cnt = images.length; i < cnt; i++) {
			var img = images[i];
			w = this._minWidth;
			if (img) {
				w = Math.max(img.width, this._minWidth)  + ( i + 1 === cnt ? 0 : this._iconGap);
				h = img.height;
				g.drawImage(img, x, _round(y + (hh - img.height) / 2), img.width, img.height);
			}
			x += w;
		}
		if (text && (loc != IconLocation.CENTER || imageUrls.length <= 0)) {
			var rect = new Rectangle(tx, ty, tw, th);
			g.save();
			g.clipRect(rect);
			TextCellRenderer.renderWrapText(cell, g, tx, ty, tw, th, text);
			g.restore();
		}

	}
});
var ImageCellRenderer = defineClass("ImageCellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
	},
	render: function(cell, g, r) {
		var url = cell.value();
		if (url) {
			var img = cell.grid().getImage(url);
			if (img) {
				r = this._rect.copy(r);
				cell.inflatePadding(r);
				var x = r.x;
				var y = r.y;
				var w = img.width;
				var h = img.height;
				var ratio;
				var rw;
				var rh;
				switch (cell.contentFit()) {
					case ContentFit.CENTER:
						x += (r.width - w) / 2;
						y += (r.height - h) / 2;
						break;
					case ContentFit.BOTH:
						rw = r.width / w;
						rh = r.height / h;
						w = r.width;
						h = r.height;
						break;
					case ContentFit.WIDTH:
						ratio = r.width / w;
						w = r.width;
						y += (r.height - h) / 2;
						break;
					case ContentFit.HEIGHT:
						ratio = r.height / h;
						h = r.height;
						x += (r.width - w) / 2;
						break;
					case ContentFit.AUTO:
						rw = r.width / w;
						rh = r.height / h;
						ratio = Math.min(rw, rh);
						w = w * ratio;
						h = h * ratio;
						if (rw > rh) {
							x += (r.width - w) / 2;
						} else {
							y += (r.height - h) / 2;
						}
						break;			
				}
				g.drawImageI(img, x, y, w, h);
			}
		}
	},
	_doMeasure: function (grid, cell, hintWidth, maxHeight) {
		var url = cell.value();
		var grid = cell.grid();
		var img = url && grid.getImage(url);
		var w = this._minWidth, h = 0;
		if (img) {
			w = Math.max(img.width, w);
			h = Math.max(img.height, h);
			if (maxHeight && h > maxHeight) {
				var ratio = maxHeight / h;
				h = maxHeight;
				w = parseInt(w * ratio);
			}
		}
		return new Size(w, h);
	},
	_doMeasureHeight: function(grid, cell, columnWidth, maxHeight) {
		return this._doMeasure(grid, cell, columnWidth, maxHeight);
	}
});
var RatingCellRenderer = defineClass("RatingCellRenderer", DataCellRenderer, {
	init : function() {
		this._super();
	},
	base: 0,
	delta: 1,
	rangeType: "match",	// match, closed, open, expression
	ranges: null,
	render : function(cell, g, r) {
	}
});
var Code39CellRenderer = defineClass("Code39CellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this._barcode = new Code39();
		this.setMinWidth(100);
	},
	render: function(cell, g, r) {
		var s = cell.value();
		if (!s) {
			return;
		}
		var fill = cell.figureBackground();
		if (fill) {
			this._rect.copy(r);
			var tr = cell.inflatePadding(this._rect);
			this._barcode.setValue(s.toUpperCase());
			this._barcode.setBarFill(fill);
			this._barcode.render(g, tr);
		}
	}
});
var Code128CellRenderer = defineClass("Code128CellRenderer", DataCellRenderer, {
	init: function() {
		this._super();
		this._barcode = new Code128();
		this.setMinWidth(100);
	},
	render: function(cell, g, r) {
		var s = cell.value();
		if (!s) {
			return;
		}
		var fill = cell.figureBackground();
		if (fill) {
			this._rect.copy(r);
			var tr = cell.inflatePadding(this._rect);
			this._barcode.setValue(s);
			this._barcode.setBarFill(fill);
			this._barcode.render(g, tr);
		}
	}
});
var /* abstract */ClickableCellRenderer = defineClass("ClickableCellRenderer", DataCellRenderer, {
	init : function() {
		this._super();
		this._hoveredUnderline = true;
	},
	spaceKey: true,
	hoveredUnderline: true,
	isClickable: function (index) {
		return true;
	},
    isHoveredUnderline: function(index) {
    	return this._hoveredUnderline;
    },
	performClick: function (cell, x, y) {
		return this._doClick(cell.index());
	},
	render : function(cell, g, r) {
	},
	_getClickSource: function () {
		return null;
	},
	_getClickData: function () {
		return null;
	},
	_doClick: function (index, x, y) {
		var data = this._getClickData(index);
		if (data) {
			this._fireClicked(index, this._getClickSource(), data);
			return true;
		}
		return false;
	},
	_fireClicked: function (index, source, data) {
		var grid = index.grid();
		grid && grid.fireEvent(GridBase.CLICKABLE_CELL_CLICKED, index, source, data);
	}
});
ClickableCellRenderer.LINKABLE_CELL = "linkableCell";
ClickableCellRenderer.IMAGE_BUTTON_CELL = "imageButtonCell";
var LinkCellRenderer = defineClass("LinkCellRenderer", ClickableCellRenderer, {
	init : function() {
		this._super();
		this._urlStatement = new ExpressionStatement(null, true);
		this._urlRuntime = new LinkCellRendererRuntime();
	},
	urlField: null,
	url: null,
	showUrl: true,
	openUrl: false,
	requiredFields: null,
	cursor: null,
	isClickable: function (index) {
		return index && this._getClickData(index) ? true : false;
	},
	isHoveredUnderline: function(index) {
		return this._hoveredUnderline && this.isClickable(index);
	},
	setUrl: function (value) {
		if (value != this._url) {
			this._url = value;
			this._urlStatement.setSource(value);
			this._changed();
		}
	},
	setRequiredFields: function (value) {
		if (value != this._requiredFields) {
			this._requiredFields = value;
			if (value) {
				var flds = value.split(",");
				for (var i = flds.length; i--;) {
					flds[i] = flds[i].trim().toUpperCase();
				}
				this._urlRuntime.setRequiredFields(flds);
			} else {
				this._urlRuntime.setRequiredFields(null);
			}
		}
	},
	/*
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		var s = this._getText(cell);
		return new Size(Math.max(this._minWidth, hintWidth), hintHeight);
	},
	*/
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		if (cell._textWrap && (cell._textWrap == TextWrapMode.NORMAL || cell._textWrap == TextWrapMode.EXPLICIT)) {
			var r = new Rectangle(0, 0, 0, 0);
			grid.measureTextRect(cell.font(),this._getText(cell), 0, 0, hintWidth, hintHeight, cell._textAlign, cell._lineAlign, cell._textWrap,r)
			return _tempSize(r.width+cell.paddingHorz(), hintHeight);
		} else {
			return _tempSize(grid.measureText(cell.font(), this._getText(cell)) + cell.paddingHorz(), hintHeight);
		}
	},
	_doMeasureHeight: function (grid, cell, columnWidth, maxHeight) {
		var r = _tempSize(columnWidth, grid.measureTextRect(cell.font(),this._getText(cell), 0, 0, columnWidth, maxHeight, cell._textAlign, cell._lineAlign, cell._textWrap )+cell.paddingVert());
		r.height = Math.min(r.height, maxHeight);
		return r;
    },

	render: function (cell, g, r) {
		var s = cell.iconLocation() != IconLocation.CENTER ? this._getText(cell) : null;
		IconCellRenderer.renderBitmapText(cell, s, g, r);
	},
	_getClickSource: function () {
		return ClickableCellRenderer.LINKABLE_CELL;
	},
	_getClickData: function (index) {
		return this._getUrl(index);
	},
	isShowTooltip: function() {
		return this._showTooltip || this._showUrl;
	},
	getTooltip: function (cell, index) {
		if (this._showUrl) { 
			// var index;
			if (index && cell.grid().getItem(index._itemIndex) instanceof GridRow) {

			} else if (cell instanceof MergedDataCellElement) {
				index = cell.index().clone();
				var item = cell.item();
				item = item instanceof GridRow ? item : item instanceof MergedGroupFooter ? item.parent().firstItem() : item.firstItem();
				if (item) {
					index.setItemIndex(item.index());	
				} else {
					return null;
				}
			} else {
				index = cell.index();
			}
			return this._getUrl(index);
		} else {
			return null
		};
	},
	_getUrl: function (index) {
		if (this._url) {
			this._urlRuntime.setIndex(index);
			return this._urlStatement.evaluate(this._urlRuntime);
		} else if (this._urlField) {
			var item = index.item();
			if (item) {
				var ds = item.dataSource();
				if (ds) {
					var fld = ds.getFieldIndex(this._urlField);
					if (fld >= 0) {
						return item.getData(fld);
					}
				}
			}
		}
		return null;
	},
	getCursor: function(index) {
		return this._getUrl(index) ? this._cursor : null;
	}
});
var ImageButtonCellRenderer = defineClass("ImageButtonCellRenderer", ClickableCellRenderer, {
	init : function() {
		this._super();
	},
	imageUrl: null,
	disabledUrl: null,
	hoverUrl: null,
	activeUrl: null,
	text: "Click",
	hoverText: undefined,
	disabledText: undefined,
	enabledExpression: null,
	cursor: null,
	tooltip: null,
    downOffset: IntProp_0,
    ptInButton: function (cell, x, y) {
		var grid = cell._grid || cell.grid();
		var url = this._hoverUrl ? this._hoverUrl : this._imageUrl;
		var img = grid.getImage(url);
		// this._rect는 최종적으로 그려진 셀의 정보를 가지고 있다. 현재 Cell의 rect와는 다를수 있다.
		var rect = cell.inflatePadding(cell._getRenderRect());
		if (img && this._rect) {
			var r = rect;
			var imgX = r.x + (r.width - img.width) / 2;
			var imgY = r.y + (r.height - img.height) / 2;
			var imgRight = imgX + img.width;
			var imgBottom = imgY + img.height;
			return (x >= imgX && y >= imgY && x <= imgRight && y <= imgBottom);
		}
    },
    ptInButtonIndex: function (cell, x, y) {
    	return this.ptInButton(cell, x, y) ? 0 : -1;
    },
    isButton: function () {
        return true;
    },
    prepare: function(grid) {
		if (!this._inited) {
			grid.getImage(this._imageUrl);
			grid.getImage(this._disabledUrl);
			grid.getImage(this._hoverUrl);
			grid.getImage(this._activeUrl);
			this._inited = true;
		}
    },    
	/*
	 _doMeasure: function (grid, cell, hintWidth, hintHeight) {
	 var s = this._getText(cell);
	 return new Size(Math.max(this._minWidth, hintWidth), hintHeight);
	 },
	 */
	render: function (cell, g, r) {
        var grid = cell.grid();
        var s = this._text || this._getText(cell);
        r = this._rect.copy(r);
        cell.inflatePadding(r);
        var url = this._imageUrl;
        if (cell.isPressed()) {
            url = this._activeUrl;
        } else if (cell.isHovered()) {
            url = this._hoverUrl;
        }
        var img = grid.getImage(url) || grid.getImage(this._imageUrl);
        var x, y, w, h;
        if (img && (w = img.width) > 0 && (h = img.height) > 0) {
            x = _int(r.x + (r.width - w) / 2);
            y = _int(r.y + (r.height - h) / 2);
            g.drawImage(img, x, y, w, h);
        }
        TextCellRenderer.renderWrapText(cell, g, r.x, r.y, r.width, r.height, s);
	},
    getCursor: function(index) {
    	return !isNaN(index) ? this._cursor : null;
    },
	getTooltip: function(cell, index, buttonIndex) {
		if (buttonIndex == null || buttonIndex < 0 || !this._tooltip) {
			return this._super(cell, index);
		} else {
			return this._tooltip;
		}
	}
});
var ImageButtonsCellRenderer = defineClass("ImageButtonsCellRenderer", ClickableCellRenderer, {
	init: function () {
		this._super();
		this._inited = false;
		this._images = [];
		this._count = 0;
		this._imagePoints = [];
		this._imageGap = 2; // 이미지간의 간격
		this._margin =  2;  // Cell Border에서 간격
		this._showText = null;
		this._imageHeight = null;  // 버튼의 높이.
		this._buttonWidth = 0; // 버튼 전체 넓이.
		this._hoveredUnderline = false;
	},
	imageWidth: 16,
	imageHeight : null,
	imageUrls: [],
	margin: null,
	imageGap: null,
	images: [],
	alignment: Alignment.FAR,
	lineAlignment: Alignment.CENTER,
	width: 0,             // image 전체넓이 
	height : 14,
	showText: true,
	assign: function (source) {
		this._super(source);
		if (this._images != null) {
			this.setImageUrls(this._images);
		} else {
			this._imageUrls = [];
			this._imagePoints = [];
			this._count = 0;
		}
	},
	setImages: function(value) {
		if (this._images != value) {
			this._images = value;
		}
	},
	canEditable: function() {
		return this._alignment === Alignment.FAR || this._alignment === Alignment.NEAR;
	},
	isClickable: function (index) {
		return false;
	},
	setHeight: function(value) {
		if (this._imageHeight != value) {
			this._imageHeight = value;
		}
	},	
	isButton: function(){
		return true;
	},
	setImageUrls: function (value) {
		if (!value) {
			this._count = 0;
			this._imageUrls = null;
			this._images = null;
		} else {
			value = value && _isArray(value) ? value : [value];
			this._count = value.length;
			this._imageUrls = [];
			this._images = [];
			this._imagePoints = [0];
			var point = 0, w;
			for (var i = 0; i < this._count; i++) {
				var obj = value[i];
				var clone = {};
				for (var attr in obj) {
    				if (obj.hasOwnProperty(attr)) {
    					for (var state in ButtonState) {
    						if (ButtonState[state] == attr) {
		    					clone[attr] = obj[attr];
    							break;
    						}
    					}
    				}
    			}
    			this._imageUrls.push(clone);
    			w = (obj.hasOwnProperty("width") && !isNaN(obj["width"]) ? parseInt(obj["width"]) : this._imageWidth)+ ( i < this._count - 1 ?this._imageGap : 0);
    			point += w;
    			var image = {"name":obj["name"], "width":w, cursor:obj["cursor"], tooltip:obj["tooltip"]};
    			this._imagePoints.push(point);
    			this._images.push(image);
			}
			this._buttonWidth = Math.max(point + this._margin, isNaN(this._width) ? 0 : this._width);
		}
		this._inited = false;
	},
	setAlignment:function(value) {
		if (this._alignment != value) {
			this._alignment = value;
		};
	},
	prepare: function (grid) {
		if (!this._inited) {
			for (var i = 0; i < this._count; i ++) {
				for (var attr in this._imageUrls[i]) {
					grid.getImage(this._imageUrls[i][attr]);
				}
			}
			this._inited = true;
		}
	},
	ptInButton: function(cell, x, y) {
		return -1 != this.ptInButtonIndex(cell, x, y);
	},
	ptInButtonIndex: function(cell, x, y) {
		if (!cell._getButtonVisible(cell.index().column().buttonVisibility())) {
			return -1;
		}
		var x1 =  this.$_getButtonX(cell.width(), this._buttonWidth);
		x -= x1;
		if (x < 0) {
			return -1;
		}
		if (cell instanceof MergedDataCellElement) {
			var grid = cell.grid();
			var lm = grid && grid.layoutManager();
			var r = lm && lm.getItemRect(cell._mergeRoom.headItem() + cell._innerIndex - grid.topIndex());
			r.y -= cell.topBy(grid,0);
			y -= r.y;
			return this.$_buttonIndex(0, r.height, x, y);
		} else {
			return this.$_buttonIndex(0,cell.height(),x,y);
		}
	},
	$_buttonIndex: function (w, h, x, y) {
		// lineAlignment : far 아래쪽에 그린다. y > h - this._imageHeight && y < h
		// near : 위에 그린다. y > 0 && y < this._imageHe dsghjklhrtyuight
		// center : 중앙에 그린다. c = (h - this._imageHeight) / 2
		var idx;
		if (this._imageHeight) {
			switch (this._lineAlignment) {
				case Alignment.FAR :
					idx = y > h - this._imageHeight && y < h;
					break;
				case Alignment.NEAR :
					idx = y > 0 && y < this._imageHeight;
					break;
				default :
					var c = (h - this._imageHeight) / 2;
					idx = (y > c && y < c + this._imageHeight );
					break;
			}
			if (!idx) return -1;
		}
		for (var i = 1, cnt = this._imagePoints.length; i < cnt ; i++) {
			if (this._imagePoints[i] >= x) {
				idx = this._imagePoints[i] - ( i < cnt - 1 ? this._imageGap : 0 ) >= x ? i-1 : -1;
				return idx;
			}
		}
		return -1;
	},
	$_getButtonX: function(width, buttonsWidth) {
		switch(this._alignment) {
			case Alignment.NEAR:
				return 0;
			case Alignment.CENTER:
				return Math.round((width-buttonsWidth)/2)
			default:
				return width - buttonsWidth;
		}
	},
	_doMeasure: function (grid, cell, hintWidth, hintHeight) {
		var w;
		if (!cell._getButtonVisible(cell.index().column().buttonVisibility())) {
			w = 0;
		} else {
			w = this._buttonWidth > 0 ? this._buttonWidth : this._imagePoints.length <= 0 ? 0 : (this._imagePoints[this._imagePoints.length-1]+this._margin);
		}
		return new Size(w, hintHeight);
	},
	render: function (cell, g, r) {
		var showText = (this._alignment === Alignment.FAR && (this._showText || this._showText == null)) || (this._alignment === Alignment.NEAR && this._showText);
		var s = showText ?this._getText(cell) : "";
		var fName = cell.figureName();
		fName && TextCellRenderer.drawEdgeMark(fName, cell, g, r);
		r = this._rect.copy(r);
		cell.inflatePadding(r);
		TextCellRenderer.renderWrapText(cell, g, r.x, r.y, r.width, r.height, s);
	},
	doDrawButton:function(cell,g,r) {
		if ( (this._imagePoints.length <= 0) || !cell._getButtonVisible(cell.index().column().buttonVisibility())) {
			return;
		}		
		var index = cell.index();
		var x1;
		var br = r.clone();
		r = this._rect.copy(r);
		cell.inflatePadding(r);
		// 왼쪽// 오른쪽// 중앙.
		x1 = this.$_getButtonX(br.width, this._buttonWidth);
		br.setLeft(x1);
		this._doRender(index, g, br, cell.isHovered(), cell.isPressed(), cell.isFocused(), cell._buttonIndex);
	},
	_doRender: function (index, g, r, hovered, pressed, focused, buttonIndex) {
		var column = index.dataColumn();
		if (column) {
			var br = r.clone();
			if (focused && index.grid().isEditing()) {
				br.leftBy(2);
				br.rightBy(-2);
			} else {
				br.leftBy(1);
				br.rightBy(-3);
			}
			for (var i = 0; i < this._count; i++) {
				if (buttonIndex === i) {
					this.$_drawButton(index.grid(), g, br, i, hovered, pressed);
				} else {
					this.$_drawButton(index.grid(), g, br, i, false, false);
				}
			}
		}
	},
	$_getImage: function (grid, index, state, url) {
		var img = this._images[index][state];
		if (!img) {
			img = grid.getImage(url);
			if (img) {
				this._images[index][state] = img;
			}
		}
		return img;
	},
	$_drawButton: function (grid, g, r, index, hovered, pressed) {
		var w, h;
		var state = pressed ? ButtonState.DOWN : hovered ? ButtonState.HOVER : ButtonState.UP;
		// Hover, Down Image가 없을땐 Normal이미지로 대체
		if (!this._imageUrls[index][state]) {
			if (this._imageUrls[index][ButtonState.UP]) {
				state = ButtonState.UP;
			}
		};
		var img = this.$_getImage(grid, index, state, this._imageUrls[index][state]);
		var lineAlign = this.lineAlignment();
		var y;
		var height;
		if (img && (w = img.width) > 0 && (h = img.height) > 0) {
			height = parseInt(this.imageHeight()) || h;
			switch(lineAlign) {
				case Alignment.FAR :
					y = _int(r.y + r.height - height + ( (height - h) / 2 ) - 2);
					break;
				case Alignment.NEAR :
					y = _int(r.y + 2 + ( (height - h) / 2 ));
					break;
				default : // center;
					y = _int(r.y + (r.height - h) / 2);
					break;
			}
			var x = _int(r.x + 1 + this._imagePoints[index]);
			g.drawImage(img, x, y, w, h);
		};
	},
	getCursor: function(index) {
		return this._images && this._images[index] && this._images[index].cursor;
	},
	getTooltip: function(cell, index, buttonIndex) {
		if (buttonIndex == null || buttonIndex < 0) {
			return this._super(cell, index);
		} else {
			return (this._images && this._images[buttonIndex] && this._images[buttonIndex].tooltip) || this._super(cell, index);
		}
	}
}, {

});
var SeriesTextCellRenderer = defineClass("SeriesTextCellRenderer", TextCellRenderer, {
	init: function () {
		this._super();
	},
	valueSeparator:null,
	_getText: function (cell) {
		var vals = cell.value();
		return SeriesCell.getText(vals, this._valueSeparator);
	}
});
SeriesTextCellRenderer.Default = new SeriesTextCellRenderer();
var /* abstract */ SeriesCellRenderer = defineClass("SeriesCellRenderer", DataCellRenderer, {
	init: function () {
		this._super();
		this.setMinWidth(100);
	},
	_getValues: function (cell) {
		return cell.value() || [];
	}
}); 
var /* abstract */ SparkChartRenderer = defineClass("SparkChartRenderer", SeriesCellRenderer, {
	init: function() {
		this._super();
	},
	baseValue: NaN,
	firstFill: null,
	lastFill: null,
	highFill: null,
	lowFill: null,
	belowFill: null,
	pointFill: null,
	setFirstFill: function (value) {
		if (value != this._firstFill) {
			this._firstFill = VisualStyles.getFill(value);
			this._changed();
		}
	},
	setLastFill: function (value) {
		if (value != this._lastFill) {
			this._lastFill = VisualStyles.getFill(value);
			this._changed();
		}
	},
	setPointFill: function (value) {
		if (value != this._PointFill) {
			this._pointFill = VisualStyles.getFill(value);
			this._changed();
		}
	},
	setHighFill: function (value) {
		if (value != this._highFill) {
			this._highFill = VisualStyles.getFill(value);
			this._changed();
		}
	},
	setLowFill: function (value) {
		if (value != this._lowFill) {
			this._lowFill = VisualStyles.getFill(value);
			this._changed();
		}
	},
	setBelowFill: function (value) {
		if (value != this._belowFill) {
			this._belowFill = VisualStyles.getFill(value);
			this._changed();
		}
	},
	render: function (cell, g, r) {
		var values = this._getValues(cell);
		if (values && values.length) {
			var i, v, base,
				cnt = values.length,
				min = values[0],
				max = values[0];
			i = 1;
			while (isNaN(min) && i < cnt) {
				max = min = values[i++];
			}
			for (; i < cnt; i++) {
				v = Number(values[i]);
				if (!isNaN(v)) {
					if (v < min) min = v;
					if (v > max) max = v;
				}
			}
			base = isNaN(this._baseValue) ? min : this._baseValue;
			if (!isNaN(min)) {
				this._renderChart(cell, g, r, values, min, max, base);
			}
		}
	},
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
	},
	_getPoints: function (cell, r, values, minimum, maximum) {
		var i, x, y, v,
			cnt = values.length,
			pts = [],
			sx = r.x + cell.paddingLeft(),
			w = r.width - cell.paddingHorz(),
			sy = r.y + cell.paddingTop(),
			h = r.height - cell.paddingVert(),
			len = maximum - minimum;
		for (i = 0; i < cnt; i++) {
			v = Number(values[i]);
			x = sx + i / (cnt - 1) * w;
			y = sy + ( (isNaN(v) || len == 0) ? h : (1 - (v - minimum) / len) * h);
			pts.push(x, y);
		}
		return pts;
	},
	_getBasePoint: function (cell, r, minimum, maximum, base) {
		var h = r.height - cell.paddingVert();
		var sy = r.y + cell.paddingTop();
		var len = maximum - minimum;
		var y = sy + ((isNaN(base) || len == 0) ? h : (1 - (base - minimum) / len) * h);
		return y;
	}
}); 
var SparkLineRenderer = defineClass("SparkLineRenderer", SparkChartRenderer, {
	init : function() {
		this._super();
	},
	curved: false,
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
		var stroke = cell.line();
		if (!stroke) {
			return;
		}
		var max = isNaN(base) ? maximum : Math.max(maximum, base);
		var min = isNaN(base) ? minimum : Math.min(minimum, base);
		var pts = this._getPoints(cell, r, values, min, max);
		var i, x, y, fill;
		var cnt = values.length;
		for (i = 0; i < cnt - 1; i++) {
			g.drawLine(stroke, pts[i * 2], pts[i * 2 + 1], pts[(i + 1) * 2], pts[(i + 1) * 2 + 1]);
			if (fill = this.pointFill()) {
				x = pts[i * 2];
				y = pts[i * 2 + 1];
				g.drawCircle(fill, null, x, y, 2);	
			}
		}
		if (fill = this.firstFill()) {
			x = pts[0];
			y = pts[1];
			g.drawCircle(fill, null, x, y, 2);
		}
		if (fill = this.lastFill()) {
			x = pts[(cnt - 1) * 2];
			y = pts[(cnt - 1) * 2 + 1];
			g.drawCircle(fill, null, x, y, 2);
		}
		if (fill = this.highFill()) {
			for (i = 0; i < cnt; i++) {
				if (values[i] >= maximum) {
					x = pts[i * 2];
					y = pts[i * 2 + 1];
					g.drawCircle(fill, null, x, y, 2);
				}
			}
		}
		if (fill = this.lowFill()) {
			for (i = 0; i < cnt; i++) {
				if (values[i] <= minimum) {
					x = pts[i * 2];
					y = pts[i * 2 + 1];
					g.drawCircle(fill, null, x, y, 2);
				}
			}
		}
	}
}); 
var SparkColumnRenderer = defineClass("SparkColumnRenderer", SparkChartRenderer, {
	init: function() {
		this._super();
	},
	barWidth: 0.8,
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
		var fill = cell.figureBackground();
		if (!fill) {
			return;
		}

		var max = maximum;
		var min = minimum;
		if (!isNaN(base)) {
			min = base;
			max = Math.max(base, max);
		}
		var i, v, f, y;
		var cnt = values.length;
		var p = _int(this._getBasePoint(cell, r, min, max, base));
		var w = (r.width - cell.paddingHorz()) / cnt;
		var h = r.height - cell.paddingVert();
		var x = r.x + cell.paddingLeft() + w / 2;
		var len = max - min;
		var cw = _int(w * this._barWidth);
		for (i = 0; i < cnt; i++) {
			v = values[i];
			if (!isNaN(v)) {
				if (v <= minimum && this._lowFill) {
					f = this._lowFill;
				} else if (v >= maximum && this._highFill) {
					f = this._highFill;
				} else if (v < base && this._belowFill) {
					f = this._belowFill;
				} else if (i == 0 && this._firstFill) {
					f = this._firstFill;
				} else if (i == (cnt-1) && this._lastFill) {
					f = this._lastFill;
				} else {
					f = fill;
				}
				y = len == 0 ? 1 : Math.max(1, _int((v - min) * h / len));
				g.drawBoundsI(f, null, _int(x - cw / 2), p, cw, -y); 
			}
			x += w;
		}
	}
}); 
var SparkWinLossRenderer = defineClass("SparkWinLossRenderer", SparkChartRenderer, {
	init: function() {
		this._super();
		this.setBaseValue(0);
	},
	barWidth: 0.8,
	belowHeight: 0.4,
	_renderChart: function(cell, g, r, values, minimum, maximum, base) {
		var fill = cell.figureBackground();
		if (!fill) {
			return;
		}
		var i, v, f, y;
		var cnt = values.length;
		var w = (r.width - cell.paddingHorz()) / cnt;
		var h = r.height - cell.paddingVert();
		var x = r.x + cell.paddingLeft() + w / 2;
		var sy = r.y + cell.paddingTop();
		var cw = w * this._barWidth;
		var p = sy + h * (1 - this._belowHeight);
		for (i = 0; i < cnt; i++) {
			v = values[i];
			if (!isNaN(v) && v != base) {
				f = fill;
				if (v < base && this._belowFill) {
					f = this._belowFill;
				}
				y = (v < base) ? (sy + h) : sy;
				g.drawBoundsI(f, null, _int(x - cw / 2), _int(y), _int(cw), _int(p - y));
			}
			x += w;
		}
	}
}); 
var /* abstract */ TargetActualRenderer = defineClass("TargetActualRenderer", SeriesCellRenderer, {
	init: function() {
		this._super();
		this.setMinWidth(100);
	},
	minValue: 0,
	maxValue: 100,
	render: function (cell, g, r) {
		var values = this._getValues(cell);
		if (values.length >= 2) {
			this._doRender(cell, g, r, values[0], values[1]);
		}
	},
	_getValueRate: function (value) {
		return (value - this._minValue) / (this._maxValue - this._minValue);
	},
	_doRender: function (cell, g, r, targetValue, actualValue) {
	}
}); 
var ActualTargetBulletRenderer = defineClass("ActualTargetBulletRenderer", TargetActualRenderer, {
	init: function() {
		this._super();
		this.setMinWidth(100);
	},
	maximumBackground: null,
	figureBackground: null,
	figureBorder:null,
	line:null,
	setMaximumBackground: function (value) {
		if (value != this._maximumBackground) {
			this._maximumBackground = VisualStyles.getFill(value);
			this._changed();
		}
	},
	_readOption:function(prop, value) {
		switch (prop) {
			case "figureBackground":
				if (value) return VisualStyles.getFill(value);
				break;
			case "figureBorder":
			case "line":
				if (value) return VisualStyles.getStroke(value)
				break;
		}
		return value;
	},
	_doRender: function(cell, g, r, targetValue, actualValue) {
		var x = cell.paddingLeft();
		var y = cell.paddingTop();
		var w = r.width - x - cell.paddingRight();
		var h = r.height - y - cell.paddingBottom();
		var fill = this._maximumBackground;
		if (fill) {
			g.drawBounds(fill, null, x, y, w, h);
		}
		this._figureBackground = cell.figureBackground();
		this._line = cell.line();
		this._figureBorder = cell.figureBorder();
		fill = this._getOption("figureBackground");
		if (fill) {
			var h2 = h;
			var sz;
			if (sz = cell.figureSize()) {
				h2 = sz.getDimension(h);
			}
			var w2 = w * this._getValueRate(actualValue); 
			var stroke = this._getOption("figureBorder");
			g.drawBoundsI(fill, stroke, x, y + (h - h2) / 2, w2, h2);
		}
		var x2 = x + w * this._getValueRate(targetValue);
		stroke = this._getOption("line");
		if (!stroke) {
			stroke = SolidPen.DKGRAY;
		}
		g.drawLine(stroke, x2, y, x2, y + h);
	}
}); 
var ActualTargetTextRenderer = defineClass("ActualTargetTextRenderer", SeriesCellRenderer, {
	init: function() {
		this._super();
		this._actualForeground = SolidBrush.BLACK;
		this._targetForeground = SolidBrush.BLACK;
	},
	separator: " / ",
	actualForeground: null,
	actualFont: null,
	targetForeground: null,
	targetFont: null,
	setActualForeground: function(value) {
		if (value != this._actualForeground) {
			this._actualForeground = VisualStyles.getFill(value) || SolidBrush.BLACK;
			this._changed();
		}
	},
	setActualFont: function (value) {
		if (value != this._actualFont) {
			this._actualFont = VisualStyles.getFont(value);
		}
	},
	setTargetForeground: function(value) {
		if (value != this._targetForeground) {
			this._targetForeground = VisualStyles.getFill(value) || SolidBrush.BLACK;
			this._changed();
		}
	},
	setTargetFont: function (value) {
		if (value != this._targetFont) {
			this._targetFont = VisualStyles.getFont(value);
		}
	},
	_readOption: function (prop, value) {
		switch (prop) {
			case "actualForeground":
			case "targetForeground":
				if (value) return VisualStyles.getFill(value);
				break;
			case "actualFont":
			case "targetFont":
				if (value) return VisualStyles.getFont(value);
				break;
		}
		return value;
	},
	render: function(cell, g, r) {
		var actualFont = this._getOption("actualFont");
		var targetFont = this._getOption("targetFont");
		var values = this._getValues(cell);
		var target = cell._numberFormatter ? cell._numberFormatter.format(values[0]) : String(values[0] != null ? values[0] : "");
		var actual = cell._numberFormatter ? cell._numberFormatter.format(values[1]) : String(values[1] != null ? values[1] : "");
		var wSep = g.getTextWidth(cell.font(), this._separator);
		var wActual = g.getTextWidth(this._actualFont, actual);
		var wTarget = g.getTextWidth(this._targetFont, target);
		var w = wSep + wActual + wTarget;
		var x = r.x + cell.paddingLeft();
		var y = r.y;
		switch (cell.textAlignment()) {
		case Alignment.CENTER:
			x = r.x + (r.width - cell.paddingHorz() - w) / 2;
			break;
		case Alignment.FAR:
			x = r.right() - cell.paddingRight() - w;
			break;
		}
		if (actual != "" || target != "") {
			g.drawTextBounds(actualFont, this._getOption("actualForeground"), actual, x, y, wActual, r.height);
			x += wActual;
			g.drawTextBounds(cell.font(), cell.foreground(), this._separator, x, y, wSep, r.height);
			x += wSep;
			g.drawTextBounds(targetFont, this._getOption("targetForeground"), target, x, y, wTarget, r.height);
		}
	}
}); 
function $_exportGrid(exportOptions) {
    exportOptions.type = (exportOptions.type || "excel").toLowerCase();
    if (exportOptions.type === "excel") {
       new GridExcelExporter2()["export"](exportOptions); 
    } else if (exportOptions.type === "pdf") {
        new GridPDFExporter()["export"](exportOptions);
    }
};

var /* internal */ ColumnArrayItem = function (column) {
    this.column = column;
    this.dataColumn = _cast(column, DataColumn);
    this.colIndex = 0;
    this.colSpan = 0;
    this.rowIndex = 0;
    this.rowSpan = 0;
    this.width = 0;
    this.valueType = 's';
    this.tag = undefined;
    this.data = undefined;
};
var /* internal */ ColumnArray = defineClass("ColumnArray", null, {
    init: function (grid, linearize, allColumns, showColumns, hideColumns) {
        this._super();
        this._grid = grid;
        this._headerRows = [];
        this._dataRows = [];
        this._dataColumns = [];
        this._sparkColumns = [];
        this.$_parse(grid, linearize, allColumns, showColumns, hideColumns);
    },
    destroy: function() {
        this._destroying = true;
        this._grid = null;
        this._headerRows = null;
        this._dataRows = null;
        this._sparkColumns = null;
        this._super();
    },
    grid: function () {
        return this._grid;
    },
    colCount: function () {
        return this._headerRows.length && this._headerRows[0].length;
    },
    headerRowCount: function () {
        return this._headerRows.length;
    },
    dataRowCount: function () {
        return this._dataRows.length;
    },
    getHeader: function (row, col)/*ColumnArrayItem*/ {
        return this._headerRows[row][col];
    },
    getItem: function (row, col)/*ColumnArrayItem*/ {
        return this._dataRows[row][col];
    },
    setItem: function (row, col, item) {
        this._dataRows[row][col] = item;
    },
    // allColumns : 전체 컬럼을 export할것인가?
    // showColumns : inVisible인 컬럼을 export할것인가?
    // hideColumns : visible인 컬럼을 export하지 않을것인가?
    // allColumns:false 이고 hideColumns.length > 0 인경우
    // allColumns:false 이고 showColumns.length > 0 인경우
    // allColumns: true 이고 hideColumns.length > 1 인경우
    // allColumns: true이고 showColumns.length > 1 인경우 <-- 의미없음.
    $_parse: function (grid, linearize, allColumns, showColumns, hideColumns) {
        var headerLevels = 1;
        var dataLevels = 1;
        var cnt = (allColumns || showColumns.length > 0) ? grid._rootColumn.count() : grid.visibleColumnCount();
        if (!linearize) {
            for (var i = 0; i < cnt; i++) {
                var col = allColumns ? grid._rootColumn.getOrderedItem(i) : showColumns.length > 0 ? grid._rootColumn.getOrderedItem(i) : grid.getVisibleColumn(i);
                // var col = allColumns ? grid._rootColumn.getItem(i) : showColumns.length > 0 ? grid._rootColumn.getOrderedItem(i) : grid.getVisibleColumn(i);
                // var col = (allColumns || showColumns.length > 0) ? grid._rootColumn.getItem(i) : grid.getVisibleColumn(i);
                //col.isVisible 이거나 allColumns 이면 hide에 있는 컬럼은 제외.
                if (((allColumns || col.isVisible()) && hideColumns.indexOf(col.name()) < 0) || (!col.isVisible() && showColumns.indexOf(col.name()) >= 0)) {
                    if (col instanceof ColumnGroup) {
                        headerLevels = Math.max(headerLevels, col.calcHeaderLevels(!allColumns, showColumns, hideColumns));
                        dataLevels = Math.max(dataLevels, col.calcDataLevels(!allColumns, showColumns, hideColumns));
                    }
                }
            }
        }
        for (i = 0; i < headerLevels; i++) {
            this._headerRows.push([]);
        }
        for (i = 0; i < dataLevels; i++) {
            this._dataRows.push([]);
        }
        this.$_parseRows(grid, true, this._headerRows, linearize, allColumns, showColumns, hideColumns);
        this.$_parseRows(grid, false, this._dataRows, linearize, allColumns, showColumns, hideColumns);
        this.$_setDataColumns(this._dataRows);
        this.$_setSparkInfo(this._dataRows);
    },
    $_parseRows: function (grid, includeHeader, rows, linearize, allColumns, showColumns, hideColumns) {
        function addColumn(x, y, w, h, column) {
            var r, c, item/*ColumnArrayItem*/;
            for (r = 0; r < h; r++) {
                for (c = 0; c < w; c++) {
                    item = new ColumnArrayItem(column);
                    item.colIndex = c;
                    item.colSpan = w;
                    item.rowIndex = r;
                    item.rowSpan = h;
                    if (item instanceof DataColumn) {
                        switch (column.valueType()) {
                            case ValueType.NUMBER:
                                item.valueType = 'n';
                                break;
                            case ValueType.BOOLEAN:
                                item.valueType = 'b';
                                break;
                            case ValueType.DATETIME:
                                item.valueType = 'd';
                                break;
                            default:
                                item.valueType = 's';
                                break;
                        }
                    } else {
                        item.valueType = 's';
                    }
                    rows[y + r][x + c] = item;
                }
            }
        }
        function addGroup(x, y, w, h, group, allColumns, showColumns, hideColumns) {
            var cnt = (allColumns || showColumns.length > 0) ? group._columns.count() : group.visibleCount();
            if (cnt < 1) {
                addColumn(x, y, w, h, group);
                return;
            }
            if (includeHeader && group.header().isVisible()) {
                if (group.isHideChildHeaders()) {
                    addColumn(x, y, w, h, group);
                    return;
                }
                addColumn(x, y, w, 1, group);
                y++;
                h--;
            }
            if (includeHeader && group.isHideChildHeaders()) {
                addColumn(x, y, w, h, group);
                return;
            }
            var i, column, hh, ww;
            if (group.isVertical()) {
                for (i = 0; i < cnt; i++) {
                // var col = (allColumns || showColumns.length > 0) ? grid._rootColumn.getItem(i) : grid.getVisibleColumn(i);
                    // column = allColumns ? group.getItem(i) : showColumns.length > 0 ? group.getOrderedItem(i) : group.getVisibleItem(i);    
                    column = allColumns ? group.getOrderedItem(i) : showColumns.length > 0 ? group.getOrderedItem(i) : group.getVisibleItem(i);    
                    // column = (allColumns || showColumns.length > 0) ? group._columns.getItem(i): group.getVisibleItem(i);
                    if (((allColumns || column.isVisible()) && hideColumns.indexOf(column.name()) < 0) || (!column.isVisible() && showColumns.indexOf(column.name()) >= 0)) {
                        if (column instanceof ColumnGroup) {
                            if (i < cnt - 1) {
                                hh = includeHeader ? column.calcHeaderLevels(!allColumns, showColumns, hideColumns) : column.calcDataLevels(!allColumns, showColumns, hideColumns);
                            } else {
                                hh = h;
                            }
                            addGroup(x, y, w, hh, column,allColumns, showColumns, hideColumns);
                            y += hh;
                            h -= hh;
                        } else if (i < cnt - 1) {
                            addColumn(x, y, w, 1, column);
                            y++;
                            h--;
                        } else {
                            addColumn(x, y, w, h, column);
                        }
                    }
                }
            } else {
                for (i = 0; i < cnt; i++) {
                    // column = allColumns ? group.getItem(i) : showColumns.length > 0 ? group.getOrderedItem(i) : group.getVisibleItem(i);    
                    column = allColumns ? group.getOrderedItem(i) : showColumns.length > 0 ? group.getOrderedItem(i) : group.getVisibleItem(i);    
                    // column = (allColumns || showColumns.length > 0)? group._columns.getItem(i): group.getVisibleItem(i);
                    if (((allColumns || column.isVisible()) && hideColumns.indexOf(column.name()) < 0) || (!column.isVisible() && showColumns.indexOf(column.name()) >= 0)) {
                        if (column instanceof ColumnGroup) {
                            if (i < cnt - 1) {
                                ww = column.calcHorz(!allColumns, showColumns, hideColumns);
                            } else {
                                ww = w;
                            }
                            addGroup(x, y, ww, h, column, allColumns, showColumns, hideColumns);
                            x += ww;
                            w -= ww;
                        } else if (i < cnt - 1) {
                            addColumn(x, y, 1, h, column);
                            x++;
                            w--;
                        } else {
                            addColumn(x, y, w, h, column);
                        }
                    }
                }
            }
        }
        var h = rows.length;
        var w = 0;
        var x = 0;
        var y = 0;
        var col;
        if (linearize) {
            var columns = grid.getLeafColumns(!allColumns && showColumns.length == 0);
            for (var i = 0, cnt = columns.length; i < cnt; i++) {
                col = columns[i];
                if ((((allColumns || col.isVisible()) && hideColumns.indexOf(col.name()) < 0)) || (!col.isVisible() && showColumns.indexOf(col.name()) >= 0)) {
                    addColumn(x++, y, 1, h, col);
                }
            }
        } else {
            var cnt = (allColumns || showColumns.length > 0) ? grid._rootColumn.count() : grid.visibleColumnCount();
            for (var i = 0; i < cnt; i++) {
                col = allColumns ? grid._rootColumn.getOrderedItem(i) : showColumns.length > 0 ? grid._rootColumn.getOrderedItem(i) : grid.getVisibleColumn(i);
                // col = allColumns ? grid._rootColumn.getItem(i) : showColumns.length > 0 ? grid._rootColumn.getOrderedItem(i) : grid.getVisibleColumn(i);
                // col = (allColumns || showColumns.length > 0) ? grid._rootColumn.getItem(i) : grid.getVisibleColumn(i);
                if ((((allColumns || col.isVisible()) && hideColumns.indexOf(col.name()) < 0)) || (!col.isVisible() && showColumns.indexOf(col.name()) >= 0)) {
                    if (col instanceof ColumnGroup) {
                        w = col.calcHorz(!allColumns, showColumns, hideColumns);
                        addGroup(x, y, w, h, col, allColumns, showColumns, hideColumns);
                    } else {
                        w = 1;
                        addColumn(x, y, w, h, col);
                    }
                    x += w;
                }
            }
        }
    },
    $_setDataColumns: function(colArr) {
        var cols;
        var item;
        this._dataColumns = [];
        for (var r = 0, rCnt = colArr.length; r < rCnt ; r++) {
            cols = [];
            for (var c = 0, cnt = colArr[r].length; c < cnt ; c++) {
                item = colArr[r][c];
                cols.push(item.column.name());
            }
            this._dataColumns.push(cols);
        }
    },
    $_setSparkInfo: function(colArr) {
        function findColumn( grid, fields, row, dataColumns ) {
            var column;
            var ret = {};
            var startField = fields[0], endField = fields[fields.length-1];
            var startColumn = grid.columnByField(startField), endColumn = grid.columnByField(endField);
            if (!startColumn || !endColumn) { 
                return null
            }
            startColumn = startColumn.name();
            endColumn = endColumn.name();
            for (var r = 0, rCnt = dataColumns.length; r < rCnt ; r++) {
                for (var c = 0, cnt = dataColumns[r].length; c < cnt ; c++) {
                    startColumn == dataColumns[r][c] && (ret["startColumn"] = c, ret["row"] = r - row);
                    endColumn == dataColumns[r][c] && (ret["endColumn"] = c);
                }
            }
            return ret;
        };
        var item, column, render, fields, grid;
        this._sparkColumns = [];
        for (var r = 0, rCnt = colArr.length; r < rCnt ; r++) {
            for (var c = 0, cnt = colArr[r].length; c < cnt ; c++) {
                item = colArr[r][c];
                column = item.column;
                if (column instanceof SeriesColumn) {
                    render  = column.rendererObj();
                    if (render && (render instanceof SparkChartRenderer)) {
                        fields = column._fields;
                        grid = column.grid();
                        var refColumnInfo = fields.length > 0 && findColumn(grid, fields, r, this._dataColumns);
                        var type;
                        if (render instanceof SparkLineRenderer) {
                            type = "line";
                        } else if (render instanceof SparkColumnRenderer) {
                            type = "column";
                        } else if (render instanceof SparkWinLossRenderer) {
                            type = "stacked";
                        } else {
                            type = '';
                        };
                        if (refColumnInfo) { 
                            var sparkLineGroup = {
                                type:type,
                                colors: {},
                                sparkLines : [],
                                refColumnInfo : refColumnInfo
                            };
                            var colors = sparkLineGroup.colors;
                            render._highFill && (colors["colorHigh"] = render._highFill._color.toHex());
                            render._lowFill && (colors["colorLow"] = render._lowFill._color.toHex());
                            render._firstFill && (colors["colorFirst"] = render._firstFill._color.toHex());
                            render._lastFill && (colors["colorLast"] = render._lastFill._color.toHex());

                            switch (type) {
                                case "line" :
                                    render._pointFill && (colors["colorMarkers"] = render._pointFill._color.toHex());
                                    column._styles && column._styles.line()._color && (colors["colorSeries"] = column.styles().line()._color.toHex());
                                    break;
                                case "column" :
                                case "stacked" :
                                    column.styles().figureBackground() && (colors["colorSeries"] = column.styles().figureBackground()._color.toHex());
                                    break;
                            }
                            item.sparkLineGroup = sparkLineGroup;
                            this._sparkColumns[column.$_hash] = item;
                        };
                    }
                }
            }
        }
    }
});
var VIS_DEFAULT = "default";
var VIS_HIDDEN = "hidden";
var VIS_VISIBLE = "visible";
var INDICATOR_DEFAULT = "default";
var INDICATOR_ITEM = "item";
var INDICATOR_ROW = "row";
var PIXELS_PER_CHAR = 7;

var DocumentTitle = defineClass("DocumentTitle", null, {
    init: function (source) {
        if (typeof source == "string") {
            this._message = source;
            this._styles = new VisualStyles(null, "DocumentTitleStyle");
            this.$_initStyles();
            this._visible = true;
            this._spaceTop = 0;
            this._spaceBottom = 0;
            this._height = -1;
        } else if (typeof source == "object") {
            this._message = source.message;
            this._visible = source.hasOwnProperty('visible') ? source.visible : true;
            this._styles = new VisualStyles(null, "DocumentTitleStyle");
            this.$_initStyles();
            source.styles && this._styles.extend(source.styles);
            this._spaceTop = source.spaceTop ? (isNaN(parseInt(source.spaceTop)) ? 0 : parseInt(source.spaceTop)) : 0;
            this._spaceBottom = source.spaceBottom ? (isNaN(parseInt(source.spaceBottom)) ? 0 : parseInt(source.spaceBottom)): 0;
            this._height = source.height ? (isNaN(parseInt(source.height)) ? -1 : parseInt(source.height)) : -1;
        }
    },
    $_initStyles: function() {
        var border = "#ff555555,1px";
        this._styles.borderLeft(border);
        this._styles.borderRight(border);
        this._styles.borderTop(border);
        this._styles.borderBottom(border);
    },
    proxy: function () {
        var obj = {
            message: this._message,
            visible: this._visible
        };
        if (this._styles)
            obj.styles = this._styles.toProxy();
        return obj;
    },
    message: null,
    visible: true,
    styles: null,
    spaceTop: 0,
    spaceBottom: 0,
    height: -1
});

var GridExportOptions = defineClass("GridExportOptions", null, {
    init: function (source) {
        this._super();
        this._datetimeWriter = null;
        source && this.assign(source);
    },
    target: "remote",   // "remote" | "local"
    url: undefined,
    fileName: null,
    linear: false,
    allColumns:false,
    allItems: true,
    onlyCheckedItems:false,
    pagingAllItems: false,
    indicator: VIS_DEFAULT,
    checkBar: VIS_HIDDEN,
    header: VIS_DEFAULT,
    footer: VIS_DEFAULT,
    headerSummary:VIS_DEFAULT,
    indicatorValue: INDICATOR_DEFAULT,
    checkMark: "v",
    indenting: true,
    checkNumber: false,
    datetimeFormat: undefined,
    nullDateText: "",
    datetimeCallback: null,
    numberFormat: undefined,
    numberCallback: null,
    booleanFormat: null,
    booleanCallback: null,
    objectCallback: null,
    separateRows: false,
    showConfirm: true,
    confirmMessage: "Excel 문서로 저장하시겠습니까?",
    confirmTitle: "Excel 저장",
    lookupDisplay: false,
    textCallback: null,
    compatibility: false,
    showLevelOutline: true,
    documentTitle: null,
    documentSubtitle: null,
    documentTail: null,
    start: 0,
    count: -1,
    showProgress: false,
    progressMessage:null,
    applyDynamicStyles: false,
    applyDefaultColumnFormat: false,
    done: null,
    sheetName:null,
    exportSeriesColumn: false,
    exportLink: false,
    setFileName: function (value) {
        value = _trim(value);
        this._fileName = value;
    },
    setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
        }
    },
    setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._booleanFormatter = new BooleanFormatter(value);
            } else {
                this._booleanFormatter = null;
            }
        }
    },
    setNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
        }
    },
    isIndicatorVisible: function (grid) {
        if (grid) {
            switch (this._indicator) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.indicator().isVisible();
            }
        }
        return false;
    },
    isCheckBarVisible: function (grid) {
        if (grid) {
            switch (this._checkBar) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.checkBar().isVisible();
            }
        }
        return false;
    },
    isHeaderVisible: function (grid) {
        if (grid) {
            switch (this._header) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.header().isVisible();
            }
        }
        return false;
    },
    isHeaderSummaryVisible: function (grid) {
        // header와 독립적으로 표시되도록 한다.
        if (grid) {
            switch (this._headerSummary) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.header().summary().isVisible();
            }
        }
        return false;
    },
    isFooterVisible: function (grid) {
        if (grid) {
            switch (this._footer) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.footer().isVisible();
            }
        }
        return false;
    },
    isIndicatorDataRow: function (grid) {
        if (grid) {
            switch (this._indicatorValue) {
                case INDICATOR_ITEM:
                    return false;
                case INDICATOR_ROW:
                    return true;
                case INDICATOR_DEFAULT:
                default:
                    return grid.indicator().displayValue() == IndicatorValue.ROW;
            }
        }
        return false;
    },
    setDocumentTitle: function (value) {
        this._documentTitle = value ? new DocumentTitle(value) : null; 
    },
    setDocumentSubtitle: function (value) {
        this._documentSubtitle = value ? new DocumentTitle(value) : null;
    },
    setDocumentTail: function (value) {
        this._documentTail = value ? new DocumentTitle(value) : null;
    },
    assign: function(source) {
        this._super(source);
        var fileExt;
        if (this._fileName) {
            fileExt = this._type === "csv" ? ".csv" : ".xlsx";
            this._fileName.indexOf(".") < 0 && (this._fileName += fileExt);
        }

    }
});
var DataProviderExportOptions = defineClass("DataProviderExportOptions", null, {
    init: function (source) {
        this._super(true);
        this._datetimeWriter = null;
        source && this.assign(source);
    },
    target: "remote",   // "remote" | "local" | "string"
    url: undefined,
    fileName: null,
    // onlyCheckedItems:false,
    datetimeFormat: undefined,
    nullDateText: "",
    datetimeCallback: null,
    numberFormat: undefined,
    numberCallback: null,
    booleanFormat: null,
    booleanCallback: null,
    objectCallback: null,
    textCallback: null,
    start: 0,
    count: -1,
    done: null,
    lfText: null,
    crText: null,
    seperator: null,
    exportFields:null,
    hideFields:null,
    includeFieldNames:false,
    setFileName: function (value) {
        value = _trim(value);
        this._fileName = value;
    },
    setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
        }
    },
    setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._booleanFormatter = new BooleanFormatter(value);
            } else {
                this._booleanFormatter = null;
            }
        }
    },
    setNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
            this._numberFormatter = value ? new DecimalFormatter(value) : null;
        }
    },
    assign: function(source) {
        this._super(source);
        var fileExt;
        if (this._fileName) {
            fileExt = this._type === "csv" ? ".csv" : ".xlsx";
            this._fileName.indexOf(".") < 0 && (this._fileName += fileExt);
        }

    }
});
 
/* 
	RealGridJS.exportGrid({
		type:"excel",
		fileName:"aaaa.xlsx",
		done: function() {
		},
		exportGrids:[
			{
				grid:grid,
				indicator:"hidden"
			},
            {
                grid:grid2,
                indicator:"visible"
                sheetName:"sheetname" // 중복되면 안된다.
            }
		]
	})
*/
var GridExportGridOptions = defineClass("GridExportGridOptions", null, {
    init: function (source) {
        this._super(true);
        this._datetimeWriter = null;
        this._showColumns = [];
        this._hideColumns = [];
        source && this.assign(source);
    },
    destroy : function() {
        this._grid = null;
        this._super();
    },
	grid:null,
    linear: false,
    allColumns:false,
    allItems: true,
    onlyCheckedItems:false,
    pagingAllItems: false,
    indicator: VIS_DEFAULT,
    checkBar: VIS_HIDDEN,
    header: VIS_DEFAULT,
    footer: VIS_DEFAULT,
    headerSummary:VIS_DEFAULT,
    indicatorValue: INDICATOR_DEFAULT,
    checkMark: "v",
    indenting: true,
    checkNumber: false,
    datetimeFormat: undefined,
    nullDateText: "",
    datetimeCallback: null,
    numberFormat: undefined,
    numberCallback: null,
    booleanFormat: null,
    booleanCallback: null,
    objectCallback: null,
    textCallback: null,
    separateRows: false,
    showConfirm: true,
    lookupDisplay: false,
    compatibility: false,
    showLevelOutline: true,
    documentTitle: null,
    documentSubtitle: null,
    documentTail: null,
    start: 0,
    count: -1,
    showProgress: false,
    progressMessage:null,
    applyDynamicStyles: false,
    applyDefaultColumnFormat: false,
    applyFitStyle: false,
    sheetName:null,
    exportSeriesColumn: false,
    showColumns: null,
    hideColumns: null,
    exportLink: false,
    setGrid: function(value) {
    	this._grid = value instanceof GridBase ? value : value._gv;
    },
    setDatetimeFormat: function (value) {
        if (value != this._datetimeFormat) {
            this._datetimeFormat = value;
        }
    },
    setBooleanFormat: function (value) {
        if (value != this._booleanFormat) {
            this._booleanFormat = value;
            if (value) {
                this._booleanFormatter = new BooleanFormatter(value);
            } else {
                this._booleanFormatter = null;
            }
        }
    },
    setNumberFormat: function (value) {
        if (value != this._numberFormat) {
            this._numberFormat = value;
        }
    },
    isIndicatorVisible: function (grid) {
        if (grid) {
            switch (this._indicator) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.indicator().isVisible();
            }
        }
        return false;
    },
    isCheckBarVisible: function (grid) {
        if (grid) {
            switch (this._checkBar) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.checkBar().isVisible();
            }
        }
        return false;
    },
    isHeaderVisible: function (grid) {
        if (grid) {
            switch (this._header) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.header().isVisible();
            }
        }
        return false;
    },
    isHeaderSummaryVisible: function (grid) {
        // header와 독립적으로 표시되도록 한다.
        if (grid) {
            switch (this._headerSummary) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.header().summary().isVisible();
            }
        }
        return false;
    },
    isFooterVisible: function (grid) {
        if (grid) {
            switch (this._footer) {
                case VIS_VISIBLE:
                    return true;
                case VIS_HIDDEN:
                    return false;
                case VIS_DEFAULT:
                default:
                    return grid.footer().isVisible();
            }
        }
        return false;
    },
    isIndicatorDataRow: function (grid) {
        if (grid) {
            switch (this._indicatorValue) {
                case INDICATOR_ITEM:
                    return false;
                case INDICATOR_ROW:
                    return true;
                case INDICATOR_DEFAULT:
                default:
                    return grid.indicator().displayValue() == IndicatorValue.ROW;
            }
        }
        return false;
    },
    setDocumentTitle: function (value) {
        this._documentTitle = value ? new DocumentTitle(value) : null; 
    },
    setDocumentSubtitle: function (value) {
        this._documentSubtitle = value ? new DocumentTitle(value) : null;
    },
    setDocumentTail: function (value) {
        this._documentTail = value ? new DocumentTitle(value) : null;
    },
    setShowColumns: function (value) {
        this._showColumns = value ? (_isArray(value) && value.length > 0 ? value : [value]) : [];
    },
    setHideColumns: function (value) {
        this._hideColumns = value ? (_isArray(value) && value.length > 0 ? value : [value]) : [];
    },
});

var GridExportOptions2 = defineClass("GridExportOptions2", null, {
	init: function(options) {
		this._super(true);
		options && this.assign(options);
        this._progressMessage = this.progressMessage() || "Exporting...";
	},
    destroy: function() {
        this._super();
    },
    target: "remote",   // "remote" | "local"
    url: undefined,
    fileName: null,
	showProgress: false,
	progressMessage: null,
    progressMax: 0,
    prepareProgress: 10,
	done: null,
	exportGrids:null,
    params: null,
    assign: function( options ) {
        var grids = options.exportGrids;
        var opts = new GridExportGridOptions();
        for (var i = 0, cnt = grids.length; i < cnt ; i++) {
            var grid = grids[i];
            for (var v in options) {
                if (!this.hasOwnProperty("_"+v) && !grid.hasOwnProperty(v) && opts.hasOwnProperty("_"+v)) {
                    grid[v] = options[v];
                }
            }
        }
        this._super(options);
    },
    setFileName: function (value) {
        value = _trim(value);
        if (value && value.indexOf(".") < 0) {
            value = value + ".xlsx";
        }
        this._fileName = value;
    },
	setExportGrids: function(source) {
		source = _isArray(source) ? source : [source];
		var grids = this._exportGrids = [];
		for (var i = 0, cnt = source.length; i < cnt; i++) {
			var gridOptions = new GridExportGridOptions(source[i]);
			grids.push(gridOptions);
		};
	}
});
var GridExcelExporter2 = defineClass("GridExcelExporter2", null, {
	init: function() {
        this._super();
        this._runStyles = new VisualStyles();
        this._seriesCell = new SeriesCell();
	},
	destroy: function() {
        this._destroying = true;
        this._runStyles = null;
        this._seriesCell = null;
        this._progressGrid = null;
        this._super();
    },
    setProgress: function (pos) { 
        var grid = this._progressGrid;
        grid && grid.setExportProgress(this._progressMax, pos+this._options.prepareProgress(), this._options.progressMessage()); 
    },
    $_setOptions: function(options) {
    	var exportGrids = this._exportGrids = [];
    	var option;
    	options = _isArray(options) ? options : [options];
    	for (var i = 0, cnt = options.length; i < cnt ; i++) {
    		option = options[i]
    		if (option && option.grid instanceof GridBase) {
    			exportGrids.push(option);
    		}
    	}
    },
    $_prepareCount: function(exportGrids) {
    	var allCnt = 0;
    	var allItems;
    	var grid, gridOption;
    	for (var i = 0, cnt = exportGrids.length; i < cnt ; i++) {
            allItems = null;
    		gridOption = exportGrids[i];
    		grid = gridOption.grid();
            this._progressGrid = $$_activeGrid == grid ? grid : (this._progressGrid || grid);
	    	if (grid instanceof GridView) {
	            if (gridOption.isAllItems() && grid.isRowGrouped()) {
	                allItems = grid.getAllItems();
	                var fixed = grid.layoutManager().fixedItemCount();
	                if ( fixed > 0) {
	                    for (var i=0; i<fixed; i++) {
	                        allItems.splice(i,0,grid.getItem(i));
	                    }
	                }
	            } else if (gridOption.isPagingAllItems() && grid.isPaged()) {
	                allItems = grid.getPagingAllItems();
	            } else if (gridOption.isOnlyCheckedItems() && !grid.isRowGrouped()) {
	                allItems = grid.getCheckedItems();
	            } else {

                }
	    	} else if (grid instanceof TreeView) {
	    		if (gridOption.isAllItems()) {
	    			allItems = grid.getAllItems();
	    		}
	    	}
	    	allCnt += allItems ? allItems.length : grid.itemCount();
	    }
    	return allCnt;
	},
    export: function(options) {
    	function save(owner) {
            var t1 = getTimer();
            t = t1 - t;
            _trace("E X C E L: " + "buildBook " + t);
            t = t1;
            var parts = workBook.createParts();
            t1 = getTimer();
            t = t1 - t;
            _trace("E X C E L: " + "createParts " + t);
            t = t1;
            var data = [];
            for (var p in parts) {
                data.push({key: p, body: parts[p]});
            }
            owner.$_export(data, options);
            t1 = getTimer();
            t = t1 - t;
            _trace("E X C E L: " + "zip " + t);
            t = t1;
            options._done && (options.target() !== "file" && options.target() !== "string") && typeof options._done == "function" && options._done();
            owner.destroy && owner.destroy();
            workBook && workBook.destroy && workBook.destroy();;
    	};
    	var t = getTimer();
    	if (!options) return;
    	this._options = options = options instanceof GridExportOptions2 ? options : new GridExportOptions2(options);
    	var exportGrids = this._exportGrids = options._exportGrids;
    	var currentGridIndex = this._currentGridIndex = 0;
    	if (!exportGrids || exportGrids.length <= 0) {
    		return;
    	};
    	var workBook = new ExcelWorkbook2();
    	if (options.isShowProgress()) {
    		this._allCount = this.$_prepareCount(options._exportGrids);
            this._progressMax = this._allCount + this._options.prepareProgress();
            this._progressPos = 0;
            this._progressStep = Math.max(_int(this._allCount / 10), 1);
            this._progressGrid && this._progressGrid.beginExportProgress(this._options.progressMessage());
            this.setProgress(this._progressPos);
            if (this._currentGridIndex < this._exportGrids.length) {
	    		setTimeout(function() {
    				this.$_exportGridAsync(workBook, function() {
                            this._progressGrid && this._progressGrid.endExportProgress();
                            save(this);
                        }.bind(this));
	    		}.bind(this), 0);
    		}
    	} else {
	    	for (var i = 0, cnt = exportGrids.length; i < cnt ; i++) {
	    		this.$_exportGrid(workBook, exportGrids[i]);
	    	}
	   		save(this);
	   	}
    },
    $_exportGridAsync: function(workBook, done) {
    	if (this._currentGridIndex < this._exportGrids.length) {
	    	this.$_exportGrid(workBook, this._exportGrids[this._currentGridIndex++], function(){
	    		setTimeout(function() {
                    this.$_exportGridAsync(workBook, done)}.bind(this),0);
	    	}.bind(this));
    	} else {
    		done();
    	}
    },
    $_exportGrid: function(workBook, exportGrid, done) {
    	var grid = exportGrid.grid();
    	var options = exportGrid;
    	var self = this;
    	var context = {
    		grid: grid,
    		options: options,
    		indicator: options.isIndicatorVisible(grid) ? grid.indicator() : null,
    		header: options.isHeaderVisible(grid) ? grid.header() : null,
    		headerSummary: options.isHeaderSummaryVisible(grid) ? grid.header().summary() : null,
    		footer : options.isFooterVisible(grid) ? grid.footer() : null,
    		colArr : new ColumnArray(grid, options.isLinear(), options.isAllColumns(), options.showColumns(), options.hideColumns()),
            numberFormatId: 0,
            textFormatId:49,  // 일반 텍스트.
            dateFormatId: 14, //22, // 14 는 날짜만
            columnStyles: {},
            columnWrapStyles: {},
            fixedStyles:undefined,
            fixedWrapStyles:undefined,
            allItems: null,
            indicatorHead: grid.indicator().headText() || "No",
            indicatorFoot: grid.indicator().footText() || "",
            indicatorSummary: grid.indicator().summaryText(),
            compatibility: options.isCompatibility(),
            showLevelOutline: options.isShowLevelOutline(),
            rowGrouped: false,
            rowLevels: 0,
            indents: 0,
            indentWidth: 3,
            indicatorStyle: undefined,
            indentHeadStyle: undefined,
            indentHeadSummaryStyle: undefined,
            indentFootStyle: undefined,
            columnMerged: false,
            mergeHeads: {},
            excelFormulaRuntime: new ColumnExportStatementRuntime(),
            defHt: grid._displayOptions.rowHeight() || grid._layoutManager._heightMeasurer.$_calcItemHeights(grid, grid.getDataLevel()),
            sheetName: options.sheetName()
    	};
        context.defHt && context.colArr && (context.defHt = context.defHt * 0.75 / context.colArr.dataRowCount());        
    	if (grid instanceof GridView) {
            if (options.isAllItems() && grid.isRowGrouped()) {
                context.allItems = grid.getAllItems();
                var fixed = grid.layoutManager().fixedItemCount();
                if ( fixed> 0) {
                    for (var i=0; i<fixed; i++) {
                        context.allItems.splice(i,0,grid.getItem(i));
                    }
                }
            } else if (options.isPagingAllItems() && grid.isPaged()) {
                context.allItems = grid.getPagingAllItems();
            } else if (options.isOnlyCheckedItems() && !grid.isRowGrouped()) {
                context.allItems = grid.getCheckedItems();
            }
            this.$_buildSheet(workBook, context, done);            
    	} else if (grid instanceof TreeView) {
    		if (options.isAllItems()) {
    			context.allItems = grid.getAllItems();
    		}
    		this.$_buildTreeSheet(workBook, context, done);
    	}
    },
    $_createStyles: function (book, styles/*VisualStyles*/, borders, fonts,fills, isLink) {
        borders = borders == undefined ? true : borders;  // arguments.length > 2 ? borders : true;
        fonts = fonts == undefined ? true : fonts;  //arguments.length > 3 ? fonts : true;
        fills = fills == undefined ? true : fills;  //arguments.length > 4 ? fills : true;
        isLink = isLink == undefined ? false : isLink;

        var numFmt;
        var formatCode;
        var numberFormat = styles.numberFormat();
        if (numberFormat && typeof numberFormat == "string" && numberFormat.indexOf(";") >= 0) {
            var nfs = numberFormat.split(";");
            numberFormat = nfs[0];
        }
        var datetimeFormat = styles.datetimeFormat();
        if (numberFormat && numberFormat.length > 0) {
            formatCode = ExcelFormatConverter.convertNumberFormat(numberFormat);
        } else if (datetimeFormat) {
            formatCode = ExcelFormatConverter.convertDateFormat(datetimeFormat);
        }
        if (formatCode) {
            var prefix = styles.prefix();
            if (prefix) {
                formatCode = "\"" + prefix + "\"" + formatCode;
            }
            var suffix = styles.suffix();
            if (suffix) {
                formatCode = formatCode + "\"" + suffix + "\"";          
            }
            var numFmtId = book.addNumberFormat(formatCode);
        }
        var fill;
        if (fills) {
            fill = new ExcelFill();
            var background = styles.background();
            if (background instanceof LinearGradient) {
                fill.gradient = "linear";
                fill.color = background._colors[0].toColorHex();
                fill.color2 = background._colors[1].toColorHex();
                fill.tint = 1 - background._colors[0]._a;
                switch (background._angle) {
                    case 90:
                        fill.degree = "90";
                        break;
                    case 45:
                        fill.degree = "45";
                        break;
                    default:
                        fill.degree = "0";
                        break;
                }
            } else {
                fill.patternType = "solid";
                fill.color = background._color.toColorHex();
                fill.tint = 1 - background._color._a;
            }
            book.addFill(fill);
        }
        var border = null;
        if (borders) {
            border = new ExcelBorder();
            border.right = styles.borderRight();
            border.bottom = styles.borderBottom();
            border.left = styles.borderLeft();
            border.top = styles.borderTop();
            book.addBorder(border);
        }
        var font = null;
        if (isLink) {
            font = new ExcelFont();
            font.name = styles.fontFamily();
            font.size = "11";
            font.color = "0000ff";
            font.underline = true;
            book.addFont(font);
        } else 
        if (fonts) {
            font = new ExcelFont();
            font.name = styles.fontFamily();
            font.size = styles.fontSize() * 72 / 96;
            font.color = styles.foreground()._color.toColorHex();
            font.bold = styles.fontBold();
            font.italic = styles.fontItalic();
            book.addFont(font);
        }
        var es = new ExcelStyle();
        es.fill = fill;
        es.border = border;
        es.font = font;
        if (numFmtId)
            es.formatId = numFmtId;

        switch (styles.textAlignment()) {
            case Alignment.CENTER:
                es.horzAlign = ExcelStyle.ALIGN_CENTER;
                break;
            case Alignment.FAR:
                es.horzAlign = ExcelStyle.ALIGN_FAR;
                break;
            default:
                es.horzAlign = ExcelStyle.ALIGN_NEAR;
                break;
        }
        switch (styles.lineAlignment()) {
            case Alignment.CENTER:
                es.vertAlign = ExcelStyle.VALIGN_CENTER;
                break;
            case Alignment.FAR:
                es.vertAlign = ExcelStyle.VALIGN_FAR;
                break;
            default:
                es.vertAlign = ExcelStyle.VALIGN_NEAR;
                break;
        }
        return es;
    },
    $_addStyle: function (book, styles, borders, fonts, fills) {
        borders = arguments.length > 2 ? borders : true;
        fonts = arguments.length > 3 ? fonts : true;
        fills = arguments.length > 4 ? fills : true;
        var es = this.$_createStyles(book, styles, borders, fonts, fills);
        book.addStyle(es);
        return es;
    },
    $_addStyle2: function(book, es) {
        book.addStyle(es);
        return es;
    },
    $_buildSheet: function(workBook, ctx, done) {
    	var grid = ctx.grid;
    	var allItems = ctx.allItems;
    	var rows = allItems ? allItems.length : grid.itemCount();
    	var sheet = new ExcelSheet(workBook);
    	sheet._id = workBook.getRelationshipId();
        sheet._sheetName = ctx.sheetName || sheet._sheetName;
    	workBook.sheets().push(sheet);
    	ctx.sheet = sheet;
    	ctx.rowGrouped = grid.isRowGrouped();
    	ctx.mergedGrouped = grid.isMergedRowGrouped();
    	ctx.rowGrouped && (ctx.rowLevels = grid.rowGroupLevels());
    	ctx.start = 0;
    	if (!grid.isRowGrouped()) {
    		ctx.start = ctx.options.start() > 0 ? ctx.options.start() : 0;
    		var count = ctx.options.count() > 0 ? ctx.options.count() : rows;
    		rows = count > 0 ? (ctx.start+count > rows ? rows - ctx.start : count) : rows - ctx.start;
    	}
    	ctx.last = ctx.start + rows;

    	this.$_prepareFormats(workBook, ctx);
    	this.$_prepareStyles(workBook, ctx);
    	this.$_buildColumns(workBook, ctx);

    	var r=0, c = 0;

    	r += this.$_buildDocumentTitle(workBook, ctx, r, c);
    	r += ctx.header ? this.$_buildHeader(workBook, ctx, r, c) : 0;
    	r += ctx.headerSummary ? this.$_buildHeaderSummary(workBook, ctx, r, c) : 0;
    	if (this._options.isShowProgress()) {
            r += this.$_buildItemsAsync(workBook, ctx, r, c, function() {
                r = ctx.row;
                r += ctx.footer ? this.$_buildFooter(workBook, ctx, r, c) : 0;
                r += this.$_buildDocumentTail(workBook, ctx, r, c);
                done();
            }.bind(this))
    	} else {
    		r += this.$_buildItems(workBook, ctx, r, c);
    		r += ctx.footer ? this.$_buildFooter(workBook, ctx, r, c) : 0
    		r += this.$_buildDocumentTail(workBook, ctx, r, c);
    	}
    },
    $_buildTreeSheet: function (workBook, ctx, done) {
        var grid = ctx.grid;
        ctx.rowLevels = grid.getLevels();

    	var sheet = new ExcelSheet(workBook);
    	sheet._id = workBook.getRelationshipId();
        sheet._sheetName = ctx.sheetName || sheet._sheetName;
    	workBook.sheets().push(sheet);
    	ctx.sheet = sheet;
        
        this.$_prepareFormats(workBook, ctx);
        this.$_prepareStyles(workBook, ctx);
        this.$_buildColumns(workBook, ctx);

        ctx.start = 0;
        ctx.last = ctx.allItems ? ctx.allItems.length : grid.itemCount();

        var r = 0;
        var c = 0;
        r += this.$_buildDocumentTitle(workBook, ctx, r, c);
        r += ctx.header ? this.$_buildTreeHeader(workBook, ctx, r, c) : 0;
        r += ctx.headerSummary ? this.$_buildTreeHeaderSummary(workBook, ctx, r, c) : 0;
        if (this._options.isShowProgress()) {
            var self = this;
            r += this.$_buildTreeItemsAsync(workBook, ctx, r, c, function () {
                r = ctx.row;
                if (ctx.footer) r += self.$_buildTreeFooter(workBook, ctx, r, c);
                r += self.$_buildDocumentTail(workBook, ctx, r, c);
                done();
            });
        } else {
            r += this.$_buildTreeItems(workBook, ctx, r, c);
            if (ctx.footer) r += this.$_buildTreeFooter(workBook, ctx, r, c);
            r += this.$_buildDocumentTail(workBook, ctx, r, c);
        }
    },
    $_buildTreeHeader: function(workBook, ctx, startRow, startCol) {
        var i, es, row;
        var grid = ctx.grid;
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.headerRowCount();
        var indents = ctx.indents;
        var ht = grid._header.realHeight();
        ht && (ht = ht * 0.75 / rows );        
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.indicator().headStyles());
            sheet.addText(startRow, startCol, ctx.indicatorHead, es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentHeadStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            row = startRow + i;
            sheet.addRow(row, ht);
            for (var c = 0; c < cols; c++) {
                var item = colArr.getHeader(i, c);
                var column = item.column;
                var col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var h = column.header();
                    es = this.$_createStyles(book, h.styles());
                    var text = h.displayText();
                    var subText = h.subText();
                    var subLocation = h.subTextLocation();
                    if (subText) {
                        switch (subLocation) {
                            case SubTextLocation.LEFT:
                            case SubTextLocation.LEFT_FILL:
                                text = subText + " " + text;
                                break;
                            case SubTextLocation.RIGHT:
                            case SubTextLocation.RIGHT_FILL:
                                text = text + " " + subText;
                                break;
                            case SubTextLocation.UPPER:
                            case SubTextLocation.UPPER_FILL:
                                text = subText + "\r\n" + text;
                                break;
                            case SubTextLocation.LOWER:
                            case SubTextLocation.LOWER_FILL:
                            default : 
                                text = text + "\r\n" + subText;
                                break;
                        }
                    }
                    if (text && text.match($_linereg)) 
                        es.wrapText = true;
                    this.$_addStyle2(book, es);
                    sheet.addText(row, col, text, es);
                    if (item.rowSpan > 1 || item.colSpan > 1) {
                        sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                    }
                }
            }
        }
        return rows;
    },
    $_buildTreeHeaderSummary: function(workBook, ctx, startRow, startCol) {
        function addHeaderSummaryCell(row, col, column, es) {
            var cell = grid.header().summary().getCell(grid.getIndex(-1, column));
            var v = cell.value();

            if (!isNaN(v)) {
                sheet.addNumber(row, col, v, es);
            } else {
                sheet.addText(row, col, cell.displayText() || "", es);
            }
        }
        var i, es;
        var grid = ctx.grid;
        var mergeManager = grid.headerSummaryMergeManager();
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.dataRowCount();
        var indents = ctx.indents;
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.indicator().summaryStyles());
            sheet.addText(startRow, startCol, ctx.indicatorSummary, es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentHeadStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            var row = startRow + i;
            for (var c = 0; c < cols; c++) {
                var item = colArr.getItem(i, c);
                var column = item.column;
                var col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var room = mergeManager.findRoom(c);
                    if (room && c == room.start() && c != room.base()) {
                        colItem = colArr.getItem(i, room.base());
                        column = colItem.column; 
                    }
                    var hs = column.header().summary();
                    es = this.$_addStyle(book, hs.styles());
                    if (room) {
                        if (room.start() == c) {
                            addHeaderSummaryCell(row, col, column, es);
                            sheet.addMerge(row, col, 1, room.count());
                        } else {
                            sheet.addBlank(row, col, es);
                        }
                    } else {
                        addHeaderSummaryCell(row, col, column, es)
                        if (item.rowSpan > 1 || item.colSpan > 1) {
                            sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                        }
                    }
                }
            }
        }
        if (!ctx.compatibility && ctx.showLevelOutline)
            sheet.setRowLevel(startRow, 1);
        return rows;
    },
    $_buildTreeFooter: function(workBook, ctx, startRow, startCol) {
        function addFooterCell(row, col, column, footerIndex, es) {
            var cell = grid.footer().getCell(grid.getIndex(-1, column), footerIndex);
            var v = cell.value();

            if (!isNaN(v)) {
                sheet.addNumber(row, col, v, es);
            } else {
                sheet.addText(row, col, cell.displayText() || "", es);
            }
        }
        var i, r, c, es;
        var grid = ctx.grid;
        var mergeManager = grid.footerMergeManager();
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.dataRowCount();
        var indents = ctx.indents;
        var footers = grid.footer().count();
        var mrows = footers * rows;
        var ht = grid._footer.realHeight();
        ht && (ht = ht * 0.75 / mrows);        
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.indicator().footStyles());
            sheet.addText(startRow, startCol, ctx.indicatorFoot, es);
            if (rows > 1 || footers > 1) {
                for (i = 1; i < mrows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, mrows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < mrows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentFootStyle);
                }
                sheet.addMerge(startRow, c + startCol, mrows, 1);
            }
            startCol += indents;
        }
        var row = startRow;
        for (r = 0; r < footers; r++) {
            for (i = 0; i < rows; i++) {
                sheet.addRow(row, ht);
                for (var c = 0; c < cols; c++) {
                    var item = colArr.getItem(i, c);
                    var column = item.column;
                    var col = c + startCol;
                    if (item.colIndex > 0 || item.rowIndex > 0) {
                        sheet.addBlank(row, col, es);
                    } else {
                        var room = mergeManager.findRoom(c);
                        if (room && c == room.start() && c != room.base()) {
                            colItem = colArr.getItem(i, room.base());
                            column = colItem.column; 
                        }
                        var f = column.footer();
                        es = this.$_addStyle(book, f.styles());
                        if (room) {
                            if (room.start() == c) {
                                addFooterCell(row, col, column, r, es);
                                sheet.addMerge(row, col, 1, room.count());
                            } else {
                                sheet.addBlank(row, col, es);
                            }
                        } else {
                            addFooterCell(row, col, column, r, es)
                            if (item.rowSpan > 1 || item.colSpan > 1) {
                                sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                            }
                        }
                    }
                }
                row++;
            }
        }
        if (!ctx.compatibility && ctx.showLevelOutline)
            sheet.setRowLevel(startRow, 1);
        return rows;
    },
    $_buildTreeItemsAsync: function(workBook, ctx, startRow, startCol, done) {
        var grid = ctx.grid;
        var showRow = ctx.options.isIndicatorDataRow(grid);
        this.$_buildTreeItemAsync(workBook, ctx, startRow, startCol, showRow, 0, done);
    },
    $_buildTreeItems: function(workBook, ctx, startRow, startCol) {
        var grid = ctx.grid;
        var showRow = ctx.options.isIndicatorDataRow(grid);
        var row = startRow;
        for (var i = 0; i < ctx.last; i++) {
            var item = ctx.allItems ? ctx.allItems[i] : grid.getItem(i);
            if (item instanceof TreeItem) {
                row += this.$_buildTreeItem(workBook, ctx, item, showRow ? item.dataRow() : i + 1, row, startCol);
            } else {
                throw "Unkonw tree item type";
            }
        }
        return row - startRow;
    },
    $_buildTreeItemAsync: function (workBook, ctx, row, startCol, showRow, index, done) {
        var stepLast = index + Math.min(this._progressStep, ctx.last-index);
        for (var i = index; i < stepLast; i++) { 
            var item = ctx.allItems ? ctx.allItems[i] : ctx.grid.getItem(i);
            if (item instanceof TreeItem) {
                row += this.$_buildTreeItem(workBook, ctx, item, showRow ? item.dataRow() : i + 1, row, startCol);
            } else {
                throw "Unkonw tree item type";
            }
            this._progressPos += 1;
        }
        ctx.row = row;
        this.setProgress(this._progressPos);
        index = stepLast;
        if (index >= ctx.last) {
            done();
        } else {
            setTimeout(function() {
                this.$_buildTreeItemAsync(workBook, ctx, row, startCol, showRow, index, done);
            }.bind(this),0);
        }
    },
    $_buildTreeItem: function(workBook, ctx, item, no, startRow, startCol) {
        var c;
        var grid = ctx.grid;
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var rows = colArr.dataRowCount();
        var cols = colArr.colCount();
        var colStyles = ctx.columnStyles;
        var indents = ctx.indents;
        var level = item.level();
        var defHt = ctx.defHt;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(workBook, ctx, no, startRow, startCol, rows);
        }
        for (var r = 0; r < rows; r++) {
            var row = startRow + r;
            var start = indents > 0 ? startCol + level - 1 : startCol;
            var colItem = colArr.getItem(r, 0);
            var column = colItem.column;
            var es = colStyles[column.$_hash];
            var ind = indents > 0 ? indents - level + 1 : 0;
            if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                sheet.addBlank(row, start, es);
                for (c = 0; c < ind; c++) {
                    sheet.addBlank(row, 1 + c + start, es);
                }
            } else {
                this.$_buildValueCell(workBook, ctx, row, start, item, column,r, startCol);
                for (c = 0; c < ind; c++) {
                    sheet.addBlank(row, 1 + c + start, es);
                }
                sheet.addMerge(row, start, colItem.rowSpan, colItem.colSpan + ind);
            }
            if (indents > 0) {
                start = startCol + indents;
            } else {
                start = startCol;
            }
            sheet.addRow(row, defHt);
            for (c = 1; c < cols; c++) {
                var col = c + start;
                colItem = colArr.getItem(r, c);
                column = colItem.column;
                es = colStyles[column.$_hash];
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    this.$_buildValueCell(workBook, ctx, row, col, item, column,r, startCol);
                    if (colItem.rowSpan > 1 || colItem.colSpan > 1) {
                        sheet.addMerge(row, col, colItem.rowSpan, colItem.colSpan);
                    }
                }
            }
            if (!ctx.compatibility && ctx.showLevelOutline)
                sheet.setRowLevel(startRow, item.level());
        }
        return rows;
    },
    $_prepareFormats: function(workBook, ctx) {
        var options = ctx.options;
        var book = workBook;
        var f = options.numberFormat();
        if (typeof f == "number" || _int(f) > 0)  {
            ctx.numberFormatId = _int(f);
        } else if (f) {
            ctx.numberFormatId = book.addNumberFormat(ExcelFormatConverter.convertNumberFormat(f));
        }
        f = options.datetimeFormat();
        if (typeof f == "number" || _int(f) > 0)  {
            ctx.dateFormatId = _int(f);
        } else if (f) {
            ctx.dateFormatId = book.addNumberFormat(f);
        }

    },
    $_prepareStyles: function(workBook, ctx) {
        function prepareColumn(es, column, ctx) {
            if (column instanceof DataColumn) {
                var fld = ds.getField(column.dataIndex());
                var isLink = ctx.options.isExportLink() && column.rendererObj() instanceof LinkCellRenderer && !column.excelFormat();
                if (fld) {
                    var fmt = column.excelFormat();
                    if (typeof fmt == "number" || _int(fmt) > 0) {
                        es.formatId = fmt;
                    } else if (isLink) {
                        es.formatId = 0;
                    } else {
                        switch (fld.dataType()) {
                            case ValueType.TEXT:
                                es.formatId = fmt ? workBook.addNumberFormat(fmt) : es.formatId ? es.formatId : ctx.textFormatId;
                                break;
                            case ValueType.NUMBER:
                                es.formatId = fmt ? workBook.addNumberFormat(fmt) : es.formatId ? es.formatId : ctx.numberFormatId;
                                break;
                            case ValueType.DATETIME:
                                es.formatId = fmt ? workBook.addNumberFormat(fmt) : es.formatId ? es.formatId : ctx.dateFormatId;
                                break;
                        }
                    }
                }
            }
        }
        var colArr = ctx.colArr;
        var columnMerged = false;
        var cols = colArr.colCount();
        var columnStyles = ctx.columnStyles;
        var wrapStyles = ctx.columnWrapStyles;
        var grid = ctx.grid;
        var fixed = grid.layoutManager().fixedItemCount();
        var ds = grid.dataSource();
        var options = ctx.options;
        var book = workBook;
        var es, wes;  // defaultStyle, wrapTextStyle
        for (var r = 0, rows = colArr.dataRowCount(); r < rows; r++) {
            for (var c = 0; c < cols; c++) {
                var item = colArr.getItem(r, c);
                if (item.colIndex == 0 && item.rowIndex == 0) {
                    var column = item.column;

                    var isLink = ctx.options.isExportLink() && column.rendererObj() instanceof LinkCellRenderer && !column.excelFormat();
                    if (column && !columnStyles[column.$_hash]) {
                        var runStyles = grid._body._runtimeStyles2;
                        runStyles.clearValues();
                        if (!grid._body._fixedIgnoreColumn || !column.isFixed()) {
                            runStyles.assign(column.styles());
                        }
                        if (column.isFixed() && !grid._body._fixedIgnoreColumn) {
                            runStyles.setParent(grid._body._fixedStyles, false);
                        }
                        runStyles._sysDefault = column.isFixed() ? grid._body._fixedStyles._sysDefault : grid._body._bodyStyles._sysDefault;                        
                        es = this.$_createStyles(book, runStyles, null, null, null, isLink);
                        prepareColumn(es, column, ctx);
                        es = this.$_addStyle2(book, es);
                        columnStyles[column.$_hash] = es;
                        wes = this.$_createStyles(book, runStyles, null, null, null, isLink);
                        prepareColumn(wes, column, ctx);
                        wes.wrapText = true;
                        wes = this.$_addStyle2(book, wes);
                        wrapStyles[column.$_hash] = wes;
                        if (!options.isSeparateRows() && (!options.isOnlyCheckedItems() || grid.isRowGrouped()) && item.rowIndex === 0 && item.rowSpan === colArr.dataRowCount()) {
                            var merges/*ColumnMergeManager*/ = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
                            if (!merges && column._mergeRule) {  // 숨겨진 컬럼에 mergeRule이 설정된 경우.
                                merges = new ColumnMergeManager(column);
                                column.setState(ColumnMergeManager.MERGE_ROOMS, merges);
                                merges.clear();
                                merges.initialize(grid.itemCount()-1);
                            }
                            if (merges && column.canMerge && column.canMerge()) {
                                merges.refresh(fixed, grid.itemCount() - 1);
                                columnMerged = true;
                            }
                        }
                        runStyles = null;
                    }
                }
            }
        }
        ctx.columnMerged = columnMerged;
        ctx.fixedStyles = this.$_addStyle(book, grid.fixedOptions().styles());
        wes = this.$_createStyles(book, grid.fixedOptions().styles());
        wes.wrapText = true;
        this.$_addStyle2(book, wes);
        ctx.fixedWrapStyles = wes;
        if (grid instanceof GridView && grid.isRowGrouped()) {
            var rowGroup = grid.rowGroup();
            ctx.rowGroupHeadStyle = this.$_addStyle(book, rowGroup.headStyles());  // ??
            ctx.rowGroupFootStyle = this.$_addStyle(book, rowGroup.footStyles());  // 
            ctx.headerBarStyle = this.$_addStyle(book, rowGroup.headerBarStyles(), false);
            ctx.groupBarStyle = this.$_addStyle(book, rowGroup.headerStyles(), false);
            ctx.rowGroupHeaderStyle = this.$_addStyle(book, rowGroup.headerStyles(), false);
            ctx.rowGroupFooterStyle = this.$_addStyle(book, rowGroup.footerStyles(), true);
            ctx.rowGroupBarStyle = this.$_addStyle(book, rowGroup.barStyles());
            ctx.rowGroupHeaderStyles = [];
            ctx.rowGroupFooterStyles = [];
            ctx.rowGroupHeaderBarStyles = [];
            ctx.rowGroupFooterBarStyles = [];
            ctx.rowGroupBarStyles = [];
            var levels = rowGroup.levels();
            if (levels && _isArray(levels) && levels.length > 0) {
                for (var i = 0, cnt = ctx.rowLevels, levelCnt = levels.length-1; i < cnt; i++) {
                    // levels가 있는 경우 groupLevel보다 levels의 length가 작은 경우 levels의 마지막 style이 적용된다.
                    ctx.rowGroupHeaderStyles.push(this.$_addStyle(book, levels[Math.min(i, levelCnt)].headerStyles(), false));
                    ctx.rowGroupFooterStyles.push(this.$_addStyle(book, levels[Math.min(i, levelCnt)].footerStyles(), true));
                    ctx.rowGroupBarStyles.push(this.$_addStyle(book, levels[Math.min(i, levelCnt)].barStyles()));
                    ctx.rowGroupHeaderBarStyles.push(this.$_addStyle(book, levels[Math.min(i, levelCnt)].headerBarStyles(), false));
                    ctx.rowGroupFooterBarStyles.push(this.$_addStyle(book, levels[Math.min(i, levelCnt)].footerBarStyles(), true));
                }
            }
        }
    },
    $_buildColumns: function(workBook, ctx) {
        var i, es, ec, item, column;
        var grid = ctx.grid;
        var options = ctx.options;
        var book = workBook;
        var colArr = ctx.colArr;
        var index = 1; // 0이면 에러다.
        var columns = [];
        if (ctx.indicator) {
            es = ctx.indicatorStyle = this.$_addStyle(book, ctx.indicator.styles());
            ec = new ExcelColumn();
            ec.index = index++;
            ec.width = _round(grid.indicator().minWidth() / PIXELS_PER_CHAR);
            columns.push(ec);
        }
        if (options.isIndenting()) {
            if (ctx.rowGrouped && !ctx.mergedGrouped) {
                ctx.indents = ctx.rowLevels - (grid.rowGroup().expandedAdornments() === RowGroupAdornments.SUMMARY ? 0 : 1);
            } else if (grid instanceof TreeView) {
                ctx.indents = ctx.rowLevels - 1;
            }
            if (ctx.indents) {
                for (i = 0; i < ctx.indents; i++) {
                    ec = new ExcelColumn();
                    ec.width = Math.max(ctx.indentWidth, 1);
                    ec.index = index++;
                    columns.push(ec);
                }
                ctx.indentHeadStyle = this.$_addStyle(book, grid.header().styles());
                ctx.indentHeadSummaryStyle = this.$_addStyle(book, grid.header().summary().styles());
                ctx.indentFootStyle = this.$_addStyle(book, grid.footer().styles());
            }
        }
        var cols = colArr.colCount();
        for (i = 0; i < cols; i++) {
            item = colArr.getItem(0, i);
            column = item.column;
            /*
            es = ctx.columnStyles[column.$_hash];
            if (!es) {
                es = this.$_addStyle(book, column.styles());
            }
            */
            ec = new ExcelColumn();
            ec.index = index++;
            ec.width = _round( (options.isApplyFitStyle() ? column.displayWidth() : (column.groupWidth() || column.width())) / PIXELS_PER_CHAR);
            var ds = grid.dataSource();
            var fld = column instanceof DataColumn ? ds.getField(column.dataIndex()) : null;
            var fmt = column instanceof DataColumn ? column.excelFormat() : null;
            if ( (fld != null ) && (fmt || options._applyDefaultColumnFormat)) {
                es = this.$_createStyles(book, column.styles(), false,true,false);
                if (typeof fmt == "number" || _int(fmt) > 0)  {
                    es.formatId = fmt 
                } else {
                    switch( fld.dataType()) {
                        case ValueType.TEXT :
                            es.formatId = fmt ? workBook.addNumberFormat(fmt) : es.formatId ? es.formatId : ctx.textFormatId;
                            break;
                        case ValueType.NUMBER:
                            es.formatId = fmt ? workBook.addNumberFormat(fmt) : es.formatId ? es.formatId : ctx.numberFormatId;
                            break;
                        case ValueType.DATETIME:
                            es.formatId = fmt ? workBook.addNumberFormat(fmt) : es.formatId ? es.formatId : ctx.dateFormatId;
                            break;
                    }
                }
                this.$_addStyle2(book, es);
                ec.style = es;
            }
            columns.push(ec);
        }
        ctx.sheet.setColumns(columns);
    },
    $_buildDocumentTitle: function(workBook, ctx, startRow, col) {
        var grid = ctx.grid;
        var options = ctx.options;
        var book = workBook;
        var sheet = ctx.sheet;
        var es; 
        var colspan = sheet._columns.length;
        var title;
        var row = startRow;
        if ((title = options.documentTitle()) && title._visible) {
            row += title.spaceTop();
            var text = title.message();
            es = this.$_createStyles(book, title.styles());
            if (text && text.match($_linereg))
                es.wrapText = true;
            this.$_addStyle2(book, es);
            sheet.addText(row, col, text, es, title.height());
            sheet.addMerge(row, col, 1, colspan);
            for (var i = 1; i < colspan; i++) {
                sheet.addBlank(row, col + i, es);
            }
            row ++;
            row += title.spaceBottom();
        }
        if ((title = options.documentSubtitle()) && title._visible) {
            row += title.spaceTop();
            var text = title.message();
            es = this.$_createStyles(book, title.styles());
            if (text && text.match($_linereg))
                es.wrapText = true;
            this.$_addStyle2(book, es);
            sheet.addText(row, col, text, es, title.height());
            sheet.addMerge(row, col, 1, colspan);
            for (var i = 1; i < colspan; i++) {
                sheet.addBlank(row, col + i, es);
            }
            row ++;
            row += title.spaceBottom();
        }
        return row - startRow;

    },
    $_buildDocumentTail: function(workBook, ctx, startRow, col) {
        var grid = ctx.grid;
        var options = ctx.options;
        var book = workBook;
        var sheet = ctx.sheet;
        var es; 
        var colspan = sheet._columns.length;
        var tail;
        var row = startRow;
        if ((tail = options.documentTail()) && tail._visible) {
            row += tail.spaceTop();
            var text = tail.message();
            es = this.$_createStyles(book, tail.styles());
            if (text && text.match($_linereg))
                es.wrapText = true;
            this.$_addStyle2(book, es);
            sheet.addText(row, col, text, es, tail.height());
            sheet.addMerge(row, col, 1, colspan);
            for (var i = 1; i < colspan; i++) {
                sheet.addBlank(row, col + i, es);
            }
            row ++;
            row += tail.spaceBottom();
        }
        return row - startRow;
    },
    $_buildHeader: function(workBook, ctx, startRow, startCol) {
        var i, es, row, c; 
        var grid = ctx.grid;
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.headerRowCount();
        var ht = Math.max(grid._header.realHeight(), grid._header.minHeight() * rows);

        ht && (ht = ht * 0.75 / rows );
        var indents = ctx.indents;
        if (ctx.indicator) {
            es = this.$_addStyle(book, grid.indicator().headStyles());
            sheet.addText(startRow, startCol, ctx.indicatorHead, es);
            if (rows > 1) {
                for (i = 1; i < rows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, rows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < rows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, ctx.indentHeadStyle);
                }
                sheet.addMerge(startRow, c + startCol, rows, 1);
            }
            startCol += indents;
        }
        for (i = 0; i < rows; i++) {
            row = startRow + i;
            sheet.addRow(row, ht);            
            for (c = 0; c < cols; c++) {
                var item = colArr.getHeader(i, c);
                var column = item.column;
                var col = c + startCol;
                if (item.colIndex > 0 || item.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var h = column.header();
                    es = this.$_createStyles(book, h.styles());
                    var text = h.displayText();
                    var subText = h.subText();
                    var subLocation = h.subTextLocation();
                    if (subText) {
                        switch (subLocation) {
                            case SubTextLocation.NONE:
                            case SubTextLocation.DEFAULT:
                                break;
                            case SubTextLocation.LEFT:
                            case SubTextLocation.LEFT_FILL:
                                text = subText + " " + text;
                                break;
                            case SubTextLocation.RIGHT:
                            case SubTextLocation.RIGHT_FILL:
                                text = text + " " + subText;
                                break;
                            case SubTextLocation.UPPER:
                            case SubTextLocation.UPPER_FILL:
                                text = subText + "\r\n" + text;
                                break;
                            case SubTextLocation.LOWER:
                            case SubTextLocation.LOWER_FILL:
                            default:
                                text = text + "\r\n" + subText;
                                break;
                        }
                    }
                    if (text && text.match($_linereg))
                        es.wrapText = true;
                    this.$_addStyle2(book, es);
                    sheet.addText(row, col, text, es);
                    if (item.rowSpan > 1 || item.colSpan > 1) {
                        sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                    }
                }
            }
        }
        return rows;
    },
    $_buildSummary: function(workBook, isFooter, ctx, startRow, startCol) {
        // isFooter footer와 headerSummary를 구분.
        function addSummaryCell(row, col, column, summaryIndex, es) {
            var cell = grid.footer().getCell(grid.getIndex(-1, column), summaryIndex);
            var v = cell.value();
            if (v instanceof Date) {
                if (ctx.options._datetimeCallback) {
                    v = ctx.options._datetimeCallback(-1, column.name(), v);
                    if (v instanceof Date) {
                        sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                    } else {
                        sheet.addText(row, col, v, es);
                    }
                } else {
                    sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                }                
            } else if (!isNaN(v)) {
                sheet.addNumber(row, col, v, es);
            } else {
                if (v === undefined || typeof v == "number") {
                    sheet.addText(row, col, cell.displayText() || "", es);
                } else {
                    sheet.addText(row, col, v || "", es);
                }
            }         
        }
        var grid = ctx.grid;

        var summaryObject = isFooter ? grid.footer() : grid.header().summary();

        var mergeManager = isFooter ? grid.footerMergeManager() : grid.headerSummaryMergeManager();
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.dataRowCount();
        var indents = ctx.indents;
        var i, es, c, r;
        var summaryCnt = summaryObject.count();
        var mrows = summaryCnt * rows;
        var ht = summaryObject.realHeight();
        ht && (ht = ht * 0.75 / mrows);
        if (ctx.indicator) {
            es = this.$_addStyle(book, isFooter ? grid.indicator().footStyles() : grid.indicator().summaryStyles());
            sheet.addText(startRow, startCol, isFooter ? ctx.indicatorFoot : ctx.indicatorSummary, es);
            if (rows > 1 || summaryCnt > 1) {
                for (i = 1; i < mrows; i++) {
                    sheet.addBlank(startRow + i, startCol, es);
                }
                sheet.addMerge(startRow, startCol, mrows, 1);
            }
            startCol++;
        }
        if (indents > 0) {
            for (c = 0; c < indents; c++) {
                for (i = 0; i < mrows; i++) {
                    sheet.addBlank(i + startRow, c + startCol, isFooter ? ctx.indentFootStyle : ctx.indentHeadSummaryStyle);
                }
                sheet.addMerge(startRow, c + startCol, mrows, 1);
            }
            startCol += indents;
        }
        var row = startRow;
        for (r = 0; r < summaryCnt; r++) {
            for (i = 0; i < rows; i++) {
                sheet.addRow(row, ht);
                for (c = 0; c < cols; c++) {
                    var item = colArr.getItem(i, c);
                    var column = item.column;
                    var col = c + startCol;
                    if (item.colIndex > 0 || item.rowIndex > 0) {
                        sheet.addBlank(row, col, es);
                    } else {
                        var colIndex = column.displayIndex();
                        var room = null;
                        // if (column.parent() instanceof RootColumn) {
                            room = mergeManager.findRoomBy(column);
                            if (room && column == room.startColumn() && column != room.baseColumn()) {
                                // colItem = colArr.getItem(i, room.base()+colIndex-c);
                                // column = colItem.column; 
                                column = room.baseColumn();
                            }
                        // }
                        var f = summaryObject.getCell(grid.getIndex(-1,column), r);
                        es = this.$_addStyle(book, f.styles());
                        if (room) {
                            if (room.startColumn() == item.column) {
                                addSummaryCell(row, col, column, r, es);
                                sheet.addMerge(row, col, item.rowSpan, room.count());
                            } else {
                                sheet.addBlank(row, col, es);
                            }
                        } else {
                            addSummaryCell(row, col, column, r, es)
                            if (item.rowSpan > 1 || item.colSpan > 1) {
                                sheet.addMerge(row, col, item.rowSpan, item.colSpan);
                            }
                        }
                    }
                }
                row++;
            }
        }
        if (ctx.rowGrouped && !ctx.compatibility && ctx.showLevelOutline) {
            sheet.setRowLevel(row, 1);
        }
        return mrows;
    },

    $_buildHeaderSummary: function(workBook, ctx, startRow, startCol) {
        return this.$_buildSummary(workBook, false, ctx, startRow, startCol);
    },

	$_buildFooter: function(workBook, ctx, startRow, startCol) {
        return this.$_buildSummary(workBook, true, ctx, startRow, startCol);
	},
    $_buildIndicatorCell: function (workBook, ctx, no, startRow, startCol, rows, ht) {
        var grid = ctx.grid;
        var book = workBook;
        var sheet = ctx.sheet;
        var es = ctx.indicatorStyle ? ctx.indicatorStyle : this.$_addStyle(book, grid.indicator().styles());
        sheet.addNumber(startRow, startCol, no, es, ht);
        if (rows > 1) {
            for (var i = 1; i < rows; i++) {
                sheet.addBlank(startRow + i, startCol, es, ht);
            }
            sheet.addMerge(startRow, startCol, rows, 1);
        }
        return 1;
    },
    $_buildValueCell: function (workBook, ctx, row, col, item, column, r, startCol) {
        var grid = ctx.grid;
        var isFixedRow = item.index() >= 0 && item.index() < grid.fixedOptions().rowCount();
        var body = grid.body();
        var options = ctx.options;
        var sheet = ctx.sheet;
        var index = CellIndex.temp(grid, item.index(), column);
        var isDynamicStyles = false;
        var es = (column.isFixed() || isFixedRow) && grid.fixedOptions()._ignoreColumnStyles ? ctx.fixedStyles : ctx.columnStyles[column.$_hash];
        if ((options.isApplyDynamicStyles() && body.checkDynamicStyle(index, item)) ||(isFixedRow) ) {
            var numFmtId = es.formatId;
            es = this.$_createStyles(workBook, body.getCell(index, false, item)._styles);
            column._excelFormat && (es.formatId = numFmtId);
            this.$_addStyle2(workBook, es);
            isDynamicStyles = true;
        }
        if (column._blankWhenExport) {
            sheet.addBlank(row, col, es);
        } else if (column instanceof DataColumn) {
            var fld = column.dataIndex();
            var field = grid.dataSource().getField(fld);
            var v, displayCallback;
            var runtime = ctx.excelFormulaRuntime;
            var exprStatement = column._excelFormulaExprStatement;
            var excelFormula;
            if (exprStatement && r != null) {
                runtime.setItemIndex(row, startCol);
                runtime.setColumns(ctx.colArr._dataColumns[r]);
                excelFormula = exprStatement.evaluate(runtime);
            }
            if (field) {
                v = item.getData(fld);
                displayCallback = column.displayCallback && column.displayCallback();
                switch (field.dataType()) {
                case "number":
                    if (options._numberCallback || displayCallback) {
                        v = options._numberCallback ? options._numberCallback(item.index(), column.name(), v) : displayCallback(grid.getHandler(), index.proxy(), v);
                    };
                    if (v != null || excelFormula) {
                        if (typeof v == "number" || excelFormula) {
                            sheet.addNumber(row, col, v, es, undefined, excelFormula)
                        } else {
                            v == null ? sheet.addBlank(row, col, es) : sheet.addText(row, col, v, es);
                        }
                    } else {
                        sheet.addBlank(row, col, es);
                    }
                    break;
                case "datetime":
                case "date":
                    if (v) {
                        if (options._datetimeCallback || displayCallback) {
                            v = options._datetimeCallback ? options._datetimeCallback(item.index(), column.name(), v) : displayCallback(grid.getHandler(), index.proxy(), v);
                            if (v instanceof Date) {
                                sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                            } else {
                                sheet.addText(row, col, v, es);
                            }
                        } else {
                            sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                        }
                    } else if (options._nullDateText) {
                        sheet.addText(row, col, options._nullDateText, es);
                    } else {
                        sheet.addBlank(row,col,es);
                    }
                    break;
                case "boolean":
                    if (options._booleanCallback || displayCallback) {
                        v = options._booleanCallback ? options._booleanCallback(item.index(), column.name(), v) : displayCallback(grid.getHandler(), index.proxy(), v);
                        sheet.addText(row, col, v, es);
                    } else if (options._booleanFormatter) {
                        v = options._booleanFormatter.formatValue(v);
                        sheet.addText(row, col, v, es);
                    } else {
                        sheet.addBool(row, col, v, es);
                    }
                    break;
                case "object":
                    if (v) {
                        var cb = options._objectCallback;
                        var key = column._objectKey;
                        var fn = column._objectCallback;
                        var os = es && es.clone();
                        var book = workBook;
                        os.id = es.id;
                        v = cb ? cb(item.index(), column.name(), v) : fn ? fn(field.orgFieldName(), item.dataRow(), v) : key && v.hasOwnProperty(key) ? v[key] : displayCallback ? displayCallback(grid.getHandler(), index.proxy(), v) : v; 
                        if (typeof v == "number") { // formatId가 변경되면 style.id도 변경되어야 한다.
                            os.formatId = ctx.numberFormatId;
                            book.addStyle(os);
                            sheet.addNumber(row, col, v, os);   
                        } else if (v instanceof Date) {
                            os.formatId = ctx.dateFormatId;
                            book.addStyle(os);
                            sheet.addDate(row, col, v, os, undefined, undefined, ctx.compatibility);
                        } else if (v) {
                            os.formatId = ctx.textFormatId;
                            book.addStyle(os);
                            sheet.addText(row, col, v, os);
                        } else { // v가 null인경우.
                            os.formatId = ctx.textFormatId;
                            book.addStyle(os);
                            sheet.addBlank(row, col, os);
                        }
                    } else {
                        sheet.addBlank(row, col, es);
                    }
                    break;
                default:  
                    var gcell = body.getCellSimple(index);
                    var exportText;
                    var exp, rep;
                    if (options._lookupDisplay && (column.labelField() || column.isLookupDisplay())) {
                        exportText = gcell instanceof DataCell ? DataCell._displayText(item, column) : gcell.getTextFromItem(item);
                    } else if (v) {
                        if (options.isCheckNumber()) {
                            v = Number(v);
                            if (!isNaN(v)) {
                                sheet.addNumber(row, col, v, es);
                                break;
                            } else {
                                exportText = "";
                            }
                        } else {
                            exportText = (exp = column.getDisplayRegExp()) && (rep = column.displayReplace()) ? v.replace(exp, rep) : v;
                        }
                    } else {
                        exportText = "";
                    }
                    exportText = options._textCallback ? options._textCallback(item.index(), column.name(), exportText) : displayCallback && (!rep || !rep) ? displayCallback(grid.getHandler(), index.proxy(), v) : exportText;
                    if (typeof exportText === "number") {
                        sheet.addNumber(row, col, exportText, es);
                    } else {
                        if (exportText && exportText.match($_linereg)) {
                            if (isDynamicStyles) {
                                es.wrapText = true;
                            } else {
                                es = (column.isFixed()||isFixedRow) && grid.fixedOptions()._ignoreColumnStyles ? ctx.fixedWrapStyles : ctx.columnWrapStyles[column.$_hash];
                            }
                        }

                        if (exportText && options.isExportLink() && column.rendererObj() instanceof LinkCellRenderer && !column.excelFormat()) {
                            var link = column.rendererObj()._getUrl(index);
                            sheet.addLink(row, col, exportText, link, es);
                        } else if (!exportText) {
                            sheet.addBlank(row, col, es);
                        } else {
                            sheet.addText(row, col, exportText, es);
                        }
                    }
                    break;
                }
            } else {
                sheet.addBlank(row, col, es);
            }
        } else if (column instanceof SeriesColumn) {
            var sr = column.rendererObj();
            if (sr instanceof SeriesTextCellRenderer) {
                this._seriesCell.setIndex(index);
                var vals = this._seriesCell.value();
                if (vals) {
                    var s = SeriesCell.getText(vals);
                    sheet.addText(row, col, s, es);
                } else {
                    sheet.addBlank(row, col, es);    
                }
            } else {
                var colArr = ctx.colArr;
                if (options.isExportSeriesColumn() && sr instanceof SparkChartRenderer && colArr._sparkColumns[column.$_hash]) {
                    sheet.addSparkLine(row, col, startCol, colArr._sparkColumns[column.$_hash], es);
                } else {
                    sheet.addBlank(row, col, es);
                }
            }
        }
    },
    // merged RowGrouping상태에서 HeaderRow왼쪽 컬럼의 style은 위쪽 셀의 스타일을 따라가야 한다.
    $_findPrevCellStyle: function(sheet, r, c) {
        var row = sheet._dataRows[r];
        var cols = row ? row.childNodes() : null;
        if (!cols) return null;
        var ref = _excelColCaption(c)+(r+1);
        for (var i = 0, cnt=cols.length; i < cnt; i++) {
            if (cols[i]._attributes && cols[i]._attributes["r"] == ref) {
                var s = cols[i]._attributes["s"];
                return s ? {id:s} : null;
            }
        }
        return null;
    },
    $_buildRow: function (workBook, ctx, item, startRow, startCol, no) {
        var c;
        var grid = ctx.grid;
        var rowGroup = grid.rowGroup();
        var addi = rowGroup.expandedAdornments() === RowGroupAdornments.SUMMARY ? 0 : 1;
        var isSummary = rowGroup.expandedAdornments() === RowGroupAdornments.SUMMARY && rowGroup.isMergeMode();
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var rows = colArr.dataRowCount();
        var cols = colArr.colCount();
        var colStyles = ctx.columnStyles;
        var groupBarStyles = ctx.rowGroupBarStyle;
        var lm = grid.layoutManager();
        var defHt = ctx.defHt;
        var ht = (item && item.dataId && lm._itemHeights[item.dataId()]) || defHt;
        var columnMerged = ctx.columnMerged;
        var mergeHeads = ctx.mergeHeads;
        var indents = ctx.indents;
        var level = item.level();
        var parent;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(workBook, ctx, no, startRow, startCol, rows, ht);
        }
        for (var r = 0; r < rows; r++) {
            var row = startRow + r;
            var start = startCol;
             sheet.addRow(row, ht);
            for (c = 0; c < indents; c++) {
                if (ctx.rowGroupBarStyles && ctx.rowGroupBarStyles.length > 0) {
                    sheet.addBlank(row, start, ctx.rowGroupBarStyles[Math.min(c+addi, ctx.rowGroupBarStyles.length-1)])
                } else {
                    sheet.addBlank(row, start, groupBarStyles);    
                }
                start++;
            }
            for (c = 0; c < cols; c++) {
                var col = c + start;
                var colItem = colArr.getItem(r, c);
                var column = colItem.column;
                var es = colStyles[column.$_hash];
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    var rowSpan = colItem.rowSpan;
                    var colSpan = colItem.colSpan;
                    var celled = false;
                    if (columnMerged) { 
                        var index = CellIndex.temp(grid, item.index(), column);
                        var room = lm.getMergedCell(index);
                        if (room) {
                            if ((room.isHead(index) && r == 0) || (ctx.start > 0 && item.index() == ctx.start) && !isSummary) {
                                this.$_buildValueCell(workBook, ctx, row, col, item, column, r, start);
                                mergeHeads[column.$_hash] = row;
                                celled = true;
                            } else {
                                var prevRow = row - 1 < 0 ? 0 : row - 1;
                                var tmpEs = this.$_findPrevCellStyle(sheet, prevRow, col);
                                sheet.addBlank(row, col, tmpEs ? tmpEs : es, ht);
                                if (room.isTail(index) || (ctx.last > 0 && item.index() == ctx.last - 1)) {
                                    rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                    sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);
                                    delete mergeHeads[column.$_hash];
                                }
                                celled = true;
                            }
                        } else if (ctx.allItems && !item.isVisible()) {
                            if (grid.isGroupedColumn(column) && ctx.mergedGrouped) {
                                sheet.addBlank(row, col,es);
                                celled = true;
                                parent = item.parent();
                                while(column.groupLevel() != parent.level() && parent) {
                                    parent = parent.parent();
                                }
                                switch(rowGroup.expandedAdornments()) {
                                    case RowGroupAdornments.NONE :
                                        if (item == parent.firstItem() && item == parent.lastDataItem()) {
                                            celled = false;
                                        } else if (item == parent.firstItem()) {
                                            this.$_buildValueCell(workBook, ctx, row, col, item, column,r, start);
                                            mergeHeads[column.$_hash] = row;
                                        } else if (item == parent.lastDataItem()) {
                                            rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                            sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);
                                        }
                                        break;
                                    case RowGroupAdornments.BOTH :
                                        if (item == parent.lastDataItem() && !parent.footer().isVisible() && !parent._hasFooter) {
                                            rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                            sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);
                                        } else {
                                            celled = ctx.mergedGrouped;
                                        }                                    
                                        // 따로 처리하지 않아도 buildHeader, buildFooter등에서 처리한다.
                                        break;
                                    case RowGroupAdornments.HEADER :
                                    case RowGroupAdornments.SUMMARY :
                                        if (item == parent.firstItem() && item == parent.lastDataItem()) {
                                            if (mergeHeads[column.$_hash]) {
                                                rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                                sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);   
                                                delete mergeHeads[column.$_hash];
                                            } else {
                                                celled = false;
                                            }
                                        } else if (item == parent.lastDataItem()) {
                                            rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                            sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);   
                                            delete mergeHeads[column.$_hash];
                                        } else if (item === parent.firstDataItem() && !parent._hasFooter && !mergeHeads[column.$_hash]) {
                                            this.$_buildValueCell(workBook, ctx, row, col, item, column,r, start);
                                            mergeHeads[column.$_hash] = row;
                                        }
                                        break;
                                    case RowGroupAdornments.FOOTER :
                                        if (item == parent.firstItem()) {
                                            this.$_buildValueCell(workBook, ctx, row, col, item, column,r, start);
                                            mergeHeads[column.$_hash] = row;
                                        } 
                                        if (item == parent.lastDataItem()) {
                                            if (parent.lastItem(true) instanceof GroupFooter) {

                                            } else {
                                                rowSpan = (row - mergeHeads[column.$_hash]) + rows;
                                                sheet.addMerge(mergeHeads[column.$_hash], col, rowSpan, 1);
                                                delete mergeHeads[column.$_hash]
                                            }
                                        }
                                        break;
                                }
                            }
                        }
                    }
                    if (!celled) {
                        this.$_buildValueCell(workBook, ctx, row, col, item, column,r, start);
                        if (rowSpan > 1 || colSpan > 1) {
                            sheet.addMerge(row, col, rowSpan, colSpan);
                        }
                    }
                }
            }
            if (ctx.rowGrouped && !ctx.compatibility && ctx.showLevelOutline) {
                sheet.setRowLevel(row, item.level());
            }
        }
        return rows;
    },
    $_buildGroupItem: function (workBook, ctx, item, startRow, startCol, no) {
        var grid = ctx.grid;
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var level = item.level() - 1;
        var groupBarStyles = ctx.rowGroupBarStyle;
        var defHt = ctx.defHt;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(workBook, ctx, no, startRow, startCol, 1);
        }
        if (ctx.options.isIndenting()) {
            for (var c = 0; c < level; c++) {
                if (ctx.rowGroupBarStyles && ctx.rowGroupBarStyles.length > 0) {
                    sheet.addBlank(startRow, startCol, ctx.rowGroupBarStyles[Math.min(c+1, ctx.rowGroupBarStyles.length-1)]);
                } else {
                    sheet.addBlank(startRow, startCol, groupBarStyles);
                }
                startCol++;
            }
        }
        var s = grid.rowGroup().getHeaderText(item);//.getHeadCell(level).displayText;
        sheet.addRow(startRow, defHt);
        if (ctx.rowGroupHeaderStyles && ctx.rowGroupHeaderStyles.length > 0) {
            sheet.addText(startRow, startCol, s, ctx.rowGroupHeaderStyles[level])
        } else {
            sheet.addText(startRow, startCol, s, ctx.rowGroupHeaderStyle);
        }
        if (ctx.indents > 0) {
            cols += ctx.indents - (item.level()-1);
        }
        for (var i = 1; i < cols; i++) {
            sheet.addBlank(startRow, i + startCol, ctx.rowGroupHeaderStyle);
        }
        sheet.addMerge(startRow, startCol, 1, cols);
        if (ctx.rowGrouped && !ctx.compatibility && ctx.showLevelOutline) {        
            sheet.setRowLevel(startRow, item.level());
        }
        return 1;
    },
    $_buildGroupFooter: function (workBook, ctx, item, startRow, startCol, no) {
        function addGroupFooterCell(row, col, column, es) {
            var v = RowGroupFooterCell.getValue(item, column);
            if (v instanceof Date) {
                if (ctx.options._datetimeCallback) {
                    v = ctx.options._datetimeCallback(item.index(), column.name(), v);
                    if (v instanceof Date) {
                        sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                    } else {
                        sheet.addText(row, col, v, es);
                    }
                } else {
                    sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                }
            } else if (typeof v == "string") {
                sheet.addText(row, col, v, es);
            } else if (isNaN(v)) {
                var itemId = item.index();
                var text = v;
                var groupText;
                if (itemId > -1) {
                    var index = CellIndex.temp(grid, itemId, column);
                    var cell = rowGroup.getFooterCell(index);
                    if (v === undefined || typeof v == "number") {
                        text = cell.displayText() || "";
                    } else {
                        text = v;
                    }
                } else if (groupText = column.footer().groupText()) {
                    text = groupText;
                }
                sheet.addText(row, col, text, es);
            } else {
                sheet.addNumber(row, col, v, es);
            }
        }
        var c, col, colItem, column, es;
        var grid = ctx.grid;
        var rowGroup = grid.rowGroup();
        var fixedRows = grid.fixedOptions().rowCount();
        var mergeManager = grid.groupFooterMergeManager();
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var firstColumn = colArr.getItem(0, 0).column;
        var firstCell = CellIndex.temp(grid, item.index(), firstColumn);
        var rows = colArr.dataRowCount();
        var cols = colArr.colCount();
        var footerStyles = ctx.rowGroupFooterStyle;
        var groupBarStyles = ctx.rowGroupBarStyle;
        var indents = ctx.indents;
        var level = item.level();
        var groupLevels = grid.rowGroup().levels();
        var srcStyles = groupLevels.length > 0 ? groupLevels[Math.min(groupLevels.length-1, Math.max(level-2,0))].footerStyles() : grid.rowGroup().footerStyles();
        var isSummary = grid._rowGroup._expandedAdornments == RowGroupAdornments.SUMMARY;
        var lm = grid.layoutManager();
        var defHt = ctx.defHt;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(workBook, ctx, no, startRow, startCol, rows);
        }
        for (var r = 0; r < rows; r++) {
            var row = startRow + r;
            var start = startCol;
            if (indents > 0) {
                column = firstColumn;
                for (c = 0; c < indents; c++) {
                    if (ctx.rowGroupFooterBarStyles && ctx.rowGroupFooterBarStyles.length > 0) {
                        if (isSummary) {
                            if (c < level-2) {
                                sheet.addBlank(row, start, ctx.rowGroupBarStyles[c]);
                            } else if (c == level-2) {
                                sheet.addBlank(row, start, ctx.rowGroupFooterBarStyles[level-2]);
                            } else {
                                sheet.addBlank(row, start, ctx.rowGroupFooterStyles[level-2])
                            }
                        } else {
                            if (c < level-2) {
                                sheet.addBlank(row, start, ctx.rowGroupBarStyles[Math.min(c+1, ctx.rowGroupBarStyles.length-1)]);
                            } else {
                                sheet.addBlank(row, start, ctx.rowGroupFooterBarStyles[level-2]);
                            }
                        }
                    } else {
                        if (isSummary) {
                            if (c < level-2) {
                                sheet.addBlank(row, start, groupBarStyles);
                            } else {
                                sheet.addBlank(row, start, footerStyles);    
                            }
                            
                        } else {
                            sheet.addBlank(row, start, groupBarStyles);
                        }
                    }
                    if (r == 0 && rows > 1) {
                        sheet.addMerge(row, start, rows, 1);
                    }
                    start++;
                }
            }
            var rootCol = firstColumn.root();
            var rc = -1;
            sheet.addRow(row, defHt);
            for (var c = 0; c < cols; c++) {
                col = c + start;
                colItem = colArr.getItem(r, c);
                column = colItem.column;
                if (!column.group() || column.root() != rootCol) {
                    rootCol = column.root();
                    rc++;
                }
                var room = mergeManager.findRoom(level-1, rc);
                if (room && rc == room.start() && rc != room.base()) {
                    colItem = colArr.getItem(r, room.base()+(c-rc));
                    column = colItem.column;
                }
                if (ctx.rowGroupFooterStyles && ctx.rowGroupFooterStyles.length > 0) {
                    es = ctx.rowGroupFooterStyles[item.level()-2]
                } else {
                    es = null;
                }
                if (!es || column.footer().groupStyles()._values.length > 0) {
                    var fs = footerStyles[level] = footerStyles[level] ? footerStyles[level] : {};
                    es = fs[column.$_hash];
                    if (!es) {
                        var f = column.footer();
                        this._runStyles.assign(f.groupStyles());
                        this._runStyles.copy(f.styles());
                        this._runStyles.setParent(srcStyles);
                        es = this.$_addStyle(book, this._runStyles);
                        footerStyles[level][column.$_hash] = es;
                    }
                }
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    if (room) {  // room을 찾았으면 
                        if (room.start() == rc) {
                            addGroupFooterCell(row, col, column, es);
                            sheet.addMerge(row, col, colItem.rowSpan, room.count());
                        } else {
                            sheet.addBlank(row, col, es);
                        }
                    } else {
                        addGroupFooterCell(row, col, column, es);
                        if (colItem.rowSpan > 1 || colItem.colSpan > 1) {
                            sheet.addMerge(row, col, colItem.rowSpan, colItem.colSpan);
                        }
                    } 
                }
                if (ctx.rowGrouped && !ctx.compatibility && ctx.showLevelOutline) {
                    sheet.setRowLevel(row, item.level());
                }
            }
        }
        return rows;
    },
    $_buildMergedGroupHeader: function (workBook, ctx, item, startRow, startCol, no) {
        var grid = ctx.grid;
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var level = item.level();
        var defHt = ctx.defHt;
        var rowGroupHeaderStyle = ctx.rowGroupHeaderStyles && ctx.rowGroupHeaderStyles.length > 0 ? ctx.rowGroupHeaderStyles[level-1] :  ctx.rowGroupHeaderStyle;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(workBook, ctx, no, startRow, startCol, 1);
        }
        for (var c=0;c<level-1;c++) {
            sheet.addBlank(startRow, startCol+c, this.$_findPrevCellStyle(sheet, startRow-1,startCol+c));
        }
        if (ctx.columnMerged) {
            var col = level - 1;
            var column = colArr.getItem(0, col).column;
            this.$_buildValueCell(workBook, ctx, startRow, startCol + col, item.firstItem(), column);
            ctx.mergeHeads[column.$_hash] = startRow;
        }
        var s = grid.rowGroup().getHeaderText(item);
        var c = startCol + level;
        sheet.addRow(startRow, defHt);
        level < colArr.colCount() && sheet.addText(startRow, c++, s, rowGroupHeaderStyle);
        for (; c < cols + startCol; c++) {
            sheet.addBlank(startRow, c/* + startCol*/, rowGroupHeaderStyle);
        }
        cols - level > 1 && sheet.addMerge(startRow, level + startCol, 1, cols - level);
        return 1;
    },
    $_buildMergedGroupFooter: function (workBook, ctx, item, startRow, startCol, no) {
        function addMergedGroupFooterCell(row, col, column, es) { 
            var v = RowGroupFooterCell.getValue(item, column);
            if (v instanceof Date) {
                if (ctx.options._datetimeCallback) {
                    v = ctx.options._datetimeCallback(item.index(), column.name(), v);
                    if (v instanceof Date) {
                        sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                    } else {
                        sheet.addText(row, col, v, es);
                    }
                } else {
                    sheet.addDate(row, col, v, es, undefined, undefined, ctx.compatibility);
                }
            } else if (typeof v === "string") {
                sheet.addText(row, col, v, es);
            } else if (isNaN(v)) {
                var itemId = item.index();
                var text = RowGroupFooterCell.$_displayText(item, column, v) || "";
                sheet.addText(row, col, text, es);
            } else {
                sheet.addNumber(row, col, v, es);
            }
        }

        var r, c, column, es, row, col, colItem;
        var grid = ctx.grid;
        var rowGroup = grid.rowGroup();
        var isSummary = rowGroup._expandedAdornments == RowGroupAdornments.SUMMARY;
        var mergeManager = grid.groupFooterMergeManager();
        var book = workBook;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var firstColumn = colArr.getItem(0, 0).column;
        var rows = colArr.dataRowCount();
        var cols = colArr.colCount();
        var srcStyles = grid.rowGroup().footerStyles();
        var footerStyles = ctx.rowGroupFooterStyle;
        var colStyles = ctx.columnStyles;
        var showRow = ctx.options.isIndicatorDataRow(grid);
        var level = item.level() - 1;
        var lm = grid.layoutManager();
        var defHt = ctx.defHt;
        if (ctx.indicator) {
            startCol += this.$_buildIndicatorCell(workBook, ctx, no, startRow, startCol, rows);
        }
        for (c = 0; c < level; c++) {
            column = colArr.getItem(0, c).column;
            es = colStyles[column.$_hash];
            if (ctx.allItems || item.parent().isExpanded()) {
                for (r = 0; r < rows; r++) {
                    if (isSummary && r == 0) {
                        var parent = item.parent();
                        while ( parent && column.groupLevel() != parent.level() ) {
                            parent = parent.parent();
                        }
                        if (parent && parent.firstVisibleItem(isSummary) === item) {
                            this.$_buildValueCell(workBook, ctx, startRow, startCol + c, item.parent().firstItem(), column);
                        } else {
                            sheet.addBlank(startRow + r, startCol + c, es);    
                        }
                    } else {
                        sheet.addBlank(startRow + r, startCol + c, es);
                    }
                }
                if (ctx.columnMerged) {
                    if (!isSummary) {
                        if (item.isVisible()) {
                            var merges = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
                            var room = merges && merges.findRoom(item.index());
                            if (room && room.tail() === item.index()) {
                                r = ctx.mergeHeads[column.$_hash];
                                sheet.addMerge(r, c + startCol, startRow + rows - r, 1);
                            }
                        } else {
                            var parent = item.parent();
                            while ( parent && column.groupLevel() != parent.level() ) {
                                parent = parent.parent();
                            };
                            if (parent && parent.lastItem(true) === item) {
                                r = ctx.mergeHeads[column.$_hash];
                                sheet.addMerge(r, c + startCol, startRow + rows - r, 1);
                            }
                        }
                    } else if (!ctx.mergeHeads[column.$_hash]) {
                        ctx.mergeHeads[column.$_hash] = startRow;
                    } else if (column.groupLevel() === level) {
                        ctx.mergeHeads[column.$_hash] = startRow;
                    }
                }                
            } else {
                for (r = 0; r < rows; r++) {
                    this.$_buildValueCell(workBook, ctx, startRow + r, startCol + c, item.parent().firstItem(), column);
                }
            }
        }
        for (r = 0; r < rows; r++) {
            row = startRow + r;
            sheet.addRow(row, defHt);
            for (c = level; c < cols; c++) {
                col = c + startCol;
                colItem = colArr.getItem(r, c);
                column = colItem.column;
                var room = mergeManager.findRoom(level, c);
                if (room && c != room.base()) {
                    colItem = colArr.getItem(r, room.base());
                    column = colItem.column; 
                }
                if (ctx.rowGroupFooterStyles && ctx.rowGroupFooterStyles.length > 0) {
                    es = ctx.rowGroupFooterStyles[item.level()-2]
                } else {
                    es = null;
                }
                if (!es || column.footer().groupStyles()._values.length > 0) {
                    var fs = footerStyles[level] = footerStyles[level] ? footerStyles[level] : {};
                    es = fs[column.$_hash];
                    if (!es) {
                        var f = column.footer();
                        this._runStyles.assign(f.groupStyles());
                        this._runStyles.copy(f.styles());
                        this._runStyles.setParent(srcStyles);
                        es = this.$_addStyle(book, this._runStyles);
                        footerStyles[level][column.$_hash] = es;
                    }
                }
                if (colItem.colIndex > 0 || colItem.rowIndex > 0) {
                    sheet.addBlank(row, col, es);
                } else {
                    if (room) {
                        if (room.start() == c) {
                            addMergedGroupFooterCell(row, col, column, es);
                            sheet.addMerge(row, col, rows, room.count());
                        } else {
                            sheet.addBlank(row, col, es);
                        }
                    } else {
                        addMergedGroupFooterCell(row, col, column, es);
                        if (colItem.rowSpan > 1 || colItem.colSpan > 1) {
                            sheet.addMerge(row, col, colItem.rowSpan, colItem.colSpan);
                        }
                    }
                }
                if (ctx.rowGrouped && !ctx.compatibility && ctx.showLevelOutline) {
                    sheet.setRowLevel(row, level);
                }
            }
        }
        return rows;
    },
    $_buildItemsAsync: function(workBook, ctx, startRow, startCol, done) {
        var showRow = ctx.options.isIndicatorDataRow(ctx.grid);
        this.$_buildItemAsync(workBook, ctx, startRow, startCol, showRow, ctx.start, done);
    },
    $_buildItemAsync: function(workBook, ctx, startRow, startCol, showRow, index, done) {
        var grid = ctx.grid;
        var showRow = ctx.options.isIndicatorDataRow(grid);
        var allItems = ctx.allItems;

        var stepLast = index + Math.min(this._progressStep, ctx.last-index);
        var row = startRow;
        for (var i = index; i < stepLast; i++) {
            var item = allItems ? allItems[i] : grid.getItem(i);

            if (item instanceof GridRow) {
                row += this.$_buildRow(workBook, ctx, item, row, startCol, showRow ? item.dataRow() : i + 1);
            } else if (item instanceof GroupItemImpl) {
                row += this.$_buildGroupItem(workBook, ctx, item, row, startCol, i + 1);
            } else if (item instanceof MergedGroupHeader) {
                row += this.$_buildMergedGroupHeader(workBook, ctx, item, row, startCol, i + 1);
            } else if (item instanceof MergedGroupFooter) {
                row += this.$_buildMergedGroupFooter(workBook, ctx, item, row, startCol, i + 1);
            } else if (item instanceof GroupFooter) {
                row += this.$_buildGroupFooter(workBook, ctx, item, row, startCol, i + 1);
            } else {
                throw "Unkown item type";
            };
            this._progressPos += 1;
        };
        ctx.row = row;
        this.setProgress(this._progressPos);
        index = stepLast;
        if (index >= ctx.last) {
            done();
        } else {
            setTimeout(function() {
                this.$_buildItemAsync(workBook, ctx, row, startCol, showRow, index, done)
            }.bind(this), 0);
        }
    },
    $_buildItems: function (workBook, ctx, startRow, startCol) {
        var grid = ctx.grid;
        var showRow = ctx.options.isIndicatorDataRow(grid);
        var allItems = ctx.allItems;

        var row = startRow;
        for (var i = ctx.start; i < ctx.last; i++) {
            var item = allItems ? allItems[i] : grid.getItem(i);

            if (item instanceof GridRow) {
                row += this.$_buildRow(workBook, ctx, item, row, startCol, showRow ? item.dataRow() : i + 1);
            } else if (item instanceof GroupItemImpl) {
                row += this.$_buildGroupItem(workBook, ctx, item, row, startCol, i + 1);
            } else if (item instanceof MergedGroupHeader) {
                row += this.$_buildMergedGroupHeader(workBook, ctx, item, row, startCol, i + 1);
            } else if (item instanceof MergedGroupFooter) {
                row += this.$_buildMergedGroupFooter(workBook, ctx, item, row, startCol, i + 1);
            } else if (item instanceof GroupFooter) {
                row += this.$_buildGroupFooter(workBook, ctx, item, row, startCol, i + 1);
            } else {
                throw "Unkown item type";
            }
        }
        return row - startRow;
    },
	$_export: function (parts, options) {
        function saveLocal(blob) {
                if(window.navigator.msSaveOrOpenBlob) { //navigator.appVersion.toString().indexOf('.NET') > 0
                    window.navigator.msSaveOrOpenBlob(blob, filename);
                } else if (window.navigator.msSaveBlob) {
                    window.navigator.msSaveBlob(blob, filename);
                } else {
                    var a = document.createElement("a");
                    document.body.appendChild(a);
                    var url = URL.createObjectURL(blob);
                    a.href = url;
                    a.download = filename;
                    a.click();
                    document.body.removeChild(a);
                }
        }
        function saveServer(base64) {
                var url = options.url();
                var formtag = '<form name="tempForm" action="' + url + '" method="post">';
                formtag += '<input type="hidden" name="fileName" value = "' + filename + '"/>';
                formtag += '<input type="hidden" name="data" value = "' + base64 + '"/>';
                if (params) {
                    for (var key in params) {
                        formtag += '<input type="hidden" name="'+key+'" value = "' + params[key] + '"/>';
                    }
                }
                formtag += '<input id="submitBtn" type="submit"/>';
                formtag += '</form>';
                var div = document.createElement('div');
                div.innerHTML = formtag;
                document.body.appendChild(div);
                document.getElementById("submitBtn").click();
                document.body.removeChild(div);
        }
        var filename = options.fileName() || "realgrid.xlsx";
        var params = options.params();
        var local = options.target() == "local";
        if (JSZip.support.blob || !local) {
            var zip = new JSZip();
            for (var i = 0; i < parts.length; i++) {
                var s = parts[i].body;
                s.indexOf("xmlns=\"\"") >= 0 && (s = s.replace(/ xmlns=""/g, '').replace(/xmlns=""/g, ''));
                zip.file(parts[i].key, s);
            }
            if (local) {
                if (zip.generateAsync) {
                    zip.generateAsync({type: "blob", compression: "DEFLATE"})
                    .then(function(blob) {
                        saveLocal(blob);
                    });
                } else {
                    saveLocal(zip.generate({type: "blob", compression: "DEFLATE"}));
                }
            } else if (options.target() === "file" || options.target() === "string") {
                if (zip.generateAsync) {
                    zip.generateAsync({type: "base64", compression: "DEFLATE"})
                    .then(function(base64) {
                        options._done && typeof options._done == "function" && options._done(base64);
                    });
                } else {
                    var base64 = zip.generate({type: "base64", compression: "DEFLATE"});
                    options._done && typeof options._done == "function" && options._done(base64);
                }
            } else {
                if (zip.generateAsync) {
                    zip.generateAsync({type: "base64", compression: "DEFLATE"})
                    .then(function(base64) {
                        saveServer(base64);
                    });
                } else {
                    saveServer(zip.generate({type: "base64", compression: "DEFLATE"}));
                }
            }
        } else {
            alert("not supported on this browser");
        }
    }    
});
var GridHtmlExporter = defineClass("GridHtmlExporter", null, {
    init: function () {
        this._super();
        this._runStyles = new VisualStyles();
        this._seriesCell = new SeriesCell();
    },
    "export": function (grid, options/*GridExportOptions*/) {
        if (!grid) return;
        options = options instanceof GridExportOptions ? options : new GridExportOptions(options);
        var context = {
            grid: grid,
            options: options,
            indicator: options.isIndicatorVisible(grid) ? grid.indicator() : null,
            checkBar: options.isCheckBarVisible(grid) ? grid.checkBar() : null,
            checkMark: options.checkMark(),
            header: options.isHeaderVisible(grid) ? grid.header() : null,
            headerSummary: options.isHeaderSummaryVisible(grid) ? grid.header().summary() : null,
            footer: options.isFooterVisible(grid) ? grid.footer() : null,
            colArr: new ColumnArray(grid, options.isLinear()),
            allItems: null,
            indicatorHead: grid.indicator().headText() || "",
            indicatorFoot: grid.indicator().footText() || "",
            checkBarHead: grid.checkBar().headText() || "",
            checkBarFoot: grid.checkBar().footText() || "",
            indicatorSummary: grid.indicator().summaryText(),
            rowGrouped: false,
            rowLevels: 0,
            indents: 0,
            indentWidth: 3,
            columnMerged: false,
            mergeHeads: {},
            showProgress: options.isShowProgress(),
            progressMessage:options.progressMessage() || "Exporting...",
            progressMax: 0,
            prepareProgress: 10,
            setProgress: function (pos) { grid.setExportProgress(this.progressMax, pos+this.prepareProgress, this.progressMessage); }
        };
        context.sheet = new HtmlSheet();
        var t = getTimer();
        var self = this;
        var finalize = function () {
            var result;
            var html = context.sheet.serialize();
            var done = options.done();
            done && done(html);
        }
        
        if (grid instanceof TreeView) {
            throw new Error("Tree는 Html Export기능이 지원되지 않습니다.");
            
            if (options.isAllItems()) {
                context.allItems = grid.getAllItems();
            }
            this.$_buildTreeDocument(context, finalize);
        } else {
            if (grid.isRowGrouped()) {
                throw new Error("RowGrouping상태에서는 Html Export기능이 지원되지 않습니다.");
            }
            if (options.isAllItems() && grid.isRowGrouped()) {
                context.allItems = grid.getAllItems();
                var fixed = grid.layoutManager().fixedItemCount();
                if ( fixed > 0) {
                    for (var i=0; i<fixed; i++) {
                        context.allItems.splice(i,0,grid.getItem(i));
                    }
                }
            }
            this.$_buildDocument(context, finalize);
        }

        var t1 = getTimer();
        t = t1 - t;
        _trace("H T M L: " + "buildBook " + t);
    },
    $_buildDocument: function (ctx, done) {
        var t = getTimer();

        var grid = ctx.grid;
        ctx.rowGrouped = grid.isRowGrouped();
        ctx.mergedGrouped = grid.isMergedRowGrouped()
        if (ctx.rowGrouped && !grid.rowGroup().isMergeMode()) {
            ctx.rowLevels += grid.rowGroupLevels();
        }
        ctx.start = 0;
        var allItems = ctx.allItems;
        var rows = allItems ? allItems.length : grid.itemCount();
        if (!grid.isRowGrouped()) {
            ctx.start = ctx.options.start() > 0 ? ctx.options.start() : 0;
            var count = ctx.options.count();
            rows = count > 0 ? (ctx.start+count > rows ? rows - ctx.start : count) : rows - ctx.start;
        }
        ctx.last = ctx.start + rows;

        this.$_prepare(ctx);
        //this.$_buildColumns(ctx);

        this.$_buildDocumentTitle(ctx);
        ctx.header && this.$_buildHeader(ctx);
        ctx.headerSummary && this.$_buildHeaderSummary(ctx);

        if (ctx.showProgress) {
            grid.beginExportProgress(ctx.progressMessage);
            ctx.progressMax = rows + ctx.prepareProgress;
            ctx.progressStep = Math.max(_int(rows/10),1);
            ctx.setProgress(0);
            var self = this;
            this.$_buildItemsAsync(ctx, function () {
                r = ctx.row;
                if (ctx.footer) self.$_buildFooter(ctx);
                self.$_buildDocumentTail(ctx);
                grid.endExportProgress();
                done && done();
            });
        } else {
            this.$_buildItems(ctx);
            if (ctx.footer) this.$_buildFooter(ctx);
            this.$_buildDocumentTail(ctx);
            done && done();
        }
    },
    $_buildTreeDocument: function (ctx, done) {
        var grid = ctx.grid;
        ctx.rowLevels = ctx.grid.getLevels();
        
        this.$_prepare(ctx);

        ctx.start = 0;
        ctx.last = ctx.allItems ? ctx.allItems.length : grid.itemCount();

        this.$_buildDocumentTitle(ctx);
        ctx.header && this.$_buildTreeHeader(ctx);
        ctx.headerSummary && this.$_buildTreeHeaderSummary(ctx);
        if (ctx.showProgress) {
            grid.beginExportProgress(ctx.progressMessage);
            ctx.progressMax = ctx.last + ctx.prepareProgress;
            ctx.progressStep = Math.max(_int(ctx.last/10),1);
            ctx.setProgress(0);
            var self = this;
            this.$_buildTreeItemsAsync(ctx, function () {
                r = ctx.row;
                if (ctx.footer) r += self.$_buildTreeFooter(ctx);
                r += self.$_buildDocumentTail(ctx);
                grid.endExportProgress();
                done && done();
            });
        } else {
            r += this.$_buildTreeItems(ctx);
            if (ctx.footer) r += this.$_buildTreeFooter(ctx);
            r += this.$_buildDocumentTail(ctx);
            done && done();
        }
    },
    $_prepare: function (ctx) {
        var grid = ctx.grid;
        var fixed = grid.layoutManager().fixedItemCount();
        var cols = grid.visibleColumnCount();
        var options = ctx.options;
        for (var c = 0; c < cols; c++) {
            var column = grid.getVisibleColumn(c);
            if (!options.isSeparateRows()) {
                var merges/*ColumnMergeManager*/ = column.stateFor(ColumnMergeManager.MERGE_ROOMS);
                if (merges) {
                    merges.refresh(fixed, grid.itemCount() - 1);
                    ctx.columnMerged = true;
                }
            }
        }
    },
    /*
    $_buildColumns: function (ctx) {
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.dataRowCount();
        var heads = colArr.headerRowCount();
        var r, c;
        sheet.setHeadRows(heads);
        for (r = 0; r < heads; r++) {
            if (ctx.indicator && r == 0) {
                sheet.addHeadColumn(r, ctx.indicator.realWidth());
            } 
            for (c = 0; c < cols; c++) {
                var item = colArr.getHeader(r, c);
                if (item.colIndex == 0 && item.rowIndex == 0) {
                    var column = item.column;
                    sheet.addHeadColumn(r, column.displayWidth());
                }
            }
        }
        sheet.setBodyRows(rows);
        for (r = 0; r < rows; r++) {
            if (ctx.indicator && r == 0) {
                sheet.addColumn(r, ctx.indicator.realWidth());
            } 
            for (c = 0; c < cols; c++) {
                var item = colArr.getItem(rows-1, c);
                if (item.colIndex == 0 && item.rowIndex == 0) {
                    var column = item.column;
                    sheet.addColumn(r, column.displayWidth());
                }
            }
        }
    },
    */
    $_buildDocumentTitle: function(ctx) {
    },
    $_buildDocumentTail: function(ctx) {
    },
    $_buildHeader: function (ctx) {
        var i, row, c; 
        var grid = ctx.grid;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.headerRowCount();
        var indents = ctx.indents;

        for (i = 0; i < rows; i++) {
            sheet.addHeadRow();
            if (ctx.indicator && i == 0) {
                sheet.addHeader(ctx.indicator, ctx.indicatorHead, ctx.indicator.headStyles(), rows, 1);
            }
            if (ctx.checkBar && i == 0) {
                sheet.addHeader(ctx.checkBar, ctx.checkBarHead, ctx.checkBar.headStyles(), rows, 1);
            }

            for (c = 0; c < cols; c++) {
                var item = colArr.getHeader(i, c);
                var column = item.column;
                if (item.colIndex == 0 && item.rowIndex == 0) {
                    w = column.displayWidth();
                    var header = column.header();
                    sheet.addHeader(column, header.displayText(), header.styles(), item.rowSpan, item.colSpan);
                }
            }
        }
    },
    $_buildFooter: function (ctx) {
        function addFooterCell(column, cell, styles, rowspan, colspan) {
            var v = cell.value();
            var v1 = Number(v);
            if (!isNaN(v1) && styles.numberFormat()) {
                sheet.addFooterNumber(column, v1, styles, rowspan, colspan);
            } else if (v) {
                sheet.addFooterText(column, v, styles, rowspan, colspan);
            } else {
                sheet.addFooterText(column, cell.displayText(), styles, rowspan, colspan);
            }

        }
        var i, row, c; 
        var grid = ctx.grid;
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var cols = colArr.colCount();
        var rows = colArr.dataRowCount();
        var indents = ctx.indents;
        var mergeManager = grid.footerMergeManager();
        var lm = grid.layoutManager();
        for (i = 0; i < rows; i++) {
            sheet.addFootRow();
            if (ctx.indicator && i == 0) {
                sheet.addFooterText(ctx.indicator, ctx.indicatorFoot, ctx.indicator.footStyles(), rows, 1);
            }
            if (ctx.checkBar && i == 0) {
                sheet.addFooterText(ctx.checkBar, ctx.checkBarFoot, ctx.checkBar.footStyles(), rows, 1);
            }
            
            for (c = 0; c < cols; c++) {
                var item = colArr.getItem(i, c);
                var column = item.column;
                
                if (item.colIndex == 0 && item.rowIndex == 0) {
                    var colIndex = column.displayIndex();
                    var room = null;
                    // if (column.parent() instanceof RootColumn) {
                        room = mergeManager.findRoomBy(column);
                        if (room && column == room.startColumn() && column != room.baseColumn()) {
                            // colItem = colArr.getItem(i, room.base()+colIndex-c);
                            column = room.baseColumn(); 
                        }
                    // }
                    var cell = grid.footer().getCell(grid.getIndex(-1, column));
                    var f = column.footer();

                    if (room) {
                        if (room.startColumn() == column) {
                            addFooterCell(column, cell, f.styles(), item.rowSpan, room.count());
                        }
                    } else {
                        addFooterCell(column, cell, f.styles(), item.rowSpan, item.colSpan);
                    }
                }
            }
        }
    },
    $_buildHeaderSummary: function (ctx) {
    },
    $_buildValueCell: function (ctx, item, column, rowspan, colspan) {
        var grid = ctx.grid;
        var body = grid.body();
        var options = ctx.options;
        var sheet = ctx.sheet;
        var index = CellIndex.temp(grid, item.index(), column);

        var cell = body.getCell(index);
        var cellStyle = cell._styles;

        if (column._blankWhenExport) {
            return sheet.addBlank(column, cellStyle, rowspan, colspan, width, height);
        } else if (column instanceof DataColumn) {
            var fld = column.dataIndex();
            var field = grid.dataSource().getField(fld);
            var v = item.getData(fld);
            if (field) {
                switch (field.dataType()) {
                    case "number":
                        if (isNaN(v)) {
                            return sheet.addText(column, column.nanText(), cellStyle, rowspan, colspan);
                        } else if (cellStyle.numberFormat()) {
                            return sheet.addNumber(column, v, cellStyle, rowspan, colspan);
                        } else if (item.isVisible()) {
                            return sheet.addText(column, cell.displayText(), cellStyle, rowspan, colspan);
                        } else {
                            return sheet.addNumber(column, v, cellStyle, rowspan, colspan);
                        }
                    case "datetime":
                    case "date":
                        if (v && v instanceof Date) {
                            return sheet.addDate(column, v, cellStyle, rowspan, colspan);
                        } else if (item.isVisible()) {
                            return sheet.addText(column, cell.displayText(), cellStyle, rowspan, colspan);
                        } else {
                            return sheet.addText(column, "", cellStyle, rowspan, colspan);
                        }
                    case "boolean":
                        if (typeof v == "boolean" && cellStyle.booleanFormat()) {
                            return sheet.addBool(column, v, cellStyle, rowspan, colspan);
                        } else if (item.isVisible()) {
                            return sheet.addText(column, cell.displayText(), cellStyle, rowspan, colspan);
                        } else {
                            return sheet.addBool(column, v, cellStyle, rowspan, colspan);
                        }
                    default:  
                        if (options._lookupDisplay && (column.labelField() || column.isLookupDisplay())) {
                            v = cell.getTextFromItem(item);
                        } else if (v) {
                            if (options.isCheckNumber()) {
                                var v1 = Number(v);
                                if (!isNaN(v1)) {
                                    return sheet.addNumber(v1, cellStyle, rowspan, colspan, width, height);
                                }
                            } else {
                                var exp, rep;
                                if ((exp = column.getDisplayRegExp()) && (rep = column.displayReplace())) {
                                    v = v.replace(exp, rep);
                                    return sheet.addText(column, v, cellStyle, rowspan, colspan, false);
                                }
                            }
                        }
                        if (item.isVisible()) {
                            return sheet.addText(column, cell.displayText(), cellStyle, rowspan, colspan);
                        } else { 
                            return sheet.addText(column, v, cellStyle, rowspan, colspan);
                        }
                }
            } else {
                return sheet.addBlank(column, cellStylet, rowspan, colspan);
            }
        } else if (column instanceof SeriesColumn) {
            this._seriesCell.setIndex(index);
            var vals = this._seriesCell.value();
            if (vals) {
                var s = SeriesCell.getText(vals);
                return sheet.addText(column, s, cellStyle, rowspan, colspan);
            } else {
                return sheet.addBlank(column, cellStyle, rowspan, colspan);
            }
        }
    },
    $_buildRow: function (ctx, item, no) {
        var grid = ctx.grid;
        var body = grid.body();
        var sheet = ctx.sheet;
        var colArr = ctx.colArr;
        var rows = colArr.dataRowCount();
        var cols = colArr.colCount();
        var groupBarStyles = ctx.rowGroupBarStyles;
        var lm = grid.layoutManager();
        var columnMerged = ctx.columnMerged;
        var mergeHeads = ctx.mergeHeads;
        var rowGroup = grid.rowGroup();
        var indents = ctx.indents;
        var level = item.level();
        var row, col;
        for (var r = 0; r < rows; r++) {
            row = sheet.addBodyRow();

            if (ctx.indicator && r == 0) {
                w = ctx.indicator.realWidth();
                sheet.addText(ctx.indicator, no+"", ctx.indicator.styles(), rows, 1);
            }
            if (ctx.checkBar && r == 0) {
                w = ctx.checkBar.width();
                sheet.addText(ctx.checkBar, item.isChecked() ? ctx.checkMark : "", ctx.checkBar.styles(), rows, 1);
            }

            for (c = 0; c < cols; c++) {
                var colItem = colArr.getItem(r, c);
                if (colItem.colIndex == 0 && colItem.rowIndex == 0) {
                    var column = colItem.column;
                    var index = CellIndex.temp(grid, item.index(), column);
                    var rowspan = colItem.rowSpan;
                    var colspan = colItem.colSpan;
                    var celled = false;
                    w = column.displayWidth();
                    if (columnMerged) {
                        var index = CellIndex.temp(grid, item.index(), column);
                        var room = lm.getMergedCell(index);
                        if (room) {
                            if ((room.isHead(index) && r == 0) || (ctx.start > 0 && item.index() == ctx.start)) {
                                var tail = ctx.last > 0 ? Math.min(room.tail(), ctx.last) : room.tail();
                                rowspan = rowspan * (tail - item.index() + 1);
                                this.$_buildValueCell(ctx, item, column, rowspan, colspan);
                            }
                            celled = true;
                        }
                    }

                    if (!celled) {
                        this.$_buildValueCell(ctx, item, column, rowspan, colspan);
                    }
                }
            }
        }
    },
    $_buildGroupItem: function (ctx, item, no) {
    },
    $_buildGroupFooter: function (ctx, item, no) {
    },
    $_buildMergedGroupHeader: function (ctx, item, no) {
    },
    $_buildMergedGroupFooter: function (ctx, item, no) {
    },
    $_buildItems: function (ctx) {
        var grid = ctx.grid;
        var showRow = ctx.options.isIndicatorDataRow(grid);
        var allItems = ctx.allItems;
        var zeroBase = ctx.indicator.isZeroBase();
        for (var i = ctx.start; i < ctx.last; i++) {
            var item = allItems ? allItems[i] : grid.getItem(i);
            var no = zeroBase ? i : i + 1;
            if (item instanceof GridRow) {
                this.$_buildRow(ctx, item, showRow ? item.dataRow() : no);
            } else if (item instanceof GroupItemImpl) {
                this.$_buildGroupItem(ctx, item, no);
            } else if (item instanceof MergedGroupHeader) {
                this.$_buildMergedGroupHeader(ctx, item, no);
            } else if (item instanceof MergedGroupFooter) {
                this.$_buildMergedGroupFooter(ctx, item, no);
            } else if (item instanceof GroupFooter) {
                this.$_buildGroupFooter(ctx, item, no);
            } else {
                throw "Unkown item type";
            }
        }
    },
    $_buildItemsAsync: function (ctx, done) {
        var showRow = ctx.options.isIndicatorDataRow(ctx.grid);
        try {
            this.$_buildItemAsync(ctx, showRow, ctx.start, done);
        } catch (ex) {
            ctx.grid.endExportProgress();
            throw ex;
        }
    },
    $_buildItemAsync: function (ctx, showRow, index, done) {
        var stepLast = index + Math.min(ctx.progressStep, ctx.last-index);
        var zeroBase = ctx.indicator.isZeroBase();
        for (var i = index; i < stepLast; i++) {
            var item = ctx.allItems ? ctx.allItems[i] : ctx.grid.getItem(i);
            var no = zeroBase ? i : i + 1;
            if (item instanceof GridRow) {
                this.$_buildRow(ctx, item, showRow ? item.dataRow() : no);
            } else if (item instanceof GroupItemImpl) {
                this.$_buildGroupItem(ctx, item, no);
            } else if (item instanceof MergedGroupHeader) {
                this.$_buildMergedGroupHeader(ctx, item, no);
            } else if (item instanceof MergedGroupFooter) {
                this.$_buildMergedGroupFooter(ctx, item, no);
            } else if (item instanceof GroupFooter) {
                this.$_buildGroupFooter(ctx, item, no);
            } else {
                throw "Unkown item type";
            }
        }
        ctx.setProgress(stepLast-ctx.start);
        index = stepLast;
        if (index >= ctx.last) {
            done();
        } else {
            var self = this;
            setTimeout(function() {
                self.$_buildItemAsync(ctx, showRow, index, done);
            },0);
        }
    },
    $_buildTreeHeader: function (ctx) {
    },
    $_buildTreeHeaderSummary: function (ctx) {
    },
    $_buildTreeFooter: function (ctx) {
    },
    $_buildTreeItems: function (ctx) {
        var grid = ctx.grid;
        var showRow = ctx.options.isIndicatorDataRow(grid);
        var zeroBase = ctx.indicator.isZeroBase();
        for (var i = 0; i < ctx.last; i++) {
            var item = ctx.allItems ? ctx.allItems[i] : grid.getItem(i);
            if (item instanceof TreeItem) {
                row += this.$_buildTreeItem(ctx, item, showRow ? item.dataRow() : zeroBase ? i : i + 1, row, startCol);
            } else {
                throw "Unknown tree item type";
            }
        }
    },
    $_buildTreeItemsAsync: function (ctx, done) {
        var showRow = ctx.options.isIndicatorDataRow(ctx.grid);
        this.$_buildTreeItemAsync(ctx, showRow, 0, done);
    },
    $_buildTreeItemAsync: function (ctx, showRow, index, done) {
        var item = ctx.allItems ? ctx.allItems[index] : ctx.grid.getItem(index);
        var stepLast = index + Math.min(ctx.progressStep, ctx.last-index);
        var zeroBase = ctx.indicator.isZeroBase();
        var indexOffset = ctx.indicator.indexOffset();
        for (var i = index; i < stepLast; i++) { 
            if (item instanceof TreeItem) {
                row += this.$_buildTreeItem(ctx, item, showRow ? item.dataRow() : zeroBase ? i : i + 1);
            } else {
                throw "Unknown tree item type";
            }
        }

        ctx.row = row;
        ctx.setProgress(stepLast-ctx.start);
        index = stepLast;
        if (index >= ctx.last) {
            done();
        } else {
            var self = this;
            setTimeout(function() {
                self.$_buildTreeItemAsync(ctx, row, startCol, showRow, index, done);
            },0);
        }
    },
    $_buildTreeItem: function (ctx, item, no) {
    }
});
var GridCsvExporter = defineClass("GridCsvExporter", null, {
	init: function() {
		this._super(true);
	},
	destroy: function() {
		this._super();
	},
	$_export: function(ctx) {
		function saveLocal(data) {
			data = "\ufeff"+data;
			var blob = new Blob([data], {type:"text/csv charset=UTF-8"});
            if(window.navigator.msSaveOrOpenBlob) { //navigator.appVersion.toString().indexOf('.NET') > 0
                window.navigator.msSaveOrOpenBlob(blob, fileName);
            } else if (window.navigator.msSaveBlob) {
                window.navigator.msSaveBlob(blob, fileName);
            } else {
                var a = document.createElement("a");
                document.body.appendChild(a);
                var url = URL.createObjectURL(blob);
                a.href = url;
                a.download = fileName;
                a.click();
                document.body.removeChild(a);
            }			
		};
		function saveServer(data) {
            var url = options.url();
            var base64 = Base64.encode("\ufeff"+data);
            var formtag = '<form name="tempForm" action="' + url + '" method="post">';
            formtag += '<input type="hidden" name="fileName" value = "' + fileName + '"/>';
            formtag += '<input type="hidden" name="data" value = "' + base64 + '"/>';
            formtag += '<input id="submitBtn" type="submit"/>';
            formtag += '</form>';
            var div = document.createElement('div');
            div.innerHTML = formtag;
            document.body.appendChild(div);
            document.getElementById("submitBtn").click();
            document.body.removeChild(div);
		};
		var options = ctx.options;
		var fileName = options.fileName() || "realgrid.csv";
		var local = options.target() == "local";
		var data = ctx.rows.join("\n");
		local ? saveLocal(data) : saveServer(data);
	},
	export: function(grid, options) {
		// csv는 columnGroup을 사용할수 없다. 모두  하나로 처리될수 밖에 없다.
		// 현재 보이는 형태로 가져와야 하나??
		// rows 전체 row를 담고 있는 array
		function save(owner) {
			owner.$_export(context);
		};
		if (!grid) return;
		options = options instanceof GridExportOptions ? options : new GridExportOptions(options);
		var self = this;
		var context = {
			grid:grid,
			options: options,
            indicator: options.isIndicatorVisible(grid) ? grid.indicator() : null,
            header: options.isHeaderVisible(grid) ? grid.header() : null,
            headerSummary: options.isHeaderSummaryVisible(grid) ? grid.header().summary() : null,
            footer: options.isFooterVisible(grid) ? grid.footer() : null,
            colArr: grid.getLeafColumns(true),
            allItems: null,
            indicatorHead: grid.indicator().headText() || "No",
            indicatorFoot: grid.indicator().footText() || "",
            indicatorSummary: grid.indicator().summaryText(),
            progressMax: 0,
            prepareProgress: 10,
            indicatorNo:1,
            rows: [],
            setProgress: function (pos) { grid.setExportProgress(this.progressMax, pos+this.prepareProgress, this.progressMessage); }
		};
		if (context.indicator) {

		}
        if (grid instanceof TreeView) {
            if (options.isAllItems()) {
                context.allItems = grid.getAllItems();
            }
            this.$_buildTreeBook(context, function () {
                save(self);
            });
        } else {
            if (options.isAllItems() && grid.isRowGrouped()) {
                context.allItems = grid.getAllItems();
                var fixed = grid.layoutManager().fixedItemCount();
                if ( fixed> 0) {
                    for (var i=0; i<fixed; i++) {
                        context.allItems.splice(i,0,grid.getItem(i));
                    }
                }
            } else if (options.isPagingAllItems() && grid.isPaged()) {
                context.allItems = grid.getPagingAllItems();
            } else if (options.isOnlyCheckedItems() && !grid.isRowGrouped()) {
                context.allItems = grid.getCheckedItems();
            }
            this.$_buildBook(context, function () {
                save(self);
            });            
        }
	},
	$_buildBook: function(ctx, done) {
		if (ctx.header) {
			this.$_buildHeader(ctx);
		};
		if (ctx.headerSummary) {
			this.$_buildHeaderSummary(ctx);
		};
		this.$_buildItems(ctx);
		if (ctx.footer) {
			this.$_buildFooter(ctx);
		};
		done();
	},
	$_addQuat: function(value, dataType, options) {
		if (typeof value === "string") {
			if (options) {
				var lfText = options.lfText();
				var crText = options.crText();
				lfText && value && (value = value.replace(/\n/g,lfText));
				crText && value && (value = value.replace(/\r/g,crText));
			}
			if (dataType === ValueType.TEXT || value.indexOf("\n") >= 0|| value.indexOf(",") >= 0 || value.indexOf("\"") >= 0) {
				value = '"'+value.replace(/\"/g, '""')+'"';
			}
		}
		return value === null ? "" : value;
	},
	$_buildHeader: function(ctx) {
		var ret = [];
		var col;
		ctx.indicator && (ret.push(ctx.indicatorHead));
		for (var i = 0, cnt = ctx.colArr.length; i < cnt ; i++) {
			col = ctx.colArr[i];
			ret[ret.length] = this.$_addQuat(col.header().displayText());
		};

		var row = ret.join(',');
		ctx.rows.push(row);
	},
	$_buildHeaderSummary: function(ctx) {
		var ret = [];
		var grid = ctx.grid;
		var options = ctx.options;
		var v, s, cell, row, col;
		for (var i = 0, cnt = ctx.colArr.length; i < cnt ; i++) {
			col = ctx.colArr[i];
			cell = grid.header().summary().getCell(grid.getIndex(-1, col));
			v = cell.value();
			if (typeof v === "number") {
				s = isNaN(v) ? cell.displayText() : String(v);
			} else if (v instanceof Date) {
                if (options._datetimeCallback) {
                    v = options._datetimeCallback(-1, col.name(), v);
                    if (v instanceof Date) {
                        s = DatetimeConverter.Default.getText(v);
                    } else {
                        s = v;
                    }
                } else {
                    s = DatetimeConverter.Default.getText(v);
                }
			} else {
				s = v == null ? cell.displayText() : String(v);					
			}
			ret[ret.length] = this.$_addQuat(s);
		};
		row = ret.join(',');
		ctx.rows.push(row);
	},
	$_buildFooter: function(ctx) {
		var ret, col, cell, v, row, s;
        var options = ctx.options;
		var grid = ctx.grid;
		var footer = grid.footer();
		var footerCnt = footer.count();
		for (var i = 0; i < footerCnt; i++) {
			ret = [];
			ctx.indicator && (i == 0 ? ret.push(ctx.indicatorFoot) : ret.push(""));
			for (var j = 0, cnt = ctx.colArr.length; j < cnt ; j++) {
				col = ctx.colArr[j];
				cell = footer.getCell(grid.getIndex(-1,col), i);
				v = cell.value();
				if (typeof v === "number") {
					s = isNaN(v) ? cell.displayText() : String(v);
				} else if (v instanceof Date) {
                    if (options._datetimeCallback) {
                        v = options._datetimeCallback(-1, col.name(), v);
                        if (v instanceof Date) {
                            s = DatetimeConverter.Default.getText(v);
                        } else {
                            s = v;
                        }
                    } else {
                        s = DatetimeConverter.Default.getText(v);
                    }
				} else {
					s = v == null ? cell.displayText() : String(v);					
				}
				ret[ret.length] = this.$_addQuat(s);
			};
			row = ret.join(",");
			ctx.rows.push(row);
		}
	},
	$_buildItems: function(ctx) {
		var grid = ctx.grid;
		var cnt = ctx.allItems ? ctx.allItems.length : grid.itemCount();
		var allItems = ctx.allItems;
		var item;
		var rows = ctx.rows;
		for (var i =0; i < cnt ; i++) {
			item = allItems ? allItems[i] : grid.getItem(i);
			if (item instanceof GridRow) {
				this.$_buildItem(ctx, item);
			} else if (item instanceof GroupItemImpl) {
				this.$_buildGroupItem(ctx, item);
			} else if (item instanceof MergedGroupHeader) {
				this.$_buildMergedGroupHeader(ctx, item);
			} else if (item instanceof MergedGroupFooter) {
				this.$_buildMergedGroupFooter(ctx, item);
			} else if (item instanceof GroupFooter) {
				this.$_buildGroupFooter(ctx, item);
			}
		}
	},
	$_buildItem: function(ctx, item) {
		var cols = ctx.colArr;
		var col, field, v, ret = [], s;
		var cnt = cols.length;
		var options = ctx.options;
		var grid = ctx.grid;
		var displayCallback;
		ctx.indicator && ( options.isIndicatorDataRow(grid) ? ret.push(item.dataRow()) : ret.push(ctx.indicatorNo++));
		for (var i = 0; i < cnt ; i++) {
			col = cols[i];
			field = col.getField();
			s = undefined;
			if (field) {
				v = item.getData(col.dataIndex());
				displayCallback = col.displayCallback && col.displayCallback()
				switch(field.dataType()) {
					case ValueType.NUMBER:
						if (isNaN(v) || v == null) {
							s = "";
						} else if (options._numberCallback || displayCallback){
							s = options._numberCallback ? options._numberCallback(item.index(), col.name(), v) : displayCallback(grid.getHandler(), CellIndex.temp(item.index(), col).proxy(), v);
						} else {
							s = String(v);
						}
						break;
					case ValueType.BOOLEAN:
						if (v != null) {
	                        if (options._booleanCallback || displayCallback) {
	                            v = options._booleanCallback ? options._booleanCallback(item.index(), col.name(), v) : displayCallback(grid.getHandler(), CellIndex.temp(item.index(), col).proxy(), v);
	                        } else if (options._booleanFormatter) {
	                            v = options._booleanFormatter.formatValue(v);
	                        }
	                        s = String(v);
						}
						break;
					case ValueType.DATE:
					case ValueType.DATETIME:
						if (v) {
                            if (options._datetimeCallback || displayCallback) {
                                v = options._datetimeCallback ? options._datetimeCallback(item.index(), col.name(), v) : displayCallback(grid.getHandler(), CellIndex.temp(item.index(), col).proxy(), v);
                                if (v instanceof Date) {
                                    s = DatetimeConverter.Default.getText(v);
                                } else {
                                    s = v;
                                }
                            } else {
                                s = DatetimeConverter.Default.getText(v);
                            }
						}
						break;
					case ValueType.OBJECT:
						break;
					default:
						var exp, rep;
						if (options._lookupDisplay && (col.labelField() || col.isLookupDisplay())) {
							var index = CellIndex.temp(grid, item.index(), col);
							var gCell = grid.body().getCellSimple(index);
							v = gCell.getTextFromItem(item);
						} else {
							v = v && (exp = col.getDisplayRegExp()) && (rep = col.displayReplace()) ? v.replace(exp, rep) : v;
						}
						v = options._textCallback ? options._textCallback(item.index(), col.name(), v) : displayCallback && (!exp || !rep) ? displayCallback(grid.getHandler(), CellIndex.temp(grid, item.index(), col).proxy(), v) : v;
						s = v != null ? String(v) : "";
				}
			};
			ret[ret.length] = this.$_addQuat(s,field && field.dataType());
		}
		var row = ret.join(",");
		ctx.rows.push(row);
	},
	$_buildGroupItem: function(ctx, item) {
		var grid = ctx.grid;
		var s = grid.rowGroup().getHeaderText(item)
		var ret = [];
		ctx.indicator && !ctx.options.isIndicatorDataRow(grid) && ret.push(ctx.indicatorNo++);
		ret.push(this.$_addQuat(s));
		var row = ret.join(",");
		ctx.rows.push(row);
	},
	$_buildGroupFooter: function(ctx, item) {
		var grid = ctx.grid;
		var rowGroup = grid.rowGroup();
		var ret = [];
		var cols = ctx.colArr;
		var cnt = cols.length;
		var col;
		var v, s;
		ctx.indicator && !ctx.options.isIndicatorDataRow(grid) && ret.push(ctx.indicatorNo++);
		for (var i = 0; i < cnt ; i++)		 {
			col = cols[i];
			s = "";
			v = RowGroupFooterCell.getValue(item, col);
			if (v instanceof Date) {
				if (ctx.options._datetimeCallback) {
					v = ctx.options._datetimeCallback(item.index(), col.name(), v);
					if (v instanceof Date) {
						s = DatetimeConverter.Default.getText(v);
					} else {
						s = v;
					}
				} else {
					s = DatetimeConverter.Default.getText(v);
				}
			} else if (isNaN(v)) {
				if (item.index() > -1) {
					if (v === undefined || typeof v === "number") {
						var index = CellIndex.temp(grid, item.index(), col);
						var cell = rowGroup.getFooterCell(index);
						s = cell.displayText()||"";
					} else {
						s = String(v);
					}
				} else {
					s = col.footer().groupText();
				}
			} else if (typeof v === "number") {
				s = String(v);
			};
			ret[ret.length] = this.$_addQuat(s);
		}
		var row = ret.join(",");
		ctx.rows.push(row);
	},
	$_buildMergedGroupHeader: function(ctx, item) {
		var grid = ctx.grid;
		var s = grid.rowGroup().getHeaderText(item)
		var ret = [];
		var level = item.level();
		ctx.indicator && !ctx.options.isIndicatorDataRow(grid) && ret.push(ctx.indicatorNo++);
		for (var c = 0; c < level -1 ; c++) {
			ret[ret.length] = "";
		}
		ret.push(this.$_addQuat(s));
		var row = ret.join(",");
		ctx.rows.push(row);
	},
	$_buildMergedGroupFooter: function(ctx, item) {
		var grid = ctx.grid;
		var rowGroup = grid.rowGroup();
		var ret = [];
		var level = item.level();
		var cols = ctx.colArr;
		var cnt = cols.length;
		var v, s, col;
		ctx.indicator && !ctx.options.isIndicatorDataRow(grid) && ret.push(ctx.indicatorNo++);
		for (var c = 0; c < level -1 ; c++) {
			ret[ret.length] = "";
		}
		for (;c < cnt; c++) {
			col = cols[c];
			s = "";
			v = RowGroupFooterCell.getValue(item, col);
			if (v instanceof Date) {
				if (ctx.options._datetimeCallback) {
					v = ctx.options._datetimeCallback(item.index(), col.name(), v);
					if (v instanceof Date) {
						s = DatetimeConverter.Default.getText(v);
					} else {
						s = v;
					}
				} else {
					s = DatetimeConverter.Default.getText(v);
				}
			} else if (isNaN(v)) {
				if (item.index() > -1) {
					if (v === undefined || typeof v === "number") {
						var index = CellIndex.temp(grid, item.index(), col);
						var cell = rowGroup.getFooterCell(index);
						s = cell.displayText()||"";
					} else {
						s = String(v);
					}
				} else {
					s = col.footer().groupText();
				}
			} else if (typeof v === "number") {
				s = String(v);
			};
			ret[ret.length] = this.$_addQuat(s);
		}
		var row = ret.join(",");
		ctx.rows.push(row);
	},
	$_buildTreeBook: function(ctx, done) {
		if (ctx.header) {
			this.$_buildTreeHeader(ctx);
		};
		if (ctx.headerSummary) {
			this.$_buildTreeHeaderSummary(ctx);
		};
		this.$_buildTreeItems(ctx);
		if (ctx.footer) {
			this.$_buildTreeFooter(ctx);
		};
		done();
	},
	$_buildTreeHeader: function(ctx) {
		this.$_buildHeader(ctx);
	},
	$_buildTreeHeaderSummary: function(ctx) {
		this.$_buildHeaderSummary(ctx);
	},
	$_buildTreeFooter: function(ctx) {
		this.$_buildFooter(ctx);
	},
	$_buildTreeItems: function(ctx) {
		var grid = ctx.grid;
		var cnt = ctx.allItems ? ctx.allItems.length : grid.itemCount();
		var allItems = ctx.allItems;
		var item;
		var rows = ctx.rows;
		for (var i =0; i < cnt ; i++) {
			item = allItems ? allItems[i] : grid.getItem(i);
			if (item instanceof TreeItem) {
				this.$_buildTreeItem(ctx, item);
			} else {
				throw "Unkonw tree item type";
			}
		}
	},
	$_buildTreeItem: function(ctx, item) {
		this.$_buildItem(ctx, item);
	}
});

// exportFields와 hideFields를 추가한다.
// seperator를 추가한다.
// export와 마찬가지고 local, string, server로 저장할수 있도록 한다.
// 
var DataProviderCsvExporter = defineClass("DataProviderCsvExporter", GridCsvExporter, {
	init: function() {
		this._super(true);
	},
	destroy: function() {
		this._super();
	},
	// exportFields : 보내고자하는 필드를 지정한다.
	// hideFields : 숨기고자 하는 필드를 지정한다.
	$_prepareFields: function(provider, exportFields, hideFields) {
		var fields = provider.getFields();
		var flds = [];  // 실제 export할 field
		var f;
		if (exportFields) {
			for (var i = 0, cnt = exportFields.length ; i < cnt; i++) {
				(f = provider.getFieldIndex(exportFields[i])) >= 0 && flds.push(provider.getField(f))
			}
			return flds;
		};
		if (hideFields) {
			for (var i=0, cnt = hideFields.length; i < cnt ; i++) {
				hideFields[i] = hideFields[i].toUpperCase();
			}
			for (var i = fields.length; i--;) {
				hideFields.indexOf(fields[i].fieldName()) >= 0 && fields.splice(i, 1);
			}
		}
		return fields;
	},
	export: function(dataProvider, options) {
		function save(owner) {
			owner.$_export(context)			
		}
		options = options instanceof DataProviderExportOptions ? options : new DataProviderExportOptions(options);
		var self = this;
		var context = {
			"provider":dataProvider,
			"options": options,
			"fields": this.$_prepareFields(dataProvider, options.exportFields(), options.hideFields()),
            "rows": [],
		};

        if (dataProvider instanceof LocalTreeDataProvider) {
            this.$_buildTreeBook(context, function () {
                save(self);
            });
        } else {
            this.$_buildBook(context, function () {
                save(self);
            });            
        }
	},
	$_buildBook: function(ctx, done) {
		var options = ctx.options;
		var provider = ctx.provider;
		var rowCount = provider.rowCount();

		var start = Math.max(0,options.start());
		var cnt = options.count() == -1 ? rowCount : Math.min(Math.max(options.count(),0), rowCount)
		options.isIncludeFieldNames() && this.$_buildFieldName(ctx);
		for (var i = start ; i < cnt; i++) {
			this.$_buildItem(ctx, i);
		};

		if (options.target() === "string") {
			var data = ctx.rows.join("\n");
			options._done && typeof options._done == "function" && options._done(data);
		} else {
			options._done && typeof options._done == "function" && options._done();
			done();
		}
	},
	$_buildFieldName:function(ctx) {
		var fields = ctx.fields,
			cnt = fields.length,
			ret = [],
			seperator = ctx.options.seperator();
		for (var i = 0; i < cnt ; i++) {
			ret.push(fields[i].orgFieldName());
		}
		ctx.rows.push(ret.join(seperator || ","));
	},
	$_buildItem: function(ctx, dataRow) {
		var provider = ctx.provider;
		var fields = ctx.fields;
		var field;
		var values;
		if (provider instanceof LocalTreeDataProvider) {
			values = dataRow ? dataRow.values() : [];
		} else {
			values = provider.getRow(dataRow);
		} 
		var v, ret = [], s;
		var cnt = fields.length;
		var options = ctx.options;
		var seperator = options.seperator();

		for (var i = 0; i < cnt ; i++) {
			field = fields[i];
			s = undefined;
			if (field) {
				v = values[field.index()];
				switch(field.dataType()) {
					case ValueType.NUMBER:
						if (isNaN(v) || v == null) {
							s = "";
						} else if (options._numberCallback){
							s = options._numberCallback(dataRow, field.orgFieldName(), v);
						} else if (options._numberFormat) {
							s = options._numberFormatter.format(v);
						} else {
							s = String(v);
						}
						break;
					case ValueType.BOOLEAN:
						if (v != null) {
	                        if (options._booleanCallback) {
	                            v = options._booleanCallback(dataRow, field.orgFieldName(), v);
	                        } else if (options._booleanFormatter) {
	                            v = options._booleanFormatter.formatValue(v);
	                        }
	                        s = String(v);
						}
						break;
					case ValueType.DATE:
					case ValueType.DATETIME:
						if (v) {
                            if (options._datetimeCallback) {
                                v = options._datetimeCallback(dataRow, field.orgFieldName(), v);
                                if (v instanceof Date) {
                                    s = DatetimeConverter.Default.getText(v);
                                } else {
                                    s = v;
                                }
                            } else {
                                s = DatetimeConverter.Default.getText(v);
                            }
						}
						break;
					case ValueType.OBJECT:
						if (v) {
							v = options._objectCallback ? options._objectCallback(dataRow, field.orgFieldName(), v) : v;
							s = typeof v == "object" ? JSON.stringify(v) : String(v);
						}
						break;
					default:
						v = options._textCallback ? options._textCallback(dataRow, field.orgFieldName(), v) : v;
						s = v != null ? String(v) : "";
				}
			};
			ret[ret.length] = this.$_addQuat(s,field && field.dataType(), options);
		}
		var row = ret.join(seperator || ",");
		ctx.rows.push(row);
	},
	$_buildTreeBook: function(ctx, done) {
		var options = ctx.options;
		var provider = ctx.provider;
		var rows = provider.getDescendants();
		// var rowCount = provider.rowCount();

		// var start = Math.max(0,options.start());
		// var cnt = options.count() == -1 ? rowCount : Math.min(Math.max(options.count(),0), rowCount)
		options.isIncludeFieldNames() && this.$_buildFieldName(ctx);
		for (var i = 0, cnt = rows.length; i < cnt ; i++) {
			this.$_buildItem(ctx, rows[i]);
		};

		if (options.target() === "string") {
			var data = ctx.rows.join("\n");
			options._done && typeof options._done == "function" && options._done(data);
		} else {
			options._done && typeof options._done == "function" && options._done();
			done();
		}
	},
});
var TreeAggregateMode = _enum({
	LEAF: "leaf",
	ROOT: "root",
	ALL: "all",
	CUSTOM: "custom"
});
var TreeDataTag = defineClass("TreeDataTag", null, {
	init: function() {
		this._super();
	},
	connect: function (provider) {
	},
	disconnect: function () {
	},
	clearRows: function () {
	},
	setRows: function () {
	},
	addRow: function (row) {
	},
	addRows: function (rows) {
	},
	removeRow: function (row) {
	},
	removeRows: function (rows) {
	},
	updateRow: function () {
	}
});
var TreeDataTagCollection = defineClass("TreeDataTagCollection", null, {
	init: function(owner) {
		this._super();
		this._owner = owner;
		this._tags = [];
	},
	add: function (tag) {
		if (tag) {
			var tags = this._tags || (this._tags = []);
			if (tags.indexOf(tag) < 0) {
				tags.push(tag);
			}
			tag.connect(this._owner);
		}
	},
	remove: function (tag) {
		if (tag && this._tags) {
			var idx = this._tags.indexOf(tag);
			if (idx >= 0) {
				this._tags.splice(idx, 1);
				tag.disconnect();
			}
		}
	},
	clearRows: function () {
		if (this._tags) {
            var tags = this._tags;
			for (var i = tags.length; i--;) {
				tags[i].clearRows();
			}
		}
	},
	setRows: function () {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].setRows();
            }
		}
	},
	addRow: function (row) {

		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].addRow(row);
            }
		}		
	},
	addRows: function (rows) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].addRows(rows);
            }
		}
	},
	removeRow: function (row) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].removeRow(row);
            }
		}
	},
	removeRows: function (rows) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].removeRows(rows);
            }
		}
	},
	updateRow: function (row) {
		if (this._tags) {
            var tags = this._tags;
            for (var i = tags.length; i--;) {
                tags[i].updateRow(row);
            }
		}
	}
});
var TreeDataSource = defineClass("TreeDataSource", null, {
	init : function(provider, rootRow) {
		Base.init.call(this, provider, rootRow);
		this._provider = provider;
		this._rootRow = rootRow;
		this._rows = null;
		this._rowCount = 0;
	},
	provider: function () {
		return this._provider;
	},
	rootRow: function () {
		return this._rootRow;
	},
	insertedRows: function () {
		return this._rows;
	},
	insertedCount: function () {
		return this._rowCount;
	},
	_prepareLoad: function (parent) {
		this._rowCount = 0;
		this._rows = [];
	},
	_objectToArray: function (row, provider) {
		var c, fld;
		var flds = provider.fieldCount();
		var vals = new Array(flds);
		for (c = 0; c < flds; c++) {
			fld = provider.getOrgFieldName(c);
			if (row.hasOwnProperty(fld)) {
				vals[c] = row[fld];
			}
		}
		//provider.$_internalCalculateValues(vals, -1);
		return vals;
	},
	_createRow: function (childrenField, iconField, values) {
		var row = new TreeDataRowImpl(this._provider, values);
		this.provider().$_internalCalculateValues(row._values, row.rowId())
		if (childrenField >= 0) {
			this._provider.setHasChildren(row, values[childrenField]);
		} 
		if (iconField >= 0) {
			this._provider.setIconIndex(row, values[iconField]);
		}
		return row;
	},
	_createRow2: function (hasChildren, iconIndex, values) {
		var row = new TreeDataRowImpl(this._provider, values);
		this.provider().$_internalCalculateValues(row._values, row.rowId())
		if (hasChildren !== undefined) {
			this._provider.setHasChildren(row, hasChildren);
		}
		if (iconIndex !== undefined) {
			this._provider.setIconIndex(row, iconIndex);
		}
		return row;
	},
	_rowAdded: function (root, row) {
		this._rowCount++;
		if (this._rows && row.parent() === root) {
			this._rows.push(row);
		}
	},
	_addRow: function (root, parent, childrenField, iconField, values) {
		var row = this._createRow(childrenField, iconField, values);
		parent._insertChild(parent.count(), row, true, true);
		this._rowAdded(root, row);
		return row;
	},
	_addRow2: function (root, parent, hasChildren, iconIndex, values) {
		var row = this._createRow2(hasChildren, iconIndex, values);
		parent._insertChild(parent.count(), row, true, true);
		this._rowAdded(root, row);
		return row;
	}
});
var TreeDataSource$ = TreeDataSource.prototype;
var ArraySourceImpl = defineClass("ArraySourceImpl", TreeDataSource, {
	init : function(provider, rootRow) {
		TreeDataSource$.init.call(this, provider, rootRow);
		this.checkParentProc = null;
	},
	_loadData: function (source, parent, treeField, needSorting, childrenField, iconField) {
		this._prepareLoad(parent);
		if (!source || source.length < 1) {
			return this._rowCount;
		}
		var i, arr,
			provider = this.provider(),
			cnt = source.length,
			rows = [];
		for (i = 0; i < cnt; i++) {
			rows[i] = i;
			if (!_isArray(source[i])) {
				source[i] = this._objectToArray(source[i], provider);
			//} else {
			//	provider.$_internalCalculateValues(source[i]);
			}
		}
		if (needSorting) {
			this.$_sortRows(rows, source, treeField, 0, cnt - 1);
		}
		this.provider().beginUpdate();
		try {
			this.$_buildTree(parent ? parent : this.rootRow(), rows, source, treeField, childrenField, iconField);
		} finally {
			this.provider().endUpdate(false);
		}
		return this.insertedCount();
	},
	$_sortRows: function (rows, values, field, left, right) {
		function compare(r1, r2) {
			var s1 = values[r1][field];
			var s2 = values[r2][field];
			if (s1 == s2) {
				return 0;
			}
			if (s1 < s2) {
				return -1;
			}
			return 1;
		}
		return rows.sort(function(r1, r2) {compare(r1, r2)}.bind(this));
		/*
		var i, j, m, t, r, v;
		do {
			i = left;
			j = right;
			m = rows[_floor((left + right) / 2)];
			do {
				while (true) {
					r = rows[i];
					v = compare(m, r);
					if (v <= 0)
						break;
					i++;
				}
				while (true) {
					r = rows[j];
					v = compare(m, r);
					if (v >= 0)
						break;
					j--;
				}
				if (i <= j) {
					if (i != j) {
						t = rows[i];
						rows[i] = rows[j];
						rows[j] = t;
					}
					i++;
					j--;
				}
			} while (i <= j);
			if (left < j) {
				this.$_sortRows(rows, values, field, left, j);
			}
			left = i;
		} while (left < right);
		*/
	},
	$_buildTree: function (parent, rows, values, treeField, childrenField, iconField) {
		function getParent(prev, row, values) {
			var s;
			var tree = values[treeField];
			while (prev != parent) {
				s = prev.getValue(treeField);
				if (this.checkParentProc) {
					if (this.checkParentProc(s, tree)) {
						return prev;
					}
				} else if (tree.indexOf(s) == 0) {
					return prev;
				}
				prev = prev.parent();
			}
			return parent;
		}
		var r = rows[0];
		var row = this._createRow(childrenField, iconField, values[r]);
		var p = getParent(parent, row, values[r]);
		p._insertChild(p.count(), row, true, true);
		this._rowAdded(parent, row);
		if (rows.length > 1) {
			var i, 
				cnt = rows.length,
				prev = row;
			for (i = 1; i < cnt; i++) {
				r = rows[i];
				row = this._createRow(childrenField, iconField, values[r]);
				p = getParent(prev, row, values[r]);
				p._insertChild(p.count(), row, true, true);
				this._rowAdded(parent, row);
				prev = row;
			}
		}
	}
});
var ArraySourceImpl$ = ArraySourceImpl.prototype;
var ArrayTreeSource = defineClass("ArrayTreeSource", ArraySourceImpl, {
	init: function(provider, rootRow) {
		ArraySourceImpl$.init.call(this, provider, rootRow);
	},
	load: function (parent, source, treeField, needSorting, childrenField, iconField) {
		return this._loadData(source, parent, treeField, needSorting, childrenField, iconField);
	}
});
var ArrayTreeSource$ = ArrayTreeSource.prototype;
var CsvTreeSource = defineClass("CsvTreeSource", ArraySourceImpl, {
	init: function(provider, rootRow) {
		ArraySourceImpl$.init.call(this, provider, rootRow);
	},
	load: function (parent, source, treeField, needSorting, childrenField, iconField) {
		var rows = DataHelper.csvToArray(this.provider(), source);
		return this._loadData(rows, parent, treeField, needSorting, childrenField, iconField);
	}
});
var CsvTreeSource$ = CsvTreeSource.prototype;
var JsonTreeSource = defineClass("JsonTreeSource", TreeDataSource, {
	init: function(provider, rootRow) {
		TreeDataSource$.init.call(this, provider, rootRow);
	},
	load: function (parent, source, rowsProp, childrenField, iconField) {
		this._prepareLoad(parent);
		if (source) {
			var rows = DataPath.extractJson(source, rowsProp);
			if (rows && rows.length > 0) {
				this.provider().beginUpdate();
				try {
					this.$_buildTree(this.provider(), parent ? parent : this.rootRow(), rows, rowsProp, childrenField, iconField);
				} finally {
					this.provider().endUpdate(false);
				}
			}
		}
		return this._rowCount;
	},
	load2: function (parent, source, rowsProp, childRowsProp, childrenProp, iconProp) {
		this._prepareLoad(parent);
		if (source) {
			var rows = DataPath.extractJson(source, rowsProp);
			if (rows && rows.length > 0) {
				this.provider().beginUpdate();
				try {
					this.$_buildTree2(this.provider(), parent ? parent : this.rootRow(), rows, childRowsProp, childrenProp, iconProp);
				} finally {
					this.provider().endUpdate(false);
				}
			}
		}
		return this._rowCount;
	},
	$_buildTree: function (provider, parent/*TreeDataRow*/, source, rowsProp, childrenField, iconField) {
		function build(self, p, rows, fldNames) {
			var flds = fldNames.length;
			for (var i = 0, cnt = rows.length; i < cnt; i++) {
				var obj = rows[i];
				var vals = new Array(flds);
				for (var c = 0; c < flds; c++) {
					var fld = fldNames[c];
					if (obj.hasOwnProperty(fld)) {
						vals[c] = obj[fld];
					}
				}
				var row = self._addRow(parent, p, childrenField, iconField, vals);
				if (obj.hasOwnProperty(rowsProp)) {
					var arr = obj[rowsProp];
					if (_isArray(arr) && arr.length > 0)
						build(self, row, arr, fldNames);
				}
			}
		}
		var fldNames = provider.getOrgFieldNames();
		build(this, parent, source, fldNames);
	},
	$_buildTree2: function (provider, parent/*TreeDataRow*/, source, rowsProp, childrenProp, iconProp) {
		function build(self, p, rows, fldNames) {
			var flds = fldNames.length;
			for (var i = 0, cnt = rows.length; i < cnt; i++) {
				var obj = rows[i];
				var vals = new Array(flds);
				for (var c = 0; c < flds; c++) {
					var fld = fldNames[c];
					if (obj.hasOwnProperty(fld)) {
						vals[c] = obj[fld];
					}
				}
				var row = self._addRow2(parent, p, obj[childrenProp], obj[iconProp], vals);
				if (obj.hasOwnProperty(rowsProp)) {
					var arr = obj[rowsProp];
					if (_isArray(arr) && arr.length > 0)
						build(self, row, arr, fldNames);
				}
			}
		}
		var fldNames = provider.getOrgFieldNames();
		build(this, parent, source, fldNames);
	}
});
var JsonTreeSource$ = JsonTreeSource.prototype;
var XmlTreeSource = defineClass("XmlTreeSource", TreeDataSource, {
	init: function(provider, rootRow) {
		TreeDataSource$.init.call(this, provider, rootRow);
	},
	load: function (parent, source, rowsProp, childrenField, iconField) {
		this._prepareLoad(parent);
		if (source) {
			var xml = typeof source === "string" ? _parseXml(source) : source;
			if (xml) {
				var rows = DataPath.extractXml(xml.documentElement, rowsProp);
				if (rows && rows.length > 0) {
					this.provider().beginUpdate();
					try {
						this.$_buildTree(this.provider(), parent ? parent : this.rootRow(), rows, rowsProp, childrenField, iconField);
					} finally {
						this.provider().endUpdate(false);
					}
				}
			}
		}
		return this._rowCount;
	},
	$_buildTree: function (provider, parent/*TreeDataRow*/, source, rowElement, childrenField, iconField) {
		var fields = provider.getFields();
		var fieldNames = provider.getOrgFieldNames();
		function build(self, p, rows) {
			for (var i = 0, cnt = rows.length; i < cnt; i++) {
				var xml = rows[i];
				var vals = DataHelper.xmlToRow(xml, fields, fieldNames);
				var row = self._addRow(parent, p, childrenField, iconField, vals);
				var elts = DataPath.extractXml(xml, rowElement);
				if (elts && elts.length > 0) {
					build(self, row, elts);
				}
			}
		}
		build(this, parent, source, provider.getFields());
	}
});
var XmlTreeSource$ = XmlTreeSource.prototype;
var _nextTreeRowId = 0;
var /* abstract */ TreeDataRow = defineClass("TreeDataRow", null, {
	init : function(provider) {
		Base.init.call(this, true);
		this._rowId = provider && provider._nextRowId++;//_nextTreeRowId++;
		this._children = null;
		this._descendantCount = 0;
	},
	rowId: function () {
		return this._rowId;
	},
	provider: function () {
		return null;
	},
	parent: function () {
		return null;
	},
	index: function () {
		return -1;
	},
	level: function () {
		return 0;
	},
	iconIndex: function () {
		return -1;
	},
	hasChildren: function () {
		return false;
	},
	count: function () {
		return this._children ? this._children.length : 0;
	},
	descendantCount: function () {
		return this._descendantCount;
	},
	children: function () {
		return this._children ? this._children.concat() : null;
	},
	descendants: function () {
		function collectRows (p, rows) {
			var i, row,
				cnt = p.count();
			for (i = 0; i < cnt; i++) {
				rows.push(row = p.getChild(i));
				collectRows(row, rows);
			}
		}
		if (this._children) {
			var rows = [];
			collectRows(this, rows);
			return rows;
		}
		return null;
	},
	ancestors: function () {
		var rows = null,
			p = this.parent();
		if (p) {
			rows = [];
			while (p && p.rowId() >= 0) {
				rows.push(p);
				p = p.parent();
			}
		}
		return rows;
	},
	getChild: function (index) {
		if (index >= 0) {
			if (!this._children || index >= this._children.length) {
				throw new RangeError("Index is invalid: " + index);
			}
			return this._children[index];
		}
		throw new RangeError("Index is invalid: " + index);
	},
	getChildObjects: function (recursive, childrenProp, iconProp, addRowId) {
		var children = this._children;
		if (children) {
			var objects = [];
            childrenProp = childrenProp || "rows";
			iconProp = iconProp || "iconIndex";
			for (var i = 0, cnt = children.length; i < cnt; i++) {
				var child = children[i];
				var obj = child.getObject();
				if (addRowId) obj["_rowId"] = child._rowId;
				if (recursive) {
					obj[childrenProp] = child.getChildObjects(recursive, childrenProp, iconProp, addRowId);
				}
				obj[iconProp] = child.iconIndex();
				objects.push(obj);
			}
			return objects;
		}
		return null;
	},
    $_createTreeOutputRows: function (rows, options, childrenProp) {
    	function rowsToDataRows(rows, dataRows, childrenProp) {
		  for (var i=0, cnt=rows.length; i < cnt; i++) {
		  	var row = rows[i];
		    dataRows.push(rows[i]);
		    if (childrenProp && row[childrenProp] && row[childrenProp].length) {
		      rowsToDataRows(row[childrenProp], dataRows, childrenProp)
		    }
		  }
		}
		var dataRows = [];
		rowsToDataRows(rows,dataRows,childrenProp);
		var provider = this.provider();
        var fldCount = provider.fieldCount();
        var rowCount = dataRows.length;
        var r, row;
        if (!(options instanceof DataOutputOptions)) {
            options = new DataOutputOptions(options);
        }
        var nullDate = options.nullDateText();
        var nullText = options.nullText();
        var nanText = options.nanText();
        for (var i = 0; i < fldCount; i++) {
            var field = provider.getField(i);
            var prop = field.orgFieldName();
            var callback, writer;
            if (field._dataType == ValueType.DATETIME && ((callback = options._datetimeCallback) || (writer = options._datetimeWriter) || (nullDate != null && nullDate != undefined) )) {
                if (callback) {
                    for (r = 0; r < rowCount; r++) {
                        row = dataRows[r];
                        row[prop] = callback(row["_rowId"], prop, row[prop]);
                    }
                } else {
                    for (r = 0; r < rowCount; r++) {
                        row = dataRows[r];
                        var d = row[prop];
                        row[prop] = d ? writer ? writer.getText(row[prop]) : d : nullDate;
                    }
                }
            } else if (field._dataType == ValueType.BOOLEAN && ((callback = options._booleanCallback) || (writer = options._booleanFormatter))) {
                if (callback) {
                    for (r = 0; r < rowCount; r++) {
                        row = dataRows[r];
                        row[prop] = callback(row["_rowId"], prop, row[prop]);
                    }
                } else {
                    for (r = 0; r < rowCount; r++) {
                        row = dataRows[r];
                        row[prop] = writer.formatValue(row[prop]);
                    }
                }
            } else if (field._dataType == ValueType.NUMBER && ((callback = options._numberCallback) || (writer = options._numberFormatter) || (nanText != null && nanText != undefined))) {
                if (callback) {
                    for (r = 0; r < rowCount; r++) {
                        row = dataRows[r];
                        row[prop] = callback(row["_rowId"], prop, row[prop]);
                    }
                } else {
                    for (r = 0; r < rowCount; r++) {
                        row = dataRows[r];
                        var v = row[prop];
                        row[prop] = v == null || isNaN(v) ? nanText : writer ? writer.format(v) : v;
                    }
                }
            } else if (nullText != null && nullText != undefined) {
                for (r = 0; r < rowCount; r++) {
                    row = dataRows[r];
                    var v = row[prop];
                    row[prop] = v == null || v == undefined ? nullText : v;
                }
            }
        }
        for (var i =0, cnt=dataRows.length; i<cnt; i++) {
        	delete dataRows[i]["_rowId"];
        }
    },
	getOutput: function (options, iconProp) {
		if (options) {
			var row = this.getObject();
			row[iconProp || "iconIndex"] = this.iconIndex();
			row["_rowId"] = this._rowId;
			this.$_createTreeOutputRows([row], options);
			return row;
		}
		return null;
	},
    getChildOutputObjects: function (options, recursive, childrenProp, iconProp) {
        var rows = this.getChildObjects(recursive, childrenProp, iconProp, true);
        rows && options && this.$_createTreeOutputRows(rows, options, childrenProp);
        return rows;
    },
	findById: function (rowId) {
		if (this._children) {
			var i, child, c,
				cnt = this._children.length;
			for (i = 0; i < cnt; i++) {
				child = this._children[i];
				if (child.rowId() == rowId) {
					return child;
				}
				c = child.findById(rowId);
				if (c) {
					return c;
				}
			}
		}
		return null;
	},
	indexOf: function (childRow) {
		return this._children ? this._children.indexOf(childRow) : -1;
	},
	_moveChild: function (index, newIndex) {
		if (index < 0 || index >= this._children.length)
			throw new RangeError("index is out of range: " + index);
		if (newIndex < 0 || newIndex >= this._children.length)
			throw new RangeError("newIndex is out of range: " + newIndex);

		var child = this._children[index];
		if (index > newIndex) {
			for (var i = index; i > newIndex; i--) 
				this._children[i] = this._children[i-1];
		} else {
			for (var i = index; i < newIndex; i++)
				this._children[i] = this._children[i+1];			
		}
		this._children[newIndex] = child;
	},
	_changeParent: function (parent, index) {
		if (index < 0 || index > parent._children.length)
			throw new RangeError("index is out of range: " + index);

		var old = this.parent();
		var oldIndex = this.index();

		old._children.splice(oldIndex, 1);
		old._descendantCountChanged(-1 - this.descendantCount());
		old._detach(this);
		
		parent._children.splice(index, 0, this);
		parent._descendantCountChanged(1 + this.descendantCount());
		parent._attach(this);
	},
	_insertChild: function (index, child, force, noState) {
		var provider = this.provider();
		if (provider && !force) {
			if (!provider._checkClientState()) return;
			provider.refreshFieldFormats();
		}
		if (!child) {
			throw new Error("child is null");
		}
		this._children = this._children || [];
		if (index < 0 || index > this._children.length) {
			throw new RangeError("Insert index is invalid: " + index);
		}
		if (force || this._doChildAdding(index, child)) {
			this._children.splice(index, 0, child);
			this._descendantCountChanged(1 + child.descendantCount());
			this._attach(child);
			if (!noState) {
				child._changeRowState(RowState.CREATED, true);
			}
			this._doChildAdded(index, child);
			return true;
		}
		return false;
	},
	insertChild: function (index, child, noState) {
		return this._insertChild(index, child, false, noState);
	},
	_addChild: function (child, force, noState) {
		return this._insertChild(this.count(), child, force, noState);
	},
	addChild: function (child, noState) {
		return this._insertChild(this.count(), child, false, noState);
	},
	$_removeChild: function (child, index, force) {
		if (force || this._doChildRemoving(child)) {
			this._children.splice(index, 1);
			this._descendantCountChanged(-1 - child.descendantCount());
			this._detach(child);
			this._doChildRemoved(child);
			return true;
		}
		return false;
	},
	_removeChild: function (child, force) {
		var provider = this.provider();
		if (provider && !force) {
			if (!provider._checkClientState()) return;
		}
		if (child && this._children) {
			var i, ds;
			for (i = this._children.length; i--;) {
				if (this._children[i] === child) {
					ds = this.provider();
					if (ds.isSoftDeleting() && ds.isCheckStates()) {
						switch (child.rowState()) {
							case RowState.CREATED:
								if (ds.isDeleteCreated()) {
									return this.$_removeChild(child, i, force);
								} else {
									child._changeRowState(RowState.CREATE_AND_DELETED, true);
								}
								break;
							case RowState.DELETED:
							case RowState.CREATE_AND_DELETED:
								break;
							default: 
								child._changeRowState(RowState.DELETED, true);
						}
					} else {
						return this.$_removeChild(child, i, force);
					}
				}
			}
		}
		return false;
	},
	removeChild: function (childRow) {
		return this._removeChild(childRow, false);
	},
	_removeChildren: function () {
		if (this._children && this._children.length > 0) {
			this._children.splice(0, this._children.length);
			this._descendantCountChanged(-this._descendantCount);
			this._doCleared();
		}
	},
	clearChildren: function () {
		var provider = this.provider();
		if (provider && !provider._checkClientState()) return;
		this._removeChildren();
	},
	_setChildren: function (children) {
		if (this._children && this._children.length > 0) {
			this._children.splice(0, this._children.length);
		}
		var	dcount = -this._descendantCount;
        var cnt;
		if (children && (cnt = children.length) > 0) {
			if (!this._children) {
				this._children = [];
			}
			for (var i = 0; i < cnt; i++) {
				var child = children[i];
				this._children.push(child);
				dcount += 1 + child.descendantCount();
				this._attach(child);
			}
		}
		this._descendantCountChanged(dcount);
	},
	findChild: function (fields, values) {
		var provider = this.provider();
		if (!provider || !fields || fields.length < 1 || !values || values.length < fields.length) {
			return null;
		}
		var	flds = [];
		var	vals = [];
        var i, c, cnt, len;
		cnt = fields.length;
		for (i = 0; i < cnt; i++) {
			if (typeof fields[i] === "string") {
				c = provider.getFieldIndex(fields[i]);
			} else {
				c = Number(fields[i]);
			}
			if (c >= 0 && c < provider.fieldCount() && flds.indexOf(c) < 0) {
				flds.push(c);
				vals.push(values[i]);
			}
		}
		len = flds.length;
		for (i = 0; i < len; i++) {
			flds[i] = provider.getField(flds[i]);
		}
		return this.$_findChild(flds, vals);
	},
	$_findChild: function (flds, vals) {
		var i, c, child, found,
			len = flds.length,
			cnt = this.count();
		for (i = 0; i < cnt; i++) {
			child = this._children[i];
			found = true;
			for (c = 0; c < len; c++) {
				if (!flds[c].equalValues(vals[c], child.getValue(flds[c].index()))) {
					found = false;
					break;
				}
			}
			if (found) {
				return child;
			}
			child = child.$_findChild(flds, vals);
			if (child) {
				return child;
			}
		}
		return null;
	},
	isAncestorOf: function (row) {
		if (row && row !== this) {
			var p = row.parent();
			while (p && p !== this) {
				p = p.parent();
			}
			return p === this;
		}
		return false;
	},
	_descendantCountChanged: function (count) {
		this._descendantCount += count;
		var p = this.parent();
		if (p) {
			p._descendantCountChanged(count);
		}
	},
	clearRowStates: function (deleteRows, rowEvents) {
		var provider = this.provider();
		if (!provider) {
			return;
		}
		var i, cnt, row,
			rows = [],
			deletes = deleteRows ? [] : null;
		this._collectStateRows(rows, deletes);
		var nState = rows.length;
		var nDelete = deletes ? deletes.length : 0;
		if (nState == 0 && nDelete == 0) {
			return;
		}
		if (rowEvents) {
			cnt = rows.length;
			for (i = 0; i < cnt; i++) {
				rows[i]._changeRowState(RowState.NONE, true);
			}
		} else if (nState) {
            provider.changeRowStates(rows, RowState.NONE);
		}
        if (nDelete) {
      //   	if (rowEvents) {
      //   		for (var i in deletes) {
    		// 		provider.deleteRow(deletes[i]);
    		// 	}
    		// } else {
            	provider.deleteRows(deletes);
            // }
        }
	},
	_collectStateRows: function (rows, deletes) {
		for (var i = this.count(); i--;) {
			var row = this.getChild(i);
			var state = row.rowState();
			if (deletes && (state == RowState.DELETED || state == RowState.CREATE_AND_DELETED)) {
				deletes.push(row);
			} else {
                if (state != RowState.NONE) {
                    rows.push(row);
                }
				row._collectStateRows(rows, deletes);
			}
		}
	},
	$_clearOrgValues: function () {
		for (var i = this.count(); i--;) {
			this.getChild(i).$_clearOrgValues();
		}
	},
	$_restoreState: function (recursive, restoredRows) {
		if (recursive) {
			for (var i = this.count(); i--;) {
				this.getChild(i).$_restoreState(true, restoredRows);
			}
		}
		return false;
	},
	$_restoreRow: function (recursive, restoredRows) {
		if (recursive) {
			for (var i = this.count(); i--;) {
				this.getChild(i).$_restoreRow(true, restoredRows);
			}
		}
		return false;
	},
	toTreeString: function () {
		var s = this.rowId();
		var indent = new Array(this.level() + 1).join("  ");
		for (var i = 0; i < this.count(); i++) {
			s += "\n" + indent + this.getChild(i).toTreeString();
		}
		return s;
	},
	_attach: function (child) {
		throwAbstractError();
	},
	_deatach: function (child) {
		throwAbstractError();
	},
	_checkFieldIndex: function (field) {
		var flds = this.provider().fieldCount();
		if (field < 0 || field >= flds) {
			throw new DataSourceError("Field index is out of bounds: " + field);
		}
	},
	_doChildAdding: function (index, child) {
		var prov = this.provider();
		if (prov) {
			return prov._rowAdding(this, index, child);
		}
		return true;
	},
	_doChildAdded: function (index, child) {
		var prov = this.provider();
		if (prov) {
			prov._rowAdded(child);
		}
	},
	_doChildRemoving: function (child) {
		var prov = this.provider();
		if (prov) {
			return prov._rowRemoving(child);
		}
		return true;
	},
	_doChildRemoved: function (child) {
		var prov = this.provider();
		if (prov) {
			prov._rowRemoved(child);
		}
	},
	_doCleared: function () {
		var prov = this.provider();
		if (prov) {
			prov._rowCleared(this);
		}
	}
});
var TreeDataRow$ = TreeDataRow.prototype;
var TreeDataRowImpl = defineClass("TreeDataRowImpl", TreeDataRow, {
	init : function(provider, values) {
		TreeDataRow$.init.call(this, provider);
		this._parent = null;
		this._iconIndex = -1;
		this._hasChildren = false;
		this._values = null;
		this._orgValues = null;
		this._state = RowState.NONE;
		this._extents = 0;
		if (provider && values) {
			var i,
				flds = provider.fieldCount(),
				cnt = Math.min(values.length, flds);
			this._values = new Array(flds);
			for (i = 0; i < cnt; i++) {
				this._values[i] = provider.getField(i).readValue(values[i]);
			}
		}
	},
	provider: function () {
		return this._parent ? this._parent.provider() : null;
	},
	parent: function () {
		return this._parent;
	},
	index: function () {
		return this._parent ? this._parent.indexOf(this) : -1;
	},
	level: function () {
		return this._parent ? this._parent.level() + 1 : 0;
	},
	hasChildren: function () {
		return this._hasChildren;
	},
	setHasChildren: function (value) {
		if (value != this._hasChildren) {
			this._hasChildren = value;
			var provider = this.provider();
			if (provider) {
				provider.hasChildrenChanged(this);
			}
		}
	},
	iconIndex: function () {
		return this._iconIndex;
	},
	setIconIndex: function (value) {
		value = parseInt(value);
		if (isNaN(value)) {
			value = -1;
		}
		if (value != this._iconIndex) {
			this._iconIndex = value;
			var provider = this.provider();
			if (provider) {
				provider._iconIndexChanged(this);
			}
		}
	},
	values: function () {
		return this._values ? this._values.concat() : [];
	},
	rowState: function () {
		return this._state;
	},
	_changeRowState: function (newState, fireEvent, refresh) {
		var provider = this.provider();
		if (provider && provider.isCheckStates() && newState != this._state) {
			var oldState = this._state;
			this._state = newState;
			if (newState == RowState.UPDATED && provider._needOrgValues) {
				this._orgValues = this._values.concat();
			} else if (oldState == RowState.updated) {
				if (this._orgValues) {
					this._orgValues = null;
				}
			}
			if (fireEvent) {
				provider._stateChanged(this, refresh);
			}
			return true;
		}
		return false;
	},
	getValue: function (field) {
		var provider = this.provider();
		if (provider) {
			this._checkFieldIndex(field);
			if (this._values) {
				return this._values[field];
			}
			throw new Error("Row data is not loaded");
		}
		return undefined;
	},

	setValue: function (field, value, noState) {
		var provider = this.provider();
		if (provider) {
			if (!provider._checkClientState()) return;
			provider.refreshFieldFormats();
			this._checkFieldIndex(field);

			if (this._values) {
				var fld = provider.getField(field);
				var newVal = fld.readValue(value);
				if (!fld.equalValues(newVal, this._values[field])) {
					
					var oldVals;
					var needState = provider.isCheckStates() && (this._state == RowState.NONE || !this._state);
					if (!noState && needState && provider._needOrgValues) {
						oldVals = this._values.concat();
					}
					this._values[field] = newVal;
					provider.$_internalCalculateValues(this._values, this.rowId());

					if (!noState && needState) {
						if (provider._needOrgValues) {
							this._orgValues = oldVals;
						}
						this._state = RowState.UPDATED;
						provider._stateChanged(this);
					} else if (provider._needRestore) {
						this.$$_restoreState(provider);
					}
					provider._valueChanged(this, field);
				}
				return;
			}
			throw new Error("Row data is not loaded");
		}
	},

	getObject: function () {
		var provider = this.provider();
		if (provider) {
			var i, fld;
			var	cnt = provider.fieldCount();
			var	row = {};
			for (i = 0; i < cnt; i++) {
				fld = provider.getOrgFieldName(i);
				row[fld] = this._values[i];
			}
			return row;
		}
		return null;
	},
	update: function (values) {
		return this.$_update(values, false, false);
	},
	updateStrict: function (values) {
		return this.$_update(values, true, false);
	},
	_update: function (values, force) {
		return this.$_update(values, false, force);
	},
	_updateStrict: function (values, force) {
		return this.$_update(values, true, force);
	},
	$_update: function (values, strict, force) {
		var provider = this.provider();
		if (provider) {
			if (!force) {
				if (!provider._checkClientState()) return;
				provider.refreshFieldFormats();
			}
			if (values && (force || provider._rowUpdating(this))) {
				this._internalUpdate(values, strict, true);
				provider._rowUpdated(this);
				return true;
			}
		}
		return false;
	},
	copy: function () {
		var row = new TreeDataRowImpl(null, null);
		row._rowId = this._rowId;
		row._iconIndex = this._iconIndex;
		row._hasChildren = this._hasChildren;
		row._state = this._state;
		row._values = this._values ? this._values.concat() : null;
		var i, child,
			cnt = this.count();
		for (i = 0; i < cnt; i++) {
			child = this.getChild(i).copy();
			row._addChild(child, true, true);
		}
		return row;
	},
	_attach: function (child) {
		child._parent = this;
	},
	_detach: function (child) {
		if (child._parent === this) {
			child._parent = null;
		}
	},
	$_clearOrgValues: function () {
		if (this._orgValues) {
			this._orgValues.length = 0;
			this._orgValues = null;
		}
		this._super();
	},
	$_restoreState: function (recursive, restoredRows) {
		var restored = $$_restoreState(this.provider());
		if (restored && restoredRows) {
			restoredRows.push(this);
		}
		this._super(recursive, restoredRows);
		return restored;
	},
	$_restoreRow: function (recursive, restoredRows) {
		var restored = false;
		if (this._state === RowState.UPDATED) {
			var orgs = this._orgValues;
			if (orgs) {
				var vals = this._values;
				for (var i = 0, cnt = Math.min(orgs.length, this.provider().fieldCount()); i < cnt; i++) {
					vals[i] = orgs[i];
				}
				this._state = RowState.NONE;
				if (restoredRows) {
					restoredRows.push(this);
				}
				restored = true;
			}
		}
		this._super(recursive, restoredRows);
		return restored;
	},
	$$_restoreState: function (provider) {
		if (this._state == RowState.UPDATED && this._orgValues) {
			var orgs = this._orgValues;
			var vals = this._values;
            var provider = this.provider();
            var strict = provider.isStrictRestore();
            for (var i = 0, cnt = provider.fieldCount(); i < cnt; i++) {
                var v1 = vals.length > i ? vals[i] : undefined;
                var v2 = orgs.length > i ? orgs[i] : undefined;
                if (strict) {
                    if (!provider.getField(i).equalValues(v1, v2)) {
                        return false;
                    }
                } else {
                    if (!provider.getField(i).sameValues(v1, v2)) {
                        return false;
                    }
                }
            }
            this._state = RowState.NONE;
            return true;
		}
		return false;
	},
	$_getUpdatedCells:function() {
		var orgs = this._orgValues;
		var vals = this._values;
        var provider = this.provider();
        var strict = provider.isStrictRestore();
        var cells = [];
        if (!orgs || orgs.length <= 0) {
        	return null;
        }
        for (var i = 0, cnt = provider.fieldCount(); i < cnt; i++) {
            var v1 = vals.length > i ? vals[i] : undefined;
            var v2 = orgs.length > i ? orgs[i] : undefined;
            if (provider._fields[i].isCalculated()) continue;
            if (strict) {
                if (!provider.getField(i).equalValues(v1, v2)) {
                    cells.push({
						fieldName:provider.getOrgFieldName(i),
						oldValue:orgs[i],
						newValue:vals[i]
                    })
                }
            } else {
                if (!provider.getField(i).sameValues(v1, v2)) {
                    cells.push({
						fieldName:provider.getOrgFieldName(i),
						oldValue:orgs[i],
						newValue:vals[i]
                    })
                }
            }
        }
        return cells;
	},
	_setHasChildren: function (value) {
		this._hasChildren = value;
	},
	_setIconIndex: function (value) {
		value = parseInt(value);
		this._iconIndex = isNaN(value) ? -1 : parseInt(value);
	},
	_internalUpdate: function (values, strict, stateEvent) {
		var fld, changed = false;
		var isAry = _isArray(values);
		var provider = this.provider();
		if (provider) {
			var i, v, oldVals;
			var cnt = Math.min(provider.fieldCount(), isAry ? values.length : provider.fieldCount());
			var needState = provider.isCheckStates() && (this._state == RowState.NONE || !this._state);
			if (needState && provider._needOrgValues) {
				oldVals = this._values.concat();
			}
			for (i = 0; i < cnt; i++) {
				fld = provider.getField(i);
				if (isAry || values.hasOwnProperty(fld._orgFieldName)) {
					v = isAry ? values[i] : values[fld._orgFieldName];
					if (!strict || v !== undefined) {
						if (provider._needRestore) {
							changed = changed || (strict ? !fld.equalValues(this._values[i], fld.readValue(v)) : !fld.sameValues(this._values[i], fld.readValue(v)))
						} else {
							changed = true;
						}
						this._values[i] = provider.getField(i).readValue(v);
					}
				}
			}
			provider.$_internalCalculateValues(this._values, this.rowId());

			if (needState && changed) {
				if (oldVals) {
					this._orgValues = oldVals;
				}
				this._state = RowState.UPDATED;
				if (stateEvent) {
					provider._stateChanged(this);
				}
			} else if (provider._needRestore) {
				this.$$_restoreState(provider);
			}
		}
	}
});
var /* internal */ RootTreeRow = defineClass("RootTreeRow", TreeDataRow, {
	init: function(provider) {
		this._super(provider);
		this._provider = provider;
	},
	copy: function () {
		var i, row,
			cnt = this.count(),
			root = new RootTreeRow(null);
		for (i = 0; i < cnt; i++) {
			row = this.getChild(i).copy();
			root._addChild(row, true, true);
		}
		root._provider = this._provider;
		return root;
	},
	set: function (source) {
		var	children = [];
		for (var i = 0, cnt = source.count(); i < cnt; i++) {
			children.push(source.getChild(i).copy());
		}
		this._setChildren(children);
	},
	provider: function () {
		return this._provider;
	},
	rowId: function () {
		return -1;
	},
	parent: function () {
		return null;
	},
	level: function () {
		return 0;
	},
	index: function () {
		return 0;
	},
	hasChildren: function () {
		return true;
	},
	iconIndex: function () {
		return -1;
	},
	setIconIndex: function (value) {
	},
	values: function () {
		return null;
	},
	rowState: function () {
		return RowState.NONE;
	},
	_setHasChildren: function () {
	},
	_changeRowState: function (newState, fireEvent) {
		return false;
	},
	getValue: function (field) {
		return UNDEFINED;
	},
	setValue: function (field, value, noState) {
	},
	getObject: function () {
		return null;
	},
	update: function (values, force) {
		return false;
	},
	updateStrict: function (values, force) {
		return false;
	},
	/*
	clearRowStates: function (deleteRows, fireStateEvents) {
		var i, row;
		for (i = this.count() - 1; i >= 0; i--) {
			row = this.getChild(i);
			if (deleteRows && (row.rowState() == RowState.DELETED || RowState.CREATE_AND_DELETED)) {
				this._removeChild(row, false);
			} else {
				row.clearRowStates(deleteRows, fireStateEvents);
			}
		}
	},
	*/
	_attach: function (child) {
		child._parent = this;
	},
	_detach: function (child) {
		if (child._parent === this) {
			child._parent = null;
		}
	}
});
var TreeDataProvider = defineClass("TreeDataProvider", DataSource, {
	init: function () {
		this._super();
	},
	rootRow: function () {
		return null;
	}
});
var LocalTreeDataProvider = defineClass("LocalTreeDataProvider", TreeDataProvider, {
	init : function() {
		this._super();
		this._eventLock = 0;
		this._resetLock = 0;
		this._countDirty = false;
		this._tagLock = false;
		this._points = [];
		this._nextPoint = 0;
		this._nextRowId = 0;
		this._rootRow = new RootTreeRow(this);
		this._rowMap = [];
		this._tags = new TreeDataTagCollection(this);
		this._needOrgValues = false;
		this._needRestore = false;
		this.checkParentProc = null;
		this._hideRowIds = [];
		this.calculateRuntime();
	},
	destroy: function() {
		this._destroying = true;
		this._points = null;
		this._rootRow = null;
		this._rowMap = null;
		this._tags = null;
		this._hideRowIds = null;
		this._super();
	},
	needOrgValues: function () {
		return this._needOrgValues;
	},
	needRestore: function () {
		return this._needRestore;
	},
	addTag: function (tag) {
		this._tags.add(tag);
	},
	removeTag: function (tag) {
		this._tags.remove(tag);
	},
	setRows: function (rows, treeField, needSorting, childrenField, iconField) {
		if (!this._checkClientState()) return;
		var source,
			count = 0,
			tfield = this.getFieldIndex(treeField);
		if (tfield >= 0) {
			this.beginUpdate();
			try {
				this._clearRows();
				this.refreshFieldFormats();
				source = new ArrayTreeSource(this, this._rootRow);
				source.checkParentProc = this.checkParentProc;
				count = source.load(null, rows, tfield, needSorting, this.getFieldIndex(childrenField), this.getFieldIndex(iconField));
				this._checkSum(count);
			} finally {
				this.endUpdate(false);
			}
		}
		this._tags.setRows();
		this._fireReset();
		this._fireRowCountChanged();
		return count;
	},
	setCsvRows: function (rows, treeField, needSorting, childrenField, iconField) {
		if (!this._checkClientState()) return;
		var source,
			count = 0,
			tfield = this.getFieldIndex(treeField);
		if (tfield >= 0) {
			this.beginUpdate();
			try {
				this._clearRows();
				this.refreshFieldFormats();
				source = new CsvTreeSource(this, this._rootRow);
				source.checkParentProc = this.checkParentProc;
				count = source.load(null, rows, tfield, needSorting, this.getFieldIndex(childrenField), this.getFieldIndex(iconField));
				this._checkSum(count);
			} finally {
				this.endUpdate(false);
			}
		}
		this._tags.setRows();
		this._fireReset();
		this._fireRowCountChanged();
		return count;
	},
	setXmlRows: function (rows, rowElement, childrenField, iconField) {
		if (!this._checkClientState()) return;
		var source,
			count = 0;
		if (rows) {
			this.beginUpdate();
			try {
				this._clearRows();
				this.refreshFieldFormats();
				source = new XmlTreeSource(this, this._rootRow);
				count = source.load(null, rows, rowElement, this.getFieldIndex(childrenField), this.getFieldIndex(iconField));
				this._checkSum(count);
			} finally {
				this.endUpdate(false);
			}
		}
		this._tags.setRows();
		this._fireReset();
		this._fireRowCountChanged();
		return count;
	},
	setJsonRows: function (rows, rowsProp, childrenProp, iconProp) {
		if (!this._checkClientState()) return;
		if (rows) {
			this.beginUpdate();
			try {
				this._clearRows();
				this.refreshFieldFormats();
				var source = new JsonTreeSource(this, this._rootRow);
				this._rowCount = source.load(null, rows, rowsProp, this.getFieldIndex(childrenProp), this.getFieldIndex(iconProp));
			} finally {
				this.endUpdate(false);
			}
		}
		this._tags.setRows();
		this._fireReset();
		this._fireRowCountChanged();
		return this._rowCount;
	},
	setJsonRows2: function (rows, rowsProp, childRowsProp, childrenProp, iconProp) {
		if (!this._checkClientState()) return;
		if (rows) {
			this.beginUpdate();
			try {
				this._clearRows();
				this.refreshFieldFormats();
				var source = new JsonTreeSource(this, this._rootRow);
				this._rowCount = source.load2(null, rows, rowsProp, childRowsProp, childrenProp, iconProp);
			} finally {
				this.endUpdate(false);
			}
		}
		this._tags.setRows();
		this._fireReset();
		this._fireRowCountChanged();
		return this._rowCount;
	},
	appendDataRows: function (parent, rows, treeField, needSorting, childrenField, iconField) {
		if (!this._checkClientState()) return;
		var cnt = 0,
			tfield = this.getFieldIndex(treeField);
		if (tfield >= 0) {
			var source = new ArrayTreeSource(this, this._rootRow);
			source.checkParentProc = this.checkParentProc;
			this.beginUpdate();
			try {
				this.refreshFieldFormats();
				cnt = source.load(parent, rows, tfield, needSorting, this.getFieldIndex(childrenField), this.getFieldIndex(iconField));
			} finally {
				this.endUpdate(false);
				if (cnt > 0) {
					var newRows = source.insertedRows();
					if (newRows && (cnt = newRows.length) > 0) {
						this._rowsAdded(parent, newRows);
					}
				}
				source = null;
			}
		}
		return cnt;
	},
	appendCsvRows: function (parent, rows, treeField, needSorting, childrenField, iconField) {
		if (!this._checkClientState()) return;
		var source,
			count = 0,
			tfield = this.getFieldIndex(treeField);
		if (tfield >= 0) {
			this.beginUpdate();
			try {
				this._clearRows();
				this.refreshFieldFormats();
				source = new CsvTreeSource(this, this._rootRow);
				source.checkParentProc = this.checkParentProc;
				count = source.load(parent, rows, tfield, needSorting, this.getFieldIndex(childrenField), this.getFieldIndex(iconField));
				this._checkSum(count);
			} finally {
				this.endUpdate(false);
			}
		}
		this._tags.setRows();
		this._fireReset();
		this._fireRowCountChanged();
		return count;
	},
	appendXmlRows: function (parent, rows, rowElement, childrenField, iconField) {
		if (!this._checkClientState()) return;
		var cnt = 0;
		if (rows) {
			var source = new XmlTreeSource(this, this._rootRow);
			this.beginUpdate();
			try {
				this.refreshFieldFormats();
				cnt = source.load(parent, rows, rowElement, this.getFieldIndex(childrenField), this.getFieldIndex(iconField));
			} finally {
				this.endUpdate(false);
				if (cnt > 0) {
					var newRows = source.insertedRows();
					if (newRows && (cnt = newRows.length) > 0) {
						this._rowsAdded(parent, newRows);
					}
				}					
				source = null;
			}
		}
		this.fireRowCountChanged();
		return cnt;
	},
	appendJsonRows: function (parent, rows, rowsProp, childrenField, iconField) {
		if (!this._checkClientState()) return;
		var cnt = 0;
		if (rows) {
			var source = new JsonTreeSource(this, this._rootRow);
			this.beginUpdate();
			try {
				this.refreshFieldFormats();
				cnt = source.load(parent, rows, rowsProp, this.getFieldIndex(childrenField), this.getFieldIndex(iconField));
			} finally {
				this.endUpdate(false);
				if (cnt > 0) {
					var newRows = source.insertedRows();
					if (newRows && (cnt = newRows.length) > 0) {
						this._rowsAdded(parent, newRows);
					}
				}					
				source = null;
			}
		}
		this._fireRowCountChanged();
		return cnt;
	},
	setIconIndex: function (row, value) {
		if (row instanceof TreeDataRowImpl && row.iconIndex() != value) {
			row._setIconIndex(value);
			return true;
		} else if (row.iconIndex() != value) {
			row.setIconIndex(value);
			return true;
		}
		return false;
	},
	setHasChildren: function (row, value) {
		if (row instanceof TreeDataRow && row.hasChildren() != value) {
			row._setHasChildren(value);
			return true;
		} else if (row.hasChildren() != value) {
			row._setHasChildren(value);
			return true;
		}
		return false;
	},
	getAllRows: function () {
		var rows = [];
		return rows;
	},
	getJsonRows: function (rowId, rowsProp, childrenProp) {
		var rows = [];
		return rows;
	},
	getChildCount: function (parent) {
		var p = parent || this._rootRow;
		return p.count();
	},
	getRows: function (parent) {
		var p = parent ? parent : this._rootRow;
		return p.children();
	},
	getDescendantCount: function (parent) {
		var p = parent || this._rootRow;
		return p.descendantCount();
	},
	getDescendants: function (parent, maxLevel) {
		function collectRows(p, rows, maxLevel) {
			var i, row;
			var cnt = p.count();
			for (i = 0; i < cnt; i++) {
				rows.push(row = p.getChild(i));
				if (maxLevel > row.level()) {
					collectRows(row, rows, maxLevel);
				}
			}
		}
		maxLevel = arguments.length > 1 ? maxLevel : 0;
		var p = parent || this._rootRow;
		if (maxLevel <= 0) {
			return p.descendants();
		} else if (maxLevel > p.level()) {
			var rows = [];
			collectRows(p, rows, maxLevel);
			return rows;
		} else {
			return null;
		}
	},
	getRow: function (parent, index) {
		var p = parent || this._rootRow;
		return p.getChild(index);			
	},
	hasData: function (rowId) {
		return this.rowById(rowId) != null;
	},
	rowById: function (rowId) {
		var row = this._rowMap[rowId];
		if (!row) {
			row = this._findRowById(rowId);
			if (row) {
				this._rowMap[rowId] = row;
			}
		}
		return row;
	},
	createRow: function (values, iconIndex, hasChildren) {
		var row = null;
		this.refreshFieldFormats();
		if (_isArray(values)) {
			row = new TreeDataRowImpl(this, values);
		} else if (values) {
			var vals = new Array(this.fieldCount());
			for (var prop in values) {
				var fld = this.getFieldIndex(prop);
				if (fld >= 0) {
					vals[fld] = values[prop];
				}
			}
			row = new TreeDataRowImpl(this, vals);
		}
		if (row) {
			this.$_internalCalculateValues(row._values, row.rowId());
			row._iconIndex = iconIndex;
			row._hasChildren = hasChildren;
		}
		return row;
	},
	clearRows: function () {
		if (!this._checkClientState()) return;
		this._clearRows();
		if (this._eventLock <= 0) {
			this._fireRefresh();
			this._fireRowCountChanged();
		}
	},
	removeRows: function (rows) {
		function checkOrphaned(row, from) {
			for (var i = from; i >= 0; i--) {
				if (rows[i].isAncestorOf(row)) {
					return false;
				}
			}
			return true;
		}
		if (!this._checkClientState()) return;
		if (!rows || rows.length < 1) {
			return;
		}
		rows.sort(function (row1, row2) {
			return row1.level() - row2.level();
		});
		var orgRows = rows; // splice 이전 값 저장
		var i, row, st;
		for (i = rows.length; i--;) {
			if (rows[i].level() > 1 && !checkOrphaned(rows[i], i - 1)) {
				rows.splice(i, 1);
			}
		}
		if (rows.length < 1 || !this._rowsRemoving(rows)) {
			return false;
		}
		if (this._softDeleting && this._checkStates) {
			var changed,
				stateRows = [];
			for (i = rows.length - 1; i >= 0; i--) {
				row = rows[i];
				st = row.rowState();
				changed = false;
				switch (st) {
					case RowState.CREATED:
						if (!this.isDeleteCreated()) {
							changed = row._changeRowState(RowState.CREATE_AND_DELETED, false);
							rows.splice(i, 1);
						}
						break;
					case RowState.DELETED:
					case RowState.CREATE_AND_DELETED:
						rows.splice(i, 1);
						break;
					default: 
						changed = row._changeRowState(RowState.DELETED, true, false);
						rows.splice(i, 1);
						break;
				}
				if (changed) {
					stateRows.push(row);
				}
			}
			if (stateRows.length > 0) {
				this._fireRowStatesChanged(stateRows);
			}
		}
		this.deleteRows(orgRows);
		return true;
	},
	deleteRows: function (rows) {
		if (!this._checkClientState()) return;
		if (rows && rows.length > 0) {
			var saveSoftDeleting = this._softDeleting;
			this.beginUpdate();
			try {
				this._softDeleting = false;
				this._tagLock = true;
				try {
					for (var i = rows.length - 1; i >= 0; i--) {
						var row = rows[i];
						var p = row && row.parent();
						p = p._removeChild(row, true);
					}
				} finally {
					this._tagLock = false;
				}
			} finally {
				this._softDeleting = saveSoftDeleting;
				this.endUpdate(false);
			}
			this._rowsRemoved(rows);
		}
	},
	moveRowSibling: function (row, delta) {
		if (!(row instanceof TreeDataRow))
			throw new TypeError("row is not TreeDataRow.");
		if (delta == 0)
			return false;

		if (!this._checkClientState()) return false;

		var parent = row.parent();
		var count = parent.children().length;
		var index = row.index();
		var newIndex = Math.min(Math.max(index+delta,0),count-1);
		delta = newIndex - index;
		if (delta == 0)
			return false;

		if (this._fireRowSiblingMoving(row, delta)) {
			parent._moveChild(index, newIndex);
			this._fireRowSiblingMoved(row, delta);
			return true;
		}
		return false;
	},
	changeRowParent: function (row, parent, childIndex) {
		if (!(row instanceof TreeDataRow))
			throw new TypeError("row is not TreeDataRow.");
		if (!(row instanceof TreeDataRow))
			throw new TypeError("parent is not TreeDataRow.");
		if (row === parent) 
			throw new Error("parent must not be self.");
		if (row.isAncestorOf(parent))
			throw new Error("can`t move to child of descendant.");
		var old = row.parent();

		if (old === parent && childIndex == row.index()) 
			return false;
		if (!this._checkClientState()) return false;	
		
		if (!parent._children)
			parent._children = [];
		var count = parent._children.length;
		childIndex = Math.min(Math.max(childIndex,0),count);

		if (this._fireRowParentChanging(row, parent, childIndex)) {
			row._changeParent(parent, childIndex);

			if (!(parent instanceof RootTreeRow))
				this.setHasChildren(parent, true);
			if (!(old instanceof RootTreeRow) && old.count() == 0)
				this.setHasChildren(old, false);

			this._fireRowParentChanged(row, parent, childIndex);
			return true;
		}
		return false;
	},
	getRowState: function (rowId) {
		var row = this.rowById(rowId);
		return row ? row.rowState() : RowState.NONE;
	},
	setRowState: function (rowId, newState, force) {
		var row = this.rowById(rowId);
		if (row && (this._checkStates || force)) {
			var state = row.rowState();
			if (newState != state) {
				row._changeRowState(newState, true, RowState.isDeleted(state) ? true : undefined);
			}
		}
	},
	changeRowStates: function (rows, newState) {
		var i, row;
		var	cnt = rows.length;
		var	changed = [];
		for (i = 0; i < cnt; i++) {
			row = rows[i];
			if (row._changeRowState(newState, false)) {
				changed.push(row);
			}
		}
		if (changed.length > 0) {
			this._fireRowStatesChanged(changed);
		}
	},
	clearRowStates: function (deleteRows, fireStateEvents) {
		if (!this._checkClientState()) return;
		this._rootRow.clearRowStates(deleteRows, fireStateEvents);
	},
	setRowStates: function (rows, state, force, rowEvents) {
		if (!this._checkClientState()) return;
		var i, row,
			changedRows = rowEvents ? null : [],
			cnt = rows.length;
		for (i = 0; i < cnt; i++) {
			row = this.rowById(rows[i]);
			if (row) {
				if (this._checkStates || force) {
					if (row._changeRowState(state, rowEvents) && !rowEvents) {
						changedRows.push(row);
					}
				}
			}
		}
		if (!rowEvents && changedRows.length > 0) {
			this._fireRowStatesChanged(changedRows);
		}
	},
	$_collectStateRows: function (row, state, rows) {
		var i, child,
			cnt = row.count();
		for (i = 0; i < cnt; i++) {
			child = row.getChild(i);
			if (child.rowState() == state) {
				rows.push(child.rowId());
			}
			this.$_collectStateRows(child, state, rows);
		}
	},
	getStateRows: function (state) {
		var rows = [];
		this.$_collectStateRows(this._rootRow, state, rows);
		return rows;
	},
	$_collectAllStateRows: function (row, rows) {
		var i, child,
			cnt = row.count();
		for (i = 0; i < cnt; i++) {
			child = row.getChild(i);
			switch (child.rowState()) {
				case RowState.CREATED:
					rows.created.push(child.rowId());
					break;
				case RowState.UPDATED:
					rows.updated.push(child.rowId());
					break;
				case RowState.DELETED:
					rows.deleted.push(child.rowId());
					break;
				case RowState.CREATE_AND_DELETED:
					rows.createAndDeleted.push(child.rowId());
					break;
			}
			this.$_collectAllStateRows(child, rows);
		}
	},
	getAllStateRows: function () {
		var rows = {
				created: [],
				updated: [],
				deleted: [],
				createAndDeleted: []
			};
		this.$_collectAllStateRows(this._rootRow, rows);
		return rows;
	},
	$_getRowStateCount: function (row, states) {
		var i,
			cnt = row.count(),
			count = 0;
		for (i = 0; i < cnt; i++) {
			var child = row.getChild(i);
			if (states.indexOf(child.rowState()) >= 0) {
				count++;
			}
			count += this.$_getRowStateCount(child, states);
		}
		return count;
	},
	getRowStateCount: function (states) {
		return this.$_getRowStateCount(this._rootRow, states);
	},
	restoreUpdatedStates: function (rows) {
		this.restoreUpdatedRows(rows);
		/*
		if (!this._checkClientState()) return;
		var row;
		if (_isArray(rows) && rows.length == 1) {
			row = this.rowById(rows[0]);
			if (row && row.$_restoreRow(false, null)) {
				this._fireRowStateChanged(row);
			}
		} else {
			var list = [];
			if (_isArray(rows)) {
				for (var i = rows.length; i--;) {
					row = this.rowById(rows[i]);
					if (row) {
						row.$_restoreRow(false, list);
					}
				}
			} else if (rows) {
				row = this.rowById(rows);
				if (row) {
					row.$_restoreRow(false, null);
					this._fireRowStateChanged(row);
				}
			} else {
				this._rootRow.$_restoreRow(true, list);
			}
			if (list.length == 1) {
				this._fireRowStateChanged(list[0]);
			} else if (list.length > 1) {
				this._fireRowStatesChanged(list);
			}
		}
		*/
	},
	restoreUpdatedRows: function (rows) {
		if (!this._checkClientState()) return;
		var row,
			list = [];
		if (rows == null) {
			this._rootRow.$_restoreRow(true, list);
		} else {
			rows = _isArray(rows) ? rows : [rows];
			for (var i = rows.length; i--;) {
				row = this.rowById(rows[i]);
				if (row) {
					row.$_restoreRow(false, list);
				}
			}
		};
		if (list.length == 1) {
			this._fireRowStateChanged(list[0]);
		} else if (list.length > 1) {
			this._fireRowStatesChanged(list);
		}
		/*		
		if (_isArray(rows) && rows.length == 1) {
			row = this.rowById(rows[0]);
			if (row && row.$_restoreRow(false, null)) {
				this._fireRowStateChanged(row);
			}
		} else {
			var list = [];
			if (_isArray(rows)) {
				for (var i = rows.length; i--;) {
					row = this.rowById(rows[i]);
					if (row) {
						row.$_restoreRow(false, list);
					}
				}
			} else if (rows || rows == 0) {
				row = this.rowById(rows);
				if (row) {
					row.$_restoreRow(false, list);
					this._fireRowStateChanged(row);
				}
			} else {
				this._rootRow.$_restoreRow(true, list);
			}
			if (list.length == 1) {
				this._fireRowStateChanged(list[0]);
			} else if (list.length > 1) {
				this._fireRowStatesChanged(list);
			}
		}
		*/
	},
	getUpdatedCells: function (rows) {
		var mode = this.restoreMode();
		if ( !(mode == RestoreMode.AUTO || mode == RestoreMode.EXPLICIT)) return null;
		if (rows == null) {
			rows = this.getStateRows(RowState.UPDATED);
		} else if (!_isArray(rows)) {
			if (typeof rows == "number") {
				rows = [rows];
			} else {
				return null;
			}
		}
		if (!_isArray(rows)) {
			return null;
		}
		var ret = [];
		for (var i=0,cnt=rows.length; i < cnt; i++) {
			var row = this.rowById(rows[i]);
			if (row) {
				var updatedCells = row.$_getUpdatedCells();
				if (updatedCells && updatedCells.length > 0) {
					ret.push({
						__rowId:row._rowId,
						updatedCells:updatedCells
					})
				}
			}
		}
		return ret;
	},
	canUpdateRow: function (row) {
		return true;
	},
	canInsertRow: function (row) {
		return true;
	},
	canDeleteRow: function (row) {
		return true;
	},
	toTreeString: function () {
		return this._rootRow.toTreeString();
	},
	rootRow: function () {
		return this._rootRow;
	},
	rowCount: function () {
		return this._rootRow._descendantCount;
	},
	immediateUpdate: function () {
		return true;
	},
	isSummarized: function () {
		return true;
	}, 
	beginUpdate: function () {
		this._checkClientState();
		this._eventLock++;
	},
	endUpdate: function (refresh) {
		this._checkClientState();
		refresh = arguments.length > 0 ? refresh : true;
		this._eventLock = Math.max(0, this._eventLock - 1);
		if (this._eventLock == 0) {
			if (refresh) {
				if (this._resetLock > 0) {
					this._fireReset();
				} else {
					this._fireRefresh();
				}
				if (this._countDirty) {
					this._fireRowCountChanged();
				}
			}				
			this._resetLock = 0;
			this._countDirty = false;
		}
	},
	findRow: function (fields, values) {
		if (fields && fields.length > 0 && values && values.length >= fields.length) {
			var row = this._rootRow.findChild(fields, values);
			return row;
		}
		return null;
	},
	$_extractTreeRowIds : function(rows) {
		if (rows) {
			var cnt = rows.length;
			var ids = new Array(cnt);
			for (var i = 0; i  <cnt; i++) {
				ids[i] = rows[i].rowId();
			}
			return ids;
		}
		return null;
	},
	$_searchDataRow: function(dataRows, fields, values, options, startIndex, endIndex) {
		var rows = dataRows.length;
		if (rows < 1) {
			return -1;
		}
		var flds = Math.min(fields.length, values.length);
		if (flds < 1) {
			return -1;
		}
		var i, item, found, c, v;
		var all = !options || options.allFields;
		var sensitive = options && options.caseSensitive;
		var partial = options && options.partialMatch;
		var dateConvert = null;
		var fieldTypes = [];
		for (c = 0; c < flds; c++) {
			fieldTypes[c] = this.getField(fields[c]).dataType();
		}		
/* tree의 경우 dataRow가 0부터 시작하는 것이 아니고 순차적이지도 않다.전체 dataRow를 받아서 돌려야 한다. */
		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(rows - 1, endIndex);
		for (i = startIndex; i <= endIndex; i++) {
			found = true;
			if (found) {
				for (c = 0; c < flds; c++) {
					v = this.rowById(dataRows[i]).getValue(fields[c]);
					switch (fieldTypes[c]) {
						case ValueType.DATETIME :
						case ValueType.DATE :
							if (values[c] instanceof Date) {
								found = $$_compareTextValue(values[c], v, sensitive, partial);
							} else {
								if (!dateConvert) {
									var fmt = /[.]/.test(values[c]) ? "yyyy.MM.dd" : /[/]/.test(values[c]) ? "yyyy/MM/dd" : /[-]/.test(values[c]) ? "yyyy-MM-dd" : "yyyyMMdd";
									dateConvert = new DatetimeConverter(fmt);
								}
								found = $$_compareTextValue(values[c], v ? dateConvert.getText(v) : v, sensitive, partial);
							}
							break;
						default :
							found = $$_compareTextValue(values[c], v, sensitive, partial);
							break;
					}
					if (found && !all) {
						return dataRows[i];
					}
					if (!found && all) {
						break;
					}
				}
			}
			if (found) {
				return dataRows[i];
			}
		}
		return -1;
	},
	searchDataRow: function(fields, values, options, startRowId, wrap, parentId) {
		startRowId = arguments.length > 3 ? startRowId : 0;
		wrap = arguments.length > 4 ? wrap : true;
		parentId = arguments.length > 5 ? parentId : null;
		options = options instanceof SearchOptions ? options : options ? new SearchOptions(options) : null;
		var rowCnt, dataRows, startIndex;
		if (parentId != null) {
			var row = this.rowById(parentId);
			if (row) {
				dataRows = this.$_extractTreeRowIds(row.descendants());
			} else {
				return -1;
			}
		} else {
			dataRows = this.$_extractTreeRowIds(this._rootRow.descendants());
		}
		if (!_isArray(dataRows) || dataRows.length <= 0) {
			return -1;
		}
		rowCnt = dataRows.length;
		startIndex = Math.max(0, dataRows.indexOf(startRowId));
		var result = -1;
		if (fields && fields.length > 0 && values && values.length > 0) {
			var c, n, f, index;
			var cnt = fields.length;
			var flds = [];
			for (c = 0; c < cnt; c++) {
				n = parseFloat(fields[c]);
				if (!isNaN(n) && n | 0 == n) {
					flds.push(n);
				} else {
					f = this.getFieldIndex(fields[c]);
					if (f >= 0) {
						flds.push(f);
					}
				}
			}
			if (flds.length > 0) {
				result = startIndex < rowCnt ? this.$_searchDataRow(dataRows, flds, values, options, startIndex, rowCnt - 1) : -1;
				if (result < 0 && wrap && startIndex > 0) {
					result = this.$_searchDataRow(dataRows, flds, values, options, 0, startIndex - 1);
				}
			}
		}
		return result;
	},
	$_searchData: function(dataRows, fields, value, options, startIndex, endIndex, startFieldIndex) {
		var rows = this.rowCount();
		if (rows < 1) {
			return null;
		}
		var i, item, found, c, v;
		var sensitive = options && options.caseSensitive;
		var partial = options && options.partialMatch;
		var fldCount = this.fieldCount();
        var fldLen = fields.length;
        var dateConvert = null;
        var fieldTypes = [];
        for (c = 0; c < fldCount; c++) {
        	fieldTypes[c] = this.getField(c).dataType();
        }        
		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(rows - 1, endIndex);
		startFieldIndex = Math.max(0, startFieldIndex);
		if (startFieldIndex >= fields.length) {
			startIndex++;
			startFieldIndex = 0;
		}
		for (i = startIndex; i <= endIndex; i++) {
            c = (i > startIndex) ? 0 : startFieldIndex;
			for (; c < fldLen; c++) {
				var f = fields[c];
				if (f >= 0 && f < fldCount) {
					v = this.rowById(dataRows[i]).getValue(f);
					switch (fieldTypes[f]) {
						case ValueType.DATETIME :
						case ValueType.DATE :
							if (value instanceof Date) {
								found = $$_compareTextValue(value, v, sensitive, partial);	
							} else {
								if (!dateConvert) {
									var fmt = /[.]/.test(value) ? "yyyy.MM.dd" : /[/]/.test(value) ? "yyyy/MM/dd" : /[-]/.test(value) ? "yyyy-MM-dd" : "yyyyMMdd";
									dateConvert = new DatetimeConverter(fmt);
								}
								found = $$_compareTextValue(value, v ?  dateConvert.getText(v) : v, sensitive, partial);
							}
							break;
						default :
							found = $$_compareTextValue(value, v, sensitive, partial);
							break;
					}
					if (found) {
						var returnObj = {
							dataRow: dataRows[i],
							fieldIndex: f,
							searchFieldIndex: c
						};
						return returnObj;
					}
				}
			}
		}
		return null;
	},
	searchData: function (fields, value, options/* SearchCellOptions */, startRowId, startFieldIndex, wrap, parentId) {
		startIndex = arguments.length > 3 ? startIndex : 0;
		startFieldIndex = arguments.length > 4 ? startFieldIndex : 0;
		wrap = arguments.length > 5 ? wrap : true;
		options = options instanceof SearchCellOptions ? options : options ? new SearchCellOptions(options) : null;
		parentId = arguments.length > 5 ? parentId : null;
		var rowCnt, dataRows, startIndex;
		if (parentId != null) {
			var row = this.rowById(parentId);
			if (row) {
				dataRows = this.$_extractTreeRowIds(row.descendants());
			} else {
				return null;
			}
		} else {
			dataRows = this.$_extractTreeRowIds(this._rootRow.descendants());
		}
		if (!_isArray(dataRows) || dataRows.length <= 0) {
			return null;
		}
		rowCnt = dataRows.length;
		startIndex = Math.max(0, dataRows.indexOf(startRowId));
		var result = null;
		if (!fields || fields.length < 1) {
			fields = [];
			var arr = this.getFields();
			for (var i = 0; i < arr.length; i++) {
				fields.push(arr[i].orgFieldName());
			}
		}
		if (fields && fields.length > 0 && value != null) {
			var c, n;
			var cnt = fields.length;
			var flds = [];
			for (c = 0; c < cnt; c++) {
				n = parseFloat(fields[c]);
				if (!isNaN(n) && n | 0 == n) {
					flds.push(n);
				} else {
					flds.push(this.getFieldIndex(fields[c]));
				}
			}
			if (flds.length > 0) {
				startFieldIndex = Math.max(0, startFieldIndex);
				result = startIndex < rowCnt ? this.$_searchData(dataRows, flds, value, options, startIndex, rowCnt - 1, startFieldIndex) : null;
				if (!result && wrap && startIndex > 0) {
					result = this.$_searchData(dataRows, flds, value, options, 0, startIndex - 1, 0);
				}
				if (result) {
					result.fieldName = this.getOrgFieldName(result["fieldIndex"]);
				}
			}
		}
        return result;
	},
	isDataChanged: function(row, fieldIndex) {
		var row = this.rowById(row);
		if (!row) {
			if ($_debug) debugger;
		}
		if (row.rowState() !== RowState.UPDATED || !row._orgValues) {
			return false;
		}
		if (row._orgValues) {
			var v1 = row._orgValues[fieldIndex];
			var v2 = row._values[fieldIndex];
			var field = this._fields[fieldIndex];
			return field && field.dataType() !== ValueType.OBJECT && !field.sameValues(v1,v2);
		}
		return false;
	},
	$_hideDataRows: function(rowIds, hide) {
		if (rowIds == null) {
			return;
		};
		var idx, rowId;
		var oldCnt = this._hideRowIds.length;
		var ids = [];
		rowIds = _isArray(rowIds) ? rowIds : [rowIds];
		for (var i = 0, cnt = rowIds.length; i < cnt ; i++) {
			rowId = rowIds[i];
			if (this._findRowById(rowId) != null) {
				ids.push(rowId);
				if (hide) {
					this._hideRowIds.indexOf(rowId) < 0 && this._hideRowIds.push(rowId);
				} else {
					idx = this._hideRowIds.indexOf(rowId);
					idx >= 0 && this._hideRowIds.splice(idx, 1);
				}
			}
		}
		this._hideRowIds.length !== oldCnt && this._fireRowHided(ids, hide);
	},
	hideDataRows: function(rowIds) {
		this.$_hideDataRows(rowIds, true);
	},
	showDataRows: function(rowIds) {
		this.$_hideDataRows(rowIds, false);
	},
	clearHideDataRows:function() {
		if (this._hideRowIds.length > 0) {
			this._hideRowIds = [];
			this._fireRowHided([],false);
		}
	},
	getHideDataRows: function() {
		var ret = this._hideRowIds.concat();
		// ret.sort(function(a,b) {return a - b});
		// 	dataRow = null;
		// for (var i = 0, cnt = this._hideRowIds.length; i < cnt ; i++) {
		// 	dataRow = this._rowIds.indexOf(this._hideRowIds[i]);
		// 	dataRow >= 0 && ret.push(dataRow);
		// }
		ret.sort(function(a,b) {return a - b});
		return ret;
	},
	isHideDataRow: function(rowId) {
		var row = this.rowById(rowId);
		return !!row && this._hideRowIds.indexOf(rowId) >= 0;
	},
	hideCount: function() {
		return this._hideRowIds && _isArray(this._hideRowIds) ? this._hideRowIds.length : 0;
	},


	setOptions: function (options) {
		this._super(options);
	},
	getOptions: function () {
		var options = this._super();
		_extend(options, {
		});
	},
	_doCheckStatesChanged: function () {
		this.$_resetOrgValues();
	},
	_doRestoreModeChanged: function (oldMode, newMode) {
		this.$_resetOrgValues();
	},
	$_getSortedRows: function (field) {
		var compFunc;
		switch (this.getField(field).dataType()) {
			case ValueType.NUMBER:
				compFunc = this.compareNumbers.bind(this);
				break;
			case ValueType.DATETIME:
				compFunc = this.compareDates.bind(this);
				break;
			case ValueType.BOOLEAN:
				compFunc = this.compareBools.bind(this);
				break;
			case ValueType.OBJECT:
				compFunc = this.compareObjects.bind(this);
				break;
			default:
				compFunc = this.compareValues.bind(this);
				break;
		}
		var rows = this.getDescendants(this._rootRow, 0);
		this.$_sortRows(rows, field, compFunc, 0, rows.length - 1);
		return rows;
	},
	getDistinctValues: function (field, maxCount, sortDir) {
		maxCount = arguments.length > 1 ? maxCount : -1;
		this._checkFieldIndex(field);
		var values = [];
		if (maxCount < 0) {
			maxCount = this.getDescendantCount(this._rootRow);
		}
		if (maxCount > 0) {
			var isNum = this.getField(field).dataType() == ValueType.NUMBER;
			var rows = this.$_getSortedRows(field);
			sortDir === SortDirection.DESCENDING && rows.reverse();
			values.push(rows[0]._values[field]);
			for (var i = 1, cnt = rows.length; i < cnt; i++) {
				if (values.length >= maxCount) {
					break;
				}
				if (!this.equalValues(field, rows[i - 1], rows[i])) {
					var value = rows[i]._values[field];
					if (values.indexOf(value) == -1 && (!isNum || !isNaN(value) )) {// undefined나 NaN이 중복들어가는것을 방지
						values.push(value);
					}
				}
			}
		}
		return values;
	},
	_doFieldsReset: function () {
		this._super();
		this._clearRows();
		this._fireReset();
	},
	refreshClients: function () {
		this._fireRefreshClient();
	},
	savePoint: function (saveStates) {
		if (!this._checkClientState()) return;
		saveStates = arguments.length > 0 ? saveStates : true;
        var flds = this._fields.length;
        if (flds > 0 && this._rootRow.count() > 0) {
            var root = this._rootRow.copy();
            var i = this._nextPoint++;
            if (!saveStates) {
                root.clearRowStates(false, false);
            }
            this._points.push({
                id: i,
                data: root
            });
            return i;
        }
		return -1;
	},
	rollback: function (savePoint) {
        if (!this._checkClientState()) return;
		savePoint = arguments.length > 0 ? savePoint : 0;
        for (var i = this._points.length - 1; i >= 0; i--) {
            var point = this._points[i];
            if (point.id == savePoint) {
                this.$_removeSavePoints(i + 1);
                this._rowMap = [];
                this._rootRow.set(point.data);
                this._fireReset();
                break;
            }
        }
	},
	$_removeSavePoints: function (index) {
        var points = this._points;
        var point;
        for (var i = points.length - 1; i >= index; i--) {
            point = points[i];
            point.data = null;
            points.pop();
        }
	},
	clearSavePoints: function () {
        this.$_removeSavePoints(0);
	},
	getSavePoints: function () {
		var points = [];
        for (var i = 0, cnt = this._points.length; i < cnt; i++) {
            points.push(this._points[i].id);
        }
		return points;
	},
	equalValues: function (field, row1, row2) {
		if (row1 !== row2) {
			var fld = this._fields[field];
			var v1 = row1.getValue(field);
			var v2 = row2.getValue(field);
			return fld.equalValues(v1, v2);
		} else {
			return true;
		}
	},
    sameValues: function (field, row1, row2) {
        if (row1 !== row2) {
            var fld = this._fields[field];
            var v1 = row1.getValue(field);
            var v2 = row2.getValue(field);
            return fld.sameValues(v1, v2);
        } else {
            return true;
        }
    },
	compareValues: function (field, row1, row2) {
		if (row1 !== row2) {
			var v1 = row1.getValue(field);
			var v2 = row2.getValue(field);
			if (v1 === null) {
				return (v2 === null) ? 0 : -1;
			}
			if (v2 === null) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		} else {
			return 0;
		}
	},
	compareNumbers: function (field, row1, row2) {
		if (row1 !== row2) {
			var v1 = row1.getValue(field);
			var v2 = row2.getValue(field);
			if (isNaN(v1)) {
				return (isNaN(v2)) ? 0 : -1;
			}
			if (isNaN(v2)) {
				return 1;
			}
			return v1 > v2 ? 1 : (v1 < v2) ? -1 : 0;
		} else {
			return 0;
		}
	},
	compareBools: function (field, row1, row2) {
		if (row1 !== row2) {
			var v1 = row1.getValue(field);
			var v2 = row2.getValue(field);
			return (v1 && !v2) ? 1 : (!v1 && v2) ? -1 : 0;
		} else {
			return 0;
		}
	},
	compareDates: function (field, row1, row2) {
		if (row1 !== row2) {
			var v1 = row1.getValue(field);
			var v2 = row2.getValue(field);
			if (!(v1 instanceof Date)) {
				return !(v2 instanceof Date) ? 0 : -1;
			}
			if (!(v2 instanceof Date)) {
				return 1;
			}
			return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
		} else {
			return 0;
		}
	},
	compareObjects: function (field, row1, row2) {
		var vals1 = this._values[row1];
		var vals2 = this._values[row2];
		if (vals1 === vals2) {
			return 0;
		} else {
			var v1 = vals1 ? vals1[field] : null;
			var v2 = vals2 ? vals2[field] : null;
			if (!v1) {
				return !v2 ? 0 : -1;
			};
			if (!v2) {
				return 1;
			}
			var fld = this.getField(field);
			return fld.$_compareObject(v1, v2, row1, row2);
		}
	},
	$_summarizeChildren: function (parent, summary) {
		var i;
		var row;
		var v;
		var f = summary.field;
		var cnt = parent.count();
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				summary.sum += v;
				summary.datacount++;
				if (v < summary.min) summary.min = v;
				if (v > summary.max) summary.max = v;
			}
			this.$_summarizeChildren(row, summary);
		}
	},
	$_summarizeVars: function (parent, summary) {
		var i;
		var row;
		var v;
		var f = summary.field;
		var avg = summary.avg;
		var cnt = parent.count();
		var vars = 0;
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				vars += Math.pow(v - avg, 2);
			}
			vars += this.$_summarizeVars(row, summary);
		}
		return vars;
	},
	summarize: function (summary, calcVars) {
		if (summary == null) {
			return false;
		}
		summary.clear();
		var count = this.rowCount();
		if (count < 1) {
			return false;
		}
		summary.count = count;
		summary.sum = 0;
		summary.min = Number.MAX_VALUE;
		summary.max = Number.MIN_VALUE;
		summary.datacount = 0;
		this.$_summarizeChildren(this._rootRow, summary);
		summary.avg = summary.sum / summary.count;
		summary.dataavg = summary.datacount === 0 ? NaN : summary.sum / summary.datacount;
		if (calcVars) {
			var vars = this.$_summarizeVars(this._rootRow, summary);
			summary.varsp = vars / summary.count;
			summary.vars = vars / (summary.count - 1);
		}
		return true;
	},
	summarizeRange: function (summary, rows, calcVars) {
		if (summary == null || rows == null) {
			return false;
		}
		summary.clear();
		var count = rows.length;
		if (count < 1) {
			return false;
		}
		var i;
		var row;
		var v;
		var n = 0;
		var f = summary.field;
		var sum = 0;
		var min = NaN;
		var max = NaN;
		i = 0;
		while (i < count) {
			row = rows[i++];
			v = row.getValue(f);
			if (!isNaN(v)) {
				sum = min = max = v;
				n++;
				break;
			}
		}
		while (i < count) {
			row = rows[i++];
			v = row.getValue(f);
			if (!isNaN(v)) {
				sum += v;
				if (v < min) min = v;
				if (v > max) max = v;
				n++;
			}
		}
		summary.count = count;
		if (n > 0) {
			summary.sum = sum;
			summary.min = min;
			summary.max = max;
			summary.avg = sum / count;
			summary.datacount = n;
			summary.dataavg = n === 0 ? NaN : sum / n;
			if (calcVars) {
				if (count > 1) {
					var vars = 0;
					var avg = summary.avg;
					for (i = 0; i < count; i++) {
						row = rows[i++];
						v = row.getValue(f);
						if (!isNaN(v)) {
							vars += Math.pow(v - avg, 2);
						}
					}
					summary.varsp = vars / count;
					summary.vars = vars / (count - 1);
				} else {
					summary.varsp = 0;
					summary.vars = 0;
				}
			}
		}
		return true;
	},
	getHandler: function() {
		return this.fireObjectEvent(DataProvider.GET_HANDLER);
	},
	$_resetOrgValues: function () {
		this._needOrgValues = this._checkStates && this._restoreMode != RestoreMode.NONE;
		this._needRestore = this._needOrgValues && this._restoreMode == RestoreMode.AUTO;
		this._rootRow.$_clearOrgValues();
	},
	_findRowById: function (rowId) {
		return this._rootRow.findById(rowId);
	},
	_checkSum: function (count) {
		if (count != this.rowCount()) {
			throw new Error("Invalid row count: " + count + " <> " + this.rowCount());
		}
	},
	_clearRows: function () {
		this._rootRow._removeChildren();
		this._rowMap = [];
		if (this._rootRow && this._rootRow.descendantCount() > 0) {

		} else {
			this._nextRowId = 1;  // rootRow가 0번이고 다음은 1부터 시작한다.
		}
		this._tags.clearRows();
		this._checkSum(0);
	},
	_summarizeChildren: function (parent, field) {
		var i, row, v, 
			f = field.field,
			cnt = parent.count();
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				field.sum += v;
				if (v < field.min) field.min = v;
				if (v > field.max) field.max = v;
			}
			this.summarizeChildren(row, field);
		}
	},
	_summarizeVars: function (parent, field) {
		var i, row, v, 
			f = field.field,
			avg = field.avg,
			cnt = parent.count(),
			vars = 0;
		for (i = 0; i < cnt; i++) {
			row = parent.getChild(i);
			v = row.getValue(f);
			if (!isNaN(v)) {
				vars += Math.pow(v - avg, 2);
			}
			vars += summarizeChildren(row, field);
		}
		return vars;
	},
	_summarize: function (field, calcVars) {
		if (field == null) {
			return false;
		}
		field.clear();
		var count = this.rowCount();
		if (count < 1) {
			return false;
		}
		field.count = 0;
		field.sum = 0;
		field.min = Number.MIN_VALUE;
		field.max = Number.MAX_VALUE;
		this._summarizeChildren(this._rootRow, field);
		field.avg = field.sum / field.count;
		if (calcVars) {
			var vars = this._summarizeVars(this._rootRow, field);
			field.vars = vars / field.count;
		}
		return true;
	},
	_iconIndexChanged: function (row) {
		this._fireIconIndexChanged(row);
	},
	_hasChildrenChanged: function (row) {
		this._fireHasChildrenChanged(row);	
	},
	_stateChanged: function (row, refresh) {
		this._fireRowStateChanged(row, refresh);
	},
	_valueChanged: function (row, field) {
		this._fireValueChanged(row, field);
	},
	_rowAdding: function (row, index, child) {
		return this._fireRowAdding(row, index, child);
	},
	_rowAdded: function (row) {
		if (!this._tagLock) {
			this._tags.addRow(row);
		}
		if (this._eventLock <= 0) {
			this._fireRowAdded(row);
			this._fireRowCountChanged();
		}
	},
	_rowsAdded: function (parent, rows) {
		if (!this._tagLock) {
			this._tags.addRows(rows);
		}
		if (this._eventLock <= 0) {
			this._fireRowsAdded(parent, rows);
			this._fireRowCountChanged();
		}
	},
	_rowRemoving: function (row) {
		return this._fireRowRemoving(row);
	},
	_rowRemoved: function (row) {
		if (!this._tagLock) {
			this._tags.removeRow(row);
		}
		if (this._eventLock <= 0) {
			this._fireRowRemoved(row);
			this._fireRowCountChanged();
		}
	},
	_rowsRemoving: function (rows) {
		return this._fireRowsRemoving(rows);
	},
	_rowsRemoved: function (rows) {
		if (!this._tagLock) {
			this._tags.removeRows(rows);
		}
		if (this._eventLock <= 0) {
			this._fireRowsRemoved(rows);
			this._fireRowCountChanged();
		}
	},
	_rowCleared: function (row) {
		if (row) {
			var rows = row.children();
			this._tags.removeRows(rows);
			if (this._eventLock <= 0) {
				this._fireRowsRemoved(rows);
				this._fireRowCountChanged();
			}
		}
	},
	_rowUpdating: function (row) {
		return this._fireRowUpdating(row);
	},
	_rowUpdated: function (row) {
		this._tags.updateRow(row);
		if (this._eventLock <= 0) {
			this._fireRowUpdated(row);
		}
	},
	_fireDisposed: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.DISPOSED);
		} 
	},
	_fireReset: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.RESET);
		} 
	},
	_fireRefresh: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.REFRESH);
		} 
	},
	_fireRefreshClient: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.REFRESH_CLIENT);
		} 
	},
	_fireCleared: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.CLEARED);
		} 
	},
	_fireRowCountChanged: function () {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_COUNT_CHANGED, this.rowCount());
		} 
	},
	_fireRowAdding: function (row, index, child) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(LocalTreeDataProvider.ROW_ADDING, row, index, child);
		}
		return true;
	},
	_fireRowAdded: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_ADDED, row);
		} 
	},
	_fireRowsAdded: function (parent, rows) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROWS_ADDED, parent, rows);
		} 
	},
	_fireRowRemoving: function (row) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(LocalTreeDataProvider.ROW_REMOVING, row);
		}
		return true;
	},
	_fireRowRemoved: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_REMOVED, row);
		} 
	},
	_fireRowsRemoving: function (rows) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(LocalTreeDataProvider.ROWS_REMOVING, rows);
		}
		return true;
	},
	_fireRowsRemoved: function (rows) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROWS_REMOVED, rows);
		} 
	},
	_fireRowUpdating: function (row) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(LocalTreeDataProvider.ROW_UPDATING, row);
		} 
		return true;
	},
	_fireRowUpdated: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_UPDATED, row);
		} 
	},
	_fireValueChanging: function (row, field, newValue) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(LocalTreeDataProvider.VALUE_CHNAGED, row, field, newValue);
		}
		return true;
	},
	_fireValueChanged: function (row, field) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.VALUE_CHNAGED, row, field);
		} 
	},
	_fireIconIndexChanged: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ICON_INDEX_CHANGED, row);
		} 
	},
	_fireHasChildrenChanged: function (row) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.HAS_CHILDREN_CHANGED, row);
		} 
	},
	_fireRowStateChanged: function (row, refresh) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_STATE_CHANGED, row, refresh);
		} 
	},
	_fireRowStatesChanged: function (rows) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_STATES_CHANGED, rows);
		} 
	},
	_fireRowSiblingMoving: function (row, delta) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(LocalTreeDataProvider.ROW_SIBLING_MOVING, row, delta);
		} 
		return true;
	},
	_fireRowSiblingMoved: function (row, delta) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_SIBLING_MOVED, row, delta);
		} 
	},
	_fireRowParentChanging: function (row, parent, childIndex) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(LocalTreeDataProvider.ROW_PARENT_CHANGING, row, parent, childIndex);
		} 
		return true;
	},
	_fireRowParentChanged: function (row, parent, childIndex) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_PARENT_CHANGED, row, parent, childIndex);
		} 
	},
	_fireRowHided: function(rows, hide) {
		if (this._eventLock <= 0) {
			this.fireEvent(LocalTreeDataProvider.ROW_HIDED, rows, hide);
		}
	}
});
LocalTreeDataProvider.DISPOSED = "onTreeDataProviderDisposed";
LocalTreeDataProvider.RESET = "onTreeDataProviderReset";
LocalTreeDataProvider.REFRESH = "onTreeDataProviderRefresh";
LocalTreeDataProvider.REFRESH_CLIENT = "onTreeDataProviderRefreshClient";
LocalTreeDataProvider.CLEARED = "onTreeDataProviderCleared";
LocalTreeDataProvider.ROW_COUNT_CHANGED = "onTreeDataProviderRowCountChanged";
LocalTreeDataProvider.ROW_ADDING = "onTreeDataProviderRowAdding";
LocalTreeDataProvider.ROW_ADDED = "onTreeDataProviderRowAdded";
LocalTreeDataProvider.ROWS_ADDED = "onTreeDataProviderRowsAdded";
LocalTreeDataProvider.ROW_REMOVING = "onTreeDataProviderRowRemoving";
LocalTreeDataProvider.ROW_REMOVED = "onTreeDataProviderRowRemoved";
LocalTreeDataProvider.ROWS_REMOVING = "onTreeDataProviderRowsRemoving";
LocalTreeDataProvider.ROWS_REMOVED = "onTreeDataProviderRowsRemoved";
LocalTreeDataProvider.ROW_UPDATING = "onTreeDataProviderRowUpdating";
LocalTreeDataProvider.ROW_UPDATED = "onTreeDataProviderRowUpdated";
LocalTreeDataProvider.VALUE_CHANGING = "onTreeDataProviderValueChanging";
LocalTreeDataProvider.VALUE_CHNAGED = "onTreeDataProviderValueChanged";
LocalTreeDataProvider.ICON_INDEX_CHANGED = "onTreeDataProviderIconIndexChanged";
LocalTreeDataProvider.HAS_CHILDREN_CHANGED = "onTreeDataProviderHasChildrenChanged";
LocalTreeDataProvider.ROW_STATE_CHANGED = "onTreeDataProviderRowStateChanged";
LocalTreeDataProvider.ROW_STATES_CHANGED = "onTreeDataProviderRowStatesChanged";
LocalTreeDataProvider.ROW_SIBLING_MOVING = "onTreeDataProviderRowSiblingMoving";
LocalTreeDataProvider.ROW_SIBLING_MOVED = "onTreeDataProviderRowSiblingMoved";
LocalTreeDataProvider.ROW_PARENT_CHANGING = "onTreeDataProviderRowParentChanging";
LocalTreeDataProvider.ROW_PARENT_CHANGED = "onTreeDataProviderRowParentChanged";
LocalTreeDataProvider.ROW_HIDED = "onTreeDataProviderRowHideChanged";
LocalTreeDataProvider.GET_HANDLER = "getHandler";
var /* internal */ LocalTreeDataProviderObserver = defineClass("LocalTreeDataProviderObserver", DataProviderObserver, {
	init: function () {
		this._super();
	},
	onTreeDataProviderDisposed: function (provider) {
	},
	onTreeDataProviderReset: function (provider) {
	},
	onTreeDataProviderRefresh: function (provider) {
	},
	onTreeDataProviderRefreshClient: function (provider) {
	},
	onTreeDataProviderCleared: function (provider) {
	},
	onTreeDataProviderRowCountChanged: function (provider, newCount) {
	},
	onTreeDataProviderRowAdding: function (provider, row, index) {
		return true;
	},
	onTreeDataProviderRowAdded: function (provider, row) {
	},
	onTreeDataProviderRowsAdded: function (provider, parent, rows) {
	},
	onTreeDataProviderRowRemoving: function (provider, row) {
		return true;
	},
	onTreeDataProviderRowRemoved: function (provider, row) {
	},
	onTreeDataProviderRowsRemoving: function (provider, rows) {
		return true;
	},
	onTreeDataProviderRowsRemoved: function (provider, rows) {
	},
	onTreeDataProviderRowUpdating: function (provider, row) {
		return true;
	},
	onTreeDataProviderRowUpdated: function (provider, row) {
	},
	onTreeDataProviderValueChanging: function (provider, row, field, newValue) {
		return true;
	},
	onTreeDataProviderValueChanged: function (provider, row, field) {
	},
	onTreeDataProviderIconIndexChanged: function (provider, row) {
	},
	onTreeDataProviderHasChildrenChanged: function (provider, row) {
	},
	onTreeDataProviderRowStateChanged: function (provider, row) {
	},
	onTreeDataProviderRowStatesChanged: function (provider, rows) {
	},
	onTreeDataProviderRowSiblingMoving: function (provider, row, delta) {
		return true;
	}, 
	onTreeDataProviderRowSiblingMoved: function (provider, row, delta) {
	}, 
	onTreeDataProviderRowParentChanging: function (provider, row, parent, childIndex) {
		return true;
	}, 
	onTreeDataProviderRowParentChanged: function (provider, row, parent, childIndex) {
	}
});
var TreeDataLoader = defineClass("TreeDataLoader", null, {
	init: function (provider) {
		Base.init.call(this);
		this._provider = provider;
	},
	load: function (type, data, options) {
		options = new DataFillOptions(options);
		if (this.$_checkEmpty(data, options)) {
			return 0;
		}
		this.$_prepareLoad(data, options);
		type = type && type.toLowerCase();
		switch (type) {
			case "json": return this.$_loadJson(data, options);
			case "xml": return this.$_loadXml(data, options);
			case "csv": return this.$_loadCsv(data, options);
		}
		return 0;
	},
	/**
	 * @param data Json array 이거나 Json object.
	 * @param options DataLoadOptions.
	 */
	$_loadJson: function (data, options) {
		if (typeof data === "string") {
			data = JSON.parse(data);
		}
		if (data) {
			var childrenField = options.childrenField || options.children;
			var iconField = options.iconField || options.icon;
			if (options.fillMode == DataFillMode.APPEND) {
				var parent;
				if (options.parentId === -1) {
					parent = this._provider.rootRow();
				} else {
					parent = this._provider.rowById(options.parentId);	
				}
				return this._provider.appendJsonRows(parent, data, options.rows, childrenField, iconField);
			} else {
				return this._provider.setJsonRows(data, options.rows, childrenField, iconField);
			}
			/*
			var fillPos = options.fillPos;
			var start = options.start;
			var count = options.count;
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.addRows(rows, start, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertRows(fillPos, rows, start, count);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateRows(fillPos, rows, start, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setRows(rows, start, count);
					break;
			}
			return rows.length;
			*/
		}/* else {
			this.$_fillEmpty(options)
			return 0;
		}
		*/
		return 0;
	},
	/**
	 * @param data Xml dom 객체이거나 Xml string.
	 * @param options DataLoadOptions.
	 */
	$_loadXml: function (data, options) {
		if (typeof data === "string") {
			data = _parseXml(data);
		}
		if (data && data.documentElement) {
			var childrenField = options.childrenField || options.children;
			var iconField = options.iconField || options.icon;
			if (options.fillMode == DataFillMode.APPEND) {
				var parent = this._provider.rowById(options.parentId);
				return this._provider.appendXmlRows(parent, data, options.rows, childrenField, iconField);
			} else {
				return this._provider.setXmlRows(data, options.rows, childrenField, iconField);
			}
			/*
			var fillPos = options.fillPos;
			var start = options.start;
			var count = options.count;
			var rowProp = options.rows;
			var rows = DataPath.extractXml(data.documentElement, rowProp);
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.appendXmlRows(rows, start, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertXmlRows(fillPos, rows, start, count);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateXmlRows(fillPos, rows, start, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setXmlRows(rows, start, count);
					break;
			}
			return rows.length;
			*/
		} else {
			/*
			this.$_fillEmpty(options);
			return 0;
			*/
		}
		return 0;
	},
	/**
	 * @param data csv text.
	 * @param options DataLoadOptions.
	 */
	$_loadCsv: function (data, options) {
		var start = options.start;
		var count = options.count;
		var quoted = options.quoted;
		var delimiter = options.delimiter;
		var rows = DataHelper.csvToArray(this._provider, data, start, count, quoted, delimiter);
		if (rows && (count = rows.length) > 0) {
			var treeField = options.treeField || options.tree;
			var childrenField = options.childrenField || options.children;
			var iconField = options.iconField || options.icon;
			var needSorting = options.needSorting || options.sorting;
			if (options.fillMode == DataFillMode.APPEND) {
				var parent = this._provider.rowById(options.parentId);
				return this._provider.appendDataRows(parent, rows, treeField, needSorting, childrenField, iconField);
			} else {
				return this._provider.setRows(rows, treeField, needSorting, childrenField, iconField);
			}
			/*
			switch (options.fillMode) {
				case DataFillMode.APPEND:
					this._provider.addRows(rows, 0, count);
					break;
				case DataFillMode.INSERT:
					this._provider.insertRows(fillPos, rows, 0, count);
					break;
				case DataFillMode.UPDATE:
					this._provider.updateRows(fillPos, rows, 0, count);
					break;
				case DataFillMode.SET:
				default:
					this._provider.setRows(rows, 0, count);
					break;
			}
			return rows.length;
			*/
		}/* else {
			this.$_fillEmpty(options);
			return 0;
		}
		*/
		return 0;
	},
	$_fillEmpty: function (options) {
		if (options.fillMode === DataFillMode.SET) {
			this._provider.setRows(null);
		}
	},
	$_checkEmpty: function (data, options) {
		if (!data) {
			this.$_fillEmpty(options);
			return true;
		}
		return false;
	},
	$_prepareLoad: function (options) {
		var filters = null;
		if (options.filters) {
			filters = new DataFilterCollection(this._provider.filterRuntime(), options.filters);
			options.filterMode && filters.setFilterMode(options.filterMode);
		}
	}
});

var TreeItem = defineClass("TreeItem", GroupItem, {
	init: function(dataRow) {
		this._super();
		this._dataRow = dataRow;
		this._footer = null;
		// delete this._extents; // TreeItem의 경우 GridItem과는 다르게 Sort,Filter를 실행했을때 제거후 다시 생성한다. check,unCheckable정보를 TreeDataRow로 옮겨준다.
	},
	destroy: function() {
		this._destroying = true;
		this._dataRow = null;
		this._super();
	},
	isChecked: function () {
		var dataRow = this._dataRow;
		return dataRow && (dataRow._extents & ITEM_EXT_CHECKED) != 0;
	},
	$_setChecked: function (value) {
		var dataRow = this._dataRow;
		dataRow && (dataRow._extents = value ? (dataRow._extents | ITEM_EXT_CHECKED) : (dataRow._extents & ~ITEM_EXT_CHECKED));
	},
	isCheckable: function () {
		var dataRow = this._dataRow;
		return !dataRow || (dataRow._extents & ITEM_UNCHECKABLE) == 0;
	},
	$_setCheckable: function (value) {
		var dataRow = this._dataRow;
		dataRow && (dataRow._extents = value ? (dataRow._extents & ~ITEM_UNCHECKABLE) : (dataRow._extents | ITEM_UNCHECKABLE));
	},
	iconHeight: 0,
	row: function () {
		return this._dataRow;
	},
	rowId: function () {
		return this._dataRow ? this._dataRow.rowId() : -1;
	},
	iconIndex: function () {
		return this._dataRow.iconIndex();
	},
	hasChildren: function () {
		return this.count() > 0 || this._dataRow.hasChildren();
	},
	rootItem: function () {
		var p = this;
		while (p.level() > 1) {
			p = p.parent();
		}
		return p;
	},
	lastVisible: function () {
		return (this.isExpanded() && this.count() > 0) ? this.isLastVisible() : this;
	},
	createFooter: function () {
		if (!this._footer) {
			this._footer = new TreeItemFooter();
			this._attachItem(this._footer);
		}
	},
	dataRow: function () {
		return this._dataRow ? this._dataRow.rowId() : -1;
	},
	dataId: function () {
		return this._dataRow ? this._dataRow.rowId() : -1;
		//return this._dataRow.rowId();
	},
	descendantCount: function () {
		return this._dataRow.descendantCount();
	},
	rowState: function () {
		return this._dataRow.rowState();
	},
	isLeaf: function () {
		return this.count() == 0;
	},
	footer: function () {
		return this._footer;
	},
	isEditable: function () {
		return true;
	},
	summaryMode: function () {
		return SummaryMode.AGGREGATE;
	},
	setExpanded: function (value) {
		var provider;
		if (value != this.isExpanded() && (provider = this.provider())) {
			if (value) {
				provider.expand(this, false, false);
			} else {
				provider.collapse(this);
			}
		}
	},
	isResizable: function () {
		return true;
	},
	canEdit: function () {
		return true;
	},
	getData: function (field) {
		return this._dataRow.getValue(field);
	},
	setData: function (field, value) {
		this._dataRow.setValue(field, value);
	},
	setItem: function (item, newItem) {
		this._super(item, newItem);
		newItem._addChildren(item.children());
		item.clear();
	},
	exchange: function (index1, index2) {
		this.exchangeItems(index1, index2);
	},
	moveChild: function (index, delta) {
		var newIndex = index+delta;
		var child = this._children[index];
		if (delta < 0) {
			for (var i = index; i > newIndex; i--) 
				this._children[i] = this._children[i-1];
		} else {
			for (var i = index; i < newIndex; i++)
				this._children[i] = this._children[i+1];			
		}
		this._children[newIndex] = child;		
	},
	changeParent: function(parent, index) {
		var old = this._parent;
		old.remove(this);
		if (parent) {
			parent.insert(index, this);
		}
	},
	getRowData: function() {
		return this._dataRow && this._dataRow._values.concat();
	}
});
TreeItem.$_tempTreeItem = new TreeItem();
TreeItem.getTemp = function (row) {
	TreeItem.$_tempTreeItem._dataRow = row;
	return TreeItem.$_tempTreeItem;
};
var TreeItem$ = TreeItem.prototype;
var RootTreeItem = defineClass("RootTreeItem", TreeItem, {
	init: function(provider) {
		this._super(null);
		this._provider = provider;
	},
	id: function () {
		return NaN;
	},
	provider: function () {
		return this._provider;
	},
	level: function () {
		return 0;
	},
	isExpanded: function () {
		return true;
	},
	setExpanded: function (value) {
	},
	isLeaf: function () {
		return false;
	},
	isVisible: function () {
		return true;
	},
	dataSource: function () {
		return this._provider.dataSource();
	}
});
var HierarchicalVisibleItems = function (provider) {
	_assert(provider != null && provider !== undefined, "provider is null");
	var _provider = provider;
	var _fixedCount = 0;
	var _items = [];
	var _list = [];
	this.provider = function () {
		return _provider;
	};
	this.count = function () {
		return _items.length;
	};
	this.fixedCount = function () {
		return _fixedCount;
	},
	this.getItem = function (index) {
		return _items[index];
	};
	this.setItem = function (index, newItem) {
		_items[index] = newItem;
	};
	this.indexOf = function (item) {
		return _items.indexOf(item);
	};
	this.clear = function () {
		_items.length = 0;
	};
	var collectChildren = function (parent, list, recursive, level) {
		var i, item;
		var cnt = parent.count();
		for (i = 0; i < cnt; i++) {
			item = parent.getItem(i);
			if (item) {
				list.push(item);
				if ((recursive && item.level() < level) || item.isExpanded()) {
					collectChildren(item, list, recursive, level);
				}
			}
		}
		var footer = parent.footer();
		if (footer) {
			list.push(parent.footer());
		}
	};
	var expandItem = function (item, recursive, level) {
		var i, cnt, idx;
		var list = _list;
		if (item instanceof RootTreeItem) {
			idx = _fixedCount;
		} else {
			idx = item.index() + 1;
		}
		level = Math.max(0, level);
		list.length = 0;
		collectChildren(item, list, recursive, level > 0 ? item.level() + level : 1000000);
		if (recursive) {
			for (i = idx, cnt = _items.length; i < cnt; i++) {
				if (_items[i].level() <= item.level()) {
					break;
				}
			}
			_items.splice(idx, i - idx);
		}
		for (i = 0, cnt = list.length; i < cnt; i++) {
			_items.splice(idx + i, 0, list[i]);
		}
	};
	this.expand = function (item, recursive, level) {
		level = arguments.length > 0 ? level : 0;
		if (item) {
			expandItem(item, recursive, level);
		}
	};
	this.collapse = function (item) {
		if (item) {
			var idx = item.index() + 1;
			while (idx < _items.length && _items[idx].level() > item.level()) {
				if (_items[idx] == item.footer()) {
					if (!_provider.footerWhenCollapsed()) {
						_items[idx]._index = -1;
						_items.splice(idx, 1);
					}
					break;
				}
				_items[idx]._index = -1;
				_items.splice(idx, 1);
			}
		}
	};
	this.getNext = function (item) {
		if (item && item.isVisible() && item.index() < this.count() - 1) {
			return _items[item.index() + 1];
		}
		return null;
	};
	this.getPrior = function (item) {
		if (item && item.isVisible() && item.index() > 0) {
			return _items[item.index() - 1];
		}
		return null;
	};
	this.insert = function (item, index) {
		_items.splice(index, 0, item);
	};
	this.remove = function (item) {
		var i = _items.indexOf(item);
		if (i >= 0) {
			_items.splice(i, 1);
			if (item.isExpanded()) {
				while (i < _items.length && item.isDescendant(_items[i])) {
					_items.splice(i, 1);
				}
			}
		}
	};
	this._clearAndInit = function (fixedCount) {
		this.clear();
		_fixedCount = Math.min(fixedCount, _provider.itemCount());
		for (var i = 0; i < _fixedCount; i++) {
			_items.push(_provider.getItem(i));
		}
	};
};
var TreeItemProvider = defineClass("TreeItemProvider", ItemProvider, {
	init: function () {
		this._super(true);
		this._cellStyles = new TreeCellStyleMap(this);
		this._editableMap = new TreeCellEditableMap(this);
		this._filters = {};
		this._filterRuntime = new ColumnFilterRuntime();
		this._filtered = false;
		this._sorter = new TreeItemsSorter();
		this._sortFields = [];
		this._sortDirections = [];
        this._sortCases = [];
		this._visibleItems = new HierarchicalVisibleItems(this);
		this._itemMap = [];
		this._itemCount = 0;
		this._summaryMap = null;
		this._checkableExpression = null;
		this._checkableTag = null;
		this._filterLock = 0;
	},
	destroy: function() {
		this._destroying = true;
		this._cellStyles = null;
		this._editableMap = null;
		this._filters = {};
		this._filterRuntime = null;
		this._sorter = null;
		this._sortFields = [];
		this._sortDirections = [];
        this._sortCases = [];
		this._visibleItems = null;
		this._itemMap = [];
		this._summaryMap = null;
		this._checkableExpression = null;
		this._checkableTag = null;
		this._super();
	},
	sortMode: SortMode.AUTO,
	onTreeDataProviderDisposed: function (provider/*TreeDataProvider*/) {
		this.provider().removeTag(this._cellStyls);
		this.$_clearItems();
		this.$_resetSummary();
		this._fireReset();
		this.setDataSource(null);
	}, 
	onTreeDataProviderReset: function (provider) {
		this.$_clearItems();
		this.$_resetSummary();
		this.$_buildTree();
		this._fireReset();
	},
	onTreeDataProviderRefresh: function (provider) {
		this._refreshItems();
	},
	onTreeDataProviderRefreshClient: function (provider) {
		this._fireRefreshClient();
	},
	onDataProvderCleared: function (provider) {
		this._refreshItems();
	},
	onTreeDataProviderRowCountChanged: function (provider, newCount) {
	},
	onTreeDataProviderRowAdding: function (provider, row, index) {
		return true;
	},
	onTreeDataProviderRowAdded: function (provider, row) {
		if (this.$_needSort()) {
			this._saveAndRefresh();
		} else {
			var p/*TreeItem*/ = this._itemMap[row.parent().rowId()];
			var item/*TreeItem*/ = this.$_internalAddItem(p, row);
			if (item) {
				this.$_buildItems(item);
				this.$_clearSummary();
				if (p.isExpanded()) {
					this._expandItem(p, true, false, 0, false);
				} else {
					this._fireItemChanged(p);
				}
			} else {  // filter등에 의해서 item이 제거되는 경우 itemIndicies를 다시 설정해 주어야 한다.
				this.$_resetVisibleItems();
			}
		}
		if (this._checkableTag) {
			this._checkableTag.addRow(row, false);
			if (row.parent().level() > 0) {
				this._checkableTag.addRow(row.parent(), false);
			}
		}
	},
	onTreeDataProviderRowsAdded: function (provider, parent, rows) {
		if (this.$_needSort()) {
			this._saveAndRefresh();
			return;
		}
		var i, row, item, cnt;
		var p = this._itemMap[parent.rowId()];
		if (p && rows && (cnt = rows.length) > 0) {
			for (i = 0; i < cnt; i++) {
				row = rows[i];
				item = this.$_internalAddItem(p, row);
				if (item) {
					this.$_buildItems(item);
				}
			}
			this.$_clearSummary();
			if (p.isExpanded()) {
				this._expandItem(p, true, false, 0, false);
			} else {
				this._fireItemChanged(p);
			}
			if (this._checkableTag) {
				this._checkableTag.addRows(rows);
				if (parent.level() > 0) {
					this._checkableTag.addRow(parent);
				}
			}
		}
	},
	onTreeDataProviderRowRemoving: function (provider, row) {
		return true;
	},
	onTreeDataProviderRowRemoved: function (provider, row) {
		var item = this._itemMap[row.rowId()];
		if (item) {
			var p = item.parent();
			this.$_internalRemoveItem(item);
			this.$_clearSummary();
			if (p.isExpanded() && p.isVisible()) {
				this._visibleItems.remove(item);
				this._fireRefresh();
			}
		}
	},
	onTreeDataProviderRowsRemoving: function (provider, rows) {
		return true;
	},
	onTreeDataProviderRowsRemoved: function (provider, rows) {
		var i, row, item, p;
		var cnt = rows.length;
		var removed = false;
		for (i = 0; i < cnt; i++) {
			row = rows[i];
			item = this._itemMap[row.rowId()];
			if (item) {
				p = item.parent();
				this.$_internalRemoveItem(item);
				if (p.isExpanded() && p.isVisible()) {
					this._visibleItems.remove(item);
					removed = true;
				}
			}
		}
		this.$_clearSummary();
		if (removed) {
			this._fireRefresh();
		}
	},
	onTreeDataProviderRowUpdating: function (provider, row) {
		return true;
	},
	onTreeDataProviderRowUpdated: function (provider, row) {
		if (this.$_needSort()) {
			this._saveAndRefresh();
		} else {
			var item = this._itemMap[row.rowId()];
			this.$_clearSummary();
			this._fireItemUpdated(item);
		}
		if (this._checkableTag) {
			this._checkableTag.updateRow(row);
		}
	},
	onTreeDataProviderValueChanging: function (provider, row, field) {
		return true;
	},
	onTreeDataProviderValueChanged: function (provider, row, field) {
		if (this.$_needSort()) {
			this._saveAndRefresh();
		} else {
			var item = this._itemMap[row.rowId()];
			this.$_clearSummary();
			this._fireItemUpdated(item);
		}
		if (this._checkableTag) {
			this._checkableTag.updateRow(row);
		}
	},
	onTreeDataProviderIconIndexChanged: function (provider, row) {
		var item = this._itemMap[row.rowId()];
		if (item && item.isVisible()) {
			this._fireItemChanged(item);
		}
	},
	onTreeDataProviderHasChildrenChanged: function (provider, row) {
		var item = this._itemMap[row.rowId()];
		if (item && item.isVisible()) {
			this._fireItemChanged(item);
		}
	},
	onTreeDataProviderRowStateChanged: function (provider, row, refresh) {
		var item = this._itemMap[row.rowId()];
		this.$_internalRowStateChanged(item, refresh);
		if (this._checkableTag) {
			this._checkableTag.updateRow(row);
		}
		!item && refresh && this._saveAndRefresh();
	},
	onTreeDataProviderRowStatesChanged: function (provider, rows) {
		var p, item, row, i, cnt, removed;
		var len = rows.length;
		var saveRefresh = false;
		if (len == 1) {
			row = rows[0];
			item = this._itemMap[row.rowId()];
			saveRefresh = !item;
			this.$_internalRowStateChanged(item);
			if (this._checkableTag) {
				this._checkableTag.updateRow(row);
			}
			saveRefresh && this._saveAndRefresh();
		} else if (len > 0) {
			removed = false;
			if (this._hideDeleted) {
				for (i = 0, cnt = rows.length; i < cnt; i++) {
					item = this._itemMap[rows[i].rowId()];
					saveRefresh = saveRefresh || !item;
					if (item && RowState.isDeleted(item.rowState())) {
						p = item.parent();
						this.$_internalRemoveItem(item);
						if (p.isExpanded() && p.isVisible()) {
							this._visibleItems.remove(item);
						}
						removed = true;
					}
				}
			}
			if (this._checkableTag) {
				this._checkableTag.changeStates(rows);
			}
			if (removed) {
				this.$_clearSummary();
			}
			saveRefresh ? this._saveAndRefresh() : this._fireRefresh();
			// this._fireRefresh();
		}
	},
	onTreeDataProviderRowSiblingMoved: function (provider, row, delta) {
		if (!this.$_needSort()) {// sort중에는 row이동이 안된다.
			var item = this._itemMap[row.rowId()];
			if (item) {
				var parent = item.parent();
				parent.moveChild(item.childIndex(), delta);
				this.$_resetVisibleItems();
				this._fireRefresh();
			}
		}
	},
	onTreeDataProviderRowParentChanged: function (provider, row, parent, childIndex) {
		var item = this._itemMap[row.rowId()];
		if (item) {
			var p = this._itemMap[parent.rowId()];
			if (this.$_needSort()) {  // sort중일때는 childIndex가 의미가 없다. 마지막으로 붙인다.
				childIndex = p ? p.count() : 0;
			}
			item.changeParent(p, childIndex);
			this.$_resetVisibleItems();
			this._fireRefresh();
		}
	},
	onTreeDataProviderRowHideChanged: function(provider, rows, hide) {
		var i, cnt, item, rowId, p, changed;
		if (hide) { // 숨기는 경우이다.
			for (i = 0 ,cnt = rows.length; i < cnt ; i++ ) {
				rowId = rows[i];
				item = this._itemMap[rowId];
				if (item) {
					p = item.parent();
					this.$_internalRemoveItem(item);
					if (p.isExpanded() && p.isVisible()) {
						this._visibleItems.remove(item);
					}
					changed = true;
				}
			}
			if (changed) {
				this.$_clearSummary();
			}
			this._fireRefresh();
		} else {
			this._saveAndRefresh();
		}
	},
	dataSource: function () {
		return this._dataSource;
	},
	setDataSource: function (value) {
		if (value === this._dataSource) {
			return;
		}
		this.$_clearItems();
		this.$_resetSummary();
		if (this._dataSource) {
			this._dataSource.removeTag(this._cellStyles);
			this._dataSource.removeTag(this._editableMap);
			this._dataSource.removeListener(this);
		}
		this._dataSource = _cast(value, TreeDataProvider);
		if (this._dataSource) {
			this.$_buildTree();
			this._dataSource.addTag(this._cellStyles);
			this._dataSource.addTag(this._editableMap);
			this._dataSource.addListener(this, 0);
		}
		this._fireReset();
	},
	itemCount: function () {
		return this._visibleItems.count();
	},
	rowCount: function () {
		return this._itemCount;
	},
	getItem: function (index) {
		if (index >= 0 && index < this._visibleItems.count()) {
			return this._visibleItems.getItem(index);
		} else {
			return null;
		}
	},
	_refreshItems: function () {
		this.$_clearItems();
		this.$_buildTree();
		this._fireRefresh();
	},
	_saveAndRefresh: function () {
		var save = [];
		this.$_saveExpanded(save, this._rootItem);
		this.$_clearItems();
		this.$_buildTree(save);
		this._fireRefresh();
	},
	getIndexOfRow: function (dataRow) {
		var item = this._itemMap[dataRow];
		return item && item.isVisible() ? item.index() : -1;
	},
	getItemOfRow: function (dataRow) {
		return this._itemMap[dataRow];
	},
	fixedCount: function () {
		return 0;
	},
	setFixed: function (count, sorting, filtering) {
	},
	maxItemCount: function () {
		return 0;
	},
	setMaxItemCount: function (value) {
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		var ds = _cast(this.dataSource(), TreeDataProvider);
		if (!ds) {
			return -1;
		}
		var rows = this.itemCount();
		if (rows < 1) {
			return -1;
		}
		var flds = Math.min(fields.length, values.length);
		if (flds < 1) {
			return -1;
		}
		var i, item, found, c, v,
			all = !options || options.allFields,
			sensitive = options && options.caseSensitive,
			partial = options && options.partialMatch;
		var dateConvert = null;
		var fieldTypes = [];
		var cb = options.dataComparer;
		var dataRow;
		cb = (cb && typeof cb === "function") ? cb : null;

		for (c = 0; c < flds; c++) {
			fieldTypes[c] = ds.getField(fields[c]).dataType();
		};
		startIndex = Math.max(0, startIndex);
		endIndex = Math.min(this._visibleItems.count() - 1, endIndex);
		for (i = startIndex; i <= endIndex; i++) {
			item = this._visibleItems.getItem(i);
			found = (dataRow = item.dataRow()) >= 0;
			if (found) {
				for (c = 0; c < flds; c++) {
					v = item.getData(fields[c]);
					switch (fieldTypes[c]) {
						case ValueType.DATETIME :
						case ValueType.DATE :
							if (values[c] instanceof Date) {
								found = cb ? cb(dataRow, fields[c], values[c], v) : $$_compareTextValue(values[c], v, sensitive, partial);
							} else {
								if (!dateConvert) {
									var fmt = /[.]/.test(values[c]) ? "yyyy.MM.dd" : /[/]/.test(values[c]) ? "yyyy/MM/dd" : /[-]/.test(values[c]) ? "yyyy-MM-dd" : "yyyyMMdd";
									dateConvert = new DatetimeConverter(fmt);
								}
								found = cb ? cb(dataRow, fields[c], values[c], v ? dateConvert.getText(v) : v) : $$_compareTextValue(values[c], v ? dateConvert.getText(v) : v, sensitive, partial);
							}
							break;
						default :
							found = cb ? cb(dataRow, fields[c], values[c], v) : $$_compareTextValue(values[c], v, sensitive, partial);	
							break;
					}
					if (found && !all) {
						return i;
					}
					if (!found && all) {
						break;
					}
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	},
    findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
        var ds = this.dataSource();
        if (!ds) {
            return null;
        }
        var rows = this.itemCount();
        if (rows < 1) {
            return null;
        }
        var i, item, found, c, v;
        var sensitive = options && options.caseSensitive;
        var partial = options && options.partialMatch;
        var fldCount = this.dataSource().fieldCount();
        var fldLen = fields.length;
        var dateConvert = null;
        var fieldTypes = [];
		var cb = options.dataComparer;
		var dataRow;
		cb = (cb && typeof cb === "function") ? cb : null;

        for (c = 0; c < fldCount; c++) {
        	fieldTypes[c] = ds.getField(c).dataType();
        };
        startIndex = Math.max(0, startIndex);
        endIndex = Math.min(this._visibleItems.count() - 1, endIndex);
        startFieldIndex = Math.max(0, startFieldIndex);
        if (startFieldIndex >= fields.length) {
            startIndex++;
            startFieldIndex = 0;
        }
        for (i = startIndex; i <= endIndex; i++) {
            item = this._visibleItems.getItem(i);
            if ((dataRow = item.dataRow()) >= 0) {
                c = (i > startIndex) ? 0 : startFieldIndex;
                for (; c < fldLen; c++) {
                    var f = fields[c];
                    if (f >= 0 && f < fldCount) {
                    	v = item.getData(f);
						switch (fieldTypes[f]) {
							case ValueType.DATETIME :
							case ValueType.DATE :
								if (value instanceof Date) {
									found = cb ? cb(dataRow, f, value, v) : $$_compareTextValue(value, v, sensitive, partial);
								} else {
									if (!dateConvert) {
										var fmt = /[.]/.test(value) ? "yyyy.MM.dd" : /[/]/.test(value) ? "yyyy/MM/dd" : /[-]/.test(value) ? "yyyy-MM-dd" : "yyyyMMdd";
										dateConvert = new DatetimeConverter(fmt);
									}
									found = cb ? cb(dataRow, f, value, v ? dateConvert.getText(v) : v) : $$_compareTextValue(value, v ? dateConvert.getText(v) : v, sensitive, partial);
								}
								break;
							default :
								found = cb ? cb(dataRow, f, value, v) : $$_compareTextValue(value, v, sensitive, partial);
								break;
						}
                        if (found) {
                            var returnObj = {
                                itemIndex: i,
                                fieldIndex: f,
                                searchFieldIndex: c
                            };
                            return returnObj;
                        }
                    }
                }
            }
        }
        return null;
    },
	expandWhenGrouping: true,
	footerWhenExpanded: true,
	setFooterWhenExpanded: function (value) {
		if (value != this._footerWhenExpanded) {
			this._footerWhenExpanded = value;
			this.$_resetVisibleItems();
			this._resetItemIndicies();
			this._fireRefresh();
		}
	},
	footerWhenCollapsed: true,
	setFooterWhenCollapsed: function (value) {
		if (value != this._footerWhenCollapsed) {
			this._footerWhenCollapsed = value;
			this.$_resetVisibleItems();
			this._resetItemIndicies();
			this._fireRefresh();
		}
	},
	aggregateMode: "leaf",
	setAggregateMode: function () {
		if (value != this._aggregateMode) {
			this._aggregateMode = value;
			this.$_resetSummary();
			this._fireRefresh();
		}
	},
	summaryMode: "aggregate",
	setSummaryMode: function (value) {
		if (value != this._summaryMode) {
			this._summaryMode = value;
			this.$_resetSummary();
			this._fireRefresh();
		}
	},
	groupSummaryMode: "aggregate",
	setGroupSummaryMode: function (value) {
		if (value != this._groupSummaryMode) {
			this._groupSummaryMode = value;
			this.$_resetGroupSummary();
			this._fireRefresh();
		}
	},
	hideDeleted: false,
	setHideDeleted: function (value) {
		if (value != this._hideDeleted) {
			this._hideDeleted = value;
			this._saveAndRefresh();
		}
	},
	checkableExpression: null,
	setCheckableExpression: function (value) {
		if (value != this._checkableExpression) {
			this._checkableExpression = value;
			if (this._checkableTag) {
				this._checkableTag.disconnect();
				this._checkableTag = null;
			}
			if (value) {
				this._checkableTag = new TreeCheckableTag(this, value);
				if (this._dataSource) {
					this._checkableTag.connect(this._dataSource);
				}
			}
		}
	},
	isSorted: function () {
		return this._sortFields && this._sortFields.length > 0;
	},
	$_needSort: function() {
		return this._sortFields && this._sortFields.length > 0 && this._sortMode == SortMode.AUTO;
	},
	addObserver: function (observer) {
		if (observer && this._observers.indexOf(observer) < 0) {
			this._observers.push(observer);
		}
	},
	removeObserver: function (observer) {
		var index = this._observers.indexOf(observer);
		if (index >= 0) {
			this._observers.splice(index, 1);
		}
	},
	insertItem: function (parent, item, index, after) {
		var visibles = this._visibleItems;
		if (parent.isCollapsed()) {
			visibles.expand(parent, false);
		}
		var i = visibles.indexOf(parent.getItem(index));
		if (after) {
			parent.insert(index + 1, item);
			var cnt = visibles.count();
			var lev = parent.level() + 1;
			while (++i < cnt) {
				if (visibles.getItem(i).level() <= lev) {
					break;
				}
			}
			visibles.insert(item, i);
		} else {
			parent.insert(index, item);
			visibles.insert(item, i);
		}
	},
	appendItem: function (parent, item) {
		var visibles = this._visibleItems;
		if (parent.isCollapsed()) {
			visibles.expand(parent, false);
		}
		var i;
		if (parent.count() > 0) {
			i = visibles.indexOf(parent.getItem(parent.count() - 1));
		} else {
			i = visibles.indexOf(parent);
		}
		var cnt = visibles.count();
		var lev = parent.level();
		while (++i < cnt) {
			if (visibles.getItem(i).level() <= lev) {
				break;
			}
		}
		parent.add(item);
		visibles.insert(item, i);
	},
	removeItem: function (item) {
		this._visibleItems.remove(item);
		item.parent().remove(item);
	},
	$_calcLevel: function (item, level, visibleOnly) {
		var i, child;
		var cnt = item.count();
		var lev = level;
		for (i = 0; i < cnt; i++) {
			child = item.getItem(i);
			if (child) {
				lev = Math.max(lev, level + 1);
				if (!visibleOnly || child.isExpanded()) {
					lev = Math.max(lev, this.$_calcLevel(child, level + 1, visibleOnly));
				}
			}
		}
		return lev;
	},
	getLevels: function (visibleOnly) {
		return this.$_calcLevel(this._rootItem, 0, visibleOnly);
	},
	$_setExpanded: function (item, recursive, level) {
		this._setExpanded(item, true);
		this._dataSource.setHasChildren(item.row(), false);
		if (recursive) {
			var i, child;
			var cnt = item.count();
			for (i = 0; i < cnt; i++) {
				child = item.getItem(i);
				if (child instanceof TreeItem && (child.isExpanded() || child.level() < level)) {
					this.$_setExpanded(child, true, level);
				}
			}
		}
	},
	_expandItem: function (item, force, recursive, level, fireEvents) {
		if (item && (force || !item.isExpanded())) {
			if (fireEvents && !this._fireExpanding(item)) {
				return;
			}
			this._visibleItems.collapse(item);
			this._visibleItems.expand(item, recursive, level);
			this._resetItemIndicies(item === this._rootItem ? 0 : item.index());
			this.$_setExpanded(item, recursive, level > 0 ? item.level() + level : 1000000);
			try {
				this._fireRefresh();
			} finally {
				if (fireEvents) {
					this._fireExpanded(item);
				}
			}
		}
	},
	expand: function (item, recursive, force) {
		this._expandItem(item, force, recursive, 0, true);
	},
	expandAll: function (level) {
		this._expandItem(this._rootItem, true, true, level > 0 ? level + 1 : 0, true);
	},
	$_setCollapsed: function (item, recursive) {
		this._setExpanded(item, false);
		if (recursive) {
			var i, child;
			var cnt = item.count();
			for (i = 0; i < cnt; i++) {
				child = item.getItem(i);
				if (child instanceof TreeItem) {
					this.$_setCollapsed(child, true);
				}
			}
		}
	},
	_collapseItem: function (item, force, recursive, fireEvents) {
		if (item && (force || item.isExpanded())) {
			if (fireEvents && !this._fireCollapsing(item)) {
				return;
			}
			this._visibleItems.collapse(item);
			this.$_setCollapsed(item, recursive);
			if (item == this._rootItem) {
				this._visibleItems.expand(this._rootItem, false);
			}
			this._resetItemIndicies(item === this._rootItem ? 0 : item.index());
			try {
				this._fireRefresh();
			} finally {
				if (fireEvents) {
					this._fireCollapsed(item);
				}
			}
		}
	},
	collapse: function (item, recursive) {
		this._collapseItem(item, false, recursive, true);
	},
	collapseAll: function () {
		this._collapseItem(this._rootItem, true, true, true);			
	},
	$_saveExpanded: function (map, item) {
		var i, child;
		var cnt = item.count();
		for (i = 0; i < cnt; i++) {
			child = _cast(item.getItem(i), TreeItem);
			if (child) {
				// child._extents = child.isExpanded() ? (child._extents | ITEM_EXT_SAVEEXPAND) : (child._extents & ~ITEM_EXT_SAVEEXPAND);
				map[child.rowId()] = ITEM_EXT_FILTERED | (child.isExpanded() ? ITEM_EXT_SAVEEXPAND : 0);// 
				if (child.count() > 0) {
					this.$_saveExpanded(map, child);
				}
			}
		}
	},
	orderBy: function (fields, directions, textCases, fireEvent) {
		fireEvent = arguments.length > 3 ? fireEvent : true;
		this._fireSort(fields, directions, textCases);
		this._sortFields = [];
		this._sortDirections = [];
        this._sortCases = [];
		var cnt = fields ? fields.length : 0;
		var len = directions ? directions.length : 0;
        var clen = textCases ? textCases.length : 0;
		for (var i = 0; i < cnt; i++) {
			this._sortFields.push(fields[i]);
			if (len > i) {
				this._sortDirections.push(directions[i]);
			} else if (len > 0) {
				this._sortDirections.push(directions[len - 1]);
			} else {
				this._sortDirections.push(SortDirection.ASCENDING);
			}
            if (clen > i) {
                this._sortCases.push(textCases[i]);
            } else if (clen > 0) {
                this._sortCases.push(textCases[clen - 1]);
            } else {
                this._sortCases.push(SortCase.SENSITIVE);
            }
		}
		var map = [];
		this.$_saveExpanded(map, this._rootItem);
		this.$_clearItems();
		this.$_buildTree(map);
		try {
			if (fireEvent) {
				this._fireRefresh();
			}
		} finally {
			this._fireSorted();
		}
	},
	getSortFields: function () {
		return this._sortFields.concat();
	},
	getSortDirections: function () {
		return this._sortDirections.concat();
	},
    getSortCases: function () {
        return this._sortCases.concat();
    },
    getLabelComparer: function() {
    	return this._labelComparer;
    },
    setLabelComparer: function(comparer) {
    	this._labelComparer = comparer;
    },
	beginFiltering: function () {
		this._filterLock++;
	},
	$_prepareFiltering: function (map, item) {
		// var i, child;
		var cnt = item._dataRow.count();
		var rowId = item.rowId();
		var filtered = rowId <= -1 ? true : this.$_selectItem(item);
		var child;
		for (var i = 0; i < cnt; i++) {
			child = new TreeItem(item._dataRow._children[i]);
			if (child && !this.dataSource().isHideDataRow(child.rowId())) {
				filtered = this.$_prepareFiltering(map, child) || filtered;
			}
		}
		map[rowId] = filtered && rowId >= 0 ? map[rowId] | ITEM_EXT_FILTERED : map[rowId] & ~ITEM_EXT_FILTERED;	// expand //check.
		return filtered;
	},

	endFiltering: function (apply, filterCollection, filter) {
		apply = arguments.length > 0 ? apply : true;
		var prepareMap = [];
		if (apply) {
			// this.$_saveExpanded(prepareMap, this._rootItem); // expanded가 정리될때.
			this._filterRuntime.setDataSource(this.dataSource());
			this._addParentNodeOnFiltering && this.$_prepareFiltering(prepareMap, this._rootItem);
		}
		if (this._filterLock > 0) {
			this._filterLock = Math.max(0, this._filterLock - 1);
			(apply && this._filterLock == 0) && this.applyFilters(prepareMap, filterCollection, filter);
		}
	},
	hasFilter: function (field/*int*/) {
		var filters = this._filters[field];
		return filters ? filters.length > 0 : false;
	},
	addFilter: function (field, refFilter) {
		this._fireFilterAdded();
		var filters = this._filters[field];
		if (!filters) {
			filters = [];
			this._filters[field] = filters;
		}
		var filter = new ColumnFilterRun(refFilter);
		filters.push(filter);
		// this.applyFilters();
		return filter;
	},
	removeFilter: function (field, filter/*ColumnFilter*/) {
		if (this._filtered && this._filters[field]) {
			this._fireFilterRemoved(field, filter);
			var filters = this._filters[field];
			for (var i = filters.length; i--;) {
				if (filters[i] === filter) {
					filters.splice(i, 1);
					this.applyFilters();
					break;
				}
			}
		}
	},
	clearFilters: function (field) {
		if (this._filtered && this._filters[field]) {
			this._fireFilterCleared(field);
			var filters = this._filters[field];
			if (filters && filters.length > 0) {
				filters.splice(0, filters.length);
				this._filters[field] = null;
				this.applyFilters();
			}
		}
	},
	clearAllFilters: function () {
		if (this._filtered) {
			this._fireFilterAllCleared();
			this._filters = {};
			this.applyFilters();
		}
	},
	hasFilters: function () {
		for (var fld in this._filters) {
			var filters = this._filters[fld];
			if (filters && filters.length > 0) {
				return true;
			}
		}
		return false;
	},
	applyFilters: function (map, filterCollection, filter) {
		var ds = this.dataSource();
		var cnt = ds.fieldCount();
		for (var fld in this._filters) {
			if (fld >= cnt) {
				this._filters[fld] = null;
			}
		}
		this._filtered = this.hasFilters();
		if (this._filtered) {
			for (var f in this._filters) {
				var filters = this._filters[f];
				if (filters) {
					for (var i = filters.length; i--;) {
						filters[i].prepare(this._filterRuntime, this._dataSource);
					}
				}
			}
		};
		// 
		if (this._filterLock == 0) {  // expanded가 정리될때.
			this.$_clearItems();
			this.$_buildTree(map);
			try {
				this._fireRefresh();
			} finally {
				this._fireFiltered(filterCollection, filter);
			}
		}
	},
	getItemByRow: function (row) {
		return row ? this._itemMap[row.rowId()] : null;
	},
	getCheckedRows: function () {
		function collectCheckedRows(parent, rows) {
			if (parent instanceof TreeItem) {
				var i, r, item;
				var cnt = parent.count();
				for (i = 0; i < cnt; i++) {
					item = parent.getItem(i);
					item.isChecked() && (r = item.row()) && rows.push(r);
					collectCheckedRows(item, rows);
				}
			}
		}
		var rows = [];
		collectCheckedRows(this._rootItem, rows);
		return rows;
	},
	getCheckedRowIds: function () {
		function collectCheckedRows(parent, rows) {
			if (parent instanceof TreeItem) {
				var i, r, item;
				var cnt = parent.count();
				for (i = 0; i < cnt; i++) {
					item = parent.getItem(i);
					if (item.isChecked() && (r = item.dataRow()) >= 0) {
						rows.push(r);
					}
					collectCheckedRows(item, rows);
				}
			}
		}
		var rows = [];
		collectCheckedRows(this._rootItem, rows);
		return rows;
	},
	resetCheckables: function () {
		if (this._checkableTag) {
			this._checkableTag.clearRows();
			this._fireRefresh();
		}
	},
	applyCheckables: function () {
		if (this._checkableTag) {
			this._checkableTag.setRows();
		} else {
			TreeCheckableTag.clearCheckables(this);
		}
		this._fireRefresh();
	},
	_createRootItem: function () {
		this._rootItem = new RootTreeItem(this);
		this._setExpanded(this._rootItem, true);
		return this._rootItem;
	},
	$_collectItems: function (item, list) {
		var i, child;
		var cnt = item.count();
		for (i = 0; i < cnt; i++) {
			child = item.getItem(i);
			if (child instanceof TreeItem) {
				list.push(child);
				this.$_collectItems(child, list);		
			}
		}
	},
	getAllItems: function () {
		var items = [];
		this.$_collectItems(this._rootItem, items);
		return items;
	},
	$_checkChildren: function (parent, checked, checkableOnly) {
		var i, item;
		var cnt = parent.count();
		for (i = 0; i < cnt; i++) {
			item = parent.getItem(i);
			if (item) {
				if (checkableOnly) {
					if (item.isCheckable()) {
						this._setCheckItem(item, checked);
					}
				} else {
					this._setCheckItem(item, checked);
				}
			}
			if (item instanceof TreeItem) {
				this.$_checkChildren(item, checked, checkableOnly);
			}
		}
	},
	_clearChecked: function () {
		this.$_checkChildren(this._rootItem, false, false);
	},
	checkAll: function (checked, visibleOnly, checkableOnly, checkEvent) {
		if (visibleOnly) {
			this._super(checked, visibleOnly, checkableOnly, checkEvent);
		} else {
			this.$_checkChildren(this._rootItem, checked, checkableOnly);
			checkEvent ? this._fireItemAllChecked(checked):this._fireRefreshClient();			
		}
	},
	hasCellstyle: function () {
		return !this._cellStyles.isEmpty();
	},
	setCellStyle: function (row, field, style) {
		this._cellStyles.setCellStyle(row, field, style);		
	},
	setCellStyles: function (provider, rows, fieldMap) {
		this._cellStyles.setCellStyles(provider, rows, fieldMap);
	},
	removeCellStyle: function (style) {
		this._cellStyles.removeCellStyle(style);
	},
	clearCellStyles: function () {
		this._cellStyles.clearCellStyles();
	},
	checkCellStyle: function (rowId, field) {
		return this._cellStyles.checkCellStyle(rowId, field);
	},
	getCellStyle: function (dataRow, field) {
		return this._cellStyles.getCellStyle(dataRow, field);
	},
    setCellEditable: function (dataRow, column, value) {
        this._editableMap.setEditable(dataRow, column, value);
    },
    setCellReadOnly: function(dataRow, column, value) {
        this._editableMap.setReadOnly(dataRow, column, value);
    },
    getCellEditable: function (dataRow, column) {
        return this._editableMap.getEditable(dataRow, column);
    },
    getCellReadOnly: function(dataRow, column, value) {
        return this._editableMap.getReadOnly(dataRow, column);
    },
    setCellCursor: function (dataRow, column, value) {
    	this._editableMap.setCursor(dataRow, column, value);
    },
    getCellCursor: function(dataRow, column) {
    	return this._editableMap.getCursor(dataRow, column)
    },
    setCellEditor: function (dataRow, column, value) {
    	this._editableMap.setEditor(dataRow, column, value)
    },
    getCellEditor: function (dataRow, column) {
    	return this._editableMap.getEditor(dataRow, column);
    },
    clearEditableMap: function() {
        return this._editableMap.clearEditableMap();
    },
	getSum: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.sum : NaN;
	},
	getMax: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.max : NaN;
	},
	getMin: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.min : NaN;
	},
	getAvg: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.avg : NaN;
	},
	getVar: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.vars : NaN;
	},
	getVarp: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.varsp : NaN;
	},
	getStdev: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? Math.sqrt(fs.vars) : NaN;
	},
	getStdevp: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? Math.sqrt(fs.varsp) : NaN;
	},
	getDataCount: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.datacount : 0;
	},
	getDataAvg: function (field) {
		var fs = this.$_getSummary(field);
		return fs ? fs.dataavg : NaN;
	},
	$_internalAddItem: function (parent, row, expandedMap) {
		var item = TreeItem.getTemp(row);
		var ds = this.dataSource();
		if ( (this._hideDeleted && RowState.isDeleted(item.rowState())) || (ds.isHideDataRow(row.rowId()))) {
			item = null;
		}
		if ( item && (expandedMap && (expandedMap[row.rowId()] & ITEM_EXT_FILTERED) || this.$_selectItem(item)) ) {
			var item = new TreeItem(row);
			parent.insert(row.index(), item);
			this._itemCount++;
			this._itemMap[row.rowId()] = item;
			return item;
		}
		return null;
	},
	$_internalRemoveItem: function (item) {
		if (item) {
			item.parent().remove(item);
			this._itemCount--;
			this._itemMap[item.row().rowId()] = undefined;
		}
	},
	$_internalRowStateChanged: function (item, refresh) {
		refresh = refresh == undefined ? true : refresh;
		if (item /*&& item.isVisible()*/) {
			if (this._hideDeleted && RowState.isDeleted(item.rowState())) {
				var p = item.parent();
				this.$_internalRemoveItem(item);
				this.$_clearSummary();
				if (p.isExpanded() && p.isVisible()) {
					this._visibleItems.remove(item);
					refresh = true;
				}
				refresh && this._fireRefresh();
			} else {
				this._fireItemChanged(item);
			}
		}
	},
	_setItem: function (item, newItem) {
		this._visibleItems.setItem(item.index(), newItem);
		this._resetItemIndex(item.index());
	},
	$_resetVisibleItems: function () {
		this._visibleItems._clearAndInit(this.fixedCount());
		this._visibleItems.expand(this._rootItem, false);
		this._setExpanded(this._rootItem, true);
		this._resetItemIndicies(0);
	},
	$_clearItems: function () {
		this._visibleItems.clear();
		this._rootItem.clear();
		this._itemMap = [];
		this._itemCount = 0;
	},
	$_selectField: function (filters, item, field) {
		var i, filter;
		var cnt = filters.length;
		for (i = 0; i < cnt; i++) {
			filter = filters[i];
			if (filter.select(this._filterRuntime, item, field)) {
				return true;						
			}
		}
		return false;
	},
	$_selectItem: function (item) {
		var filters;
		if (!item) {
			return false;
		}
		for (var fld in this._filters) {
			filters = this._filters[fld];
			if (filters && !this.$_selectField(filters, item, fld)) {
				return false;
			}
		}
		return !!item && true;
	},
	$_buildItems: function (parent, expandedMap) {
		var i, child, item;
		var row = parent.row();
		var cnt = row.count();
		for (i = 0; i < cnt; i++) {
			child = row.getChild(i);
			item = this.$_internalAddItem(parent, child, expandedMap);
			if (item) {
				if (expandedMap) {
					// item._extents = expandedMap[child.rowId()] ? (expandedMap[child.rowId()] & ~ITEM_EXT_SAVEEXPAND) : 0;
					this._setExpanded(item, (expandedMap[child.rowId()] & ITEM_EXT_SAVEEXPAND) != 0);
				}
				if (child.count() > 0) {
					this.$_buildItems(item, expandedMap);
				}
			}
		}
	},
	$_sortItem: function (parent) {
		var i, child;
		var cnt = parent.count();
		if (cnt > 1) {
			this.$_sort(parent, 0, 0, cnt - 1);
		}
		for (i = 0; i < cnt; i++) {
			child = parent.getItem(i);
			if (child instanceof TreeItem) {
				this.$_sortItem(child);
			}
		}
	},
	$_sort: function (parent, level, startIndex, endIndex) {
		var field = this._sortFields[level];
		var dir = this._sortDirections[level];
        var ds = this._dataSource;
        var ignoreCase = this._sortCases[level] == SortCase.INSENSITIVE;
		this._sorter.run(parent, field, dir, ignoreCase, startIndex, endIndex, level + 1 == this._sortFields.length);
        var t = ds.getField(field).dataType();
        var equalFunc;
        if (t == ValueType.TEXT && ignoreCase) {
            equalFunc = ds.equalTexts.bind(ds);
        } else {
            equalFunc = ds.equalValues.bind(ds);
        }
		if (level + 1 < this._sortFields.length) {
			var i = startIndex;
			var pi = i;
			while (i < endIndex) {
				i++;
				if (!equalFunc(field, parent.getItem(i).row(), parent.getItem(i - 1).row())) {
					this.$_sort(parent, level + 1, pi, i - 1);
					pi = i;
				}
			}
			if (pi < endIndex) {
				this.$_sort(parent, level + 1, pi, endIndex);
			}
		}
	},
	$_buildTree: function (expandedMap) {
		this._rootItem._dataRow = this._dataSource.rootRow();
		this._itemMap[this._rootItem._dataRow.rowId()] = this._rootItem;
		this.$_buildItems(this._rootItem, expandedMap);
		this.$_clearSummary();
		var flds = this._dataSource.fieldCount();
		var sortFlds = this._sortFields;
		var sortDirs = this._sortDirections;
        var sortCases = this._sortCases;
		for (var i = sortFlds.length; i--;) {
			if (sortFlds[i] < 0 ||  sortFlds[i] >= flds) {
				sortFlds.splice(i, 1);
				sortDirs.splice(i, 1);
                sortCases.splice(i, 1);
			}
		}
		if (this.isSorted() && this._rootItem.count() > 0) {
			this.$_sortItem(this._rootItem);
		}
		this.$_resetVisibleItems();
		if (this._checkableTag && (!expandedMap || expandedMap.length <= 0)) {
			this._checkableTag.setRows();
		}
	},
	$_resetSummary: function () {
		this._summaryMap = [];
	},
	$_resetGroupSummary: function () {
	},
	$_clearSummary: function () {
		if (this._summaryMap) {
			for (var i = this._summaryMap.length; i--;) {
				this._summaryMap[i] && this._summaryMap[i].clear();
			}
		}
	},
	$_getSummary: function (field) {
		var summary = this._summaryMap[field];
		if (!summary) {
			var ds = this.dataSource();
			if (ds && ds.canSummarize(field)) {
				summary = new FieldSummary(field);
				this._summaryMap[field] = summary;
			}
		}
		if (summary && summary.count == 0 && this.itemCount() > 0) {
			this.$_summarize(summary);
		}
		return summary;
	},
	$_summarize: function (fldSummary) {
		var ds = this.dataSource();
		if (ds) {
			if (this._filtered || this.isHideDeleted() || ds.hideCount() > 0) {
				var items = this._rootItem.getDescendants(false);
				var cnt = items.length;
				var rows = [];
				for (var i = 0; i < cnt; i++) {
					var ti = items[i];
					if (ti instanceof TreeItem && !ds.isHideDataRow(ti.rowId())) {
						rows.push(ti.row());
					}
				}
				fldSummary.count = rows.length;
				ds.summarizeRange(fldSummary, rows, this._summaryMode == SummaryMode.STATISTICAL);
			} else {
				fldSummary.count = ds.rowCount();
				ds.summarize(fldSummary, this._summaryMode == SummaryMode.STATISTICAL);
			}
		}
	},
	_fireItemChanged: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.ITEM_CHANGED, item);
		} 
	},
	_fireExpanding: function (item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.EXPANDING, item);
		} 
		return true;
	},
	_fireExpanded: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.EXPANDED, item);
		} 
	},
	_fireCollapsing: function (item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.COLLAPSING, item);
		} 
		return true;
	},
	_fireCollapsed: function (item) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.COLLAPSED, item);
		} 
	},
	_fireParentChanging: function (itemIndex, parent, childIndex) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.PARENT_CHANGING, itemIndex, parent, childIndex);
		}
		return true;
	},
	_fireParentChanged: function (item, oldIndex, parent) {
		if (this._eventLock <= 0) {
			this.fireEvent(TreeItemProvider.PARENT_CHANGED, item, oldIndex, parent);
		} 		
	}
});
TreeItemProvider.ITEM_CHANGED = "onTreeItemProviderItemChanged";
TreeItemProvider.EXPANDING = "onTreeItemProviderExpanding";
TreeItemProvider.EXPANDED = "onTreeItemProviderExpanded";
TreeItemProvider.COLLAPSING = "onTreeItemProviderCollapsing";
TreeItemProvider.COLLAPSED = "onTreeItemProviderCollapsed";
var TreeEditItem = defineClass("TreeEditItem", TreeItem, {
	init: function (provider, item, state) {
		this._super(item ? item.row() : null);
		this._provider = provider;
		this._item = item;
		this._state = state;
		this._values = [];
		this._started = false;
		this._checkDiff = false;
        this._strictDiff = false;
	},
	destroy: function() {
		this._destroying = true;
		this._values = null;
		this._super();
	},
	values: function () {
		return this._values.concat();
	},
	setValues: function (vals) {
		var i, f, fld, oldValue, newValue,
			ds = this.dataSource(),
			cnt = ds.fieldCount();
		if (_isArray(arr)) {
			cnt = Math.min(cnt, vals.length);
			for (i = 0; i < cnt; i++) {
				fld = ds.getField(i);
				oldValue = this._values[i];
				newValue = fld.readValue(arr[i]);
				this._values[i] = newValue;
				if (this._started && parent && !fld.equalValues(oldValue, newValue)) {
					this._provider._editItemCellUpdated(this, i, oldValue, newValue);
				}
			}
		} else if (vals) {
			for (i = 0; i < cnt; i++) {
				f = ds.getOrgFieldName(i);
				if (vals.hasOwnProperty(f)) {
					fld = ds.getField(i);
					oldValue = this._values[i];
					newValue = fld.readValue(vals[f]);
					this._values[i] = newValue;
					if (this._started && parent && !fld.equalValues(oldValue, newValue)) {
						this._provider._editItemCellUpdated(this, i, oldValue, newValue);
					}
				}
			}
		}
	},
	beginEdit: function (checkDiff, strictDiff) {
		this._started = true;
		this._checkDiff = checkDiff;
        this._strictDiff = strictDiff;
	},
	setValue: function (field, value) {
		var ds = this.dataSource();
		if (field < 0 && field >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		var fld = ds.getField(field); 
		var oldValue = this._values[field];
		value = fld.readValue(value);
		this._values[field] = value; 
		if (this._started && this.parent() && !fld.equalValues(oldValue, value)) {
			this._provider._editItemCellUpdated(this, field, oldValue, value);
		}
	},
	dataSource: function () {
		return this._provider.dataSource();
	},
	itemState: function () {
		return this._state;
	},
	rowState: function () {
		return this._item ? this._item.rowState() : RowState.NONE;
	},
	iconIndex: function () {
		return this._item ? this._super() : -1;
	},
	hasChildren: function () {
		return this._item ? this._super() : false;
	},
	dataRow: function () {
		return this._item ? this._super() : -1;
	},
	isExpanded: function () {
		return this._item ? this._item.isExpanded() : false;
	},
	getData: function (field) {
		if (field < 0 && field >= this.dataSource().fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		return this._values[field];
	},
	setData: function (field, value) {
		var ds = this.dataSource();
		if (field < 0 && field >= ds.fieldCount()) {
			throw new RangeError("field index is out of bounds: " + field);
		}
		var fld = ds.getField(field); 
		var oldValue = this._values[field];
		value = fld.readValue(value);
        var can = !this._checkDiff;
        if (!can) {
            if (this._strictDiff) {
                can = !fld.equalValues(oldValue, value);
            } else {
                can = !fld.sameValues(oldValue, value);
            }
        }
		if (can) {
			this._values[field] = value;
			if (this.parent()) {
				this._provider._editItemCellUpdated(this, field, oldValue, value);
				this._provider._editItemCellEdited(this, field);
			}
		}
	},
	getRowData: function () {
		return this._values.concat();
	},
	getRowObject: function () {
		var ds = this.dataSource();
		if (ds) {
			var i, fld, 
				cnt = ds.fieldCount(),
				row = {};
			for (i = 0; i < cnt; i++) {
				fld = ds.getOrgFieldName(i);
				row[fld] = this._values[i];
			}
			return row;
		} else {
			return null;
		}
	}
});
var /* @internal */ TreeCellEditableMap = defineClass("TreeCellEditableMap", DataTag, {
	init: function(itemProvider) {
		this._super();
		this._owner = itemProvider;
		this._editableMap = [];
	},
	destroy : function() {
		this._editableMap = null;
		this._super();
	},
	isEmpty: function () {
		return this._styleMap.length == 0 && !this._styleMap[-1];
	},
	setReadOnly: function (row, column, value) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._readOnly = value;
	},
	setEditable: function (row, column, value) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._editable = value;
	},
	getReadOnly: function (row, column) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._readOnly;
	},
	getEditable: function (row, column) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._editable
	},
	setCursor: function (row, column, value) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._cursor = value;
	},
	getCursor: function (row, column) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._cursor;
	},
	setEditor: function(row, column, value) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] = this._editableMap[row] || [];
		map[column] = map[column] || {};
		map[column]._editor = value;
	},
	getEditor: function (row, column) {
		row = this._owner.getItemOfRow(row).rowId();
		var map = this._editableMap[row] && this._editableMap[row][column];
		return map && map._editor;
	},
	removeEditableMap: function (row, column) {
		row = this._owner.getItemOfRow(row).rowId();
		if (row == null) {
			return;
		}
		column = arguments.length < 2 ? -1 : column;
		if (column < 0) {
			delete this._editableMap[row];
		} else {
			var map = this._editableMap[row];
			map && (delete map[column]);
		}
	},
	clearEditableMap: function () {
		if (this._editableMap.length === 0 && this._editableMap[-1] == null) {
			return false;
		}
		this._editableMap = [];
		return true;
	},
	getWritable: function (row, column) {
		var readOnly = this.getReadOnly(row, column);
		var editable = this.getEditable(row, column);
		return !readOnly && editable;
	},
	connect: function (provider) {
	},
	disconnect: function () {
	},
	clearRows: function () {
		this._editableMap.length = 0;
	},
	setRows: function () {
	},
	setRowCount: function (newCount) {
	},
	addRow: function (row) {
	},
	addRows: function (row, count) {
	},
	removeRow: function (row) {
		// this._editableMap.splice(row, 1);
	},
	removeRows: function (rows) {
	},
	updateRow: function () {
	},
	updateRows: function (row, count) {
	},
	setValue: function (row, field) {
	},
	moveRow: function (row, newRow) {
	},
	moveRows: function (row, count, newRow) {
	}	
})

var TreeCellStyleMap = defineClass("TreeCellStyleMap", null, {
	init: function(owner) {
		this._super();
		this._owner = owner; // TreeItemProvider
		this._styleMap = {};
	},
	isEmpty: function () {
		for (var p in this._styleMap) {
			return false;
		}
		return true;
	},
	connect: function (provider) {
	},
	disconnect: function () {
	},
	clearRows: function () {
		this._styleMap = {};
	},
	setRows: function () {
	},
	addRow: function (row/*TreeDataRow*/) {
	},
	addRows: function (row) {
	},
	removeRow: function (row) {
		if (row) {
			var children = row.descendants();
			if (children) {
				for (var i = children.length; i--;) {
					delete this._styleMap[children[i].rowId];
				}
				delete this._styleMap[row.rowId()];
			}
		}
	},
	removeRows: function (rows) {
		for (var i = rows.length; i--;) {
			this.removeRow(rows[i]);
		}
	},
	updateRow: function () {
	},
	setCellStyle: function (row, field, style) {
		var item = this._owner.getItemOfRow(row);
		var dataRow = item ? item.row() : null;
		if (dataRow == null) {
			return;
		}
		if (field < 0) {
			this._styleMap[dataRow.rowId()] = style;
		} else {
			var styles;
			var oldStyle = this._styleMap[dataRow.rowId()];
			if (oldStyle) {
				if (_isArray(oldStyle)) {
					oldStyle[field] = style;
				} else {
					var i;
					var cnt = this._owner.dataSource().fieldCount();
					styles = [];
					for (i = 0; i < cnt; i++) {
						styles[i] = oldStyle;
					}
					this._styleMap[dataRow.rowId()] = styles;
				}
			}
			styles = this._styleMap[dataRow.rowId()];
			if (!_isArray(styles)) {
				styles = [];
			}
			styles[field] = style;
			this._styleMap[dataRow.rowId()] = styles;
		}
	},
	setCellStyles: function (provider/*DataCellStyleProvider*/, rows, fieldMap) {
		function setArray(self, ds, rows, fields) {
			var r, f, fld, style, vals;
			var cnt = rows.length;
			var flds = Math.min(fields.length, ds.fieldCount());
			for (r = 0; r < cnt; r++) {
				vals  = rows[r];
				if (_isArray(vals)) {
					for (f = 0; f < flds; f++) {
						fld = fields[f];
						if (fld >= 0) {
							style = provider.getStyle(vals[fld]);
							if (style) {
								self.setCellStyle(r, f, style);
							}
						}
					}
				}
			}
		}
		function setObjects(self, ds, rows, fields) {
			var r, f, fld, style, row;
			var cnt = rows.length;
			for (r = 0; r < cnt; r++) {
				row  = rows[r];
				if (row) {
					for (f in fields) {
						fld = fields[f];
						style = provider.getStyle(row[f]);
						if (style) {
							self.setCellStyle(r, fld, style);
						}
					}
				}
			}
		}
		if (!rows || rows.length < 1 || !fieldMap) {
			return;
		}
		var i, fld, cnt, fields;
		var ds = this._owner.dataSource();
		var fldCount = ds.fieldCount();
		if (_isArray(fieldMap)) {
			fields = fieldMap.concat();
			cnt = Math.min(fldCount, fields.length);
			for (i = 0; i < cnt; i++) {
				fld = parseInt(fields[i]);
				if (isNaN(fld) || fld < 0) {
					fields[i] = -1;
				} else {
					fields[i] = fld;
				}
			}
			setArray(this, ds, rows, fields);
		} else {
			fields = {};
			for (var f in fieldMap) {
				fld = parseInt(fieldMap[f]);
				if (isNaN(fld)) {
					fld = ds.getFieldIndex(fieldMap[f]);
				}
				if (fld >= 0 && fld < fldCount) {
					fields[f] = fld;
				}
			}
			setObjects(this, ds, rows, fields);
		}
	},
	removeCellStyle: function (style) {
		for (var rowId in this._styleMap) {
			var styles = this._styleMap[rowId];
			if (_isArray(styles)) {
				for (var i = styles.length; i--;) {
					if (styles[i] === style) {
						styles[i] = null;
					}
				}
			} else {
				if (this._styleMap[rowId] === style) {
					delete this._styleMap[rowId];
				}
			}
		}
	},
	clearCellStyles: function () {
		this._styleMap = {};
	},
	checkCellStyle: function (rowId, field) {
		var style = this._styleMap[rowId];
		if (_isArray(style)) {
			return !!style[field];
		} else {
			return !!style;
		}
	},
	getCellStyle: function (row, field) {
		var item/*TreeItem*/ = this._owner.getItemOfRow(row);
		var dataRow/*ITreeDataRow*/ = item ? item.row() : null;
		if (dataRow) {
			var style = this._styleMap[dataRow.rowId()];
			if (_isArray(style)) {
				return style[field];
			} else {
				return style;
			}
		}
		return null;
	}
});
var TreeCheckableTag = defineClass("TreeCheckableTag", null, {
	init: function (owner, expression) {
		this._super();
		this._owner = owner;
		this._exprNode = ExpressionParser.Default.parse(expression, ["value", "values"]);
		this._runtime = new CheckableExpressionRuntime();
	},
	connect: function (provider) {
		this._runtime.setDataSource(provider);
	},
	disconnect: function () {
	},
	clearRows: function () {
		TreeCheckableTag.clearCheckables(this._owner);
	},
	setRows: function () {
		for (var i = this._owner.itemCount(); i--;) {
			var item = this._owner.getItem(i);
			if (item instanceof TreeItem) {
				this.$_setCheckable(item, true);
			}
		}
	},
	addRow: function(row/*TreeDataRow*/, execChild) {
		execChild = arguments.length > 1 ? execChild : true;
		var item = this._owner.getItemOfRow(row.rowId());
		if (item instanceof TreeItem) {
			this.$_setCheckable(item, execChild);
		}
	},
	addRows: function (rows) {
		for (var i = rows.length; i--;) {
			var item = this._owner.getItemOfRow(rows[i].rowId());
			if (item instanceof TreeItem) {
				this.$_setCheckable(item, true);
			}
		}
	},
	updateRow: function (row) {
		var item = this._owner.getItemOfRow(row.rowId());
		if (item instanceof TreeItem) {
			this.$_setCheckable(item, false);
		}
	},
	changeStates: function (rows) {
		for (var i = rows.length; i--;) {
			var item = this._owner.getItemOfRow(rows[i].rowId());
			if (item instanceof TreeItem) {
				this.$_setCheckable(item, false);
			}
		}
	},
	$_setCheckable: function (item/*TreeItem*/,execChild) {
		if (item) {
			this._runtime.setItem(item);
			item.setCheckable(this._exprNode.evaluate(this._runtime));
			if (execChild) {
				for (var i = item.count(); i--;) {
					var child = item.getItem(i);
					child instanceof TreeItem && this.$_setCheckable(child, execChild);
				}
			}
		}
	}
}, {
	clearCheckables: function (items) {
		var clearCheckable = function (item) {
			if (item) {
				item.setCheckable(true);
				for (var i = item.count(); i--;) {
					var child = item.getItem(i);
					child instanceof TreeItem && clearCheckable(child);
				}
			}
		};
		for (var i = items.itemCount(); i--;) {
			var item = items.getItem(i);
			if (item instanceof TreeItem) {
				clearCheckable(item);
			}
		}
	}
});
var TreeGridItemProvider = defineClass("TreeGridItemProvider", EditableItemProvider, {
	init: function (indexing) {
		this._super(null, indexing);
		this._observers = [];
		this._items = new TreeItemProvider();
		this.setSource(this._items);
		this._summarizer = new DefaultSummarizer(this._items);
		this._editingItem = null;
		this._appending = false;
		this._insertAfter = false;
		this._insertIndex = -1;
		this._updateLock = false;
	},
	destroy: function() {
		this._items = null;
		this._summarizer = null;
		this._super();
	},
	onItemProviderFilterAdd: function (provider, field, criteria) {
	},
	onItemProviderFilterRemove: function (provider, field, filter) {
	},
	onItemProviderFilterClear: function (provider, field) {
	},
	onItemProviderFilterClearAll: function (provider) {
	},
    beginUpdate: function() {
        this._updateLock = true;
    },
    endUpdate: function() {
        this._updateLock = false;
    },

	setAggregateMode: function (value) {
		this._items.setAggregateMode(value);
	},
	setSummaryMode: function (value) {
		this._items.setSummaryMode(value);
	},
	setGroupSummaryMode: function (value) {
		this._items.setGroupSummaryMode(value);
	},
	setSortMode: function (value) {
		this._items.setSortMode(value);
	},
	sortMode: function() {
		return this._items.sortMode();
	},
	summarizer: function () {
		return this._summarizer;
	},
	getLevels: function (visibleOnly) {
		return this._items.getLevels(visibleOnly);
	},
	orderBy: function (fields, directions, textCases) {
		this._items.orderBy(fields, directions, textCases);
	},
	getSortFields: function () {
		return this._items.getSortFields();
	},
	getSortDirections: function () {
		return this._items.getSortDirections();
	},
    getSortCases: function () {
        return this._items.getSortCases();
    },
    getLabelComparer: function() {
    	return this._items.getLabelComparer();
    },
    setLabelComparer: function(comparer) {
    	this._items.setLabelComparer(comparer)
    },
	isFiltered: function (field) {
		return field != null ? this._items.hasFilter(field) : this._items.hasFilters();
	},
	addFilter: function (field, refFilter) {
		this._items.addFilter(field, refFilter);
	},
	removeFilter: function (field, filter) {
		this._items.removeFilter(field, filter);
	},
	clearFilters: function (field) {
		this._items.clearFilters(field);
	},
	clearAllFilters: function () {
		this._items.clearAllFilters();
	},
	beginFiltering: function () {
		this._items.beginFiltering();
	},
	endFiltering: function (filterCollection, filter) {
		this._items._addParentNodeOnFiltering = this._addParentNodeOnFiltering;
		this._items.endFiltering(true, filterCollection, filter);
	},
	expand: function (item, recursive, force) {
		this._items.expand(item, recursive, force);
	},
	collapse: function (item, recursive) {
		this._items.collapse(item, recursive);
	},
	expandAll: function (level) {
		this._items.expandAll(level);
	},
	collapseAll: function () {
		this._items.collapseAll();
	},
	getCheckedRows: function () {
		return this._items.getCheckedRows();
	},
	getCheckedRowIds: function () {
		return this._items.getCheckedRowIds();
	},
	setCheckableExpression: function (expr) {
		this._items.setCheckableExpression(expr);
	},
	resetCheckables: function () {
		this._items.resetCheckables();
	},
	applyCheckables: function () {
		this._items.applyCheckables();
	},
	isHideDeleted: function () {
		return this._items.isHideDeleted();
	},
	setHideDeleted: function (value) {
		this._items.setHideDeleted(value);			
	},
	getAllItems: function () {
		return this._items.getAllItems();
	},
	getItem: function (index) {
		return this._items.getItem(index);
	},
	getItemOfRow: function (dataRow) {
		return this._items.getItemOfRow(dataRow);
	},
	findItem: function (fields, values, options, startIndex, endIndex) {
		return this._items.findItem(fields, values, options, startIndex, endIndex);
	},
    findCell: function (fields, value, options, startIndex, endIndex, startFieldIndex) {
        return this._items.findCell(fields, value, options, startIndex, endIndex, startFieldIndex);
    },
	checkItem: function (item, checked, exclusive, checkEvent) {
		this._items.checkItem(item, checked, exclusive, checkEvent);
	},
	checkAll: function (checked, visibleOnly, checkableOnly, checkEvent) {
		this._items.checkAll(checked, visibleOnly, checkableOnly, checkEvent);
	},
	hasCellStyle: function () {
		return this._items.hasCellstyle();
	},
	setCellStyle: function (row, field, style) {
		this._items.setCellStyle(row, field, style);
	},
	setCellStyles: function (provider, rows, fieldMap) {
		this._items.setCellStyles(provider, rows, fieldMap);
	},
	removeCellStyle: function (style) {
		this._items.removeCellStyle(style);
	},
	clearCellStyles: function () {
		this._items.clearCellStyles();
	},
	checkCellStyle: function(rowId, field) {
		return this._items.checkCellStyle(rowId, field);
	},
	getCellStyle: function (dataRow, field) {
		return this._items.getCellStyle(dataRow, field);
	},
	setCellEditable: function (dataRow, column, value) {
		this._items.setCellEditable(dataRow, column, value);
	},
	setCellReadOnly: function (dataRow, column, value) {
		this._items.setCellReadOnly(dataRow, column, value);
	},
	getCellEditable: function (dataRow, column) {
		return this._items.getCellEditable(dataRow, column);
	},
	getCellReadOnly: function (dataRow, column) {
		return this._items.getCellReadOnly(dataRow, column);
	},
	setCellCursor: function(dataRow, column, value) {
		this._items.setCellCursor(dataRow, column, value);
	},
	getCellCursor: function(dataRow, column) {
		return this._items.getCellCursor(dataRow, column);
	},
	setCellEditor: function (dataRow, column, value) {
		this._items.setCellEditor(dataRow, column, value);
	},
	getCellEditor: function (dataRow, column) {
		return this._items.getCellEditor(dataRow, column);
	},
	clearEditableMap:function() {
		return this._items.clearEditableMap();
	},

	/*
	canUpdate: function (item, field) {
		if (item) {
			return true;
		}
		return false;
	},
	*/
	canAppend: function () {
		return false;
	},
	canInsert: function (item, field) {
		if (item) {
			return true;
		}
		return false;
	},
	canDelete: function (item, field) {
		if (item) {
			return true;
		}
		return false;
	},
	$_replaceItem: function (item, newItem) {
		var parent = item.parent();
		parent.setItem(item, newItem);
		this._items._setItem(item, newItem);
	},
	_doBeginUpdate: function (item) {
		this._editingItem = this._createEditItem(item, ItemState.UPDATING, null);
		this.$_replaceItem(item, this._editingItem);
		return this._editingItem;
	},
	_doBeginAppend: function (defaultValues) {
		this._editingItem = this._createEditItem(null, ItemState.APPENDING, defaultValues);
		return this._editingItem;
	},
	_doBeginInsert: function (item, defaultValues, shift, ctrl) {
		if (ctrl) {
			this._appending = true;
			item.setExpanded(true);
			this._editingItem = this._createEditItem(null, ItemState.INSERTING, defaultValues);
			this._items.appendItem(item, this._editingItem);
		} else {
			var p = item.parent();
			this._appending = false;
			this._insertAfter = shift;
			this._insertIndex = p.indexOf(item);
			this._editingItem = this._createEditItem(item, ItemState.INSERTING, defaultValues);
			this._items.insertItem(p, this._editingItem, this._insertIndex, this._insertAfter);
		}
		return this._editingItem;
	},
	_doCompleteUpdate: function (orgItem) {
		var rslt = false;
		var ds = this.dataSource();
		if (ds) {
			this.$_replaceItem(this._editingItem, orgItem);
			var row = this._editingItem.row();
			try {
				rslt = row.update(this._editingItem.values());
			} catch (e) {
				this.$_replaceItem(orgItem, this._editingItem);
				throw e;
			}
			if (rslt) {
				// this._copyExtents(this._editingItem, orgItem);
				/* update(..)에서 orgItem에 checkable을 변경한다. 위문장은 주석처리 2016.04.04*/
			} else {
				this.$_replaceItem(orgItem, this._editingItem);
			}
		}
		return rslt;
	},
	_doCompleteInsert: function (appending) {
		var rslt = false;
		var ds = this.dataSource();
		if (ds) {
			var parent = this._editingItem.parent();
			var row = parent.row();
			var child = ds.createRow(this._editingItem.values(), -1, false);
			var index = this._editingItem.parent().indexOf(this._editingItem);
			this._items.removeItem(this._editingItem);
			try {
				if (this.isAppending()) {
					rslt = row.addChild(child);
				} else {
					rslt = row.insertChild(index, child);
				}
			} catch (e) {
				if (this._appending) {
					this._items.appendItem(parent, this._editingItem);
				} else {
					this._items.insertItem(parent, this._editingItem, this._insertIndex, this._insertAfter);
				}
				throw e;
			}
			if (rslt) {
				var item = parent.itemOfRow(child.rowId);
				this._copyExtents(this._editingItem, item);
			} else {
				if (this._appending) {
					this._items.appendItem(parent, this._editingItem);
				} else {
					this._items.insertItem(parent, this._editingItem, this._insertIndex, this._insertAfter);
				}
			}
		}
		return rslt;
	},
	_doCancelEdit: function (state, orgItem) {
		if (state == ItemState.UPDATING) {
			this.$_replaceItem(this._editingItem, orgItem);
			this._copyExtents(this._editingItem, orgItem);
		} else if (state == ItemState.INSERTING) {
			if (this._editingItem.parent()) {
				this._items.removeItem(this._editingItem);
			}
		}
		this._super(state, orgItem);
	},
	_doCommitEdit: function (state, orgItem) {
		if (state == ItemState.UPDATING) {
		} else if (state == ItemState.INSERTING) {
		}
		this._super(state, orgItem);
	},
	remove: function (item) {
		if (item instanceof TreeItem) {
			var row = item.row();
			if (row) {
				row.parent().removeChild(row);
			}
		}
	},
	removeAll: function (items) {
		if (items && items.length > 0) {
			var rows = [];
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var item = this._items.getItem(items[i]);
				if (item instanceof TreeItem) {
					rows.push(item.row());
				}
			}
			this.dataSource().removeRows(rows);
		}
	},
	getRemovableRows: function (items) {
		if (items.length > 0) {
			var rows = [];
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var item = this._items.getItem(items[i]);
				if (item instanceof TreeItem) {
					rows.push(item.row());
				}
			}
			return rows;
		}
	},
	removeRows: function (rows) {
		if (rows) {
			this.dataSource().removeRows(rows);
		}
	},
	dataSource: function () {
		return this._items.dataSource();
	},
	setDataSource: function (value) {
		this._items.setDataSource(value);
	},
	rootItem: function () {
		return this._items._rootItem;
	},
	_createEditItem: function (target, state, defaultValues) {
		this._editingItem = null;
		var ds = this.dataSource();
		if (!ds) {
			return null;
		}
		var i,
			flds = ds.fieldCount();
		switch (state) {
			case ItemState.UPDATING:
				this._editingItem = new TreeEditItem(this, target, state);
				for (i = 0; i < flds; i++) {
					this._editingItem.setValue(i, target.getData(i));
				}
				this._copyExtents(target, this._editingItem);
				break;
			case ItemState.INSERTING:
			case ItemState.APPENDING:
				this._editingItem = new TreeEditItem(this, null, state);
				if (defaultValues) {
					for (i = 0; i < flds; i++) {
						if (defaultValues.length > i) {
							this._editingItem.setValue(i, defaultValues[i]);
						}
					}
				}
				break;
		}
		return this._editingItem;
	},
	onTreeItemProviderItemChanged: function (provider, item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.ITEM_CHANGED, item);
		} 
	},
	onTreeItemProviderExpanding: function (provider, item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.EXPANDING, item);
		} 
		return true;
	},
	onTreeItemProviderExpanded: function (provider, item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.EXPANDED, item);
		} 
	},
	onTreeItemProviderCollapsing: function (provider, item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.COLLAPSING, item);
		} 
		return true;
	},
	onTreeItemProviderCollapsed: function (provider, item) {
		if (this._eventLock <= 0) {
			return this.fireConfirmEvent(TreeItemProvider.COLLAPSED, item);
		} 
	},
	onItemProviderFilterAdded: function (provider, field, criteria) {
		this._fireFilterAdded(field, criteria);
	},
	onItemProviderFilterRemoved: function (provider, field, filter) {
		this._fireFilterRemoved(field, filter);
	},
	onItemProviderFilterCleared: function (provider, field) {
		this._fireFilterCleared(field);
	},
	onItemProviderFilterAllCleared: function (provider) {
		this._fireFilterAllCleared();
	},
	onItemProviderFiltered: function (provider, filterCollection, filter) {
		this._fireFiltered(filterCollection, filter);
	},
	onItemProviderSort: function (provider, fields, directions) {
		this._fireSort(fields, directions);
	},
	onItemProviderSorted: function (provider) {
		this._fireSorted();
	}
});

var TreeOptions = defineClass("TreeOptions", GridObject, {
	init : function(treeView) {
		this._super(treeView);
		this._expanderStyles = new VisualStyles(treeView, "expanderStyles");
		this._footerStyles = new VisualStyles(treeView, "footerStyles");
		this._icons = null;
	},
	expanderStyles: null,
	expanderWithCellStyles: true,
	footerStyles: null,
	expanderWidth: 17,
	lineVisible: true,
	lineStyle: null,
	showCheckBox: false,
	checkBoxSize: 17,
	iconImages: null,
	expandImage:null,
	collapseImage:null,
	/**
	 * 0 보다 큰 값으로 지정하면 아이콘이 존재하지 않아도 그 너비를 차지한다.
	 */
	iconWidth: 0,
	iconHeight: 0,
	aggregateMode: TreeAggregateMode.LEAF,
	collapseWhenLeftArrow: true,
	collapseWhenCtrlArrow: true,
	expandWhenRightArrow: true,
	expandWhenCtrlArrow: true,
	icons: function () {
		return this._icons;
	},
	setLinseVisible: function (value) {
		if (value != this._linesVisible) {
			this._linesVisible = value;
			this._changed();
		}
	},
	setExpanderWidth: function (value) {
		if (value != this._expanderWidth) {
			this._expanderWidth = value;
			this._changed();
		}
	},
	setShowCheckBox: function (value) {
		if (value != this._showCheckBox) {
			this._showCheckBox = value;
			this._changed();
		}
	},
	setCheckBoxSize: function (value) {
		value = Math.max(0, value);
		if (value != this._checkBoxSize) {
			this._checkBoxSize = value;
			this._changed();
		}
	},
	setIconImages: function (value) {
		if (value != this._iconImages) {
			this._iconImages = value;
			this._icons = this.owner().getImageList(value);
			this._changed();
		}
	},
	setIconWidth: function (value) {
		value = Math.max(0, value);
		if (value != this._iconWidth) {
			this._iconWidth = value;
			this._changed();
		}
	},
	setIconHeight: function (value) {
		value = Math.max(0, value);
		if (value != this._iconHeight) {
			this._iconHeight = value;
			this._changed();
		}
	},
	setLineStyle: function (value) {
		if (this._lineStyle != value) {
			this._lineStyle = value;
			this._expanderStyles.line(value);
		}
	},
	setExpandImage: function(value) {
		if (value) {
			this._expandImage = value;
			this._grid.getImage(value);
		} else {
			this._expandImage = null;
		};
	},
	setCollapseImage: function(value) {
		if (value) {
			this._collapseImage = value;
			this._grid.getImage(value);
		} else {
			this._collapseImage = null;
		};
	}
});
var TreeItemExpanderCell = defineClass("TreeItemExpanderCell", GridCell, {
	init : function() {
		this._super("treeItemExpanderCell");
	},
	displayText: function () {
		return null;
	},
	value: function () {
		return null;
	}
});
var TreeItemFooterCell = defineClass("TreeItemFooterCell", GridCell, {
	init : function() {
		this._super("treeItemFooterCell");
	},
	displayText: function () {
		var s = String(this.value());
		if (!s) {
            var index = this.index();
            if (index.dataColumn()) {
                s = index().column().footer().groupText();
            }
		}
		return s;
	},
	value: function () {
		return null;
	}
});
var TreeGridDelegate = defineClass("TreeGridDelegate", GridDelegate, {
	init : function(tree) {
		this._super(tree);
		this._rowViews = [];
		this._footerViews = [];
	},
	borrowItemView: function (model, fixed, rightFixed) {
		var i, row, footer;
		if (model instanceof TreeItem) {
			if (this._rowViews.length == 0) {
				this._rowViews.push(new TreeItemElement());
			}
			i = this._rowViews.length - 1;
			row = this._rowViews[i];
			row.setFixed(fixed);
			row.setRightFixed(rightFixed);
			this._rowViews.pop();
			return row;
		} else if (model instanceof TreeItemFooter) {
			if (this._footerViews.length == 0) {
				this._footerViews.push(new TreeItemFooterElement());
			}
			i = this._footerViews.length - 1;
			footer = this._footerViews[i];
			footer.setFixed(fixed);
			row.setRightFixed(rightFixed);
			this._footerViews.pop();
			return footer;
		}
		return null;
	}
});
var TreeGridLayoutManager = defineClass("TreeGridLayoutManager", GridLayoutManager, {
	init: function(tree) {
		this._super(tree);
	},
	_doLayout: function (bounds) {
		this._super(bounds);
		var tree = this.grid();
		var elt = tree.treeLinesRenderer();
		if (elt) {
			var r = this.fixedColCount() > 0 ? this.fixedBounds() : this.bodyBounds();
			if (this.columnCount() > 0) {
				r.width = Math.max(0, this.columnRect(0).width);
			} else {
				r.width = 0;
			}
			elt.setRect(r);
			elt.setLevelWidth(tree.treeOptions().expanderWidth());
			elt.setRange(tree, this.topIndex(), Math.min(tree.itemCount(), this.topIndex() + this.itemCount()) - 1);
		}
	}
});
var /* internal */ TreeItemsSorter = function () {
	var _items, _dataSource, _parent, _field, _comparer;
	var $_comparer;
	var _userComparer = function (_field, leftItem, rightItem) {
		if ($_comparer) {
			return $_comparer(_field, leftItem._rowId, rightItem._rowId);
		}
	};
	var _sort = function (left, right, dir, checkRow) {
		var i, j, m, mi, mr, r, v;
		do {
			i = left;
			j = right;
			m = _floor((left + right) / 2);
			mi = _parent.getItem(m).dataRow();
			mr = _parent.getItem(m).row();
			do {
				if (dir == SortDirection.ASCENDING) {
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(i).row());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(i).dataRow();
						}
						if (v <= 0) {	
							break;
						}
						i++;
					}
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(j).row());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(j).dataRow();
						}
						if (v >= 0) {	
							break;
						}
						j--;
					}
				} else {
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(i).row());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(i).dataRow();
						}
						if (v >= 0) { 
							break;
						}
						i++;
					}
					while (i <= j) {
						v = _comparer(_field, mr, _parent.getItem(j).row());
						if (v == 0 && checkRow) {
							v = mi - _parent.getItem(j).dataRow();
						}
						if (v <= 0) {	
							break;
						}
						j--;
					}
				}
				if (i <= j) {
					if (i != j) {
						_parent._exchangeItems(i, j);
					}
					i++;
					j--;
				}
			} while (i <= j);
			if (left < j) {
				_sort(left, j, dir, checkRow);
			}
			left = i;
		} while (left < right);
	};
	this.run = function (parent, field, dir, ignoreCase, left, right, checkRow) {
		_items = parent.provider();
		_dataSource = _items.dataSource();
		_parent = parent;
		_field = field;
		var fld = _dataSource.getField(field);
		$_comparer = fld._comparer ? fld._comparer : _dataSource._comparers[field] ? _dataSource._comparers[field] : _items._labelComparer[field];
		if ($_comparer) {
			_comparer = _userComparer;
		} else {
			switch (fld.dataType()) {
			case ValueType.NUMBER:
				_comparer = _dataSource.compareNumbers;
				break;
			case ValueType.DATETIME:
				_comparer = _dataSource.compareNumbers;
				break;
			case ValueType.BOOLEAN:
				_comparer = _dataSource.compareBools;
				break;
			case ValueType.OBJECT:
				_comparer = _dataSource.compareObjects;
				break;
			default:
				_comparer = ignoreCase ? _dataSource.compareTexts : _dataSource.compareValues;
				break;
			}
		}
		_sort(left, right, dir, checkRow);
	};
};
var TreeSelectionTool = defineClass("TreeSelectionTool", GridSelectionTool, {
	init: function(tree) {
		this._super(tree);
	},
	_doKeyDown: function (key, ctrl, shift, alt) {
		var item;
		var idx = this.focused().clone();
		var treeOptions = this.grid()._treeOptions;
		if (idx && (item = idx.item())) {
			switch (key) {
				case Keys.RIGHT:
					if ( (!ctrl && this.grid().visibleColumnCount() == 1 && idx.isRight() && treeOptions.isExpandWhenRightArrow()) || ( ctrl && treeOptions.isExpandWhenCtrlArrow()) ) {
						if (item.isExpanded()) {
							if (item.count() > 0) {
								idx.down();
								this.setFocused(idx, true);
								return true;
							}
						} else {
							item.setExpanded(true);
							return true;
						}
					}
					break;
				case Keys.LEFT:
					if ( (!ctrl && idx.isLeft() && treeOptions.isCollapseWhenLeftArrow()) || ( ctrl && treeOptions.isCollapseWhenCtrlArrow()) ) {
						if (item.isExpanded()) {
							item.setExpanded(false);
							return true;
						} else {
							if (!(item.parent() instanceof RootTreeItem)) {
								idx.itemIndex(item.parent().index());
								this.setFocused(idx, true);
								return true;
							}
						}
					}
					break;
			}
		}
		return this._super(key, ctrl, shift, alt);
	},
	_doColumnHeaderClicked: function (column, rightClicked, event) {
		this._super(column);
		var tree = this.grid();
		var dcol = _cast(column, DataColumn);
		if (!tree.isEmpty() && dcol && dcol.isSortable() && tree.sortingOptions().isEnabled()) {
			tree.sortColumn(dcol,event);
		}
	},
	_doElementClicked: function (element) {
		this._super(element);
		if (element instanceof TreeCheckElement) {
			var tree = this.grid();
			if (tree.editOptions().isCheckable()) {
				var item = element.item();
				item && item.isCheckable() && tree.itemSource().checkItem(item, !item.isChecked(), tree.checkBar().isExclusive(), true);
			}
		}
	},
	_doHandleClicked: function (handle) {
		if (handle instanceof TreeExpandHandle) {
			var item = handle.cellView().item();
			if (item) {
				item.setExpanded(!item.isExpanded());
			}
		} else {
			this._super(handle);
		}
	},
	onTap: function(x, y) {
		var clickCell = this._clickCell;
		var clickElement = this._clickElement;
		if (clickElement instanceof TreeExpandHandle) {
			var item = clickElement.cellView().item();
			if (item) {
				item.setExpanded(!item.isExpanded());
			}
		} else if (clickElement instanceof TreeCheckElement) {
			var tree = this.grid();
			if (tree.editOptions().isCheckable()) {
				var item = clickElement.item();
				item && item.isCheckable() && tree.itemSource().checkItem(item, !item.isChecked(), tree.checkBar().isExclusive(), true);
			}
		} else {
			this._super(x, y);
		}
	}
});
var TreeContainer = defineClass("TreeContainer", GridContainer, {
	init : function(dom, containerId, accessbility) {
		GridContainer.prototype.init.call(this, dom, containerId, accessbility);
	},
	treeView: function () {
		return this._gridView;
	},
	_createGridView: function(dom, container, accessbility)  {
		return new TreeView(dom, container, accessbility);
	},
	_createDefaultTool: function () {
		if ($_mobileEnable) {
			return _isMobile() ? new MobileTreeSelectionTool(this) : new TreeSelectionTool(this);
		} else {
			return new TreeSelectionTool(this);
		}		
	}
});
var /* abstract */ TreeHandler = function () {
	this.onTreeItemExpanding = function (handler, itemIndex, rowId) {
		return true;
	};
};
var TreeView = defineClass("TreeView", GridBase, {
	init : function(dom, container, accessbility) {
		this._treeLinesView = null;
		this._treeOptions = null;
		this._focusedRow = -1;
		this._super(dom, container, accessbility);
		this._expanderCell = new TreeItemExpanderCell();
		this._footerCell = new TreeItemFooterCell();
		this.panel().setVisible(false);
		this.setItemSource(this._items = this._createItemSource());
	},
	treeLinesRenderer: function () {
		return this._treeLinesView;
	},
	treeOptions: function () {
		return this._treeOptions;
	},
	getOptions: function () {
		var options = this._super();
		return options;
	},
	setOptions: function (source) {
		this._super(source);
	},
	getLevels: function (visibleOnly) {
		return this._items.getLevels(visibleOnly);
	},
	getExpanderCell: function (index) {
		this._expanderCell.setStyles(this._treeOptions.expanderStyles());
		this._expanderCell.setIndex(CellIndex.temp(this, index));
		return this._expanderCell;
	},
	getFooterCell: function (index) {
		this._footerCell.setStyles(this._treeOptions.footerStyles());
		this._footerCell.setIndex(index);
		return this._footerCell;
	},
	expand: function (item, recursive, force) {
        if (this.isItemEditing(null)) {
            return;
        }
		this._items.expand(item, recursive, force);
	},
	collapse: function (item, recursive) {
        if (this.isItemEditing(null)) {
            return;
        }
		this._items.collapse(item, recursive);
	},
	expandAll: function (level) {
        if (this.isItemEditing(null)) {
            return;
        }
		level = arguments.length > 0 ? level : 0;
		this._items.expandAll(level);
	},
	collapseAll: function () {
        if (this.isItemEditing(null)) {
            return;
        }
		this._items.collapseAll();
	},
	getTreeIcon: function (item) {
		var images = this._treeOptions.icons();
		if (images) {
			var idx = item.iconIndex();
			if (idx >= 0 && idx < images.count()) {
				return images.getImage(idx);
			}
		}
		return null;
	},
	getCheckedItems: function () {
		var items = [];
		for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
			var item = this.getItem(i);
			item.isChecked() && items.push(item);
		}
		return items;
	},
	getCheckedItemIndices: function () {
		var items = [];
		for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
			var item = this.getItem(i);
			item.isChecked() && items.push(item.index());
		}
		return items;
	},
	getCheckedRows: function (visibleOnly) {
		var rows = null;
		if (visibleOnly) {
			rows  = [];
			for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
				var item = this.getItem(i);
				item.isChecked() && rows.push(item.row());
			}
		} else {
			rows = this._items.getCheckedRows();
		}
		return rows;
	},
	getCheckedRowIds: function (visibleOnly) {
		var rows = null;
		if (visibleOnly) {
			rows  = [];
			for (var i = 0, cnt = this.itemCount(); i < cnt; i++) {
				var item = this.getItem(i);
				item.isChecked() && rows.push(item.dataRow());
			}
		} else {
			rows = this._items.getCheckedRowIds();
		}
		return rows;
	},
	checkChildren: function (parent, checked, recursive, visibleOnly, checkableOnly, checkEvent) {
		visibleOnly = arguments.length > 3 ? visibleOnly : true;
		if (parent) {
			var i, item,
				cnt = parent.count();
			for (i = 0; i < cnt; i++) {
				item = parent.getItem(i);
				if (checkableOnly) {
					item.isCheckable() && item.setChecked(checked, checkEvent);
				} else {
					item.setChecked(checked, checkEvent);
				}
				if (recursive && (item.isExpanded() || !visibleOnly)) {
					this.checkChildren(item, checked, true, visibleOnly, checkableOnly, checkEvent);
				}
			}
		}
	},
	resetCheckables: function () {
		this._items.resetCheckables();
	},
	applyCheckables: function () {
		this._items.applyCheckables();
	},
    dataSource: function () {
        return this._items ? this._items.dataSource() : null;
    },
    setDataSource: function (value) {
        if (this._items) {
            this._items.setDataSource(value);
        }
    },
    maxItemCount: function () {
        return this._items ? this._items.maxItemCount() : 0;
    },
    setMaxItemCount: function (value) {
        if (this._items) {
            this._items.setMaxItemCount(value);
        }
    },
	_addGroupView: function () {
		this._treeLinesView = new TreeLinesElement(this._dom, this);
		this.addElement(this._treeLinesView);
	},
	addMasks: function () {
		/*
		m_linesMask = new Shape();
		addMask(m_linesMask);
		m_treeLinesView.mask = m_linesMask;
		*/
	},
	_createDelegate: function () {
		return new TreeGridDelegate(this);
	},
	_createLayoutManager: function () {
		return new TreeGridLayoutManager(this);
	},
	_createBodyView: function (dom, body, fixed, rfixed) {
		return new TreeBodyElement(dom, body, fixed, rfixed);
	},
	_visualObjectChanged: function (obj) {
		this._super(obj);
		if (obj instanceof CheckBar) {
			this._items.setCheckableExpression(obj.checkableExpression());
		}
	},
	append: function () {
		return this.insert(this._items.rootItem(), false, true);
	},
	_doCanInsert: function (item, shift, ctrl) {
		return item && (item.count() > 0 || !ctrl || item.level() == 0 || this.editOptions().isAppendable());
	},
	getSummarizer: function () {
		return this._items.summarizer();
	},
	_doMaxRowCountChanged: function () {
		this._items.setMaxItemCount(this.maxItemCount());
	},
	onImageListImageLoaded: function (images, index) {
		this._super(images, index);
		if (images === this._treeOptions.icons()) {
			this.refreshView();
			this._treeLinesView.invalidate();
		}
	},
	onImageLoaded: function (url) {
		this._super(url);
	},
	getSortFields: function () {
		return this._items.getSortFields();
	},
	getSortDirections: function () {
		return this._items.getSortDirections();
	},
    getSortCases: function () {
        return this._items.getSortCases();
    },
	_doSortItems: function (fields, directions, textCases) {
		this._items.orderBy(fields, directions, textCases);
	},
	_doColumnFiltersChanged: function (filterCollection, filter) {
		this.applyFilters(filterCollection, filter);
	},
	initStyles: function () {
		this._super();
		this._addGridObject(this._treeOptions = new TreeOptions(this));
		this._treeOptions.expanderStyles().setParent(this.body().styles());
		var sheet = GridStyleSheet.Default;
		this._treeOptions.expanderStyles().setSysDefault(sheet.treeExpander());
	},
	$_doLayout: function (bounds) {
		var treeOptions = this._treeOptions;
		treeOptions.expanderStyles().setParent(this.fixedOptions().colCount() > 0 ? this.fixedOptions().styles() : this.body().styles(), false);
		var rslt = this._super(bounds);
		if (treeOptions.isLineVisible()) {
			this._treeLinesView.setVisible(true);
			this._treeLinesView.setStroke(treeOptions.expanderStyles().line());
			this._treeLinesView.invalidate();
		} else {
			this._treeLinesView.setVisible(false);
		}
		/*
		var r = m_treeLinesView.getGlobalBounds();
		var g = m_linesMask.graphics;
		g.clear();
		if (r.width > 0 && r.height > 0) {
			g.beginFill(0, 0);
			g.drawRect(r.x, r.y, r.width, r.height);
			g.endFill();
		}
		*/
		return rslt;
	},
	assignImageList: function (list) {
		this._super(list);
		if (this.treeOptions().iconImages() == list.name()) {
			this.treeOptions._icons = list;
		}
	},
	refreshView: function () {
		if (this._treeLinesView) {
			this._treeLinesView.invalidate();
		}
		this._super();
	},
	getEditBounds: function (index) {
		/*
		if (index.column().root().displayIndex() == 0) {
			var view = this.getFocusedCellView();
			if (view) {
				var r = view.boundsByContainer();
				if (view instanceof DataCellElement) {
					r.width -= view.getButtonsWidth();
				}
				r.width = Math.max(2, r.width);
				return r;
			}
		}
		*/
		return this._super(index);
	},
	updatePastedRow: function (item, values, strict) {
		if (item instanceof TreeItem) {
			var row = item.row();
			if (row) {
				strict ? row.updateStrict(values) : row.update(values);
			}
		}
	},
	appendPastedRow: function (values) {
		var ds = this.dataSource();
		if (ds) {
			var row = ds.createRow(values, -1, false);
			ds.rootRow().addChild(row);
		}
	},
	_createItemSource: function () {
		var items = new TreeGridItemProvider(true);

		items._addParentNodeOnFiltering  = this._filteringOptions ? this._filteringOptions._addParentNodeOnFiltering : undefined;
		return items;
	},
	$_getVisibleAncestor: function (rowId) {
		var item = this._items.getItemOfRow(rowId);
		if (item) {
			while (item && !item.isVisible()) {
				item = item.parent();
			}
			return item;
		} else {
			return null;
		}
	},
	onItemProviderReset: function(itemProvider) {
		this._currentRowId = -1;
		this._super(itemProvider);
	},
	onTreeItemProviderItemChanged: function (provider, item) {
		this._treeLinesView.invalidate();
		this.invalidateLayout();
		this.fireEvent(TreeView.CHANGED, item);
	},
	$_expandChanging: function (provider, item, expanding) {
		this._focusedRow = this.focusedIndex() ? this.focusedIndex().dataRow() : -1;
		if (this.editController().isEditing() && !this._items.isEditing()) {
			this.editController().cancelEditor(true);
		}
		return !this.editController().isEditing() && !this._items.isEditing() &&
			this.fireConfirmEvent(expanding ? TreeView.EXPANDING : TreeView.COLLAPSING, item);
	},
	onTreeItemProviderExpanding: function (provider, item) {
		this.$_expandChanging(provider, item, true);
	},
	onTreeItemProviderCollapsing: function (provider, item) {
		this.$_expandChanging(provider, item, false);
	},
	$_expandChanged: function(provider, item, event) {
		if (this._focusedRow >= 0) {
			var index = this.focusedIndex().clone();
			var focusItem = this.$_getVisibleAncestor(this._focusedRow);
			var curItemIndex = focusItem.index();
			if ( curItemIndex >= this.topIndex() && curItemIndex <= this.topIndex()+this.layoutManager()._availableItemCount) {
				index._itemIndex = focusItem ? focusItem.index() : -1;
			} else {
				index._itemIndex = item ? item.index() : -1;
			}
			this.setFocusedIndex(index, true);
		}
		this.fireEvent(event, item);
	},
	onTreeItemProviderExpanded: function (provider, item) {
		this.$_expandChanged(provider, item, TreeView.EXPANDED);
	},
	onTreeItemProviderCollapsed: function (provider, item) {
		this.$_expandChanged(provider, item, TreeView.EXPANDED);
	}
});
TreeView.EXPANDING = "onTreeViewExpanding";
TreeView.EXPANDED = "onTreeViewExpanded";
TreeView.COLLAPSING = "onTreeViewCollapsing";
TreeView.COLLAPSED = "onTreeViewCollapsed";
TreeView.CHANGED = "onTreeViewChanged";

/* 미사용 코드
var TreeViewObserver = defineClass("TreeViewObserver", GridBaseObserver, {
	init: function () {
		this._super();
	},
	onTreeViewExpanding: function (tree, item) {
	},
	onTreeViewExpanded: function (tree, item) {
	},
	onTreeViewCollapsing: function (tree, item) {
	},
	onTreeViewCollapsed: function (tree, item) {
	},
	onTreeViewChanged: function (tree, item) {
	}
}); 
*/
var TreeExpandHandle = defineClass("TreeExpandHandle", CellHandle, {
	init : function(dom, cell) {
		this._super(dom, cell, "treeItemExpandHandle");
		this._figureBackground = SolidBrush.BLACK;
	},
	expanded: false,
	figureSize: 9,
	figureBackground: null,
	background: null,
	isClickable: function () {
		return true;
	},
	_doDraw: function (g) {
		var sz = this.figureSize(),
			fill = this.background(),
			r = new Rectangle(0, 0, this.width(), this.height()),
			grid = this._parent.grid(),
			options = grid && grid.treeOptions(),
			image;
		if (fill) {
		}
		if (this.isExpanded()) {
			if (options && options._collapseImage) {
				this._drawTreeExpandImage(grid,options._collapseImage, r, g);
			} else {
				$$_drawMinusBox(g, r, sz, this.figureBackground(), fill);
			}
		} else {
			if (options && options._expandImage) {
				this._drawTreeExpandImage(grid,options._expandImage, r, g);
			} else {
				$$_drawPlusBox(g, r, sz, this.figureBackground(), fill);
			}
		}
	},
	_drawTreeExpandImage: function(grid,url,r, g) {
		var img = grid.getImage(url);
		var x, y, w, h;

		if (img) {
			w = Math.min(img.width , r.width);
			h = Math.min(img.height , r.height);
			x = r.x + _int((r.width - w) / 2);
			y = r.y + _int((r.height - h) / 2);
			g.drawImage(img, x, y, w, h);
		}
	}
});
// 1 size관련 수정
// figureBackground (fill) 관련 수정.
var TREE_CHECK_FILL = new SolidBrush(0xffffffff);
var TreeCheckElement = defineClass("TreeCheckElement", VisualElement, {
	init : function(dom) {
		this._super(dom, "treeCheckView");
	},
	item: null,
	checkable: true,
	checked: false,
	exclusive: false,
	drawCheckBox: true,
	radioImageUrl: null,
	isClickable: function () {
		return true;
	},
	_doDraw: function (g) {
		var r = new Rectangle(0, 0, this.width(), this.height());
		var grid = this._parent.grid();
		var checkBar = grid.checkBar();
		var checkStyle = checkBar.styles();
		g.drawRectI(null, null, r);
		var	checkSize = checkStyle.figureSize() ? checkStyle.figureSize().getDimension(r.height) : 12;
		var sz = checkSize - 2;
		var line = checkStyle.line();
		var fill = checkStyle.figureBackground();
		var grayFill = checkStyle.figureInactiveBackground();
		var x = _floor(r.x + (r.width - sz) / 2);
		var y = _floor(r.y + (r.height - sz) / 2);
		if (this._exclusive) {
			var rd = sz / 2;
			g.drawCircle(this._checkable ? TREE_CHECK_FILL : (grayFill || CHECK_CELL_GRAY_FILL ), line || CHECK_CELL_BORDER, x + rd, y + rd, rd);
			if (this._checked) {
				if (this._radioImageUrl) {
					var img = this._parent.grid().getImage(this._radioImageUrl);
					var w, h;
					if (img && (w = img.width) > 0 && (h = img.height) > 0) {
						var x = _floor(r.x + (r.width - w) / 2);
						var y = _floor(r.y + (r.height - h) / 2);
						g.drawImage(img, x, y, w, h);
					} 
				} else {
					g.drawCircle(fill, null, x + rd, y + rd, rd - 2);
				}
			}
		} else {
			g.drawBoundsI(this._checkable ? TREE_CHECK_FILL : (grayFill || CHECK_CELL_GRAY_FILL), line || CHECK_CELL_BORDER, x, y, sz, sz);
			var img = checkBar.getCheckImage( this._checked, this._checkable );
			if (img) {
				var w, h;
				if (img && (w = img.width) > 0 && (h = img.height) > 0) {
					var x = _floor(r.x + (r.width - w) / 2);
					var y = _floor(r.y + (r.height - h) / 2);
					g.drawImage(img, x, y, w, h);
				}
			} else if (this._checked) {
				checkSize *= 0.9;
				$$_drawCheckMark(g, fill, r, checkSize);
			}				
		}
	}
});
var TreeExpanderElement = defineClass("TreeExpanderElement", CellElement, {
	init : function(dom, name) {
		this._super(dom, name);
		this._handle = new TreeExpandHandle(dom, this);
		this.addElement(this._handle);
		this._checkView = new TreeCheckElement(dom, this);
		this.addElement(this._checkView);
		this._iconView = new IconElement(dom, "treeIconView");
		this._iconView.setMouseEnabled(false);
		this.addElement(this._iconView);
		this._line = null;
		this._expanderWidth = 0;
		this._dataCell = null;
		this._useCellStyles = true;
	},
	setHandleWidth: function (value) {
		this._handle.setWidth(value);
	},
	setShowCheck: function (value) {
		this._checkView.setVisible(value);
	},
	setCheckSize: function (value) {
		this._checkView.setWidth(value);
	},
	setIconWidth: function (value) {
		this._iconView.setWidth(value);
	},
	setExpanderWidth: function (value) {
		this._expanderWidth = value;
	},
	setExclusive: function (value) {
		this._checkView.setExclusive(value);
	},
	getAdapter: function (adapter) {
		if (adapter == DataCellElement) {
			return this._dataCell;
		}
		return this._super(adapter);
	},
	_doPrepareElement: function (styles) {
		this._super(styles);
	},
	_doUpdateContent: function (cell) {
		this._super(cell);
		var tree = this.grid(),
			item = cell.index().item();
		if (this._checkView.isVisible()) {
			this._checkView.setItem(item);
			this._checkView.setCheckable(item.isCheckable());
			this._checkView.setChecked(item.isChecked());
			this._checkView.setDrawCheckBox(tree.checkBar().isDrawCheckBox());
			this._checkView.setRadioImageUrl(tree.checkBar().radioImageUrl())
		}
		this._iconView.setImage(tree.getTreeIcon(item));
		item.setIconHeight(this._iconView.iconHeight());
		this._handle.setVisible(item.hasChildren());
		this._handle.setExpanded(item.isExpanded());
		var styles = cell.styles();
		this._handle.setBackground(styles.background());
		this._handle.setFigureBackground(styles.figureBackground());
		this._handle.setFigureSize(styles.figureSize() ? styles.figureSize().getDimension(this._handle.width()) : 9);
	},
	_doLayoutContent: function (layout) {
		var styles = this.grid().treeOptions().expanderStyles();
		var x = this._handle.width() * (this.index().item().level() - 1);// + styles.paddingLeft();
		var wCheck = this._checkView.isVisible() ? this._checkView.width() : 0;
		this._handle.setBounds(x, this.borderTopWidth(), this._handle.width(), this.height() - this.borderTopWidth() - this.borderBottomWidth());
		this._handle.invalidate();
		if (wCheck > 0) {
			this._checkView.setBounds(x + this._handle.width(), this.borderTopWidth(), wCheck, this.height() - this.borderTopWidth() - this.borderBottomWidth());
			this._checkView.invalidate();
		}
		var wIcon = this._iconView.width();
		if (wIcon > 0) {
			this._iconView.setVisible(true);
			this._iconView.setBounds(x + this._handle.width() + wCheck, this.borderTopWidth(), wIcon, this.height() - this.borderTopWidth() - this.borderBottomWidth());
			this._iconView.invalidate()
		} else {
			this._iconView.setVisible(false);
		}
	},
	_doRender: function (g, rc) {
		var dataCell = this._useCellStyles ? this._dataCell : null;
		var fill = dataCell ? dataCell.background() : this.background();
		if (fill) {
			g.drawRectI(fill, null, rc);
		}
		var wBottom = dataCell ? dataCell.borderBottomWidth() : this.borderBottomWidth();
		var wRight = this.borderRightWidth();
		if (wBottom) {
			wBottom = _floor((wBottom + 1) / 2);
			g.drawLineI(dataCell ? dataCell._borderBottom : this._borderBottom, rc.x, rc.bottom() - wBottom, rc.right(), rc.bottom() - wBottom);
		}
		if (this.width() < this._expanderWidth && wRight) {
			wRight = _floor((wRight + 1) / 2);
			g.drawLineI(this._borderRight, rc.right() - wRight, rc.y, rc.right() - wRight, rc.bottom());
		}
	},
	canHovering: function () {
		return false;
	},
	_setDataCell: function (cell) {
		this._dataCell = cell;
	}
});
var TreeItemElement = defineClass("TreeItemElement", RowElement, {
	init : function(dom) {
		this._super(dom);
		this.setName("treeItemView");
		this._expander = new TreeExpanderElement(dom, "treeExpanderView");
		this.addElement(this._expander);
	},
	_clearChildren: function () {
		this._super();
		this.addElement(this._expander);
	},
	_prepareCells: function (lm) {
		this._super(lm);
		if (this.childCount() > 0 && (lm.firstCol() == 0 || this.isFixed()) && !this.isRightFixed()) {
			var tree = this.grid();
			var options = tree.treeOptions();
			var expander = this._expander;
			var cell = this.grid().getExpanderCell(this.index());
			var view = this._getFirstCell(lm);
			expander.setShowCheck(options.isShowCheckBox());
			expander.setExclusive(tree.checkBar().isExclusive());
			expander._setDataCell(view);
			expander.setVisible(true);
			expander.updateCell(cell);
		} else {
            this._expander.setVisible(false);
        }
	},
	_layoutCells: function (lm) {
		this._super(lm);
		if (this._expander.isVisible()) {
			var tree = this.grid();
			var item = this.item();
			var options = tree.treeOptions();
			var view = this._getFirstCell(lm);
			var level = item.level();
			var wHandle = options.expanderWidth();
			var wCheck = options.isShowCheckBox() ? options.checkBoxSize() : 0;
			var wIcon = options.iconWidth();
			var expander = this._expander;
			if (wIcon <= 0 && options.icons()) {
				var icon = tree.getTreeIcon(item);
				if (icon) {
					wIcon = icon.width;
				}
			}
			var styles = options.expanderStyles();
			var wExpander = wHandle * level + wCheck + wIcon + styles.paddingRight();// styles.paddingHorz();
			var wView = view.width();
			view.setWidth(wView - wExpander);
			view.setX(view.x() + wExpander);
			view.layoutTreeContent(lm);
			expander._useCellStyles = options.isExpanderWithCellStyles();
			expander.setHandleWidth(wHandle);
			expander.setShowCheck(options.isShowCheckBox());
			expander.setExclusive(tree.checkBar().isExclusive());
			expander.setCheckSize(wCheck);
			expander.setIconWidth(wIcon);
			expander.setExpanderWidth(wExpander);
			expander.setBounds(0, 0, Math.min(wExpander, wView), this.height());
			expander.setIndex(CellIndex.temp(tree, this.index(), null));
			expander.layoutContent(lm);
		}
	}
});
var TreeItemFooterElement = defineClass("TreeItemFooterElement", ItemElement, {
	init: function(dom, fixed, rightFixed) {
		this._super(dom, "treeItemFooterView");
		this._fixed = fixed;
		this._rightFixed = rightFixed;
		this._cells = {};
	},
	fixed: false,
	_doUpdateElement: function (styles) {
		this._super(styles);
	},
	_doMesasure: function (grid, hintWidth, hintHeight) {
		return { width: hintWidth, height: hintHeight };
	},
	_doLayoutContent: function (lm) {
		this._prepareCells(lm);
		this._layoutCells(lm);
	},
	_doRender: function (g, r) {
		if (this.isFixed()) {
			var fill, stroke, lstroke,
				options = this.grid().fixedOptions(),
				styles = options.colBarStyles(), 
				wbar = options.colBarWidth();

			if (this._rightFixed) {
				r.setRight(wbar);
			} else {
				r.setLeft(r.right() - wbar);
			}
			fill = styles.background();
			if (fill) {
				g.drawRectI(fill, null, r);
			}
			stroke = styles.borderRight();
			if (stroke) {
				g.drawLine(stroke, r.right() - 1, r.y, r.right() - 1, r.bottom());
			}
			lstroke = styles.borderLeft();
			if (lstroke && this._rightFixed) {
				g.drawLine(stroke, r.x, r.y, r.x, r.bottom());
			}
		}
	},
	prepareCells: function (lm) {
		this.clear();
		var	tree = this.grid();
		var	start = lm.firstCol(this._fixed, this._rightFixed);
		var	end = lm.lastCol(this._fixed, this._rightFixed);
		for (var i = start; i <= end; i++) {
			var column = lm.getColumn(i);
			var view = this._cells[column];
			if (!view) {
				if (column instanceof ColumnGroup) {
					view = new GroupFooterGroupCellElement(this._dom);
				} else {
					view = new GroupFooterCellElement(this._dom);
				}
				this._cells[column.$_hash] = view;
			}
			this.addElement(view);
			var index = CellIndex.temp(tree, this.index(), column);
			var model = tree.getFooterCell(index);
			view.updateCell(model);
		}
	},
	layoutCells: function (lm) {
		var	tree = this.grid();
		var	start = lm.firstCol(this._fixed, this._rightFixed);
		var	end = lm.lastCol(this._fixed, this._rightFixed);
		for (var i = start; i <= end; i++) {
			var view = this._cells[lm.getColumn(i).$_hash];
			var r = lm.columnBounds(i);
			if (!this.isFixed()) {
				r.x -= tree.leftPos;
			}
			r.height = this.height();
			view.setRect(r);
			view.layoutContent(lm);
		}
	}
});
var TreeLinesElement = defineClass("TreeLinesElement", LayerElement, {
	init : function(dom, tree) {
		this._super(dom, "treeLinesView");
		this._tree = tree;
		this._startIndex = -1;
		this._endIndex = -1;
		this._levelWidth = 20;
		this._handleWidth = 9;
		this._handleHeight = 9;
		this._stroke = SolidPen.LTGRAY;
		this._options = null;
	},
	setLevelWidth: function (value) {
		if (value != this._levelWidth) {
			this._levelWidth = value;
			this.invalidate();
		}
	},
	setHandleWidth: function (value) {
		if (value != this._handleWidth) {
			this._handleWidth = value;
			this.invalidate();
		}
	},
	setHandleHeight: function (value) {
		if (value != this._handleHeight) {
			this._handleHeight = value;
			this.invalidate();
		}
	},
	setStroke: function (value) {
		if (value != this._stroke) {
			this._stroke = value;
			this.invalidate();
		}
	},
	setRange: function (tree, startIndex, endIndex) {
		this._options = tree.treeOptions();
		if (startIndex != this._startIndex || endIndex != this._endIndex) {
			this._startIndex = startIndex;
			this._endIndex = endIndex;
			this.invalidate();
		}
	},
	$_findLevelItem: function (tree, level, start) {
		var i, item;
		for (i = start; i <= this._endIndex; i++) {
			item = tree.getItem(i);
			if (item && item.level() == level) {
				return item;
			}
		}
		return null;
	},
	$_drawVertLine: function (g, src, dst, level) {
		var r, sz,
			lm = this._tree.layoutManager(),
			top = lm.topIndex(),
			x1 = level * this._levelWidth + this._levelWidth / 2,
			y1 = 0,
			y2 = this.height();
		if (src) {
			r = lm.itemBounds(src.index() - top);
			sz = (src instanceof TreeItem && src.hasChildren()) ? this._handleHeight : 0;
			y1 = r.y + r.height / 2 + sz / 2;
		}
		if (dst) {
			r = lm.itemBounds(dst.index() - top);
			sz = (dst instanceof TreeItem && dst.hasChildren()) ? this._handleHeight : 0;
			y2 = r.y + r.height / 2 - sz / 2;
		}
		x1 = _floor(x1);
		g.drawLineI(this._stroke, x1, y1, x1, y2);
	},
	$_drawChildLine: function (g, src, dst) {
		var y1, r, sz, 
			lm = this._tree.layoutManager(),
			top = lm.topIndex(),
			x1 = src.level() * this._levelWidth + this._levelWidth / 2,
			y2 = this.height();
		r = lm.itemBounds(src.index() - top);
		if (this._options.isShowCheckBox()) {
			var checkStyle = this._tree.checkBar().styles();
			var	checkSize = checkStyle.figureSize() ? checkStyle.figureSize().getDimension(r.height) : 12;
			checkSize -= 2;
			y1 = r.y + r.height / 2 + checkSize / 2;
		} else if (this._options.icons() && src instanceof TreeItem && src.iconHeight() > 0) {
			y1 = r.y + r.height / 2 + src.iconHeight() / 2;
		} else {
			y1 = r.bottom() - r.height / 4;
		}
		if (dst) {
			r = lm.itemBounds(dst.index() - top);
			sz = (dst instanceof TreeItem && dst.hasChildren()) ? this._handleHeight : 0;
			y2 = r.y + r.height / 2 - sz / 2;
		}
		x1 = _floor(x1);
		g.drawLineI(this._stroke, x1, y1, x1, y2);
	},
	$_drawHorzLine: function (g, item) {
		var r,
			lm = this._tree.layoutManager(),
			top = lm.topIndex(),
			x1 = item.parent().level() * this._levelWidth + this._levelWidth / 2,
			x2 = item.level() * this._levelWidth,// + m_levelWidth / 2;
			y = 0;
		if (item instanceof TreeItem && item.hasChildren()) {
			x1 += this._handleWidth / 2;
		}
		r = lm.itemBounds(item.index() - top);
		y = _floor(r.y + r.height / 2);
		g.drawLineI(this._stroke, x1, y, x2, y);
	},
	_doDraw: function (g) {
		g.clipBounds(0, 0, this.width(), this.height());
		var tree = this._tree;
		if (!tree || this._startIndex < 0 || this._endIndex < 0 || this._startIndex > this._endIndex) {
			return;
		}
		var i, j, item, level, parent, next, prev, last, r1, r2, x1, y1, y2 ,sz;
		var lm = tree.layoutManager();
		var szExp = 9;
		var startLevel = -1; // 현재 표시되는 아이템들의 최소 level.
		var top = tree.topIndex();
		item = null;
		for (i = this._startIndex; i <= this._endIndex; i++) {
			item = tree.getItem(i);
			if (item) {
				break;
			}
		}
		if (!item) {
			return;
		}
		level = item.level();
		if (level > 1 || item.childIndex() > 0) {
			for (j = 0; j < level; j++) {
				parent = item.getAncestor(j);
				next = parent.last();
				if (next && next.index() >= i) {
					next = this.$_findLevelItem(tree, j + 1, i);
					this.$_drawVertLine(g, null, next, parent.level());
				}
			}
			if (item.childIndex() > 0) {
				this.$_drawVertLine(g, null, item, item.parent().level());
			}
		}
		for (; i <= this._endIndex; i++) {
			item = tree.getItem(i);
			parent = item.parent();
			j = item.childIndex();
			if (j < parent.count() - 1) {
				next = parent.getItem(j + 1);
				if (next.index() > this._endIndex) {
					next = null;
				}
				this.$_drawVertLine(g, item, next, parent.level());
			}
			parent = item;
			if (parent && parent.isExpanded() && parent.count() > 0) {
				next = parent.getItem(0);
				if (next.index() > this._endIndex) {
					next = null;
				}
				this.$_drawChildLine(g, item, next);
			}
			this.$_drawHorzLine(g, item);
		}
	}
});
var TreeBodyElement = defineClass("TreeBodyElement", GridBodyElement, {
	init : function(dom, body, fixed, rfixed) {
		this._super(dom, body, fixed, rfixed);
		this._footers = [];
		this._footerViews = [];
	},
	clearItems: function () {
		this._super();
		this._footers.splice(0, this._footers.length);
	},
	addItem: function (item) {
		if (item instanceof GroupFooter) {
			this._footers.push(item);
		} else {
			this._super(item);
		}
	}
});
var _vm__ = "goAAAANSUhEUgAAA";
var $$_getColumnProxy = function (column) {
	return column instanceof DataColumn ? $$_getColumnProxy2(column) : $$_getColumnGroupProxy(column);
};
var $$_getColumnProxy2 = function (column) {
	if (column instanceof Column) {
		var proxy = {
			name : column.name(),
			tag : column.tag(),
			parent : column.parent() ? column.parent().name() : null,
			visible : column.isVisible(),
			resizable : column.isResizable(),
			movable: column.isMovable(),
			width: column.width(),
			displayIndex: column.displayIndex(),
			displayWidth: column.displayWidth(),
			fillWidth: column.fillWidth(),
			fillHeight: column.fillHeight(),
            checked: column.isChecked(),
            header:column.header().proxy(),
			$_hash: column.$_hash
		};
		if (column instanceof DataColumn) {
			proxy.type = "data";
			proxy.editor = column.editor();
			proxy.editorOptions = column.editorOptions();
			proxy.readOnly = column.isReadOnly();
			proxy.editable = column.isEditable();
			proxy.fieldIndex = column.fieldIndex();
			proxy.fieldName = column.fieldName();
			proxy.dataIndex = column.dataIndex();
			proxy.sortable = column.isSortable();
			proxy.button = column.button();
            proxy.buttonVisibility = column.buttonVisibility();
            proxy.editButtonVisibility = column.editButtonVisibility();
			proxy.defaultValue = column.defaultValue();
			proxy.required = column.isRequired();
			proxy.requiredLevel = column.requiredLevel();
			proxy.requiredMessage = column.requiredMessage();
			proxy.textInputCase = column.textInputCase();
			proxy.nanText = column.nanText();
			proxy.zeroText = column.zeroText();
			proxy.lookupDisplay = column.isLookupDisplay();
			proxy.labels = column.lookupLabels() || [];
			proxy.values = column.lookupValues() || [];
			proxy.labelField = column.labelField();
			proxy.lookupSourceId = column.lookupSourceId();
			proxy.lookupKeyFields = column.lookupKeyFields();
			proxy.lookupData = column.lookupData();
			proxy.imageList = column.imageList();
			proxy.equalBlank = column.isEqualBlank();
			proxy.equalBlankExpression = column.equalBlankExpression();
			proxy.displayMinusZero = column.displayMinusZero();
			proxy.imeMode = "";//column.imeMode();

		} else if (column instanceof ColumnGroup) {
			proxy.type = "group";
			proxy.orientation = column.orientation();
			proxy.hideChildHeaders = column.isHideChildHeaders();
		} else if (column instanceof SeriesColumn) {
			proxy.type = "series";
			proxy.fieldNames = column.fieldNames();
		};
		var styles = column._styles && column._styles.toProxy(false);
		styles && Object.keys(styles).length > 0 && (proxy.styles = styles)
		var dynamicStyles = column._dynamicStyles && column._dynamicStyles.proxy();
		dynamicStyles && (proxy.dynamicStyles = dynamicStyles);
		column._footer && column._footer.proxy && (proxy.footer = column._footer.proxy());
		return proxy;
	}
	return null;
};

var $$_getFieldProxy = function (field) {
	if (field instanceof DataField) {
		var proxy = {
	        fieldName : field.fieldName(),
	        orgFieldName: field.orgFieldName(),
	        dataType : field.dataType(),
	        subType : field.subType(),
			subtypeEnabled: field.isSubtypeEnabled(),
	        length : field.length(),
			set: field.set(),
			minimum: field.minimum(),
			maximum: field.maximum(),
			required: field.isRequired(),
		    updatable: field.isUpdatable(),
	        defaultValue : field.defaultValue(),
			booleanFormat: field.booleanFormat(),
			datetimeFormat: field.datetimeFormat(),
			amText: field.amText(),
			pmText: field.pmText(),
			baseYear: field.baseYear(),
	        header : field.header(),
			baseField : field.baseField(),
			calculateExpression: field.calculateExpression(),
			calculateCallback: field.calculateCallback() && field.calculateCallback().toString && field.calculateCallback().toString(),
			$_hash: field.$_hash
		};
		return proxy;
	}
	return null;
};
var $$_getColumnGroupProxy = function (column) {
	var proxy = $$_getColumnProxy2(column);
	if (column instanceof ColumnGroup) {
		var cols = proxy.columns = [];
		for (var i = 0, cnt = column.count(); i < cnt; i++) {
			cols.push($$_getColumnGroupProxy(column.getItem(i)));
		}
	}
	return proxy;
};
var $$_getSelectionProxy = function (grid, item) {
	var range = item.getBounds();
	var item1 = grid.getItem(range.R1());
	var item2 = grid.getItem(range.R2());
	return {
		style: item.style(),
		startItem: range.R1(),
		startRow: item1 ? item1.dataRow() : -1,
		startColumn: range.C1().name(),
		endItem: range.R2(),
		endRow: item2 ? item2.dataRow() : -1,
		endColumn: range.C2().name()
	};
};
var $$_getSelectionItems = function (grid, item) {
	var range = item.getBounds();
	var item1 = grid.getItem(range.R1());
	var item2 = grid.getItem(range.R2());
	var i = item1.index();
	var i2 = item2.index();
	var rows = [];
	for (; i <= i2; i++) {
		rows.push(i);
	}
	return rows;
};
var $$_getSelectionRows = function (grid, item) {
	var range = item.getBounds();
	var item1 = grid.getItem(range.R1());
	var item2 = grid.getItem(range.R2());
	var i = item1.index();
	var i2 = item2.index();
	var rows = [];
	var items = grid.itemSource();
	for (; i <= i2; i++) {
		item1 = items.getItem(i);
		if (item1.dataRow() >= 0) {
			rows.push(item1.dataRow());
		}
	}
	return rows;
};
var $$_getItemIndicies = function (items) {
	var idxs = [];
	for (var i = 0, cnt = items.length; i < cnt; i++) {
		idxs.push(items[i].index());
	}
	return idxs;
}
var $$_getTreeRowIds = function (rows) {
	var idxs = [];
	for (var i = 0, cnt = rows.length; i < cnt; i++) {
		idxs.push(rows[i].rowId());
	}
	return idxs;
}
var $$_getItemProxy = function (item, extended) {
	var p = item._parent;
	var obj = {
		type: undefined,
		id: item._id,
		parentId: p && !(p instanceof RootItem) ? p.id() : NaN,
		itemIndex: item._index,
		dataRow: -1,
		checked: item.isChecked()
	};
	if (extended) {
		obj.childIndex = item.childIndex();
		obj.level = item.level();
	}
	if (item instanceof GridRow) {
		obj.type = "row";
		obj.dataRow = item.dataRow();
	} else if (item instanceof GroupItem) {
		obj.count = item._children.length;
		obj.expanded = item._expanded;
		if (item instanceof GroupItemImpl || item instanceof MergedGroupHeader) {
			obj.type = "group";
			obj.footerId = item._footer ? item._footer.id() : NaN;
			if (extended) {
				obj.firstItem = $$_getItemProxy(item.firstItem(), true, false);
				obj.firstDataItem = $$_getItemProxy(item.firstDataItem(), true, false);
				obj.dataRows = item.$_getRows();
			}
		} else if (item instanceof TreeItem) {
			obj.type = "tree";
			obj.dataRow = item._dataRow ? item._dataRow.rowId() : -1;
		}
        obj.$_child = obj.count > 0 ? item._children[0]._index : -1;
	} else if (item instanceof GroupFooter) {
		obj.type = "footer";
	}
	return obj;	
}
var RealGridHelper = function () {
    this.createGrid = function (containerId, handler, accessbility, shadowOptions) {
        var gridContainer = new GridContainer(false, containerId, accessbility, shadowOptions);
        handler._gv = gridContainer.gridView();
        this.initGrid(handler._gv);
        this.setGridHandler(handler);
    };
    this.createTree = function (containerId, handler, accessbility, shadowOptions) {
        var treeContainer = new TreeContainer(false, containerId, accessbility, shadowOptions);
        handler._gv = treeContainer.gridView();
        handler._gv._productName = "RealGridJS v1.0";
        this.initGrid(handler._gv);
        this.setTreeHandler(handler);
    };
	var _createField = function (provider, source) {
		var field = null;
		if (typeof source == "string") {
			field = new DataField(source, ValueType.TEXT, 0);
		} else if (source && source.fieldName) {
			field = new DataField(source.fieldName, source.dataType, source.length);
			if (source.datetimeFormat && source.datetimeFormat == "flash") {
				source.datetimeFormat = "platform";
			}
			field._typeLock = true;
			try {
				field.assign(source);
				if (source) {
					if (!source.hasOwnProperty("minimum") && source.hasOwnProperty("min")) {
						field.setMinimum(source.min);
					}
					if (!source.hasOwnProperty("maximum") && source.hasOwnProperty("max")) {
						field.setMaximum(source.max);
					}
				}
			} finally {
				field._typeLock = false;
			}
			return field;
		}
		return field;
	};
	var _createFields = function (provider, source) {
		if (_isArray(source)) {
			var fields = [];
			for (var i = 0, cnt = source.length; i < cnt; i++) {
				var fld = _createField(provider, source[i]);
				fld && fields.push(fld);
			}
			return fields;
		}
		return null;
	};
	this.setDataFields = function (provider, source) {
		var flds = _createFields(provider, source);
		provider.setFields(flds);
	};
	this.addDataField = function(provider, source, resetFields, calculateData) {
		var fld = _createField(provider, source);
		if (!fld.fieldName()) {
			throw new Error("fieldName must be exists.");
		};
		if (provider.getFieldIndex(fld.fieldName()) >= 0) {
			throw new Error("fieldName is already exists: " + fld.fieldName());
		};
		fld = provider.addField(fld, resetFields, calculateData);
		return fld && $$_getFieldProxy(fld);
	};
	var _getItemProxy = function (item, extended) {
		return $$_getItemProxy(item, extended);
	};
	this.$_setMobile = function (value) {
		$$_setMobile(value);
	};
	this.$_isMobile = function () {
		return _isMobile();
	};
	this.toProxy = function (values) {
		if (_isArray(values)) {
			var proxies = [];
			for (var i = 0, cnt = values.length; i < cnt; i++) {
				var v = values[i];
				proxies.push(v instanceof Column ? $$_getColumnProxy(v) : v && v.proxy());
			}
			return proxies;
		} else if (values) {
			return values instanceof Column ? $$_getColumnProxy(values) : values.proxy();
		}
		return null;
	};
	this.setDataProviderHandler = function (handler) {
		new RealGridDataObserver(handler);
	};
	this.setGridHandler = function (handler) {
		new RealGridObserver(handler);
	};
	this.setTreeDataProviderHandler = function (handler) {
		new RealTreeDataObserver(handler);
	};
	this.setTreeHandler = function (handler) {
		new RealTreeObserver(handler);
	};
	this.ping = function (grid, message) {
		if (grid instanceof GridBase) {
			alert(message);
		}
	};
	this.refreshGrid = function (grid) {
		grid.refreshView();
	};
	this.getDataOptions = function (provider) {
		var options = provider.proxy();
		options.datetimeFormat = options.datetimeFormat || options.dateFormat; 
		delete options.dateFormat;
		return options;
	};
	this.setDataOptions = function (provider, options) {
		provider.assign(options);
		if (options.hasOwnProperty("datetimeFormat")) {
			provider.setDateFormat(options.datetimeFormat);
		}
	};
	this.getDataFields = function (provider) {
		var fields = provider.getFields();
		var flds = [];
		for (var i = 0; i < fields.length; i++) {
			var f = fields[i];
			flds.push(f.proxy())
			// flds.push({
			// 	fieldName: f.fieldName(),
			// 	orgFieldName: f.orgFieldName(),
			// 	dataType: f.dataType(),
			// 	length: f.length(),
			// 	defaultValue: f.defaultValue(),
			// 	baseField: f.baseField()
			// });
		}
		return flds;
	};
	this.getDataValues = function (provider, row) {
		if (provider instanceof LocalTreeDataProvider) {
			var r = provider.rowById(row);
			return r ? r.values() : null;
		} else {
			return provider.getRow(row);
		}
	};
	this.loadData = function (provider, type, data, options) {
		new DataLoader(provider).load(type, data, options);
	};
	this.getDataValue = function (provider, row, field) {
		if (typeof field == "string") {
			field = provider.getFieldIndex(field);
		}
		return provider.getValue(row, field);
	};
	this.setDataValue = function (provider, row, field, newValue) {
		if (typeof field == "string") {
			field = provider.getFieldIndex(field);
		}
		return provider.setValue(row, field, newValue);
	};
	this.initGrid = function (grid) {
		grid.displayOptions()._emptyMessage = "Load data...";
        grid._productName = 'RealGridJS v1.0';
	};
	this.resetSize = function (grid, callback) {
		grid.container().resetSize(callback);
	};
	this.resetShadowDom = function (grid) {
		grid._shadowDom && grid._shadowDom.reset();
	},
	this.setShadowDomOptions = function (grid, options) {
		grid._shadowDom && grid._shadowDom.assignOptions(options);
	},
	this.setOptions = function (grid, options) {
        options && grid.setOptions(options);
        /*
		if (options) {
			grid.setOptions(options);
			grid.displayOptions().assign(options.display);
			grid.editOptions().assign(_pick(options.editing, options.edit));
			grid.fixedOptions().assign(options.fixed);
			grid.selectOptions().assign(_pick(options.selecting, options.select, options.selection));
			grid.sortingOptions().assign(_pick(options.sorting, options.sort));
			grid.filteringOptions().assign(_pick(options.filtering, options.filter));
			grid.groupingOptions().assign(options.grouping);
			grid.copyOptions().assign(options.copy);
			grid.pasteOptions().assign(options.paste);
			grid.setBody(options.body);
			grid.setPanel(options.panel);
			grid.setIndicator(options.indicator);
			grid.setStateBar(options.stateBar);
			grid.setCheckBar(options.checkBar);
			grid.setEditBar(options.editBar);
			grid.setHeader(options.header);
			grid.setFooter(options.footer);
			grid.setRowGroup(options.rowGroup);
		}
         */
	};
	this.isVisible = function (grid) {
		return grid._container.isVisible();
	};
	this.setVisible = function (grid, value) {
		grid._container.setVisible(value);
	};
	this.mouseToIndex = function (grid, x, y) {
		var index = grid.pointToIndex(x, y, true);
		return index ? index.proxy() : CellIndex.nullProxy();
	};
	this.getCellBounds = function (grid, itemIndex, column, outer) {
		var col = this.$_getColumn(grid, column);
		var cell = CellIndex.temp(grid, itemIndex, col, outer);
		var bound = grid.getCellBounds(cell, outer);
		if (bound) {
			return {
				x: bound.x,
				y: bound.y,
				width: bound.width,
				height: bound.height
			};
		} else {
			return null;
		}
	};
	this.getColumns = function (grid) {
		var root = grid._rootColumn;
		var columns = [];
		for (var i = 0, cnt = root.count(); i < cnt; i++) {
			columns.push($$_getColumnGroupProxy(root.getItem(i)));
		}
		return columns;
	};
	this.$_getColumn = function (grid, column) {
		if (!grid) {
			if ($_debug) debugger;
		}
		if (typeof column === "string") {
			return grid.columnByName(column);
		} else if (column && column.$_hash) {
			return grid.columnByHash(column.$_hash);
		}
		return null;
	};
	this.getColumnProperty = function (grid, column, prop, extended) {
		var col = this.$_getColumn(grid, column);
		if (col && prop) {
			var v = prop == "styles" ? col.styles().toProxy(extended) : col.getProperty(prop);
            return v;
		}
		return undefined;
	};
	this.$_fireColumnPropertyChanged = function (grid, col, prop, value) {
		var fireEventProps = ["displayIndex","width","visible"];
		fireEventProps.indexOf(prop) >= 0 && grid._fireColumnPropertyChanged(col, prop, value);
	};
	this.setColumnProperty = function (grid, column, prop, value, refresh) {
		var col = this.$_getColumn(grid, column);
		if (col && prop) {
			var oldValue = col.getProperty(prop);
			col._ignoreRefresh = !refresh;
			try {
           		prop == "styles" ? col.styles().extend(value) : col.setProperty(prop, value);
           	} finally {
           		delete col._ignoreRefresh;
           	}
            oldValue !== col.getProperty(prop) && this.$_fireColumnPropertyChanged(grid, col ,prop ,col.getProperty(prop));
		}
	};
	this.setColumn = function (grid, value) {
		var col = this.$_getColumn(grid, value);
		if (col) {
			(value["editor"] || value.editorOptions == null) && (delete value.editorOptions);
			var keys = Object.keys(value);
			var key;
			var v = {};
			for (var i = 0, cnt = keys.length; i < cnt ; i++) {
				key = keys[i];
				if (col.getProperty(key) != undefined && col.getProperty(key) !== value[key]) {
					(v[key] = value[key]);
				}
			}
			col.assign(value);
			if (col instanceof DataColumn) {
				if (value.hasOwnProperty("values") || value.hasOwnProperty("labels")) {
					var obj = {};
					if (value.hasOwnProperty("values")) {
						obj.lookupValues = value.values;
					}
					if (value.hasOwnProperty("labels")) {
						obj.lookupLabels = value.labels;
					}
					col.assign(obj);
				}
			}
			for (key in v) {
				this.$_fireColumnPropertyChanged(grid, col, key ,v[key]);
			}
		}
	},
	this.fieldByName = function (provider, name) {
		var field = provider.fieldByName(name);
		return field && $$_getFieldProxy(field);
	};
	this.columnByName = function (grid, name) {
		var column = grid.columnByName(name);
		return column && $$_getColumnProxy(column);
	};
	this.columnByField = function (grid, fieldName) {
		var column = grid.columnByFieldName(fieldName);
		return column && $$_getColumnProxy(column);
	};
	this.columnsByField = function (grid, fieldName) {
		var columns = grid.columnsByFieldName(fieldName);
		if (columns) {
			var proxies = [];
			for (var i = 0, cnt = columns.length; i < cnt; i++) {
				proxies.push($$_getColumnProxy(columns[i]));
			}
			return proxies;
		}
		return null;
	};
	this.columnByTag = function (grid, tag) {
		var column = grid.columnByTag(tag);
		return column && $$_getColumnProxy(column);
	};
	this.columnsByTag = function (grid, tag) {
		var columns = grid.columnsByTag(tag);
		if (columns) {
			var proxies = [];
			for (var i = 0, cnt = columns.length; i < cnt; i++) {
				proxies.push($$_getColumnProxy(columns[i]));
			}
			return proxies;
		}
		return null;
	};
	this.getDisplayColumns = function (grid) {
		function getGroupLayout(group) {
			var groupLayout = {
				name: group.name(),
				orientation: group.orientation(),
				saveWidth: group.saveWidth(),
				columns: []
			};
			if (group.header && group.header()) {
				groupLayout.header = group.header().text();
			}
			for (var i = 0, cnt = group.visibleCount(); i < cnt; i++) {
				var c = group.getVisibleItem(i);
				if (c.isVisible()) {
					if (c instanceof ColumnGroup) {
						groupLayout.columns.push(getGroupLayout(c));
					} else if (c.name()) {
						groupLayout.columns.push(c.name());
					}
				}
			}
			return groupLayout;
		}
		var columnLayout = [];
		if (grid) {
			for (var i = 0, cnt = grid.visibleColumnCount(); i < cnt; i++) {
				var c = grid.getVisibleColumn(i);
				if (c.isVisible()) {
					if (c instanceof ColumnGroup) {
						columnLayout.push(getGroupLayout(c));
					} else if (c.name()) {
						columnLayout.push(c.name());
					}
				}
			}
		}
		return columnLayout;
	};
    this.getColumnGroupNames = function (grid) {
        var names = [];
        var groups = grid.collectGroups();
        if (groups) {
            for (var i = 0, cnt = groups.length; i < cnt; i++) {
                var group = groups[i];
                var name;
                if (group && (name = group.name())) {
                    names.push(name);
                }
            }
        }
        return names;
    };
    this.getChildColumnNames = function (grid, parent) {
    	var child;
    	var parentColumn = this.$_getColumn(grid, parent);
    	if (parentColumn && parentColumn instanceof ColumnGroup) {
    		child = [];
    		var columns = parentColumn.columns();
    		for (var i = 0, cnt = columns.length; i < cnt ; i++) {
    			child.push(columns[i].name());
    		}
    	};
    	return child;
    };
	this.saveColumnLayout = function (grid) {
		function getColumnLayout(column) {
			var layout = {
				name: column.name(),
				saveWidth: column.saveWidth() ? column.saveWidth() : column.width(),
				width:column.width(),
				visible: column.isVisible()
			};
			var header = column.header && column.header();
			if (header && header.fixedHeight() > 0) {
				layout.header = {fixedHeight: header.fixedHeight()}
			};
			return layout;
		}
		function getGroupLayout(group) {
			var groupLayout = {
				type:"group",
				name: group.name(),
				orientation: group.orientation(),
				saveWidth: group.saveWidth() ? group.saveWidth() : group.width(),
				width:group.width(),
				visible: group.isVisible(),
				hideChildHeaders: group.isHideChildHeaders(),
				columns: []
			};
			var header = group.header && group.header();
			var v;
			if (header) {
				groupLayout.header = {text: header.text(), visible: header.isVisible()};
				if ((v = header.fixedHeight()) > 0) {
					groupLayout.header.fixedHeight = v;
				}
			}
			var cols = group._columns._orderedColumns;
			for (var i = 0, cnt = cols.length; i < cnt; i++) {
				var c = cols[i];
				if (c instanceof ColumnGroup) {
					groupLayout.columns.push(getGroupLayout(c));
				} else if (c.name) {
					groupLayout.columns.push(getColumnLayout(c));
				}
			}
			return groupLayout;
		}
		if (!grid) {
			return;
		}

		var orgColumn = grid.getOrderedColumns();
		var columnLayout = [];

		for (var i = 0, cnt = orgColumn.length; i < cnt; i++) {
			var c = orgColumn[i];
			if (c instanceof ColumnGroup) {
				columnLayout.push(getGroupLayout(c));
			} else if (c.name) {
				columnLayout.push(getColumnLayout(c));
			}
		}

		return columnLayout;
	};
	this.fitColumnWidth = function (grid, column, maxWidth, minWidth, visibleOnly) {
		var lm = grid.layoutManager();
		if (!column) {
			for (var i = grid.visibleColumnCount(); i--;) {
				column = grid.getVisibleColumn(i);
				maxWidth = !isNaN(maxWidth = parseInt(maxWidth)) && maxWidth > Column.MIN_WIDTH ? maxWidth : column.maxWidth() > Column.MIN_WIDTH ? column.maxWidth() : -1;
				minWidth = !isNaN(minWidth = parseInt(minWidth)) && minWidth > Column.MIN_WIDTH ? minWidth : column.minWidth() >= Column.MIN_WIDTH ? column.minWidth() : -1;
				lm.fitColumnWidth(grid.getVisibleColumn(i), visibleOnly, minWidth, maxWidth);
			}
		} else {
			column = this.$_getColumn(grid, column);
			maxWidth = !isNaN(maxWidth = parseInt(maxWidth)) && maxWidth > Column.MIN_WIDTH ? maxWidth : column.maxWidth() > Column.MIN_WIDTH ? column.maxWidth() : -1;
			minWidth = !isNaN(minWidth = parseInt(minWidth)) && minWidth > Column.MIN_WIDTH ? minWidth : column.minWidth() >= Column.MIN_WIDTH ? column.minWidth() : -1;
			column && lm.fitColumnWidth(column, visibleOnly, minWidth, maxWidth);
		}
	};
	this.fitRowHeight = function(grid, itemIndex, maxHeight, textOnly, refresh) {
		var lm = grid.layoutManager();
		if (itemIndex >= 0) {
			lm.fitRowHeight(itemIndex, maxHeight, textOnly, refresh);
		}
	};
	this.fitRowHeightAll = function(grid, maxHeight, textOnly) {
		var lm = grid.layoutManager();
		return lm.fitRowHeightAll(maxHeight, textOnly);
	};
	this.setRowHeight = function (grid, itemIndex, height, refresh) {
		var lm = grid.layoutManager();
		if (itemIndex >= 0) {
			lm.setRowHeight(itemIndex, height, refresh);
		}
	};
	this.getRowHeight = function (grid, itemIndex) {
		var lm = grid.layoutManager();
		return lm.getRowHeight(itemIndex);
	},
	this.clearRowHeights = function (grid, refresh) {
		var lm = grid.layoutManager();
		lm.clearRowHeights(refresh);
	}
	this.getGroupLevel = function (grid, field) {
		var fld = Number(field);
		if (isNaN(fld)) {
			fld = grid.dataSource().getFieldIndex(field);
		}
		return fld >= 0 ? grid.getGroupLevel(fld) : -1;
	};
	this.getDataRow = function (grid, itemIndex) {
		var item = grid.getItem(itemIndex);
		return item ? item.dataRow() : -1;
	};
	this.getRowsOfItems = function (grid, items) {
		var rows = [];
		if (items) {
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				var item = grid.getItem(items[i]);
				item && rows.push(item.dataRow());
			}
		}
		return rows;
	};
	this.setValues = function (grid, itemIndex, values, strict) {
		var item = grid.getItem(itemIndex);
		var ds = item.dataSource();
		if (item && ds) {
			var i, fld, row;
			var cnt = ds.fieldCount();
			var diff = false;
			var oldValues;
			if (grid.isItemEditing(item)) {
				var editItem = _cast(item, EditItem);
				if (editItem) {
					editItem.setValues(values);
				} else {
					for (i = 0; i < cnt; i++) {
						fld = ds.getOrgFieldName(i);
						if (values.hasOwnProperty(fld)) {
							item.setData(i, values[fld]);
						}
					}
				}
			} else if ((row = item.dataRow()) >= 0) {
				if (ds instanceof TreeDataProvider) {
					var r = ds.rowById(row);
					if (r) {
						diff = false;
						oldValues = r.values() ? r.values() : [];
						if (_isArray(values)) {
							for (i=0;i<values.length;i++) {
								if (diff = !ds.getField(i).equalValues(oldValues[i],values[i])) {
									break;
								}
							}
						} else {
							for (i=0;i < cnt;i++){
								fld = ds.getOrgFieldName(i);
								if (values.hasOwnProperty(fld)) {
									if (diff = !ds.getField(i).equalValues(oldValues[i],values[fld])) {										
										break;
									}
								}
							}
						}
						if (!diff) {
							return;
						}
						strict ? r.updateStrict(values) : r.update(values);
					}
				} else {
					/* grid.setValue의 경우 checkDiff와 strictDiff의 영향을 받지 않는다. setValues도 영향을 받지 않도록 한다. */
					diff = false;
					oldValues = ds._values[row] ? ds._values[row] : [];
					if (_isArray(values)) {
						for (i=0;i<values.length;i++) {
							if (diff = !ds.getField(i).equalValues(oldValues[i],values[i])) {
								break;
							}
						}
					} else {
						for (i=0;i < cnt;i++){
							fld = ds.getOrgFieldName(i);
							if (values.hasOwnProperty(fld)) {
								if (diff = !ds.getField(i).equalValues(oldValues[i],values[fld])) {										
									break;
								}
							}
						}
					}
					if (!diff) {
						return;
					}
					strict ? ds.updateStrictRow(row, values) : ds.updateRow(row, values);
				}
			}
		}
	};
	this.getValues = function (grid, itemIndex) {
		var item = grid.getItem(itemIndex);
		if (item) {
			var row;
			if (grid.isItemEditing(item)) {
				row = item.getRowObject();
				row["__rowId"] = item.dataRow();
				return row;
			} else {
				if (item.dataRow() >= 0) {
					var ds = item.dataSource();
					if (ds) {
						var vals = ds.getRowObject(item.dataRow());
						row = { __rowId: item.dataRow() };
						for (var fld in vals) {
							row[fld] = vals[fld];
						}
						return row;
					}
				}
			}
		}
		return null;
	};
	this.getDisplayValuesOfRow = function(grid, dataRow, applyStyle) {
		var row = grid.dataSource().getRowObject(dataRow);
		var item = grid.getItemOfRow(dataRow, true);
		return this.getDisplayValues(grid, row, undefined, applyStyle, item);
	}
	this.getDisplayValues = function (grid, row, itemIndex, applyStyle, item) {
		var ret = row ? _clone(row) : {};
		if (row) {
			var body = grid.body();
			var columns = grid.getLeafColumns();
			for (var i = 0, cnt = columns.length; i < cnt; i++) {
				var column = columns[i];
				var valueType = column.valueType();
				var field = column.getField();
				var styles = column.styles();

				var numberFormatter = applyStyle && styles.numberFormat() && new DecimalFormatter(styles.numberFormat());
				var datetimeWriter = applyStyle && styles.datetimeFormat() && new DateTimeWriter(styles.datetimeFormat());
				var booleanFormatter = applyStyle && styles.booleanFormat() && new BooleanFormatter(styles.booleanFormat());
				var prefix = applyStyle && styles.prefix();
				var suffix = applyStyle && styles.suffix();

				var value = row[field.orgFieldName()];
				var s = null;
				if (valueType == ValueType.NUMBER) {
					var v = Number(value);
					if (isNaN(v)) {
						s = column.nanText();
					} else if (v ==0 && column.zeroText() != null) {
						s = column.zeroText();
					} else if (numberFormatter) {
						s = numberFormatter.format(v);
					}
				} else if (valueType == ValueType.DATETIME && value instanceof Date) {
					s = datetimeWriter ? datetimeWriter.getText(value) : DateTimeWriter.Default.getText(value);
				} else if (valueType == ValueType.BOOLEAN && booleanFormatter) {
					s = booleanFormatter.formatValue(value);
				}
				if (!s) {
					if (itemIndex === undefined) {
						s = DataCell._displayText(item, column);
					} else {
						var index = CellIndex.temp(grid, itemIndex, column);
						var cell = body.getCell(index);
						s = cell.displayText();
					}
				}
				if (s != null) {
					if (prefix)
						s = prefix + s;
					if (suffix)
						s = s + suffix;
				}
				ret[field.orgFieldName()] = s;
			}
		}
		return ret;
	};
	this.getSelectionItem = function (grid, item) {
		if (item) {
			var range = item.getBounds();
			var item1 = grid.getItem(range.R1());
			var item2 = grid.getItem(range.R2());
			return {
				style: item.style(),
				startItem: range.R1(),
				startRow: item1 ? item1.dataRow() : -1,
				startColumn: range.C1().name(),
				endItem: range.R2(),
				endRow: item2 ? item2.dataRow() : -1,
				endColumn: range.C2().name()
			}
		}
		return null;
	};
	this.getSelectionItems = function (grid, item) {
		if (item) {
			var range = item.getBounds();
			var item1 = grid.getItem(range.R1());
			var item2 = grid.getItem(range.R2());
			var i = item1.index();
			var i2 = item2.index();
			var items = [];
			for (; i <= i2; i++) {
				items.push(i);
			}
			return items;
		}
		return null;
	};
	this.getSelectionRows = function (grid, item) {
		if (item) {
			var range = item.getBounds();
			var item1 = grid.getItem(range.R1());
			var item2 = grid.getItem(range.R2());
			var i = item1.index();
			var i2 = item2.index();
			var rows = [];
			var r;
			for (; i <= i2; i++) {
				item1 = grid.getItem(i);
				(r = item1.dataRow()) >= 0 && rows.push(r);
			}
			return rows;
		}
		return null;
	};
	this.getSelectionData = function (grid, maxRows) {
		if (grid.selections().count() > 0) {
			var item = grid.selections().getItem(0);
			var data = item.getData(maxRows);
			return data;
		}
		return null;
	};
	this.setSelectionItem = function (grid, item) {
		if (item.hasOwnProperty("style")) {
			var style = item.style;
			var startItem = 0;
			if (item.hasOwnProperty("startItem")) {
				startItem = item.startItem;
			} else if (item.hasOwnProperty("startRow")) {
				startItem = grid.getItemIndexOfRow(item.startRow);
			} else if (style != 'singleColumn' && style != 'columns') {
				return;
			}
			var startCell = new CellIndex(grid, startItem, grid.columnByName(item.startColumn));
			var endItem = 0;
			if (item.hasOwnProperty("endItem")) {
				endItem = item.endItem;
			} else if (item.hasOwnProperty("endRow")) {
				endItem = grid.getItemIndexOfRow(item.endRow);
			} else if (style != 'singleColumn' && style != 'columns') {
				return;
			}
			var endCell = new CellIndex(grid, endItem, grid.columnByName(item.endColumn));
			grid.setFocusedIndex(startCell, true);
			grid.selections().clear();
			grid.selections().add(startCell, endCell, style);
		}
	};
	this.resetCheckables = function (grid, clearExpr) {
		grid.resetCheckables();
		if (clearExpr) {
			grid.setCheckBar({
				checkableExpression: null
			});
		}
	};
	this.setCheckableExpression = function (grid, expression, apply) {
		grid.setCheckBar({
			checkableExpression: expression
		});
		apply && grid.applyCheckables();
	};
	this.createColumns = function (columns) {
		return GridBase.createColumns(columns);
	};
    this.orderBy = function (grid, fieldNames, sortDirs, textCases) {
        if (fieldNames) {
            var dirs = [];
            if (sortDirs) {
                for (var i = 0; i < sortDirs.length; i++) {
                    dirs.push(sortDirs[i]);
                }
            }
            grid.orderByFields(fieldNames, dirs, textCases);
        }
    };
    this.setColumnFilters = function (grid, column, filters) {
        var col = this.$_getColumn(grid, column);
        col && col.setFilters(filters);
    };
    this.clearColumnFilters = function (grid, column) {
        var col = this.$_getColumn(grid, column);
        col && col.clearFilters();
    };
    this.addColumnFilters = function (grid, column, filters, overwrite) {
        var col = this.$_getColumn(grid, column);
        col && col.addFilters(filters, overwrite);
    };
    this.removeColumnFilters = function (grid, column, filterNames) {
        var col = this.$_getColumn(grid, column);
        col && col.removeFilters(filterNames);
    };
    this.activateColumnFilters = function (grid, column, filterNames, active) {
        var col = this.$_getColumn(grid, column);
        col && col.activateFilters(filterNames, active);
    };
    this.activateAllColumnFilters = function (grid, column, active) {
        var col = this.$_getColumn(grid, column);
        col && col.activateAllFilters(active);
    };
    this.hideColumnFilters = function(grid, column, filterNames, hide) {
    	var col = this.$_getColumn(grid, column);
    	col && col.hideColumnFilters(filterNames, hide);
    };
    this.hideAllColumnFilters = function (grid, column, hide) {
    	var col = this.$_getColumn(grid, column);
    	col && col.hideAllColumnFilters(hide);
    };
    this.toggleColumnFilters = function (grid, column, filterNames) {
        var col = this.$_getColumn(grid, column);
        col && col.toggleFilters(filterNames);
    };
    this.toggleAllColumnFilters = function (grid, column) {
        var col = this.$_getColumn(grid, column);
        col && col.toggleAllFilters();
    };
    this.getColumnFilter = function (grid, column, filterName) {
        var col = this.$_getColumn(grid, column);
        var filter = col && col.getFilter(filterName);
        return filter && filter.proxy();
    };
    this.getColumnFilters = function (grid, column) {
        var col = this.$_getColumn(grid, column);
        return col && this.toProxy(col.getFilters());
    };
    this.getActiveColumnFilters = function (grid, column, active) {
        var col = this.$_getColumn(grid, column);
        return col && this.toProxy(col.getActiveFilters(active));
    };
    this.setFilterActions = function (grid, column, actions) {
        var col = this.$_getColumn(grid, column);
        if (col && actions) {
            col.setFilterActions(actions);
        }
    };
    this.isFiltered = function(grid, column) {
        var col = column && this.$_getColumn(grid, column);
        if (column && !col) {return};
    	return !!grid.isFiltered(col);
    };
    this.clearFilterActions = function (grid, column) {
        var col = this.$_getColumn(grid, column);
        if (col) {
            col.setFilterActions(null);
        }
    };
    this._getParentGroupItem = function(grid, model) {
    	var groupList = grid.getGroupList && grid.getGroupList();
    	if (groupList && groupList[model.parentId]) {
    		return groupList[model.parentId];
    	}
    	return null;
    };
    // rowGroup에서 header가 보이지 않을때 header Model을 이용해서 item을 찾을수 없는 현상 때문에.
    // 해당 group Header의 item을 찾기위해 사용해 보자.
    this._getGroupItem = function(grid, model) {
    	if (grid instanceof TreeView) {
    		return grid.getItem(model.itemIndex);
    	}
    	var item;
    	if (model.itemIndex >= 0) {
    		item = grid.getItem(model.itemIndex);
    		return item instanceof EditItem ? null : item;
    	} else {
	    	var groupList = grid.getGroupList();
    		if (groupList[model.id]) {
    			return groupList[model.id];
    		}
    	}
    	return null;
    };
	this.getGroupIndex = function (grid, itemIndex) {
		var item = grid.getItem(itemIndex);
		if (item) {
			var group = item.parent();
			return group ? group.index() : -1;
		}
		return -1;
	};
	this.isGroupItem = function (grid, itemIndex) {
		var item = grid.getItem(itemIndex);
		return item && item instanceof GroupItem;
	};
    this.isParentVisible = function (grid, itemIndex) {
        var item = grid.getItem(itemIndex);
        return item && item.parent() && item.parent().isVisible();
    };
	this.expandGroup = function (grid, itemIndex, recursive, force) {
		var group = grid.getItem(itemIndex);
		if (group instanceof GroupItem) {
			group && grid.expand(group, recursive, force);
		}
	};
	this.collapseGroup = function (grid, itemIndex, recursive) {
		var group = grid.getItem(itemIndex);
		if (group instanceof GroupItem) {
			group && grid.collapse(group, recursive);
        }
	};
    this.expandParent = function (grid, itemIndex, recursive, force) {
        var group = grid.getItem(itemIndex);
        if (group) {
            var p = group.parent();
            if (p && p.isExpandable() && (p.isCollapsed() || force)) {
                grid.expand(p, recursive, force);
                var idx = grid.focusedIndex();
                idx.setItemIndex(p.isVisible() ? p.index() : p.firstVisibleItem().index());
                grid.setFocusedIndex(idx);
                grid.makeCellVisible(idx);
            }
        }
    };
    this.collapseParent = function (grid, itemIndex, recursive) {
        var group = grid.getItem(itemIndex);
        if (group) {
            var p = group.parent();
            group instanceof MergedGroupFooter && p instanceof MergedGroupHeader && !p.isExpanded() && (p = p.parent());
            if (p && p.isCollapsable() && p.isExpanded()) {
                grid.collapse(p, recursive);
                var idx = grid.focusedIndex();
                idx.setItemIndex(p.isVisible() ? p.index() : p.firstVisibleItem().index());
                grid.setFocusedIndex(idx);
                grid.makeCellVisible(idx);
            }
        }
    };
    this.expandAll = function(grid, level) {
    	var childs = grid._items._groupedProvider && grid._items._groupedProvider._rootItem && grid._items._groupedProvider._rootItem._children;
    	var i, cnt = childs.length, child;
    	for (i = 0; i < cnt ; i++) {
    		child = childs[i];
    		(child instanceof GroupItemImpl || child instanceof MergedGroupHeader) && grid.expand(child, true, false, level);
    	}
    };
    this.collapseAll = function(grid, recursive) {
    	var childs = grid._items._groupedProvider && grid._items._groupedProvider._rootItem && grid._items._groupedProvider._rootItem._children;
    	var i, cnt = childs.length, child;
    	for (i = 0; i < cnt ; i++) {
    		child = childs[i];
    		(child instanceof GroupItemImpl || child instanceof MergedGroupHeader) && grid.collapse(child, recursive, true);
    	}
    };
	this.getModel = function (grid, itemIndex, extended) {
		var item = grid.getItem(itemIndex);
		return item ? _getItemProxy(item, extended) : null;
	};
	this.getModelAs = function (grid, itemIndex, itemType, extended) {
		var item = grid.getItem(itemIndex);
		switch (itemType) {
			case "row":
				item = _cast(item, GridRow);
				break;
			case "group":
				item = _cast(item, GroupItem);
				break;
			case "footer":
				item = _cast(item, GroupFooter);
				break;
			case "tree":
				item = _cast(item, TreeItem);
				break;
		}
		return item ? _getItemProxy(item, extended) : null;
	};
    this.getGroupModel = function (grid, itemIndex, extended) {
        var item = grid.getItem(itemIndex);
        if (item && !(item instanceof GroupItem)) {
            item = item.parent();
        }
        return item ? _getItemProxy(item, extended) : null;
    };
	this.getParentModel = function (grid, model, extended) {
		if (model) {
			var item = this._getGroupItem(grid, model), group;
			if (item) {
				var group = item.parent();
				if (group && !isNaN(group.id())) {
					return _getItemProxy(group, extended);
				} 
			} else {
				group = this._getParentGroupItem(grid, model);
				if (group && !isNaN(group.id())) {
					return _getItemProxy(group, extended);
				}
			}
		}
		return null;
	};
	this.getRootModel = function (grid, model, extended) {
		if (model) {
			var item = grid.getItem(model.itemIndex);
			if (item) {
				var root = item.root();
				if (root) {
					return _getItemProxy(root, extended);
				}
			}
		}
		return null;
	};
	this.getChildModels = function (grid, model, extended) {
		if (model) {
			var group = grid.getItem(model.itemIndex);
            if (!(group instanceof GroupItem) && model.$_child >= 0) {
                var item = grid.getItem(model.$_child);
                if (item) {
                    group = item instanceof EditItem ? null : item.parent();
                }
            };
            if (!(group instanceof GroupItem)) {
				var groupProvider = grid.itemSource && grid.itemSource().source && grid.itemSource().source();
				group = groupProvider ? groupProvider._groupList[model.id] : null;
            }
			if (group instanceof GroupItem) {
				var cnt = group.count();
				var items = [];
				for (var i = 0; i < cnt; i++) {
					items.push(_getItemProxy(group.getItem(i), extended));
				}
				return items;
			}
		}
		return null;
	};
	this.getDescendantModels = function(grid, model, extended) {
		var group = model ? this._getGroupItem(grid, model) : grid._items && grid._items._groupedProvider && grid._items._groupedProvider._rootItem;
		if (group instanceof GroupItem) {
			var items = group.getDescendants(false);
			var ret = [], i ,cnt;
			if (items) {
				for (i=0, cnt = items.length; i < cnt ; i++) {
					ret.push(_getItemProxy(items[i], extended));
				}
				return ret;
			}
		}
		return null;
	};
	this.getChildModel = function (grid, model, index, extended) {
		if (model) {
			var group = grid.getItem(model.itemIndex);
            if (!(group instanceof GroupItem) && model.$_child >= 0) {
                var item = grid.getItem(model.$_child);
                if (item) {
                    group = item instanceof EditItem ? null : item.parent();
                }
            };
            if (!(group instanceof GroupItem)) {
				var groupProvider = grid.itemSource && grid.itemSource().source && grid.itemSource().source();
				group = groupProvider ? groupProvider._groupList[model.id] : null;
            }
			if (group instanceof GroupItem) {
				if (index >= 0 && index < group.count()) {
					return _getItemProxy(group.getItem(index), extended);
				}
			}
		}
		return null;
	};
	this.getModels = function (grid, itemIndices, extended) {
		if (itemIndices) {
			var models = [];
			for (var i = 0, cnt = itemIndices.length; i < cnt; i++) {
				var item = grid.getItem(itemIndices[i]);
				if (item) {
					models.push(_getItemProxy(item, extended));
				}
			}
			return models;
		}
		return null;
	};
	this.getModelOfRow = function (grid, dataRow, extended) {
		var item = grid.getItemOfRow(dataRow);
		return item ? _getItemProxy(item, extended) : null;
	};
	this.getModelsOfRows = function (grid, dataRows, extended) {
		if (dataRows) {
			var models = [];
			for (var i = 0, cnt = dataRows.length; i < cnt; i++) {
				var item = grid.getItemOfRow(dataRows[i]);
				if (item) {
					models.push(_getItemProxy(item, extended));
				}
			}
			return models;
		}
		return null;
	};
	this.getGroupSummary = function (grid, model, field, statistical) {
		if (model) {
			var group = grid.getItem(model.itemIndex);
			if (!group) {
				var groupProvider = grid.itemSource && grid.itemSource().source && grid.itemSource().source();
				group = groupProvider ? groupProvider._groupList[model.id] : null;
			}
			var fld = isNaN(field) ? grid.dataSource().getFieldIndex(field) : field;
			if (group instanceof GroupItem && fld >= 0) {
				var summary = {
					count: group.getNumber(fld),
					sum: group.getSum(fld),
					max: group.getMax(fld),
					min: group.getMin(fld),
					avg: group.getAvg(fld),
					datacount: group.getDataCount(fld),
					dataavg: group.getDataAvg(fld)
				};
				if (statistical) {
					summary["var"] = group.getVar(fld, 1);
					summary["varp"] = group.getVar(fld, 0);
					summary["stdev"] = group.getStdev(fld, 1);
					summary["stdevp"] = group.getStdev(fld, 0);
				}
				return summary;
			}
		}
		return undefined;
	};
	this.expandModel = function (grid, model, recursive, force) {
		if (model) {
			var group = this._getGroupItem(grid, model);
			if (group instanceof GroupItem) {
				grid.expand(group, recursive, force);
			}
		}
	};
	this.collapseModel = function (grid, model, recursive) {
		if (model) {
			var group = this._getGroupItem(grid, model);
			if (group instanceof GroupItem) {
				grid.collapse(group, recursive);
			}
		}
	};
	this.getSortedFields = function (grid) {
		var cnt;
		var flds = grid.getSortFields();
		var dirs = grid.getSortDirections();
		if (flds && (cnt = flds.length) > 0) {
			var ds = grid.dataSource();
			var fields = [];
			for (var i = 0; i < cnt; i++) {
				fields.push({
					fieldName: ds.getFieldName(flds[i]),
					orgFieldName: ds.getOrgFieldName(flds[i]),
					direction: dirs[i]
				})
			}
			return fields;
		}
		return null;
	};
	this.getGroupFieldNames = function (grid, orgName) {
		var flds = grid.getGroupByFields();
		if (flds) {
			var ds = grid.dataSource();
			if (ds) {
				var names = [];
				for (var i = 0; i < flds.length; i++) {
					names.push(orgName ? ds.getOrgFieldName(flds[i]) : ds.getFieldName(flds[i]));
				}
				return names;
			} else {
				return flds;
			}
		}
		return null;
	},
	this.getStyles = function (grid, region, all) {
		var styles = grid.getStylesOf(region);
		var stylesObj = {};
		region === "all" ? (stylesObj = styles) : styles ? (stylesObj[region] = styles) : (stylesObj = null);
		if (stylesObj) {
			var ret = {};
			var names = VisualStyles.STYLE_NAMES;
			for (var area in stylesObj) {
				ret[area] = {};
				for (var p in names) {
					var check = all || stylesObj[area].hasValue(names[p]);
					if (check) {
						var v = stylesObj[area][p]();
						ret[area][p] = v && v.toText ? v.toText() : v;
					}
				}
				if (area === "body") {
					(all || grid.body().dynamicStyles().count() > 0 ) && (ret[area]['dynamicStyles'] = grid.body().dynamicStyles().proxy());
					(all || grid.body().cellDynamicStyles().count() > 0 ) && (ret[area]['cellDynamicStyles'] = grid.body().cellDynamicStyles().proxy());
				}
				Object.keys(ret[area]).length <= 0 && (delete ret[area]);
			}
			return region == "all" ? ret : ret[region];
		}
		return null;
	};
	this.hasCellStyle = function (grid, id) {
		return Boolean(grid.dataCellStyles().get(id));
	};
	this.addCellStyle = function (grid, id, style, overwrite) {
		if (overwrite) {
			grid.dataCellStyles().set(id, style);
		} else {
			grid.dataCellStyles().add(id, style);
		}
	};
	this.addCellStyles = function (grid, styles, overwrite) {
		if (_isArray(styles)) {
			for (var i = 0, cnt = styles.length; i < cnt; i++) {
				var s = styles[i];
				if (s && s.id) {
					if (overwrite) {
						grid.dataCellStyles().set(s.id, s);
					} else {
						grid.dataCellStyles().add(s.id, s);
					}
				}
			}
		} else if (styles && styles.id) {
			if (overwrite) {
				grid.dataCellStyles().set(styles.id, styles);
			} else {
				grid.dataCellStyles().add(styles.id, styles);
			}
		}
	};
	this.removeCellStyles = function (grid, styleIds) {
		if (_isArray(styleIds)) {
			for (var i = styleIds.length; i--;) {
				grid.dataCellStyles().set(styleIds[i], null);
			}
		} else if (styleIds) {
			grid.dataCellStyles().set(styleIds, null);
		}
	};
	this.removeAllCellStyles = function (grid) {
		grid.dataCellStyles().clear();
	};
	this.getCellApplyStyles = function (grid, itemIndex, column) {
		var col = this.$_getColumn(grid, column);
		var item = grid.getItem(itemIndex);
		var cs;
		if (!col || !item) {
			return null;
		}
		var index = CellIndex.temp(grid, itemIndex, col);
		var styles;
		if (item instanceof GridRow) {
			var lm = grid.layoutManager();
			var room = lm.getMergedCell(index);
			var cell = grid.body().getCell(index, !!room, item);
			cs = grid.getDataCellStyle(index.dataRow(), col.dataIndex());
			styles = cell._styles;
		} else if (item instanceof GroupItemImpl) {
	        styles = grid.rowGroup().getHeaderCell(itemIndex)._styles;
		} else if (item instanceof GroupFooter) {
			styles = grid.rowGroup().getFooterCell(index)._styles;
		}
		var ret = styles ? styles.toProxy() : null;
		if (cs && cs._props) {
			for (var p in cs._props) {
				ret[p] = cs._props[p];
			}
		}
		return ret;
	};
	this.beginUpdateRow = function (grid, itemIndex) {
		var index = grid.focusedIndex().clone();
		var item = grid.getItem(itemIndex);
		item && index.itemIndex(item.index());
		grid.edit(index);
	};
	this.getEditingItem = function (grid) {
		var item = grid.getEditingItem();
		if (item) {
			var ds = item.dataSource();
			var obj = {};
			var values = item.values();
			if (values) {
				for (var i = ds.fieldCount(), j = values.length; i-- && j--;) {
					obj[ds.getOrgFieldName(i)] = values[i];
				}
			}
			return {
				itemIndex: item.index(),
				dataRow: item.dataRow(),
				values: obj
			};
		}
		return null;
	};
	this.getItemState = function (grid, itemIndex) {
		var item = grid.getItem(itemIndex);
		if (item) {
			var state = item.itemState();
			if (state == ItemState.NORMAL && grid.focusedIndex().I() == item.index()) {
				state = ItemState.FOCUSED;
			}
			return state;
		}
		return ItemState.NORMAL;
	};
	this.getCurrent = function (grid) {
		var index = grid.focusedIndex();
		return index ? index.proxy() : CellIndex.nullProxy();
	};
	this.setCurrent = function (grid, current, select) {
		grid.setCurrent(current, select);
	};
	this.resetCurrent = function (grid) {
		var index = grid.getIndex(0, grid.getFirstColumn());
		grid.setFocusedIndex(index);
		grid.makeCellVisible(grid.focusedIndex());
	};
    this.addPopupMenu = function (grid, name, menuItems) {
        return grid.popupMenuManager().addMenu(name, menuItems);
    };
	this.exportGrid = function (grid, options) {
		if (options.type == "html") {
			new GridHtmlExporter()["export"](grid, options);
		} else if (options.type === "csv") {
			new GridCsvExporter()["export"](grid, options);
		} else {
			// new GridExcelExporter()["export"](grid, options);
			options["exportGrids"] = [{"grid":grid}];
			$_exportGrid(options)
		}
	};
	this.fullItemCount = function(grid) {
		var lm = grid.layoutManager();
		return lm.fullItemCount();
	};
	var _extractTreeRowIds = function (rows) {
		if (rows) {
			var cnt = rows.length;
			var ids = new Array(cnt);
			for (var i = 0; i  <cnt; i++) {
				ids[i] = rows[i].rowId();
			}
			return ids;
		}
		return null;
	};
	this.loadTreeData = function (provider, type, data, options) {
		new TreeDataLoader(provider).load(type, data, options);
	};
	this.getTreeChildCount = function (treeProvider, rowId) {
		if (rowId >= 0) {
			var row = treeProvider.rowById(rowId);
			return row ? row.count() : 0;
		} else {
			return treeProvider.getChildCount(null);
		}
	};
	this.getTreeChildren = function (treeProvider, rowId) {
		var rows = null;
		if (rowId >= 0) {
			var row = treeProvider.rowById(rowId);
			rows = row ? row.children() : 0;
		} else {
			rows = treeProvider.getRows(null);
		}
		return rows ? _extractTreeRowIds(rows) : null;
	};
	this.getTreeDescendantCount = function (treeProvider, rowId) {
		if (rowId >= 0) {
			var row = treeProvider.rowById(rowId);
			return row ? row.descendantCount() : 0;
		} else {
			return treeProvider.getDescendantCount(null);
		}
	};
	this.getTreeDescendants = function (treeProvider, rowId, maxLevel) {
		var row = null;
		if (rowId >= 0) {
			row = treeProvider.rowById(rowId);
		}
		return _extractTreeRowIds(treeProvider.getDescendants(row, maxLevel));
	};
	this.getTreeAncestors = function (treeProvider, rowId) {
		var row = treeProvider.rowById(rowId);
		return row ? _extractTreeRowIds(row.ancestors()) : null;
	};
	this.getTreeJsonRow = function (provider, rowId) {
		var row = provider.rowById(rowId);
		return row ? row.getObject() : null;
	};
	this.getTreeJsonRows = function (provider, rowId, recursive, childRowsProp, iconProp) {
		var row = (rowId === undefined || rowId < 0) ? provider.rootRow() : provider.rowById(rowId);
		return row ? row.getChildObjects(recursive, childRowsProp, iconProp) : null;
	};
	this.getTreeOutuputRow = function (provider, options, rowId, iconProp) {
		var row = (rowId === undefined || rowId < 0) ? provider.rootRow() : provider.rowById(rowId);
		return row ? row.getOutput(options, iconProp) : null;
	};
    this.getTreeOutputRows = function (provider, options, rowId, recursive, childRowsProp, iconProp) {
        var row = (rowId === undefined || rowId < 0) ? provider.rootRow() : provider.rowById(rowId);
        return row ? row.getChildOutputObjects(options, recursive, childRowsProp, iconProp) : null;
    };
	this.addTreeRow = function (provider, rowId, values, iconIndex, hasChildren) {
		var row = provider.rowById(rowId);
		var child = provider.createRow(values, iconIndex, hasChildren);
		var added = false;
		if (row) {
			added = row.addChild(child);
		} else {
			added = provider.rootRow().addChild(child);
		}
		return added ? child.rowId() : -1;
	};
	this.insertTreeRow = function (provider, rowId, index, values, iconIndex, hasChildren) {
		var row = provider.rowById(rowId);
		var child = provider.createRow(values, iconIndex, hasChildren);
		var added = false;
		if (row) {
			added = row.insertChild(index, child);
		} else {
			added = provider.rootRow().insertChild(index, child);
		}
		return added ? child.rowId() : -1;
	};
	this.removeTreeRow = function (provider, rowId) {
		var row = provider.rowById(rowId);
		if (row) {
			row.parent().removeChild(row);
		}
	};
	this.removeTreeRows = function (provider, rowIds) {
		if (rowIds && rowIds.length > 0) {
			var rows = [];
			for (var i = rowIds.length; i--;) {
				var row = provider.rowById(rowIds[i]);
				row && rows.push(row);
			}
			provider.removeRows(rows);
		}
	};
	this.updateTreeRow = function (provider, rowId, values) {
		var row = provider.rowById(rowId);
		if (row) {
			row.update(values);
		}
	};
	this.updateStrictTreeRow = function (provider, rowId, values) {
		var row = provider.rowById(rowId);
		if (row) {
			row.updateStrict(values);
		}
	};
	this.getTreeDataValue = function (provider, rowId, field) {
		if (typeof field == "string") {
			field = provider.getFieldIndex(field);
		}
		var row = provider.rowById(rowId);
		if (row) {
			return row.getValue(field);
		}
		return undefined;
	};
	this.setTreeDataValue = function (provider, rowId, field, newValue) {
		if (typeof field == "string") {
			field = provider.getFieldIndex(field);
		}
		var row = provider.rowById(rowId);
		if (row) {
			return row.setValue(field, newValue);
		}
	};
	this.moveRowSibling = function (provider, rowId, delta) {
		var row = provider.rowById(rowId);
		if (row) {
			provider.moveRowSibling(row, delta);
		}	
	};
	this.changeRowParent = function (provider, rowId, parentId, childIndex) {
		var row = provider.rowById(rowId);
		var parent = parentId < 0 ? provider.rootRow() : provider.rowById(parentId);
		if (row && parent) {
			provider.changeRowParent(row, parent, childIndex);
		}
	};
	this.getTreeOptions = function (tree) {
		return tree.treeOptions().proxy();
	};
	this.setTreeOptions = function (tree, options) {
		this.setOptions(tree, options);
		tree.treeOptions().assign(options);
	};
	this.getTreeParentIndex = function (tree, itemIndex) {
		var item = tree.getItem(itemIndex);
		return item ? item.parentIndex() : -1;
	};
	this.getTreeChildIndices = function (tree, itemIndex) {
		var item = tree.getItem(itemIndex);
		if (item) {
			var items = item.children();
			for (var i = 0, cnt = items.length; i < cnt; i++) {
				items[i] = items[i].index();
			}
			return items;
		}
		return null;
	};
	this.getTreeDescendantIndices = function (tree, itemIndex) {
		var item = tree.getItem(itemIndex);
		if (item) {
			var items = item.getDescendants(true);
			if (items && items.length > 0) {
				for (var i = items.length - 1; i >= 0; i--) {
					if (!(items[i] instanceof TreeItem)) {
						items.splice(i, 1);
					}
				}
				if (items.length > 0) {
					for (i = 0, cnt = items.length; i < cnt; i++) {
						items[i] = items[i].index();
					}
					return items;
				}
			}
		}
		return null;
	};
	this.getTreeAncestorIndices = function (tree, itemIndex, includeRoot) {
		var item = tree.getItem(itemIndex);
		if (item) {
			var items = item.getAncestors();
			if (items && items.length > 0) {
				var i, cnt;
				for (i = items.length - 1; i >= 0; i--) {
					if (!(items[i] instanceof TreeItem)) {
						items.splice(i, 1);
					}
				}
				if (!includeRoot && items.length > 0 && items[items.length - 1] instanceof RootTreeItem) {
					items.pop();
				}
				if (items.length > 0) {
					for (i = 0, cnt = items.length; i < cnt; i++) {
						items[i] = items[i].index();
					}
					return items;
				}
			}
		}
		return null;
	};
	this.expandTreeItem = function (tree, itemIndex, recursive, force) {
		var item = tree.getItem(itemIndex);
		item && tree.expand(item, recursive, force);
	};
	this.collapseTreeItem = function (tree, itemIndex, recursive) {
		var item = tree.getItem(itemIndex);
		item && tree.collapse(item, recursive);
	};
	this.checkTreeChildren = function (tree, itemIndex, checked, recursive, visibleOnly, checkableOnly, checkEvent) {
		var item = tree.getItem(itemIndex);
		item && tree.checkChildren(item, checked, recursive, visibleOnly, checkableOnly, checkEvent);
	};
	this.getTreeIconIndex = function (tree, rowId) {
		var row = tree.rowById(rowId);
		return row ? row.iconIndex() : -1;
	};
	this.setTreeIconIndex = function (tree, rowId, iconIndex) {
		var row = tree.rowById(rowId);
		row && row.setIconIndex(iconIndex);
	};
	this.getTreeParentId = function (tree, rowId) {
		var row = tree.rowById(rowId);
		if (row) {
			var p = row.parent();
			return p ? p.rowId() : -1;
		}
		return -1;
	};
	this.getTreeLevel = function (tree, rowId) {
		var row = tree.rowById(rowId);
		return row ? row.level() : 0;
	};
	this.getTreeValues = function (tree, itemIndex) {
		var item = tree.getItem(itemIndex);
		if (item instanceof TreeItem) {
			var row;
			if (tree.isItemEditing(item)) {
				row = item.getRowObject();
				row["__rowId"] = item.dataRow;
				return row;
			} else {
				var ds = item.dataSource();
				var treeRow = item.row();
				var values = treeRow.values();
				row = { __rowId: treeRow.rowId() };
				for (var i = 0, cnt = ds.fieldCount(); i < cnt; i++) {
					var fld = ds.getOrgFieldName(i);
					var v = values[i];
					row[fld] = v;
				}
				return row;
			}
		}
		return null;
	};
};
var DataObserverBase = defineClass("DataObserverBase", null, {
	init: function (handler) {
		this._super();
		this._handler = handler;
		this._handler._dp.addListener(this);
	}
});
var RealGridDataObserver = defineClass("RealGridDataObserver", DataObserverBase, {
	init: function (handler) {
		this._super(handler);
	},
	onDataProvderDisposed: function (provider) {
	},
	onDataProviderReset: function (provider) {
	},
	onDataProviderRefresh: function (provider) {
	},
	onDataProviderRefreshClient: function (provider) {
	},
	onDataProviderRowCountChanged: function (provider) {
		this._handler.onRowCountChanged && this._handler.onRowCountChanged(this._handler, provider.rowCount());
	},
	onDataProviderRowUpdating: function (provider, row, values) {
		return !this._handler.onRowUpdating || this._handler.onRowUpdating(this._handler, row);
	},
	onDataProviderRowUpdated: function (provider, row) {
		this._handler.onRowUpdated && this._handler.onRowUpdated(this._handler, row);
	},
	onDataProviderRowsUpdated: function (provider, row, count) {
		this._handler.onRowsUpdated && this._handler.onRowsUpdated(this._handler, row, count);
	},
	onDataProviderRowInserting: function (provider, row, values) {
		return !this._handler.onRowInserting || this._handler.onRowInserting(this._handler, row, values);
	},
	onDataProviderRowInserted: function (provider, row) {
		this._handler.onRowInserted && this._handler.onRowInserted(this._handler, row);
	},
	onDataProviderRowsInserted: function (provider, row, count) {
		this._handler.onRowsInserted && this._handler.onRowsInserted(this._handler, row, count);
	},
	onDataProviderRowRemoving: function (provider, row) {
		return !this._handler.onRowDeleting || this._handler.onRowDeleting(this._handler, row);
	},
	onDataProviderRowRemoved: function (provider, row) {
		this._handler.onRowDeleted && this._handler.onRowDeleted(this._handler, row);
	},
	onDataProviderRowsRemoving: function (provider, rows) {
		return true;
	},
	onDataProviderRowsRemoved: function (provider, rows) {
		this._handler.onRowsDeleted && this._handler.onRowsDeleted(this._handler, rows);
	},
	onDataProviderRowMoving: function (provider, row, newRow) {
		return !this._handler.onRowMoving || this._handler.onRowMoving(this._handler, row, newRow);
	},
	onDataProviderRowMoved: function (provider, row, newRow) {
		this._handler.onRowMoved && this._handler.onRowMoved(this._handler, row, newRow);
	},
	onDataProviderRowsMoving: function (provider, row, count, newRow) {
		return !this._handler.onRowsMoving || this._handler.onRowsMoving(this._handler, row, count, newRow);
	},
	onDataProviderRowsMoved: function (provider, row, count, newRow) {
		this._handler.onRowsMoved && this._handler.onRowsMoved(this._handler, row, count, newRow);
	},
	onDataProviderValueChanging: function (/*provider, row, field, value*/) {
		return true;
	},
	onDataProviderValueChanged: function (provider, row, field) {
		this._handler.onValueChanged && this._handler.onValueChanged(this._handler, row, field);
	},
	onDataProviderDataChanged: function(provider) {
		this._handler.onDataChanged && this._handler.onDataChanged(this._handler);
	},
	onDataProviderStateChanged: function (provider, row) {
		this._handler.onRowStateChanged && this._handler.onRowStateChanged(this._handler, row);
	},
	onDataProviderStatesChanged: function (provider, rows) {
		this._handler.onRowStatesChanged && this._handler.onRowStatesChanged(this._handler, rows);
	},
	onDataProviderStatesCleared: function (provider) {
		this._handler.onRowStatesCleared && this._handler.onRowStatesCleared(this._handler);
	},
	onDataProviderRestoreRows: function(provider, rows) {
		this._handler.onRestoreRows && this._handler.onRestoreRows(this._handler, rows);
	},
	getHandler: function() {
		return this._handler;
	}
});
var RealTreeDataObserver = defineClass("RealTreeDataObserver", LocalTreeDataProviderObserver, {
	init: function (handler) {
		this._super();
		this._handler = handler;
		this._handler._dp.addListener(this);
	},
	onTreeDataProvderDisposed: function (provider) {
	},
	onTreeDataProviderReset: function (provider) {
	},
	onTreeDataProviderRefresh: function (provider) {
	},
	onTreeDataProviderRefreshClient: function (provider) {
	},
	onTreeDataProviderRowCountChanged: function (provider) {
		this._handler.onRowCountChanged && this._handler.onRowCountChanged(this._handler, provider.rowCount());
	},
	onTreeDataProviderCleared: function (provider) {
	},
	onTreeDataProviderRowAdding: function (provider, row, index, child) {
		return !this._handler.onRowAdding || this._handler.onRowAdding(this._handler, row.rowId(), index, child._values);
	},
	onTreeDataProviderRowAdded: function (provider, row) {
		this._handler.onRowAdded && this._handler.onRowAdded(this._handler, row.rowId());
	},
	onTreeDataProviderRowsAdded: function (provider, parent, rows) {
		this._handler.onRowsAdded && this._handler.onRowsAdded(this._handler, parent.rowId(), $$_getTreeRowIds);
	},
	onTreeDataProviderRowRemoving: function (provider, row) {
		return !this._handler.onRowDeleting || this._handler.onRowDeleting(this._handler, row.rowId());
	},
	onTreeDataProviderRowRemoved: function (provider, row) {
		this._handler.onRowDeleted && this._handler.onRowDeleted(this._handler, row.rowId());
	},
	onTreeDataProviderRowsRemoving: function (provider, rows) {
		return !this._handler.onRowsDeleting || this._handler.onRowsDeleting(this._handler, $$_getTreeRowIds(rows));
	},
	onTreeDataProviderRowsRemoved: function (provider, rows) {
		this._handler.onRowsDeleted && this._handler.onRowsDeleted(this._handler, $$_getTreeRowIds(rows));
	},
	onTreeDataProviderRowUpdating: function (provider, row) {
		return !this._handler.onRowUpdating || this._handler.onRowUpdating(this._handler, row.rowId());
	},
	onTreeDataProviderRowUpdated: function (provider, row) {
		this._handler.onRowUpdated && this._handler.onRowUpdated(this._handler, row.rowId());
	},
	onTreeDataProviderValueChanging: function (provider, row, field, newValue) {
		return true;
	},
	onTreeDataProviderValueChanged: function (provider, row, field) {
		this._handler.onValueChanged && this._handler.onValueChanged(this._handler, row.rowId(), field);
	},
	onTreeDataProviderIconIndexChanged: function (provider, row) {
	},
	onTreeDataProviderHasChildrenChanged: function (provider, row) {
	},
	onTreeDataProviderRowStateChanged: function (provider, row) {
		this._handler.onRowStateChanged && this._handler.onRowStateChanged(this._handler, row.rowId());
	},
	onTreeDataProviderRowStatesChanged: function (provider, rows) {
		this._handler.onRowStatesChanged && this._handler.onRowStatesChanged(this._handler, $$_getTreeRowIds(rows));
	},
	onTreeDataProviderRowSiblingMoving: function (provider, row, delta) {
		return !this._handler.onRowSiblingMoving || this._handler.onRowSiblingMoving(this._handler, row.rowId(), delta);
	},
	onTreeDataProviderRowSiblingMoved: function (provider, row, delta) {
		this._handler.onRowSiblingMoved && this._handler.onRowSiblingMoved(this._handler, row.rowId(), delta);
	}, 
	onTreeDataProviderRowParentChanging: function (provider, row, parent, childIndex) {
		return !this._handler.onRowParentChanging || this._handler.onRowParentChanging(this._handler, row.rowId(), parent.rowId(), childIndex);
	}, 
	onTreeDataProviderRowParentChanged: function (provider, row, parent, childIndex) {
		this._handler.onRowParentChanged && this._handler.onRowParentChanged(this._handler, row.rowId(), parent.rowId(), childIndex);
	},
	getHandler: function() {
		return this._handler;
	}
});
var RealGridObserverBase = defineClass("RealGridObserverBase", null, {
	init: function (handler) {
		this._super();
		this._handler = handler;
		this._handler._gv.addListener(this);
	},
	onGridBaseCurrentChanging: function (grid, oldIndex, newIndex) {
		return !this._handler.onCurrentChanging || this._handler.onCurrentChanging(this._handler, oldIndex.proxy(), newIndex.proxy());
	},
	onGridBaseCurrentChanged: function (grid, newIndex) {
		this._handler.onCurrentChanged && this._handler.onCurrentChanged(this._handler, newIndex.proxy());
	},
	onGridBaseCurrentRowChanged: function (grid, oldRow, newRow) {
		this._handler.onCurrentRowChanged && this._handler.onCurrentRowChanged(this._handler, oldRow, newRow);
	},
	onGridBaseValidateCell: function (grid, index, inserting, value) {
		if (this._handler.onValidateColumn) {
			var itemIndex = index.itemIndex();
			var dataRow = index.item() && index.item().dataRow();
			var err = this._handler.onValidateColumn(this._handler, $$_getColumnProxy(index.column()), inserting, value, itemIndex, dataRow);
			if (err && err.level && err.message) {
				throw new ValidationError(err.level, err.message, index.column && index.column(), err.message);
			} else if (typeof err == "string" || typeof err == "number") {
				throw new ValidationError(ValidationLevel.ERROR, err, index.column && index.column(), err);
			}
		}
	},
	onGridBaseValidateRow: function (grid, item, inserting, values) {
		if (this._handler.onValidateRow) {
			var err = this._handler.onValidateRow(this._handler, item.index(), item.dataRow(), inserting, values);
			if (err && err.level && err.message) {
				throw new ValidationError(err.level, err.message, null, err.message);
			} else if (typeof err == "string" || typeof err == "number") {
				throw new ValidationError(ValidationLevel.ERROR, err, null, err);
			}
		}
	},
	onGridBaseValidationFail: function(grid, itemIndex, column, err) {
		if (this._handler.onValidationFail) {
			var retErr = this._handler.onValidationFail(this._handler, itemIndex, $$_getColumnProxy(column), {level:err.level, message:err.message});
			if (retErr && retErr.level && retErr.message) {
				err.level = retErr.level;
				err.message = retErr.message;
				err.userMessage = retErr.message;
				return err;
			} else if (typeof retErr == "string" || typeof retErr == "number") {
				err.message = retErr;
				err.userMessage = retErr;
				return err;
			}
		} else {
			return err;
		}
	},
	onGridBaseColumnHeaderClicked: function (grid, column, rightClicked, event) {
		this._handler.onColumnHeaderClicked && this._handler.onColumnHeaderClicked(this._handler, $$_getColumnProxy(column), rightClicked);
	},
	onGridBaseColumnHeaderImageClicked: function (grid, column) {
		this._handler.onColumnHeaderImageClicked && this._handler.onColumnHeaderImageClicked(this._handler, $$_getColumnProxy(column));
	},
	onGridBaseColumnHeaderDblClicked: function (grid, column) {
		this._handler.onColumnHeaderDblClicked && this._handler.onColumnHeaderDblClicked(this._handler, $$_getColumnProxy(column));
	},
    onGridBaseColumnCheckedChanged: function (grid, column) {
        this._handler.onColumnCheckedChanged && this._handler.onColumnCheckedChanged(this._handler, $$_getColumnProxy(column), column.isChecked());
    },
	onGridBaseFooterCellClicked: function (grid, column) {
		this._handler.onFooterCellClicked && this._handler.onFooterCellClicked(this._handler, $$_getColumnProxy(column));
	},
	onGridBaseFooterCellDblClicked: function (grid, column) {
		this._handler.onFooterCellDblClicked && this._handler.onFooterCellDblClicked(this._handler, $$_getColumnProxy(column));
	},
	onGridBaseHeaderSummaryCellClicked: function (grid, column) {
		this._handler.onHeaderSummaryCellClicked && this._handler.onHeaderSummaryCellClicked(this._handler, $$_getColumnProxy(column));
	},
	onGridBaseHeaderSummaryCellDblClicked: function (grid, column) {
		this._handler.onHeaderSummaryCellDblClicked && this._handler.onHeaderSummaryCellDblClicked(this._handler, $$_getColumnProxy(column));
	},
	onGridBaseCheckBarHeadClicked: function (grid) {
		this._handler.onCheckBarHeadClicked && this._handler.onCheckBarHeadClicked(this._handler);
	},
	onGridBaseCheckBarFootClicked: function (grid) {
		this._handler.onCheckBarFootClicked && this._handler.onCheckBarFootClicked(this._handler);
	},
	onGridBaseIndicatorCellClicked: function (grid, itemIndex) {
		this._handler.onIndicatorCellClicked && this._handler.onIndicatorCellClicked(this._handler, itemIndex);
	},
	onGridBaseStateBarCellClicked: function (grid, itemIndex) {
		this._handler.onStateBarCellClicked && this._handler.onStateBarCellClicked(this._handler, itemIndex);
	},
	onGridBaseRowGroupHeadClicked: function (grid) {
		this._handler.onRowGroupHeadClicked && this._handler.onRowGroupHeadClicked(this._handler);
	},
	onGridBaseRowGroupFootClicked: function (grid) {
		this._handler.onRowGroupFootClicked && this._handler.onRowGroupFootClicked(this._handler);
	},
	onGridBaseRowGroupHeaderFooterClicked: function (grid, kind, index) {
		this._handler.onRowGroupHeaderFooterClicked && this._handler.onRowGroupHeaderFooterClicked(this._handler, kind, index.proxy());
	},
	onGridBaseRowGroupBarClicked: function (grid, index) {
		this._handler.onRowGroupBarClicked && this._handler.onRowGroupBarClicked(this._handler, index);
	},
	onGridBaseCheckBarFootDblClicked: function (grid, index) {
		this._handler.onCheckBarFootDblClicked && this._handler.onCheckBarFootDblClicked(this._handler, index);
	},
	onGridBaseIndicatorCellDblClicked: function (grid, itemIndex) {
		this._handler.onIndicatorCellDblClicked && this._handler.onIndicatorCellDblClicked(this._handler, itemIndex);
	},
	onGridBaseStateBarCellDblClicked: function (grid, itemIndex) {
		this._handler.onStateBarCellDblClicked && this._handler.onStateBarCellDblClicked(this._handler, itemIndex);
	},
	onGridBaseRowGroupHeadDblClicked: function (grid) {
		this._handler.onRowGroupHeadDblClicked && this._handler.onRowGroupHeadDblClicked(this._handler);
	},
	onGridBaseRowGroupFootDblClicked: function (grid) {
		this._handler.onRowGroupFootDblClicked && this._handler.onRowGroupFootDblClicked(this._handler);
	},
	onGridBaseRowGroupHeaderFooterDblClicked: function (grid, kind, index) {
		this._handler.onRowGroupHeaderFooterDblClicked && this._handler.onRowGroupHeaderFooterDblClicked(this._handler, kind, index.proxy());
	},
	onGridBaseRowGroupBarDblClicked: function (grid, index) {
		this._handler.onRowGroupBarDblClicked && this._handler.onRowGroupBarDblClicked(this._handler, index);
	},
	onGridBasePanelClicked: function (grid) {
		this._handler.onPanelClicked && this._handler.onPanelClicked(this._handler);
	},
	onGridBasePanelDblClicked: function (grid) {
		this._handler.onPanelDblClicked && this._handler.onPanelDblClicked(this._handler);
	},
	onGridBaseRowGroupPanelClicked: function (grid, column) {
		this._handler.onRowGroupPanelClicked && this._handler.onRowGroupPanelClicked(this._handler, $$_getColumnProxy(column));
	},
	onGridBaseRowGroupPanelDblClicked: function (grid, column) {
		this._handler.onRowGroupPanelDblClicked && this._handler.onRowGroupPanelDblClicked(this._handler, $$_getColumnProxy(column));
	},
	onGridBaseBodyEmptyClicked: function(grid) {
		this._handler.onBodyEmptyClicked && this._handler.onBodyEmptyClicked(this._handler);
	},
	onGridBaseBodyEmptyDblClicked: function(grid) {
		this._handler.onBodyEmptyDblClicked && this._handler.onBodyEmptyDblClicked(this._handler);
	},
	onGridBaseMenuItemClicked: function (grid, menuItem, index) {
		this._handler.onMenuItemClicked && this._handler.onMenuItemClicked(this._handler, menuItem.proxy(), index.proxy());
	},
	onGridBaseContextMenuPopup: function (grid, x, y, eltName) {
		return this._handler.onContextMenuPopup && this._handler.onContextMenuPopup(this._handler, x, y, eltName);
	},
    onGridBaseContextMenuItemClicked: function (grid, menuItem, index) {
        this._handler.onContextMenuItemClicked && this._handler.onContextMenuItemClicked(this._handler, menuItem.proxy(), index.proxy());
    },
	onGridBaseCellButtonClicked: function (grid, index) {
		this._handler.onCellButtonClicked && this._handler.onCellButtonClicked(this._handler, index.itemIndex(), $$_getColumnProxy(index.column()));
	},
	onGridBaseEditButtonClicked: function (grid, index) {
	},
	onGridBaseImageButtonClicked: function (grid, index, buttonIndex, name) {
		this._handler.onImageButtonClicked && this._handler.onImageButtonClicked(this._handler, index.itemIndex(), $$_getColumnProxy(index.column()), buttonIndex, name);
	},
	onGridBaseClickableCellClicked: function (grid, index, source, data) {
		if (source == ClickableCellRenderer.LINKABLE_CELL) {
			this._handler.onLinkableCellClicked && this._handler.onLinkableCellClicked(this._handler, index.proxy(), data);
		}
	},
	onGridBaseScrollToBottom: function (grid) {
		this._handler.onScrollToBottom && this._handler.onScrollToBottom(this._handler);
	},
	onGridBaseTopItemIndexChanged: function (grid, itemIndex) {
		this._handler.onTopItemIndexChanged && this._handler.onTopItemIndexChanged(this._handler, itemIndex);
	},
	onGridBaseDataCellClicked: function (grid, index) {
		this._handler.onDataCellClicked && this._handler.onDataCellClicked(this._handler, index.proxy());
	},
	onGridBaseDataCellDblClicked: function (grid, index) {
		this._handler.onDataCellDblClicked && this._handler.onDataCellDblClicked(this._handler, index.proxy());
	},
	onGridBaseRowsDeleting: function (grid, rows) {
		if (this._handler.onRowsDeleting) {
			var ret = this._handler.onRowsDeleting(this._handler, rows);
			if (typeof ret == "string" && ret) {
				throw ret;
			}
			return ret;
		}
	},
	onGridBaseRowInserting: function (grid, itemIndex, dataRow) {
		if (this._handler.onRowInserting) {
			var ret = this._handler.onRowInserting(this._handler, itemIndex, dataRow);
			if (typeof ret == "string" && ret) {
				throw ret;
			}
			return ret;
		}
	},
	onGridBaseSelectionChanged: function (grid) {
		this._handler.onSelectionChanged && this._handler.onSelectionChanged(this._handler);
	},
	onGridBaseSelectionAdded: function (grid, selection) {
		this._handler.onSelectionAdded && this._handler.onSelectionAdded(this._handler, $$_getSelectionProxy(grid, selection));
	},
	onGridBaseSelectionEnded: function (grid) {
		this._handler.onSelectionEnded && this._handler.onSelectionEnded(this._handler);
	},
    onGridBaseShowEditor: function (grid, index, attrs) {
        return this._handler.onShowEditor && this._handler.onShowEditor(this._handler, index.proxy(), attrs);
    },
	onGridBaseHideEditor: function (grid, index) {
		return this._handler.onHideEditor && this._handler.onHideEditor(this._handler, index.proxy());
	},
	onGridBaseEditChange: function (grid, index, value) {
		this._handler.onEditChange && this._handler.onEditChange(this._handler, index.proxy(), value);
	},
    onGridBaseGetEditValue: function (grid, index, editResult) {
        this._handler.onGetEditValue && this._handler.onGetEditValue(this._handler, index.proxy(), editResult);
    },
	onGridBaseEditCommit: function (grid, index, oldValue, newValue) {
        if (this._handler.onEditCommit) {
            var msg = this._handler.onEditCommit(this._handler, index.proxy(), oldValue, newValue);
            if (typeof msg == "string" && msg) {
                if (grid.editOptions().isShowCommitError()) {
                    alert(msg);
                }
                return false;
            }
        }
	},
	onGridBaseEditCanceled: function (grid, index) {
		return this._handler.onEditCanceled && this._handler.onEditCanceled(this._handler, index.proxy());
	},
	onGridBaseItemEditCanceled: function (grid, item) {
		return this._handler.onItemEditCanceled && this._handler.onItemEditCanceled(this._handler, item.index(), item.itemState());
	},
	onGridBaseItemEditCancel: function (grid, item) {
		return this._handler.onItemEditCancel && this._handler.onItemEditCancel(this._handler, item.index(), item.itemState());
	},
	onGridBaseEditSearch: function (grid, index, text) {
		return this._handler.onEditSearch && this._handler.onEditSearch(this._handler, index.proxy(), text);
	},
	onGridBaseSearchCellButtonClick: function (grid, index, text) {
		return this._handler.onSearchCellButtonClick ? this._handler.onSearchCellButtonClick(this._handler, index.proxy(), text) : true;
	}, 
	onGridBaseCellEdited: function (grid, item, field) {
		return this._handler.onCellEdited && this._handler.onCellEdited(this._handler, item.index(), item.dataRow(), field);
	},
	onGridBaseEditRowChanged: function (grid, item, field, oldValue, newValue) {
		return this._handler.onEditRowChanged && this._handler.onEditRowChanged(this._handler, item.index(), item.dataRow(), field, oldValue, newValue);
	},
	onGridBaseEditRowPasted: function (grid, item, fields, oldValues, newValues) {
		return this._handler.onEditRowPasted && this._handler.onEditRowPasted(this._handler, item.index(), item.dataRow(), fields, oldValues, newValues);
	},
	onGridBaseRowsPasted: function (grid, items) {
		return this._handler.onRowsPasted && this._handler.onRowsPasted(this._handler, items);	
	},
	onGridBaseCellPasting: function (grid, index, value) {
		return this._handler.onCellPasting && this._handler.onCellPasting(this._handler, index.proxy(), value)
	},
	onGridBaseItemChecked: function (grid, item, checked) {
		return this._handler.onItemChecked && this._handler.onItemChecked(this._handler, item.index(), checked);
	},
	onGridBaseItemsChecked: function (grid, items, checked) {
		return this._handler.onItemsChecked && this._handler.onItemsChecked(this._handler, $$_getItemIndicies(items), checked);
	},
	onGridBaseItemAllChecked: function (grid, checked) {
		return this._handler.onItemAllChecked && this._handler.onItemAllChecked(this._handler, checked);
	},
	onGridBaseErrorClicked: function (grid, error) {
		this._handler.onErrorClicked && this._handler.onErrorClicked(this._handler, error);
	},
    onGridBaseSorting: function (grid, fields, directions) {
        return this._handler.onSorting && this._handler.onSorting(this._handler, fields, directions);
    },
	onGridBaseSortingChanged: function (grid) {
		return this._handler.onSortingChanged && this._handler.onSortingChanged(this._handler);
	},
    onGridBaseFiltering: function (grid) {
        return this._handler.onFiltering && this._handler.onFiltering(this._handler);
    },
	onGridBaseFilteringChanged: function (grid, filterCollection, filter) {
		var column = filterCollection && $$_getColumnProxy(filterCollection._column);
		var flt = filter && filter.proxy();
		return this._handler.onFilteringChanged && this._handler.onFilteringChanged(this._handler, column, flt);
	},
	onGridBaseFilterActionClicked: function (grid, action, x, y) {
		this._handler.onFilterActionClicked && this._handler.onFilterActionClicked(this._handler, action.column().name(), action.name(), x, y);
	},
	onGridBaseKeyDown: function (grid, key, ctrl, shift, alt) {
		return this._handler.onKeyDown && this._handler.onKeyDown(this._handler, key, ctrl, shift, alt);
	},
	onGridBaseKeyPress: function (grid, key) {
		this._handler.onKeyPress && this._handler.onKeyPress(this._handler, key);
	},
	onGridBaseKeyUp: function (grid, key, ctrl, shift, alt) {
		return this._handler.onKeyUp && this._handler.onKeyUp(this._handler, key, ctrl, shift, alt);
	},
	onGridBaseShowTooltip: function (grid, index, value) {
		return this._handler.onShowTooltip ? this._handler.onShowTooltip(this._handler, index.proxy(), value) : value;
	},
	onGridBaseShowHeaderTooltip: function (grid, column, value) {
		return this._handler.onShowHeaderTooltip ? this._handler.onShowHeaderTooltip(this._handler, column.proxy(), value) : value;
	},
	onGridBaseColumnPropertyChanged: function (grid, column, property, value) {
		return this._handler.onColumnPropertyChanged && this._handler.onColumnPropertyChanged(this._handler, column.proxy(), property, value);
	},
	onGridBaseShowInnerDragCursor: function (grid, cells) {
		return !this._handler.onShowInnerDragCursor || this._handler.onShowInnerDragCursor(this._handler, cells ? cells.proxy() : null);
	},
	onGridBaseInnerDragStart: function (grid, cells) {
		return this._handler.onInnerDragStart && this._handler.onInnerDragStart(this._handler, cells ? cells.proxy() : null);
	},
	onGridBaseInnerDragOver: function (grid, index, cells) {
		return this._handler.onInnerDragOver && this._handler.onInnerDragOver(this._handler, index.proxy(), cells ? cells.proxy() : null);
	},
	onGridBaseInnerDrop: function (grid, dropIndex, cells) {
		return this._handler.onInnerDrop && this._handler.onInnerDrop(this._handler, dropIndex.proxy(), cells ? cells.proxy() : null);
	},
	onGridBaseGridActivated: function(grid) {
		return this._handler.onGridActivated && this._handler.onGridActivated(this._handler);
	},
	onGridBasePaste: function(grid, index, e) {
		return this._handler.onPaste && this._handler.onPaste(this._handler, index.proxy(), e);
	},
	onGridBaseCopy:function(grid, selectionItem, e) {
		return this._handler.onCopy && this._handler.onCopy(this._handler, $$_getSelectionProxy(grid, selectionItem), e);	
	},
	onGridBasePasted: function(grid) {
		return this._handler.onPasted && this._handler.onPasted(this._handler);
	},
	onGridBaseApplyCallback: function() {
		var func = arguments[1];
		var args = Array.prototype.slice.call(arguments,2);
		var arg;
		for (var i = 0, cnt = args.length; i < cnt ; i++) {
			arg = args[i];
			arg && typeof arg == "object" && !arg.noProxy && arg.proxy && (args[i] = arg.proxy());
		}
		args.splice(0,0,this._handler);
		if (typeof func == "function") {
			func.apply(this._handler, args)
		}
	},
	getHandler:function() {
		return this._handler;
	}
});
var RealGridObserver = defineClass("RealGridObserver", RealGridObserverBase, {
	init: function (handler) {
		this._super(handler);
	},
	onGridViewPageChanging: function (grid, newPage) {
		return !this._handler.onPageChanging || this._handler.onPageChanging(this._handler, newPage);
	},
	onGridViewPageChanged: function (grid, page) {
		this._handler.onPageChanged && this._handler.onPageChanged(this._handler, page);
	},
	onGridViewPageCountChanged: function (grid, newCount) {
		this._handler.onPageCountChanged && this._handler.onPageCountChanged(this._handler, newCount);
	},
	onGridViewGrouping: function (grid, fields) {
        return this._handler.onGrouping && this._handler.onGrouping(this._handler, fields);
	},
	onGridViewGrouped: function (grid) {
		this._handler.onGroupingChanged && this._handler.onGroupingChanged(this._handler);
	},
	onGridViewExpanding: function (grid, group) {
		return true;
	},
	onGridViewExpanded: function (grid, group) {
	},
	onGridViewCollapsing: function (grid, group) {
		return true;
	},
	onGridViewCollapsed: function (grid, group) {
	}
});
var RealTreeObserver = defineClass("RealTreeObserver", RealGridObserverBase, {
	init: function (handler) {
		this._super(handler);
	},
	onTreeViewExpanding: function (tree, item) {
		return !this._handler.onTreeItemExpanding || this._handler.onTreeItemExpanding(this._handler, item.index(), item.dataRow());
	},
	onTreeViewExpanded: function (tree, item) {
		this._handler.onTreeItemExpanded && this._handler.onTreeItemExpanded(this._handler, item.index(), item.dataRow());
	},
	onTreeViewCollapsing: function (tree, item) {
		return !this._handler.onTreeItemCollapsing || this._handler.onTreeItemCollapsing(this._handler, item.index(), item.dataRow());
	},
	onTreeViewCollapsed: function (tree, item) {
		this._handler.onTreeItemCollapsed && this._handler.onTreeItemCollapsed(this._handler, item.index(), item.dataRow());
	},
	onTreeViewChanged: function (tree, item) {
		this._handler.onTreeItemChanged && this._handler.onTreeItemChanged(this._handler, item.index(), item.dataRow());
	}
});

var _gk = "dkdl";	

var _wm_ = (function() {
	return /*$watermarkImage$*/;
})();
	
	return __lck() ? {
		getActiveGrid:$_getActiveGrid,
		exportGrid:$_exportGrid,
		getVersion: _getVersion,
		setRootContext: _setRootContext,
        setAssetRoot: _setAssetRoot,
        setDebug: _setDebug,
		setLogging: _setLogging,
		setTrace: _setLogging,
        _log: _log,
		setMobile: $$_setMobile,
		$_setMobileEnabled: function (value) { $_mobileEnable = value; },
		getTimer: getTimer,
		Dictionary: Dictionary,
		Dimensoion: Dimension,
		SummaryMode: SummaryMode,
		ValueType: ValueType,
		DataField: DataField,
		RowState: RowState,
		ChangingMode: ChangingMode,
		LocalDataProvider: LocalDataProvider,
		GridContainer: GridContainer,
		GridView: GridView,
		CellIndex:CellIndex,
        ColumnHeaderItemLocation: ColumnHeaderItemLocation,
		ColumnGroup: ColumnGroup,
		Column: Column,
		ValueColumn: ValueColumn,
		DataColumn: DataColumn,
		SeriesColumn: SeriesColumn,
		ColumnLayout: ColumnLayout,
		VisualStyles: VisualStyles,
		SelectionStyle: SelectionStyle,
		SelectionManager: SelectionManager,
		BlockSelection: BlockSelection,
		RowSelection: RowSelection,
		ColumnSelection: ColumnSelection,
		ImageList: ImageList,
		ColumnGroupOrientation: ColumnGroupOrientation,
		CellButton: CellButton,
		SolidBrush: SolidBrush,
		SolidPen: SolidPen,
		
		LocalTreeDataProvider: LocalTreeDataProvider,
		TreeDataRow: TreeDataRow,
		TreeContainer: TreeContainer,
		TreeView: TreeView,

		realgrid: new RealGridHelper(),
		
		// for testing only
		Progress: Progress,
		PopupMenu: PopupMenu,
		PopupMenuManager: PopupMenuManager,
		GridBase: GridBase,
		AssertError: AssertError,
		ColumnHeader: ColumnHeader,
		BooleanConverter: BooleanConverter,
		DateTimeReader: DateTimeReader,
		DecimalFormatter: DecimalFormatter,
		SeriesCell: SeriesCell,
		ExpressionSyntaxError: ExpressionSyntaxError,
		DataRowExpressionRuntime: DataRowExpressionRuntime,
		// GridExcelExporter: GridExcelExporter,
		StylesArchiver: StylesArchiver
	}: null;
})(this);
